diff --git a/ADVISORIES b/ADVISORIES
new file mode 100644
index 0000000000..d4e33f2df3
--- /dev/null
+++ b/ADVISORIES
@@ -0,0 +1,2 @@
+For the GNU C Library Security Advisories, see the git master branch:
+https://sourceware.org/git/?p=glibc.git;a=tree;f=advisories;hb=HEAD
diff --git a/Makeconfig b/Makeconfig
index 85e00cef94..a6cbb0c6f3 100644
--- a/Makeconfig
+++ b/Makeconfig
@@ -360,6 +360,8 @@ whole-archive = -Wl,--whole-archive
 # Installed name of the startup code.
 # The ELF convention is that the startfile is called crt1.o
 start-installed-name = crt1.o
+# Similar to crt1.o, but without _IO_stdin_used.
+start-name-2.0 = crt1-2.0.o
 # On systems that do not need a special startfile for statically linked
 # binaries, simply set it to the normal name.
 ifndef static-start-installed-name
@@ -537,6 +539,25 @@ else  # build-static
 endif  # build-shared
 endif  # +link
 
+# Command for linking test programs with crt1.o from glibc 2.0.
++link-2.0-before-inputs = -nostdlib -nostartfiles $(no-pie-ldflag) \
+	      $(sysdep-LDFLAGS) $(LDFLAGS) $(LDFLAGS-$(@F)) \
+	      $(relro-LDFLAGS) $(hashstyle-LDFLAGS) \
+	      $(firstword $(CRT-$(@F)) $(csu-objpfx)$(start-name-2.0)) \
+	      $(+preinit) $(+prector)
++link-2.0-before-libc = -o $@ $(+link-2.0-before-inputs) \
+	      $(filter-out $(addprefix $(csu-objpfx),start.o \
+						     $(start-name-2.0))\
+			   $(+preinit) $(link-extra-libs) \
+			   $(common-objpfx)libc% $(+postinit),$^) \
+	      $(link-extra-libs)
++link-after-libc = $(+postctor) $(+postinit)
+define +link-2.0-tests
+$(CC) $(+link-2.0-before-libc) $(rtld-tests-LDFLAGS) $(link-libc-tests) \
+  $(+link-after-libc)
+$(call after-link,$@)
+endef
+
 # The pretty printer test programs need to be compiled without optimizations
 # so they won't confuse gdb.  We could use either the 'GCC optimize' pragma
 # or the 'optimize' function attribute to achieve this; however, at least on
@@ -586,10 +607,13 @@ link-libc-rpath-link = -Wl,-rpath-link=$(rpath-link)
 # before the expansion of LDLIBS-* variables).
 
 # Tests use -Wl,-rpath instead of -Wl,-rpath-link for
-# build-hardcoded-path-in-tests.
+# build-hardcoded-path-in-tests.  Add -Wl,--disable-new-dtags to force
+# DT_RPATH instead of DT_RUNPATH which only applies to DT_NEEDED entries
+# in the executable and doesn't applies to DT_NEEDED entries in shared
+# libraries which are loaded via DT_NEEDED entries in the executable.
 ifeq (yes,$(build-hardcoded-path-in-tests))
-link-libc-tests-rpath-link = $(link-libc-rpath)
-link-test-modules-rpath-link = $(link-libc-rpath)
+link-libc-tests-rpath-link = $(link-libc-rpath) -Wl,--disable-new-dtags
+link-test-modules-rpath-link = $(link-libc-rpath) -Wl,--disable-new-dtags
 else
 link-libc-tests-rpath-link = $(link-libc-rpath-link)
 link-test-modules-rpath-link =
diff --git a/Makefile b/Makefile
index 7052b46df8..f3f8153697 100644
--- a/Makefile
+++ b/Makefile
@@ -577,6 +577,14 @@ $(objpfx)lint-makefiles.out: scripts/lint-makefiles.sh
 	$(SHELL) $< "$(PYTHON)" `pwd` > $@ ; \
 	$(evaluate-test)
 
+# Link libc.a as a whole to verify that it does not contain multiple
+# definitions of any symbols.
+tests-special += $(objpfx)link-static-libc.out
+$(objpfx)link-static-libc.out:
+	$(LINK.o) $(whole-archive) -nostdlib -nostartfiles -r \
+	  $(objpfx)libc.a -o /dev/null > $@ 2>&1; \
+	$(evaluate-test)
+
 # Print test summary for tests in $1 .sum file;
 # $2 is optional test identifier.
 # Fail if there are unexpected failures in the test results.
diff --git a/NEWS b/NEWS
index 1b89f9c010..bf1887b3ec 100644
--- a/NEWS
+++ b/NEWS
@@ -5,6 +5,111 @@ See the end for copying conditions.
 Please send GNU C library bug reports via <https://sourceware.org/bugzilla/>
 using `glibc' in the "product" field.
 
+Version 2.39.1
+
+Deprecated and removed features, and other changes affecting compatibility:
+
+* __rseq_size now denotes the size of the active rseq area (20 bytes
+  initially), not the size of struct rseq (32 bytes initially).
+
+Security related changes:
+
+The following CVEs were fixed in this release:
+
+  GLIBC-SA-2024-0004:
+    ISO-2022-CN-EXT: fix out-of-bound writes when writing escape
+    sequence (CVE-2024-2961)
+
+  GLIBC-SA-2024-0005:
+    nscd: Stack-based buffer overflow in netgroup cache (CVE-2024-33599)
+
+  GLIBC-SA-2024-0006:
+    nscd: Null pointer crash after notfound response (CVE-2024-33600)
+
+  GLIBC-SA-2024-0007:
+    nscd: netgroup cache may terminate daemon on memory allocation
+    failure (CVE-2024-33601)
+
+  GLIBC-SA-2024-0008:
+    nscd: netgroup cache assumes NSS callback uses in-buffer strings
+    (CVE-2024-33602)
+
+  GLIBC-SA-2025-0001:
+    assert: Buffer overflow when printing assertion failure message
+    (CVE-2025-0395)
+
+The following bugs are resolved with this release:
+
+  [19341] ctype: Fallback initialization of TLS using relocations
+  [19622] network: Support aliasing with struct sockaddr
+  [27821] ungetc: Fix backup buffer leak on program exit
+  [30081] resolv: Do not wait for non-existing second DNS response after error
+  [30701] time: getutxent misbehaves on 32-bit x86 when _TIME_BITS=64
+  [30994] REP MOVSB performance suffers from page aliasing on Zen 4
+  [31339] libc: arm32 loader crash after cleanup in 2.36
+  [31325] mips: clone3 is wrong for o32
+  [31335] math: Compile glibc with -march=x86-64-v3 should disable FMA4
+    multi-arch version
+  [31402] libc: clone (NULL, NULL, ...) clobbers %r7 register on
+    s390{,x}
+  [31479] libc: Missing #include <sys/rseq.h> in sched_getcpu.c may
+    result in a loss of rseq acceleration
+  [31316] build: Fails test misc/tst-dirname "Didn't expect signal from
+    child: got `Illegal instruction'" on non SSE CPUs
+  [31371] x86-64: APX and Tile registers aren't preserved in ld.so 
+    trampoline
+  [31372] dynamic-link: _dl_tlsdesc_dynamic doesn't preserve all caller-
+    saved registers
+  [31429] build: Glibc failed to build with -march=x86-64-v3
+  [31476] resolv: Track single-request fallback via _res._flags
+  [31501] dynamic-link: _dl_tlsdesc_dynamic_xsavec may clobber %rbx
+  [31612] libc: arc4random fails to fallback to /dev/urandom if
+    getrandom is not present
+  [31640] dynamic-link: POWER10 ld.so crashes in
+    elf_machine_load_address with GCC 14
+  [31676] Configuring with CC="gcc -march=x86-64-v3"
+    --with-rtld-early-cflags=-march=x86-64 results in linker failure
+  [31677] nscd: nscd: netgroup cache: invalid memcpy under low
+    memory/storage conditions
+  [31678] nscd: nscd: Null pointer dereferences after failed netgroup
+    cache insertion
+  [31679] nscd: nscd: netgroup cache may terminate daemon on memory
+    allocation failure
+  [31680] nscd: nscd: netgroup cache assumes NSS callback uses in-buffer
+    strings
+  [31686] dynamic-link: Stack-based buffer overflow in
+    parse_tunables_string
+  [31695] libc: pidfd_spawn/pidfd_spawnp leak an fd if clone3 succeeds
+  [31717] elf: Avoid re-initializing already allocated TLS in dlopen
+  [31719] dynamic-link: --enable-hardcoded-path-in-tests doesn't work
+    with -Wl,--enable-new-dtags
+  [31782] Test build failure with recent GCC trunk
+    (x86/tst-cpu-features-supports.c:69:3: error: parameter to builtin
+    not valid: avx5124fmaps)
+  [31798] pidfd_getpid.c is miscompiled by GCC 6.4
+  [31840] Remove memory leak in fdopen
+  [31867] build: "CPU ISA level is lower than required" on SSE2-free
+    CPUs
+  [31883] build: ISA level support configure check relies on bashism /
+    is otherwise broken for arithmetic
+  [31890] resolv: Allow short error responses to match any DNS query
+  [31943] _dl_find_object can fail if ld.so contains gaps between load segments
+  [31965] rseq extension mechanism does not work as intended
+  [31968] mremap implementation in C does not handle arguments correctly
+  [32026] strerror/strsignal TLS not handled correctly for secondary namespaces
+  [32052] Name space violation in fortify wrappers
+  [32137] libio: Attempt wide backup free only for non-legacy code
+  [32231] elf: Change ldconfig auxcache magic number
+  [32470] x86: Avoid integer truncation with large cache sizes
+  [32582] Fix underallocation of abort_msg_s struct (CVE-2025-0395)
+  [32810] Crash on x86-64 if XSAVEC disable via tunable
+  [32987] elf: Fix subprocess status handling for tst-dlopen-sgid
+  [33185] Fix double-free after allocation failure in regcomp
+  [32483] ctype macros segfault in multithreaded programs with multiple libc.so
+  [33234] Use TLS initial-exec model for __libc_tsd_CTYPE_* thread variables
+  [33361] nss: Group merge does not react to ERANGE during merge
+  [33601] aarch64: Do not link conform tests with -Wl,-z,force-bti
+
 Version 2.39
 
 Major new features:
diff --git a/Rules b/Rules
index c7db0a4869..9010c5d5b2 100644
--- a/Rules
+++ b/Rules
@@ -188,6 +188,7 @@ binaries-all = $(binaries-all-notests) $(binaries-all-tests)
 binaries-static-notests = $(others-static)
 binaries-static-tests = $(tests-static) $(xtests-static)
 binaries-static = $(binaries-static-notests) $(binaries-static-tests)
+binaries-shared-2.0-tests = $(tests-2.0)
 ifeq (yesyes,$(have-fpie)$(build-shared))
 binaries-pie-tests = $(tests-pie) $(xtests-pie)
 binaries-pie-notests = $(others-pie)
@@ -215,7 +216,8 @@ binaries-malloc-hugetlb2-tests =
 endif
 
 binaries-pie = $(binaries-pie-tests) $(binaries-pie-notests)
-binaries-shared-tests = $(filter-out $(binaries-pie) $(binaries-static), \
+binaries-shared-tests = $(filter-out $(binaries-pie) $(binaries-static) \
+				     $(binaries-shared-2.0-tests), \
 				     $(binaries-all-tests))
 binaries-shared-notests = $(filter-out $(binaries-pie) $(binaries-static), \
 				       $(binaries-all-notests))
@@ -235,6 +237,15 @@ $(addprefix $(objpfx),$(binaries-shared-tests)): %: %.o \
 	$(+link-tests)
 endif
 
+# Linking test programs with crt1.o from glibc 2.0.
+ifneq "$(strip $(binaries-shared-2.0-tests))" ""
+$(addprefix $(objpfx),$(binaries-shared-2.0-tests)): %: %.o \
+  $(link-extra-libs-tests) \
+  $(sort $(filter $(common-objpfx)lib%,$(link-libc))) \
+  $(addprefix $(csu-objpfx),start.o) $(+preinit) $(+postinit)
+	$(+link-2.0-tests)
+endif
+
 ifneq "$(strip $(binaries-mcheck-tests))" ""
 $(addprefix $(objpfx),$(binaries-mcheck-tests)): %-mcheck: %.o \
   $(link-extra-libs-tests) \
diff --git a/advisories/GLIBC-SA-2023-0001 b/advisories/GLIBC-SA-2023-0001
deleted file mode 100644
index 3d19c91b6a..0000000000
--- a/advisories/GLIBC-SA-2023-0001
+++ /dev/null
@@ -1,14 +0,0 @@
-printf: incorrect output for integers with thousands separator and width field
-
-When the printf family of functions is called with a format specifier
-that uses an <apostrophe> (enable grouping) and a minimum width
-specifier, the resulting output could be larger than reasonably expected
-by a caller that computed a tight bound on the buffer size.  The
-resulting larger than expected output could result in a buffer overflow
-in the printf family of functions.
-
-CVE-Id: CVE-2023-25139
-Public-Date: 2023-02-02
-Vulnerable-Commit: e88b9f0e5cc50cab57a299dc7efe1a4eb385161d (2.37)
-Fix-Commit: c980549cc6a1c03c23cc2fe3e7b0fe626a0364b0 (2.38)
-Fix-Commit: 07b9521fc6369d000216b96562ff7c0ed32a16c4 (2.37-4)
diff --git a/advisories/GLIBC-SA-2023-0002 b/advisories/GLIBC-SA-2023-0002
deleted file mode 100644
index 5122669a64..0000000000
--- a/advisories/GLIBC-SA-2023-0002
+++ /dev/null
@@ -1,15 +0,0 @@
-getaddrinfo: Stack read overflow in no-aaaa mode
-
-If the system is configured in no-aaaa mode via /etc/resolv.conf,
-getaddrinfo is called for the AF_UNSPEC address family, and a DNS
-response is received over TCP that is larger than 2048 bytes,
-getaddrinfo may potentially disclose stack contents via the returned
-address data, or crash.
-
-CVE-Id: CVE-2023-4527
-Public-Date: 2023-09-12
-Vulnerable-Commit: f282cdbe7f436c75864e5640a409a10485e9abb2 (2.36)
-Fix-Commit: bd77dd7e73e3530203be1c52c8a29d08270cb25d (2.39)
-Fix-Commit: 4ea972b7edd7e36610e8cde18bf7a8149d7bac4f (2.36-113)
-Fix-Commit: b7529346025a130fee483d42178b5c118da971bb (2.37-38)
-Fix-Commit: b25508dd774b617f99419bdc3cf2ace4560cd2d6 (2.38-19)
diff --git a/advisories/GLIBC-SA-2023-0003 b/advisories/GLIBC-SA-2023-0003
deleted file mode 100644
index d3aef80348..0000000000
--- a/advisories/GLIBC-SA-2023-0003
+++ /dev/null
@@ -1,15 +0,0 @@
-getaddrinfo: Potential use-after-free
-
-When an NSS plugin only implements the _gethostbyname2_r and
-_getcanonname_r callbacks, getaddrinfo could use memory that was freed
-during buffer resizing, potentially causing a crash or read or write to
-arbitrary memory.
-
-CVE-Id: CVE-2023-4806
-Public-Date: 2023-09-12
-Fix-Commit: 973fe93a5675c42798b2161c6f29c01b0e243994 (2.39)
-Fix-Commit: e09ee267c03e3150c2c9ba28625ab130705a485e (2.34-420)
-Fix-Commit: e3ccb230a961b4797510e6a1f5f21fd9021853e7 (2.35-270)
-Fix-Commit: a9728f798ec7f05454c95637ee6581afaa9b487d (2.36-115)
-Fix-Commit: 6529a7466c935f36e9006b854d6f4e1d4876f942 (2.37-39)
-Fix-Commit: 00ae4f10b504bc4564e9f22f00907093f1ab9338 (2.38-20)
diff --git a/advisories/GLIBC-SA-2023-0004 b/advisories/GLIBC-SA-2023-0004
deleted file mode 100644
index 5286a7aa54..0000000000
--- a/advisories/GLIBC-SA-2023-0004
+++ /dev/null
@@ -1,16 +0,0 @@
-tunables: local privilege escalation through buffer overflow
-
-If a tunable of the form NAME=NAME=VAL is passed in the environment of a
-setuid program and NAME is valid, it may result in a buffer overflow,
-which could be exploited to achieve escalated privileges.  This flaw was
-introduced in glibc 2.34.
-
-CVE-Id: CVE-2023-4911
-Public-Date: 2023-10-03
-Vulnerable-Commit: 2ed18c5b534d9e92fc006202a5af0df6b72e7aca (2.34)
-Fix-Commit: 1056e5b4c3f2d90ed2b4a55f96add28da2f4c8fa (2.39)
-Fix-Commit: dcc367f148bc92e7f3778a125f7a416b093964d9 (2.34-423)
-Fix-Commit: c84018a05aec80f5ee6f682db0da1130b0196aef (2.35-274)
-Fix-Commit: 22955ad85186ee05834e47e665056148ca07699c (2.36-118)
-Fix-Commit: b4e23c75aea756b4bddc4abcf27a1c6dca8b6bd3 (2.37-45)
-Fix-Commit: 750a45a783906a19591fb8ff6b7841470f1f5701 (2.38-27)
diff --git a/advisories/GLIBC-SA-2023-0005 b/advisories/GLIBC-SA-2023-0005
deleted file mode 100644
index cc4eb90b82..0000000000
--- a/advisories/GLIBC-SA-2023-0005
+++ /dev/null
@@ -1,18 +0,0 @@
-getaddrinfo: DoS due to memory leak
-
-The fix for CVE-2023-4806 introduced a memory leak when an application
-calls getaddrinfo for AF_INET6 with AI_CANONNAME, AI_ALL and AI_V4MAPPED
-flags set.
-
-CVE-Id: CVE-2023-5156
-Public-Date: 2023-09-25
-Vulnerable-Commit: e09ee267c03e3150c2c9ba28625ab130705a485e (2.34-420)
-Vulnerable-Commit: e3ccb230a961b4797510e6a1f5f21fd9021853e7 (2.35-270)
-Vulnerable-Commit: a9728f798ec7f05454c95637ee6581afaa9b487d (2.36-115)
-Vulnerable-Commit: 6529a7466c935f36e9006b854d6f4e1d4876f942 (2.37-39)
-Vulnerable-Commit: 00ae4f10b504bc4564e9f22f00907093f1ab9338 (2.38-20)
-Fix-Commit: 8006457ab7e1cd556b919f477348a96fe88f2e49 (2.34-421)
-Fix-Commit: 17092c0311f954e6f3c010f73ce3a78c24ac279a (2.35-272)
-Fix-Commit: 856bac55f98dc840e7c27cfa82262b933385de90 (2.36-116)
-Fix-Commit: 4473d1b87d04b25cdd0e0354814eeaa421328268 (2.37-42)
-Fix-Commit: 5ee59ca371b99984232d7584fe2b1a758b4421d3 (2.38-24)
diff --git a/advisories/GLIBC-SA-2024-0001 b/advisories/GLIBC-SA-2024-0001
deleted file mode 100644
index 28931c75ae..0000000000
--- a/advisories/GLIBC-SA-2024-0001
+++ /dev/null
@@ -1,15 +0,0 @@
-syslog: Heap buffer overflow in __vsyslog_internal
-
-__vsyslog_internal did not handle a case where printing a SYSLOG_HEADER
-containing a long program name failed to update the required buffer
-size, leading to the allocation and overflow of a too-small buffer on
-the heap.
-
-CVE-Id: CVE-2023-6246
-Public-Date: 2024-01-30
-Vulnerable-Commit: 52a5be0df411ef3ff45c10c7c308cb92993d15b1 (2.37)
-Fix-Commit: 6bd0e4efcc78f3c0115e5ea9739a1642807450da (2.39)
-Fix-Commit: 23514c72b780f3da097ecf33a793b7ba9c2070d2 (2.38-42)
-Fix-Commit: 97a4292aa4a2642e251472b878d0ec4c46a0e59a (2.37-57)
-Vulnerable-Commit: b0e7888d1fa2dbd2d9e1645ec8c796abf78880b9 (2.36-16)
-Fix-Commit: d1a83b6767f68b3cb5b4b4ea2617254acd040c82 (2.36-126)
diff --git a/advisories/GLIBC-SA-2024-0002 b/advisories/GLIBC-SA-2024-0002
deleted file mode 100644
index 940bfcf2fc..0000000000
--- a/advisories/GLIBC-SA-2024-0002
+++ /dev/null
@@ -1,15 +0,0 @@
-syslog: Heap buffer overflow in __vsyslog_internal
-
-__vsyslog_internal used the return value of snprintf/vsnprintf to
-calculate buffer sizes for memory allocation.  If these functions (for
-any reason) failed and returned -1, the resulting buffer would be too
-small to hold output.
-
-CVE-Id: CVE-2023-6779
-Public-Date: 2024-01-30
-Vulnerable-Commit: 52a5be0df411ef3ff45c10c7c308cb92993d15b1 (2.37)
-Fix-Commit: 7e5a0c286da33159d47d0122007aac016f3e02cd (2.39)
-Fix-Commit: d0338312aace5bbfef85e03055e1212dd0e49578 (2.38-43)
-Fix-Commit: 67062eccd9a65d7fda9976a56aeaaf6c25a80214 (2.37-58)
-Vulnerable-Commit: b0e7888d1fa2dbd2d9e1645ec8c796abf78880b9 (2.36-16)
-Fix-Commit: 2bc9d7c002bdac38b5c2a3f11b78e309d7765b83 (2.36-127)
diff --git a/advisories/GLIBC-SA-2024-0003 b/advisories/GLIBC-SA-2024-0003
deleted file mode 100644
index b43a5150ab..0000000000
--- a/advisories/GLIBC-SA-2024-0003
+++ /dev/null
@@ -1,13 +0,0 @@
-syslog: Integer overflow in __vsyslog_internal
-
-__vsyslog_internal calculated a buffer size by adding two integers, but
-did not first check if the addition would overflow.
-
-CVE-Id: CVE-2023-6780
-Public-Date: 2024-01-30
-Vulnerable-Commit: 52a5be0df411ef3ff45c10c7c308cb92993d15b1 (2.37)
-Fix-Commit: ddf542da94caf97ff43cc2875c88749880b7259b (2.39)
-Fix-Commit: d37c2b20a4787463d192b32041c3406c2bd91de0 (2.38-44)
-Fix-Commit: 2b58cba076e912961ceaa5fa58588e4b10f791c0 (2.37-59)
-Vulnerable-Commit: b0e7888d1fa2dbd2d9e1645ec8c796abf78880b9 (2.36-16)
-Fix-Commit: b9b7d6a27aa0632f334352fa400771115b3c69b7 (2.36-128)
diff --git a/advisories/README b/advisories/README
deleted file mode 100644
index 94e68b1350..0000000000
--- a/advisories/README
+++ /dev/null
@@ -1,73 +0,0 @@
-GNU C Library Security Advisory Format
-======================================
-
-Security advisories in this directory follow a simple git commit log
-format, with a heading and free-format description augmented with tags
-to allow parsing key information.  References to code changes are
-specific to the glibc repository and follow a specific format:
-
-  Tag-name: <commit-ref> (release-version)
-
-The <commit-ref> indicates a specific commit in the repository.  The
-release-version indicates the publicly consumable release in which this
-commit is known to exist.  The release-version is derived from the
-git-describe format, (i.e. stripped out from glibc-2.34.NNN-gxxxx) and
-is of the form 2.34-NNN.  If the -NNN suffix is absent, it means that
-the change is in that release tarball, otherwise the change is on the
-release/2.YY/master branch and not in any released tarball.
-
-The following tags are currently being used:
-
-CVE-Id:
-This is the CVE-Id assigned under the CVE Program
-(https://www.cve.org/).
-
-Public-Date:
-The date this issue became publicly known.
-
-Vulnerable-Commit:
-The commit that introduced this vulnerability.  There could be multiple
-entries, one for each release branch in the glibc repository; the
-release-version portion of this tag should tell you which branch this is
-on.
-
-Fix-Commit:
-The commit that fixed this vulnerability.  There could be multiple
-entries for each release branch in the glibc repository, indicating that
-all of those commits contributed to fixing that issue in each of those
-branches.
-
-Adding an Advisory
-------------------
-
-An advisory for a CVE needs to be added on the master branch in two steps:
-
-1. Add the text of the advisory without any Fix-Commit tags along with
-   the fix for the CVE.  Add the Vulnerable-Commit tag, if applicable.
-   The advisories directory does not exist in release branches, so keep
-   the advisory text commit distinct from the code changes, to ease
-   backports.  Ask for the GLIBC-SA advisory number from the security
-   team.
-
-2. Finish all backports on release branches and then back on the msater
-   branch, add all commit refs to the advisory using the Fix-Commit
-   tags.  Don't bother adding the release-version subscript since the
-   next step will overwrite it.
-
-3. Run the process-advisories.sh script in the scripts directory on the
-   advisory:
-
-     scripts/process-advisories.sh update GLIBC-SA-YYYY-NNNN
-
-   (replace YYYY-NNNN with the actual advisory number).
-
-4. Verify the updated advisory and push the result.
-
-Getting a NEWS snippet from advisories
---------------------------------------
-
-Run:
-
-  scripts/process-advisories.sh news
-
-and copy the content into the NEWS file.
diff --git a/assert/Makefile b/assert/Makefile
index 35dc908ddb..c0fe660bd6 100644
--- a/assert/Makefile
+++ b/assert/Makefile
@@ -38,6 +38,7 @@ tests := \
   test-assert-perr \
   tst-assert-c++ \
   tst-assert-g++ \
+  tst-assert-sa-2025-0001 \
   # tests
 
 ifeq ($(have-cxx-thread_local),yes)
diff --git a/assert/assert.c b/assert/assert.c
index c29629f5f6..b6e37d694c 100644
--- a/assert/assert.c
+++ b/assert/assert.c
@@ -18,6 +18,7 @@
 #include <assert.h>
 #include <atomic.h>
 #include <ldsodefs.h>
+#include <libc-pointer-arith.h>
 #include <libintl.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -65,7 +66,8 @@ __assert_fail_base (const char *fmt, const char *assertion, const char *file,
       (void) __fxprintf (NULL, "%s", str);
       (void) fflush (stderr);
 
-      total = (total + 1 + GLRO(dl_pagesize) - 1) & ~(GLRO(dl_pagesize) - 1);
+      total = ALIGN_UP (total + sizeof (struct abort_msg_s) + 1,
+			GLRO(dl_pagesize));
       struct abort_msg_s *buf = __mmap (NULL, total, PROT_READ | PROT_WRITE,
 					MAP_ANON | MAP_PRIVATE, -1, 0);
       if (__glibc_likely (buf != MAP_FAILED))
diff --git a/assert/tst-assert-sa-2025-0001.c b/assert/tst-assert-sa-2025-0001.c
new file mode 100644
index 0000000000..102cb0078d
--- /dev/null
+++ b/assert/tst-assert-sa-2025-0001.c
@@ -0,0 +1,92 @@
+/* Test for CVE-2025-0395.
+   Copyright The GNU Toolchain Authors.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* Test that a large enough __progname does not result in a buffer overflow
+   when printing an assertion failure.  This was CVE-2025-0395.  */
+#include <assert.h>
+#include <inttypes.h>
+#include <signal.h>
+#include <stdbool.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <support/check.h>
+#include <support/support.h>
+#include <support/xstdio.h>
+#include <support/xunistd.h>
+
+extern const char *__progname;
+
+int
+do_test (int argc, char **argv)
+{
+
+  support_need_proc ("Reads /proc/self/maps to add guards to writable maps.");
+  ignore_stderr ();
+
+  /* XXX assumes that the assert is on a 2 digit line number.  */
+  const char *prompt = ": %s:99: do_test: Assertion `argc < 1' failed.\n";
+
+  int ret = fprintf (stderr, prompt, __FILE__);
+  if (ret < 0)
+    FAIL_EXIT1 ("fprintf failed: %m\n");
+
+  size_t pagesize = getpagesize ();
+  size_t namesize = pagesize - 1 - ret;
+
+  /* Alter the progname so that the assert message fills the entire page.  */
+  char progname[namesize];
+  memset (progname, 'A', namesize - 1);
+  progname[namesize - 1] = '\0';
+  __progname = progname;
+
+  FILE *f = xfopen ("/proc/self/maps", "r");
+  char *line = NULL;
+  size_t len = 0;
+  uintptr_t prev_to = 0;
+
+  /* Pad the beginning of every writable mapping with a PROT_NONE map.  This
+     ensures that the mmap in the assert_fail path never ends up below a
+     writable map and will terminate immediately in case of a buffer
+     overflow.  */
+  while (xgetline (&line, &len, f))
+    {
+      uintptr_t from, to;
+      char perm[4];
+
+      sscanf (line, "%" SCNxPTR "-%" SCNxPTR " %c%c%c%c ",
+	      &from, &to,
+	      &perm[0], &perm[1], &perm[2], &perm[3]);
+
+      bool writable = (memchr (perm, 'w', 4) != NULL);
+
+      if (prev_to != 0 && from - prev_to > pagesize && writable)
+	xmmap ((void *) from - pagesize, pagesize, PROT_NONE,
+	       MAP_ANONYMOUS | MAP_PRIVATE, 0);
+
+      prev_to = to;
+    }
+
+  xfclose (f);
+
+  assert (argc < 1);
+  return 0;
+}
+
+#define EXPECTED_SIGNAL SIGABRT
+#define TEST_FUNCTION_ARGV do_test
+#include <support/test-driver.c>
diff --git a/benchtests/atanh-inputs b/benchtests/atanh-inputs
index 455aa65b65..4985293254 100644
--- a/benchtests/atanh-inputs
+++ b/benchtests/atanh-inputs
@@ -1,6 +1,7 @@
 ## args: double
 ## ret: double
 ## includes: math.h
+## name: workload-random
 0x1.5a2730bacd94ap-1
 -0x1.b57eb40fc048ep-21
 -0x1.c0b185fb450e2p-17
diff --git a/benchtests/sinh-inputs b/benchtests/sinh-inputs
index 7b1ac46a39..2fcb2fabf8 100644
--- a/benchtests/sinh-inputs
+++ b/benchtests/sinh-inputs
@@ -1,6 +1,7 @@
 ## args: double
 ## ret: double
 ## includes: math.h
+## name: workload-random
 0x1.bcb6129b5ff2bp8
 -0x1.63057386325ebp9
 0x1.62f1d7dc4e8bfp9
diff --git a/bits/socket.h b/bits/socket.h
index 13de124bac..772074d52a 100644
--- a/bits/socket.h
+++ b/bits/socket.h
@@ -149,7 +149,7 @@ enum __socket_type
 #include <bits/sockaddr.h>
 
 /* Structure describing a generic socket address.  */
-struct sockaddr
+struct __attribute_struct_may_alias__ sockaddr
   {
     __SOCKADDR_COMMON (sa_);	/* Common data: address family and length.  */
     char sa_data[14];		/* Address data.  */
@@ -166,7 +166,7 @@ struct sockaddr
 #define _SS_PADSIZE \
   (_SS_SIZE - __SOCKADDR_COMMON_SIZE - sizeof (__ss_aligntype))
 
-struct sockaddr_storage
+struct __attribute_struct_may_alias__ sockaddr_storage
   {
     __SOCKADDR_COMMON (ss_);	/* Address family, etc.  */
     char __ss_padding[_SS_PADSIZE];
diff --git a/bits/wordsize.h b/bits/wordsize.h
index 14edae3a11..53013a9275 100644
--- a/bits/wordsize.h
+++ b/bits/wordsize.h
@@ -21,7 +21,9 @@
 #define __WORDSIZE32_PTRDIFF_LONG
 
 /* Set to 1 in order to force time types to be 32 bits instead of 64 bits in
-   struct lastlog and struct utmp{,x} on 64-bit ports.  This may be done in
+   struct lastlog and struct utmp{,x}.  This may be done in
    order to make 64-bit ports compatible with 32-bit ports.  Set to 0 for
-   64-bit ports where the time types are 64-bits or for any 32-bit ports.  */
+   64-bit ports where the time types are 64-bits and new 32-bit ports
+   where time_t is 64 bits, and there is no companion architecture with
+   32-bit time_t.  */
 #define __WORDSIZE_TIME64_COMPAT32
diff --git a/config.h.in b/config.h.in
index 44a34072a4..a5fdea0c3c 100644
--- a/config.h.in
+++ b/config.h.in
@@ -141,6 +141,9 @@
 /* LOONGARCH floating-point ABI for ld.so.  */
 #undef LOONGARCH_ABI_FRLEN
 
+/* Define whether ARM used hard-float and support VFPvX-D32.  */
+#undef HAVE_ARM_PCS_VFP_D32
+
 /* Linux specific: minimum supported kernel version.  */
 #undef	__LINUX_KERNEL_VERSION
 
@@ -283,10 +286,16 @@
 /* Define if x86 ISA level should be included in shared libraries.  */
 #undef INCLUDE_X86_ISA_LEVEL
 
+/* The x86 ISA level.  1 for baseline.  Undefined on non-x86.  */
+#undef MINIMUM_X86_ISA_LEVEL
+
 /* Define if -msahf is enabled by default on x86.  */
 #undef HAVE_X86_LAHF_SAHF
 
 /* Define if -mmovbe is enabled by default on x86.  */
 #undef HAVE_X86_MOVBE
 
+/* Define if -mapxf is enabled by default on x86.  */
+#undef HAVE_X86_APX
+
 #endif
diff --git a/configure b/configure
index 59ff1e415d..a75759f625 100755
--- a/configure
+++ b/configure
@@ -653,7 +653,7 @@ LIBGD
 libc_cv_cc_loop_to_function
 libc_cv_cc_submachine
 libc_cv_cc_nofma
-libc_cv_mtls_dialect_gnu2
+libc_cv_mtls_descriptor
 libc_cv_has_glob_dat
 libc_cv_fpie
 libc_cv_z_execstack
@@ -4760,6 +4760,12 @@ libc_config_ok=no
 # whether to use such directories.
 with_fp_cond=1
 
+# A preconfigure script may define another name to TLS descriptor variant
+mtls_descriptor=gnu2
+
+# A preconfigure script may define another name to traditional TLS variant
+mtls_traditional=gnu
+
 if frags=`ls -d $srcdir/sysdeps/*/preconfigure 2> /dev/null`
 then
   { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for sysdeps preconfigure fragments" >&5
@@ -7006,9 +7012,9 @@ fi
 printf "%s\n" "$libc_cv_has_glob_dat" >&6; }
 
 
-{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -mtls-dialect=gnu2" >&5
-printf %s "checking for -mtls-dialect=gnu2... " >&6; }
-if test ${libc_cv_mtls_dialect_gnu2+y}
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for tls descriptor support" >&5
+printf %s "checking for tls descriptor support... " >&6; }
+if test ${libc_cv_mtls_descriptor+y}
 then :
   printf %s "(cached) " >&6
 else $as_nop
@@ -7019,25 +7025,58 @@ void foo (void)
   i = 10;
 }
 EOF
-if { ac_try='${CC-cc} $CFLAGS $CPPFLAGS -fPIC -mtls-dialect=gnu2 -nostdlib -nostartfiles
-		   conftest.c -o conftest 1>&5'
+if { ac_try='${CC-cc} $CFLAGS $CPPFLAGS -fPIC -mtls-dialect=$mtls_descriptor -nostdlib -nostartfiles
+		   -shared conftest.c -o conftest 1>&5'
   { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; }; }
 then
-  libc_cv_mtls_dialect_gnu2=yes
+  libc_cv_mtls_descriptor=$mtls_descriptor
 else
-  libc_cv_mtls_dialect_gnu2=no
+  libc_cv_mtls_descriptor=no
 fi
 rm -f conftest*
 fi
-{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $libc_cv_mtls_dialect_gnu2" >&5
-printf "%s\n" "$libc_cv_mtls_dialect_gnu2" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $libc_cv_mtls_descriptor" >&5
+printf "%s\n" "$libc_cv_mtls_descriptor" >&6; }
+
+config_vars="$config_vars
+have-mtls-descriptor = $libc_cv_mtls_descriptor"
 
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for traditional tls support" >&5
+printf %s "checking for traditional tls support... " >&6; }
+if test ${libc_cv_test_mtls_traditional+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat > conftest.c <<EOF
+__thread int i;
+void foo (void)
+{
+  i = 10;
+}
+EOF
+if { ac_try='${CC-cc} $CFLAGS $CPPFLAGS -fPIC -mtls-dialect=$mtls_traditional -nostdlib -nostartfiles
+		   -shared conftest.c -o conftest 1>&5'
+  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }
+then
+  libc_cv_test_mtls_traditional=$mtls_traditional
+else
+  libc_cv_test_mtls_traditional=no
+fi
+rm -f conftest* ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $libc_cv_test_mtls_traditional" >&5
+printf "%s\n" "$libc_cv_test_mtls_traditional" >&6; }
 config_vars="$config_vars
-have-mtls-dialect-gnu2 = $libc_cv_mtls_dialect_gnu2"
+have-test-mtls-traditional = $libc_cv_test_mtls_traditional"
 
 { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking if -Wno-ignored-attributes is required for aliases" >&5
 printf %s "checking if -Wno-ignored-attributes is required for aliases... " >&6; }
diff --git a/configure.ac b/configure.ac
index 65799e5685..a313397def 100644
--- a/configure.ac
+++ b/configure.ac
@@ -442,6 +442,12 @@ libc_config_ok=no
 # whether to use such directories.
 with_fp_cond=1
 
+# A preconfigure script may define another name to TLS descriptor variant
+mtls_descriptor=gnu2
+
+# A preconfigure script may define another name to traditional TLS variant
+mtls_traditional=gnu
+
 dnl Let sysdeps/*/preconfigure act here.
 LIBC_PRECONFIGURE([$srcdir], [for sysdeps])
 
@@ -1287,7 +1293,29 @@ fi
 rm -f conftest*])
 AC_SUBST(libc_cv_has_glob_dat)
 
-AC_CACHE_CHECK([for -mtls-dialect=gnu2], libc_cv_mtls_dialect_gnu2,
+AC_CACHE_CHECK([for tls descriptor support], libc_cv_mtls_descriptor,
+[dnl
+cat > conftest.c <<EOF
+__thread int i;
+void foo (void)
+{
+  i = 10;
+}
+EOF
+if AC_TRY_COMMAND([${CC-cc} $CFLAGS $CPPFLAGS -fPIC -mtls-dialect=$mtls_descriptor -nostdlib -nostartfiles
+		   -shared conftest.c -o conftest 1>&AS_MESSAGE_LOG_FD])
+then
+  libc_cv_mtls_descriptor=$mtls_descriptor
+else
+  libc_cv_mtls_descriptor=no
+fi
+rm -f conftest*])
+AC_SUBST(libc_cv_mtls_descriptor)
+LIBC_CONFIG_VAR([have-mtls-descriptor], [$libc_cv_mtls_descriptor])
+
+dnl Check if CC supports traditional tls.
+AC_CACHE_CHECK([for traditional tls support],
+	       libc_cv_test_mtls_traditional,
 [dnl
 cat > conftest.c <<EOF
 __thread int i;
@@ -1296,16 +1324,16 @@ void foo (void)
   i = 10;
 }
 EOF
-if AC_TRY_COMMAND([${CC-cc} $CFLAGS $CPPFLAGS -fPIC -mtls-dialect=gnu2 -nostdlib -nostartfiles
-		   conftest.c -o conftest 1>&AS_MESSAGE_LOG_FD])
+if AC_TRY_COMMAND([${CC-cc} $CFLAGS $CPPFLAGS -fPIC -mtls-dialect=$mtls_traditional -nostdlib -nostartfiles
+		   -shared conftest.c -o conftest 1>&AS_MESSAGE_LOG_FD])
 then
-  libc_cv_mtls_dialect_gnu2=yes
+  libc_cv_test_mtls_traditional=$mtls_traditional
 else
-  libc_cv_mtls_dialect_gnu2=no
+  libc_cv_test_mtls_traditional=no
 fi
 rm -f conftest*])
-AC_SUBST(libc_cv_mtls_dialect_gnu2)
-LIBC_CONFIG_VAR([have-mtls-dialect-gnu2], [$libc_cv_mtls_dialect_gnu2])
+LIBC_CONFIG_VAR([have-test-mtls-traditional],
+		[$libc_cv_test_mtls_traditional])
 
 dnl clang emits an warning for a double alias redirection, to warn the
 dnl original symbol is sed even when weak definition overrides it.
diff --git a/csu/Makefile b/csu/Makefile
index ac05ab24d5..34a8d74971 100644
--- a/csu/Makefile
+++ b/csu/Makefile
@@ -33,7 +33,7 @@ elide-routines.os = libc-tls
 csu-dummies = $(filter-out $(start-installed-name),crt1.o Mcrt1.o)
 extra-objs = start.o \
 	     $(start-installed-name) g$(start-installed-name) $(csu-dummies) \
-	     S$(start-installed-name)
+	     S$(start-installed-name) $(start-name-2.0)
 omit-deps = $(patsubst %.o,%,$(start-installed-name) g$(start-installed-name) \
 			     b$(start-installed-name) $(csu-dummies) \
 			     S$(start-installed-name) \
@@ -138,6 +138,9 @@ ifndef start-installed-name-rule
 $(objpfx)$(start-installed-name): $(objpfx)start.o $(objpfx)abi-note.o \
 				  $(objpfx)init.o $(objpfx)static-reloc.o
 	$(link-relocatable)
+$(objpfx)$(start-name-2.0): $(objpfx)start.o $(objpfx)abi-note.o \
+			    $(objpfx)static-reloc.o
+	$(link-relocatable)
 $(objpfx)r$(start-installed-name): $(objpfx)start.o $(objpfx)abi-note.o \
 				  $(objpfx)init.o
 	$(link-relocatable)
diff --git a/ctype/Makefile b/ctype/Makefile
index 717d020129..b7cd5f2282 100644
--- a/ctype/Makefile
+++ b/ctype/Makefile
@@ -24,9 +24,35 @@ include ../Makeconfig
 
 headers	:= ctype.h
 
-routines	:= ctype ctype-c99 ctype-extn ctype-c99_l ctype_l isctype
-aux		:= ctype-info
-
-tests	:= test_ctype
+routines := \
+  ctype \
+  ctype-c99 \
+  ctype-c99_l \
+  ctype-extn \
+  ctype_l \
+  isctype \
+  # routines
+aux := ctype-info
+
+tests := \
+  test_ctype \
+  tst-ctype-tls-dlmopen \
+  tst-ctype-tls-dlopen-static \
+  # tests
+
+tests-static := \
+  tst-ctype-tls-dlopen-static \
+  # tests-static
+
+modules-names := \
+  tst-ctype-tls-mod \
+  # modules-names
 
 include ../Rules
+
+$(objpfx)tst-ctype-tls-dlmopen: $(shared-thread-library)
+$(objpfx)tst-ctype-tls-dlmopen.out: $(objpfx)tst-ctype-tls-mod.so
+$(objpfx)tst-ctype-tls-dlopen-static: $(static-thread-library)
+$(objpfx)tst-ctype-tls-dlopen-static.out: $(objpfx)tst-ctype-tls-mod.so
+tst-ctype-tls-dlopen-static-ENV = \
+  LD_LIBRARY_PATH=$(ld-library-path):$(common-objpfx):$(common-objpfx)elf
diff --git a/ctype/ctype-info.c b/ctype/ctype-info.c
index 9032547567..b6cdf7eb66 100644
--- a/ctype/ctype-info.c
+++ b/ctype/ctype-info.c
@@ -19,20 +19,28 @@
 #include <ctype.h>
 #include <locale/localeinfo.h>
 
-__libc_tsd_define (, const uint16_t *, CTYPE_B)
-__libc_tsd_define (, const int32_t *, CTYPE_TOLOWER)
-__libc_tsd_define (, const int32_t *, CTYPE_TOUPPER)
+/* Fallback initialization using relocations.  See the _nl_C_locobj
+   initializers in locale/xlocale.c.  Usually, this is overwritten by
+   __ctype_init before user code runs, but this does not happen for
+   threads in secondary namespaces.  With the initializers, secondary
+   namespaces at least get locale data from the C locale.  */
+__thread const uint16_t * __libc_tsd_CTYPE_B attribute_tls_model_ie
+  = (const uint16_t *) _nl_C_LC_CTYPE_class + 128;
+__thread const int32_t * __libc_tsd_CTYPE_TOLOWER attribute_tls_model_ie
+  = (const int32_t *) _nl_C_LC_CTYPE_tolower + 128;
+__thread const int32_t * __libc_tsd_CTYPE_TOUPPER attribute_tls_model_ie
+  = (const int32_t *) _nl_C_LC_CTYPE_toupper + 128;
 
 
 void
 __ctype_init (void)
 {
-  const uint16_t **bp = __libc_tsd_address (const uint16_t *, CTYPE_B);
-  *bp = (const uint16_t *) _NL_CURRENT (LC_CTYPE, _NL_CTYPE_CLASS) + 128;
-  const int32_t **up = __libc_tsd_address (const int32_t *, CTYPE_TOUPPER);
-  *up = ((int32_t *) _NL_CURRENT (LC_CTYPE, _NL_CTYPE_TOUPPER) + 128);
-  const int32_t **lp = __libc_tsd_address (const int32_t *, CTYPE_TOLOWER);
-  *lp = ((int32_t *) _NL_CURRENT (LC_CTYPE, _NL_CTYPE_TOLOWER) + 128);
+  __libc_tsd_CTYPE_B
+    = ((const uint16_t *) _NL_CURRENT (LC_CTYPE, _NL_CTYPE_CLASS)) + 128;
+  __libc_tsd_CTYPE_TOUPPER
+    = ((const int32_t *) _NL_CURRENT (LC_CTYPE, _NL_CTYPE_TOUPPER)) + 128;
+  __libc_tsd_CTYPE_TOLOWER =
+    ((const int32_t *) _NL_CURRENT (LC_CTYPE, _NL_CTYPE_TOLOWER)) + 128;
 }
 libc_hidden_def (__ctype_init)
 
@@ -41,10 +49,7 @@ libc_hidden_def (__ctype_init)
 #if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_3)
 
 /* Defined in locale/C-ctype.c.  */
-extern const char _nl_C_LC_CTYPE_class[] attribute_hidden;
 extern const char _nl_C_LC_CTYPE_class32[] attribute_hidden;
-extern const char _nl_C_LC_CTYPE_toupper[] attribute_hidden;
-extern const char _nl_C_LC_CTYPE_tolower[] attribute_hidden;
 extern const char _nl_C_LC_CTYPE_class_upper[] attribute_hidden;
 extern const char _nl_C_LC_CTYPE_class_lower[] attribute_hidden;
 extern const char _nl_C_LC_CTYPE_class_alpha[] attribute_hidden;
diff --git a/ctype/tst-ctype-tls-dlmopen.c b/ctype/tst-ctype-tls-dlmopen.c
new file mode 100644
index 0000000000..f7eeb65551
--- /dev/null
+++ b/ctype/tst-ctype-tls-dlmopen.c
@@ -0,0 +1,2 @@
+#define DO_STATIC_TEST 0
+#include "tst-ctype-tls-skeleton.c"
diff --git a/ctype/tst-ctype-tls-dlopen-static.c b/ctype/tst-ctype-tls-dlopen-static.c
new file mode 100644
index 0000000000..c2c09c362c
--- /dev/null
+++ b/ctype/tst-ctype-tls-dlopen-static.c
@@ -0,0 +1,2 @@
+#define DO_STATIC_TEST 1
+#include "tst-ctype-tls-skeleton.c"
diff --git a/ctype/tst-ctype-tls-mod.c b/ctype/tst-ctype-tls-mod.c
new file mode 100644
index 0000000000..52cbb9dcb6
--- /dev/null
+++ b/ctype/tst-ctype-tls-mod.c
@@ -0,0 +1,37 @@
+/* Wrappers for <ctype.h> macros in a secondary namespace.
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <ctype.h>
+
+int
+my_isalpha (int ch)
+{
+  return isalpha (ch);
+}
+
+int
+my_toupper (int ch)
+{
+  return toupper (ch);
+}
+
+int
+my_tolower (int ch)
+{
+  return tolower (ch);
+}
diff --git a/ctype/tst-ctype-tls-skeleton.c b/ctype/tst-ctype-tls-skeleton.c
new file mode 100644
index 0000000000..8c53e35899
--- /dev/null
+++ b/ctype/tst-ctype-tls-skeleton.c
@@ -0,0 +1,67 @@
+/* Test that <ctype.h> in a secondary namespace works.
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* Before this file is included, define DO_STATIC_TEST to 0 or 1.
+   With 0, dlmopen is used for the test.  With 1, dlopen is used.  */
+
+#include <stddef.h>
+#include <stdlib.h>
+#include <support/check.h>
+#include <support/support.h>
+#include <support/xdlfcn.h>
+#include <support/xthread.h>
+
+static int (*my_isalpha) (int);
+static int (*my_toupper) (int);
+static int (*my_tolower) (int);
+
+static void *
+checks (void *ignore)
+{
+  TEST_VERIFY (my_isalpha ('a'));
+  TEST_VERIFY (!my_isalpha ('0'));
+  TEST_COMPARE (my_toupper ('a'), 'A');
+  TEST_COMPARE (my_toupper ('A'), 'A');
+  TEST_COMPARE (my_tolower ('a'), 'a');
+  TEST_COMPARE (my_tolower ('A'), 'a');
+  return NULL;
+}
+
+static int
+do_test (void)
+{
+  char *dso = xasprintf ("%s/ctype/tst-ctype-tls-mod.so", support_objdir_root);
+#if DO_STATIC_TEST
+  void *handle = xdlopen (dso, RTLD_LAZY);
+#else
+  void *handle = xdlmopen (LM_ID_NEWLM, dso, RTLD_LAZY);
+#endif
+  my_isalpha = xdlsym (handle, "my_isalpha");
+  my_toupper = xdlsym (handle, "my_toupper");
+  my_tolower = xdlsym (handle, "my_tolower");
+
+  checks (NULL);
+  xpthread_join (xpthread_create (NULL, checks, NULL));
+
+  xdlclose (handle);
+  free (dso);
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/debug/Makefile b/debug/Makefile
index 3903cc97a3..76c311d284 100644
--- a/debug/Makefile
+++ b/debug/Makefile
@@ -287,6 +287,7 @@ tests = \
   tst-fortify-wide \
   tst-longjmp_chk \
   tst-longjmp_chk2 \
+  tst-longjmp_chk3 \
   tst-realpath-chk \
   tst-sprintf-fortify-rdonly \
   tst-sprintf-fortify-unchecked \
diff --git a/debug/pcprofiledump.c b/debug/pcprofiledump.c
index 049a9c2744..94530f0cf9 100644
--- a/debug/pcprofiledump.c
+++ b/debug/pcprofiledump.c
@@ -75,6 +75,44 @@ static struct argp argp =
   options, parse_opt, args_doc, doc, NULL, more_help
 };
 
+/* Try to read SIZE bytes from FD and store them on BUF.  Terminate
+   the process upon read error.  Also terminate the process if less
+   than SIZE bytes are remaining in the file.  If !IN_HEADER, do not
+   terminate the process if the end of the file is encountered
+   immediately, before any bytes are read.
+
+   Returns true if SIZE bytes have been read, and false if no bytes
+   have been read due to an end-of-file condition.  */
+static bool
+read_exactly (int fd, void *buffer, size_t size, bool in_header)
+{
+  char *p = buffer;
+  char *end = p + size;
+  while (p < end)
+    {
+      ssize_t ret = TEMP_FAILURE_RETRY (read (fd, p, end - p));
+      if (ret < 0)
+	{
+	  if (in_header)
+	    error (EXIT_FAILURE, errno, _("cannot read header"));
+	  else
+	    error (EXIT_FAILURE, errno,  _("cannot read pointer pair"));
+	}
+      if (ret == 0)
+	{
+	  if (p == buffer && !in_header)
+	    /* Nothing has been read.  */
+	    return false;
+	  if (in_header)
+	    error (EXIT_FAILURE, 0, _("unexpected end of file in header"));
+	  else
+	    error (EXIT_FAILURE, 0,
+		   _("unexpected end of file in pointer pair"));
+	}
+      p += ret;
+    }
+  return true;
+}
 
 int
 main (int argc, char *argv[])
@@ -110,8 +148,7 @@ main (int argc, char *argv[])
   /* Read the first 4-byte word.  It contains the information about
      the word size and the endianness.  */
   uint32_t word;
-  if (TEMP_FAILURE_RETRY (read (fd, &word, 4)) != 4)
-    error (EXIT_FAILURE, errno, _("cannot read header"));
+  read_exactly (fd, &word, sizeof (word), true);
 
   /* Check whether we have to swap the byte order.  */
   int must_swap = (word & 0x0fffffff) == bswap_32 (0xdeb00000);
@@ -121,56 +158,30 @@ main (int argc, char *argv[])
   /* We have two loops, one for 32 bit pointers, one for 64 bit pointers.  */
   if (word == 0xdeb00004)
     {
-      union
-      {
-	uint32_t ptrs[2];
-	char bytes[8];
-      } pair;
+      uint32_t ptrs[2];
 
       while (1)
 	{
-	  size_t len = sizeof (pair);
-	  size_t n;
-
-	  while (len > 0
-		 && (n = TEMP_FAILURE_RETRY (read (fd, &pair.bytes[8 - len],
-						   len))) != 0)
-	    len -= n;
-
-	  if (len != 0)
-	    /* Nothing to read.  */
+	  if (!read_exactly (fd, ptrs, sizeof (ptrs), false))
 	    break;
 
 	  printf ("this = %#010" PRIx32 ", caller = %#010" PRIx32 "\n",
-		  must_swap ? bswap_32 (pair.ptrs[0]) : pair.ptrs[0],
-		  must_swap ? bswap_32 (pair.ptrs[1]) : pair.ptrs[1]);
+		  must_swap ? bswap_32 (ptrs[0]) : ptrs[0],
+		  must_swap ? bswap_32 (ptrs[1]) : ptrs[1]);
 	}
     }
   else if (word == 0xdeb00008)
     {
-      union
-      {
-	uint64_t ptrs[2];
-	char bytes[16];
-      } pair;
+      uint64_t ptrs[2];
 
       while (1)
 	{
-	  size_t len = sizeof (pair);
-	  size_t n;
-
-	  while (len > 0
-		 && (n = TEMP_FAILURE_RETRY (read (fd, &pair.bytes[8 - len],
-						   len))) != 0)
-	    len -= n;
-
-	  if (len != 0)
-	    /* Nothing to read.  */
+	  if (!read_exactly (fd, ptrs, sizeof (ptrs), false))
 	    break;
 
 	  printf ("this = %#018" PRIx64 ", caller = %#018" PRIx64 "\n",
-		  must_swap ? bswap_64 (pair.ptrs[0]) : pair.ptrs[0],
-		  must_swap ? bswap_64 (pair.ptrs[1]) : pair.ptrs[1]);
+		  must_swap ? bswap_64 (ptrs[0]) : ptrs[0],
+		  must_swap ? bswap_64 (ptrs[1]) : ptrs[1]);
 	}
     }
   else
diff --git a/debug/tst-fortify-syslog.c b/debug/tst-fortify-syslog.c
index a7ddbf7c6b..2712acf689 100644
--- a/debug/tst-fortify-syslog.c
+++ b/debug/tst-fortify-syslog.c
@@ -22,7 +22,6 @@
 #include <syslog.h>
 #include <string.h>
 #include <unistd.h>
-#include <stdio.h>
 
 #include <support/check.h>
 #include <support/support.h>
@@ -46,18 +45,13 @@ handler (int sig)
     _exit (127);
 }
 
-#define FAIL()						\
-  do {							\
-      printf ("Failure on line %d\n", __LINE__);	\
-      support_record_failure ();			\
-  } while (0)
 #define CHK_FAIL_START					\
   chk_fail_ok = 1;					\
   if (! setjmp (chk_fail_buf))				\
     {
 #define CHK_FAIL_END					\
       chk_fail_ok = 0;					\
-      FAIL ();						\
+      FAIL ("not supposed to reach here");		\
     }
 
 static void
diff --git a/debug/tst-longjmp_chk3.c b/debug/tst-longjmp_chk3.c
index 9ff9977207..9b9db3b9e9 100644
--- a/debug/tst-longjmp_chk3.c
+++ b/debug/tst-longjmp_chk3.c
@@ -18,9 +18,13 @@
 
 #include <setjmp.h>
 #include <signal.h>
+#include <stdio.h>
 #include <string.h>
+#include <unistd.h>
 
-static char buf[SIGSTKSZ * 4];
+#include <support/support.h>
+
+static char *buf;
 static jmp_buf jb;
 
 static void
@@ -49,8 +53,10 @@ do_test (void)
   set_fortify_handler (handler);
 
   /* Create a valid signal stack and enable it.  */
+  size_t bufsize = SIGSTKSZ * 4;
+  buf = xmalloc (bufsize);
   ss.ss_sp = buf;
-  ss.ss_size = sizeof (buf);
+  ss.ss_size = bufsize;
   ss.ss_flags = 0;
   if (sigaltstack (&ss, NULL) < 0)
     {
@@ -65,8 +71,8 @@ do_test (void)
 
   /* Shrink the signal stack so the jmpbuf is now invalid.
      We adjust the start & end to handle stacks that grow up & down.  */
-  ss.ss_sp = buf + sizeof (buf) / 2;
-  ss.ss_size = sizeof (buf) / 4;
+  ss.ss_sp = buf + bufsize / 2;
+  ss.ss_size = bufsize / 4;
   if (sigaltstack (&ss, NULL) < 0)
     {
       printf ("second sigaltstack failed: %m\n");
diff --git a/elf/Makefile b/elf/Makefile
index 5d78b659ce..381b5987e3 100644
--- a/elf/Makefile
+++ b/elf/Makefile
@@ -57,6 +57,7 @@ dl-routines = \
   dl-close \
   dl-debug \
   dl-debug-symbols \
+  dl-debug_state \
   dl-deps \
   dl-exception \
   dl-execstack \
@@ -170,6 +171,7 @@ CFLAGS-.op += $(call elide-stack-protector,.op,$(elide-routines.os))
 CFLAGS-.os += $(call elide-stack-protector,.os,$(all-rtld-routines))
 
 # Add the requested compiler flags to the early startup code.
+CFLAGS-dl-misc.os += $(rtld-early-cflags)
 CFLAGS-dl-printf.os += $(rtld-early-cflags)
 CFLAGS-dl-setup_hash.os += $(rtld-early-cflags)
 CFLAGS-dl-sysdep.os += $(rtld-early-cflags)
@@ -265,6 +267,7 @@ tests-static-normal := \
   tst-array1-static \
   tst-array5-static \
   tst-dl-iter-static \
+  tst-dlopen-sgid \
   tst-dst-static \
   tst-env-setuid-static \
   tst-getauxval-static \
@@ -375,6 +378,7 @@ tests += \
   tst-align3 \
   tst-audit-tlsdesc \
   tst-audit-tlsdesc-dlopen \
+  tst-audit-tlsdesc-dlopen2 \
   tst-audit1 \
   tst-audit2 \
   tst-audit8 \
@@ -411,8 +415,16 @@ tests += \
   tst-dlmopen1 \
   tst-dlmopen3 \
   tst-dlmopen4 \
+  tst-dlmopen4-nonpic \
+  tst-dlmopen4-pic \
+  tst-dlopen-auditdup \
+  tst-dlopen-constructor-null \
   tst-dlopen-self \
   tst-dlopen-tlsmodid \
+  tst-dlopen-tlsreinit1 \
+  tst-dlopen-tlsreinit2 \
+  tst-dlopen-tlsreinit3 \
+  tst-dlopen-tlsreinit4 \
   tst-dlopenfail \
   tst-dlopenfail-2 \
   tst-dlopenrpath \
@@ -424,6 +436,7 @@ tests += \
   tst-glibc-hwcaps-prepend \
   tst-global1 \
   tst-global2 \
+  tst-gnu2-tls2 \
   tst-initfinilazyfail \
   tst-initorder \
   tst-initorder2 \
@@ -441,8 +454,12 @@ tests += \
   tst-p_align1 \
   tst-p_align2 \
   tst-p_align3 \
+  tst-recursive-tls \
   tst-relsort1 \
   tst-ro-dynamic \
+  tst-rtld-no-malloc \
+  tst-rtld-no-malloc-audit \
+  tst-rtld-no-malloc-preload \
   tst-rtld-run-static \
   tst-single_threaded \
   tst-single_threaded-pthread \
@@ -467,6 +484,7 @@ tests += \
   tst-tls19 \
   tst-tls20 \
   tst-tls21 \
+  tst-tls23 \
   tst-tlsalign \
   tst-tlsalign-extern \
   tst-tlsgap \
@@ -474,6 +492,7 @@ tests += \
   tst-unique2 \
   tst-unwind-ctor \
   tst-unwind-main \
+  tst-version-hash-zero \
   unload3 \
   unload4 \
   unload5 \
@@ -504,6 +523,8 @@ tests-internal += \
   tst-dl_find_object \
   tst-dl_find_object-threads \
   tst-dlmopen2 \
+  tst-link-map-contiguous-ldso \
+  tst-link-map-contiguous-libc \
   tst-ptrguard1 \
   tst-stackguard1 \
   tst-tls-surplus \
@@ -515,6 +536,10 @@ tests-internal += \
   unload2 \
   # tests-internal
 
+ifeq ($(build-hardcoded-path-in-tests),yes)
+tests-internal += tst-link-map-contiguous-main
+endif
+
 tests-container += \
   tst-dlopen-self-container \
   tst-dlopen-tlsmodid-container \
@@ -795,6 +820,7 @@ modules-names += \
   tst-auditmanymod8 \
   tst-auditmanymod9 \
   tst-auditmod-tlsdesc  \
+  tst-auditmod-tlsdesc2 \
   tst-auditmod1 \
   tst-auditmod11 \
   tst-auditmod12 \
@@ -835,6 +861,14 @@ modules-names += \
   tst-dlmopen-twice-mod1 \
   tst-dlmopen-twice-mod2 \
   tst-dlmopen1mod \
+  tst-dlopen-auditdup-auditmod \
+  tst-dlopen-auditdupmod \
+  tst-dlopen-constructor-null-mod1 \
+  tst-dlopen-constructor-null-mod2 \
+  tst-dlopen-sgid-mod \
+  tst-dlopen-tlsreinitmod1 \
+  tst-dlopen-tlsreinitmod2 \
+  tst-dlopen-tlsreinitmod3 \
   tst-dlopenfaillinkmod \
   tst-dlopenfailmod1 \
   tst-dlopenfailmod2 \
@@ -846,6 +880,9 @@ modules-names += \
   tst-filterobj-flt \
   tst-finilazyfailmod \
   tst-globalmod2 \
+  tst-gnu2-tls2mod0 \
+  tst-gnu2-tls2mod1 \
+  tst-gnu2-tls2mod2 \
   tst-initlazyfailmod \
   tst-initorder2a \
   tst-initorder2b \
@@ -872,6 +909,23 @@ modules-names += \
   tst-null-argv-lib \
   tst-p_alignmod-base \
   tst-p_alignmod3 \
+  tst-recursive-tlsmallocmod \
+  tst-recursive-tlsmod0 \
+  tst-recursive-tlsmod1 \
+  tst-recursive-tlsmod2 \
+  tst-recursive-tlsmod3 \
+  tst-recursive-tlsmod4 \
+  tst-recursive-tlsmod5 \
+  tst-recursive-tlsmod6 \
+  tst-recursive-tlsmod7 \
+  tst-recursive-tlsmod8 \
+  tst-recursive-tlsmod9 \
+  tst-recursive-tlsmod10 \
+  tst-recursive-tlsmod11 \
+  tst-recursive-tlsmod12 \
+  tst-recursive-tlsmod13 \
+  tst-recursive-tlsmod14 \
+  tst-recursive-tlsmod15 \
   tst-relsort1mod1 \
   tst-relsort1mod2 \
   tst-ro-dynamic-mod \
@@ -896,6 +950,7 @@ modules-names += \
   tst-tls19mod3 \
   tst-tls20mod-bad \
   tst-tls21mod \
+  tst-tls23-mod \
   tst-tlsalign-lib \
   tst-tlsgap-mod0 \
   tst-tlsgap-mod1 \
@@ -926,6 +981,9 @@ modules-names += \
   tst-unique2mod1 \
   tst-unique2mod2 \
   tst-unwind-ctor-lib \
+  tst-version-hash-zero-linkmod \
+  tst-version-hash-zero-mod \
+  tst-version-hash-zero-refmod \
   unload2dep \
   unload2mod \
   unload3mod1 \
@@ -995,13 +1053,13 @@ modules-names-tests = $(filter-out ifuncmod% tst-tlsmod%,\
 # For +depfiles in Makerules.
 extra-test-objs += tst-auditmod17.os
 
-ifeq (yes,$(have-mtls-dialect-gnu2))
+ifneq (no,$(have-mtls-descriptor))
 tests += tst-gnu2-tls1
 modules-names += tst-gnu2-tls1mod
 $(objpfx)tst-gnu2-tls1: $(objpfx)tst-gnu2-tls1mod.so
 tst-gnu2-tls1mod.so-no-z-defs = yes
-CFLAGS-tst-gnu2-tls1mod.c += -mtls-dialect=gnu2
-endif # $(have-mtls-dialect-gnu2)
+CFLAGS-tst-gnu2-tls1mod.c += -mtls-dialect=$(have-mtls-descriptor)
+endif # $(have-mtls-descriptor)
 
 ifeq (yes,$(have-protected-data))
 modules-names += tst-protected1moda tst-protected1modb
@@ -2002,6 +2060,13 @@ $(objpfx)tst-dlmopen3.out: $(objpfx)tst-dlmopen1mod.so
 
 $(objpfx)tst-dlmopen4.out: $(objpfx)tst-dlmopen1mod.so
 
+CFLAGS-tst-dlmopen4-pic.c += -fPIC
+$(objpfx)tst-dlmopen4-pic.out: $(objpfx)tst-dlmopen1mod.so
+
+CFLAGS-tst-dlmopen4-nonpic.c += -fno-pie
+tst-dlmopen4-nonpic-no-pie = yes
+$(objpfx)tst-dlmopen4-nonpic.out: $(objpfx)tst-dlmopen1mod.so
+
 $(objpfx)tst-audit1.out: $(objpfx)tst-auditmod1.so
 tst-audit1-ENV = LD_AUDIT=$(objpfx)tst-auditmod1.so
 
@@ -2968,11 +3033,11 @@ $(objpfx)tst-tls-allocation-failure-static-patched.out: \
 $(objpfx)tst-audit-tlsdesc: $(objpfx)tst-audit-tlsdesc-mod1.so \
 			    $(objpfx)tst-audit-tlsdesc-mod2.so \
 			    $(shared-thread-library)
-ifeq (yes,$(have-mtls-dialect-gnu2))
+ifneq (no,$(have-mtls-descriptor))
 # The test is valid for all TLS types, but we want to exercise GNU2
 # TLS if possible.
-CFLAGS-tst-audit-tlsdesc-mod1.c += -mtls-dialect=gnu2
-CFLAGS-tst-audit-tlsdesc-mod2.c += -mtls-dialect=gnu2
+CFLAGS-tst-audit-tlsdesc-mod1.c += -mtls-dialect=$(have-mtls-descriptor)
+CFLAGS-tst-audit-tlsdesc-mod2.c += -mtls-dialect=$(have-mtls-descriptor)
 endif
 $(objpfx)tst-audit-tlsdesc-dlopen: $(shared-thread-library)
 $(objpfx)tst-audit-tlsdesc-dlopen.out: $(objpfx)tst-audit-tlsdesc-mod1.so \
@@ -2982,6 +3047,9 @@ $(objpfx)tst-audit-tlsdesc.out: $(objpfx)tst-auditmod-tlsdesc.so
 tst-audit-tlsdesc-ENV = LD_AUDIT=$(objpfx)tst-auditmod-tlsdesc.so
 $(objpfx)tst-audit-tlsdesc-dlopen.out: $(objpfx)tst-auditmod-tlsdesc.so
 tst-audit-tlsdesc-dlopen-ENV = LD_AUDIT=$(objpfx)tst-auditmod-tlsdesc.so
+$(objpfx)tst-audit-tlsdesc-dlopen2.out: $(objpfx)tst-auditmod-tlsdesc2.so \
+  $(patsubst %, $(objpfx)%.so, $(tlsmod17a-modules))
+tst-audit-tlsdesc-dlopen2-ENV = LD_AUDIT=$(objpfx)tst-auditmod-tlsdesc2.so
 
 $(objpfx)tst-dlmopen-twice.out: \
   $(objpfx)tst-dlmopen-twice-mod1.so \
@@ -3044,8 +3112,108 @@ $(objpfx)tst-tlsgap.out: \
   $(objpfx)tst-tlsgap-mod0.so \
   $(objpfx)tst-tlsgap-mod1.so \
   $(objpfx)tst-tlsgap-mod2.so
-ifeq (yes,$(have-mtls-dialect-gnu2))
-CFLAGS-tst-tlsgap-mod0.c += -mtls-dialect=gnu2
-CFLAGS-tst-tlsgap-mod1.c += -mtls-dialect=gnu2
-CFLAGS-tst-tlsgap-mod2.c += -mtls-dialect=gnu2
+
+$(objpfx)tst-gnu2-tls2: $(shared-thread-library)
+$(objpfx)tst-gnu2-tls2.out: \
+  $(objpfx)tst-gnu2-tls2mod0.so \
+  $(objpfx)tst-gnu2-tls2mod1.so \
+  $(objpfx)tst-gnu2-tls2mod2.so
+
+ifneq (no,$(have-mtls-descriptor))
+CFLAGS-tst-tlsgap-mod0.c += -mtls-dialect=$(have-mtls-descriptor)
+CFLAGS-tst-tlsgap-mod1.c += -mtls-dialect=$(have-mtls-descriptor)
+CFLAGS-tst-tlsgap-mod2.c += -mtls-dialect=$(have-mtls-descriptor)
+CFLAGS-tst-gnu2-tls2mod0.c += -mtls-dialect=$(have-mtls-descriptor)
+CFLAGS-tst-gnu2-tls2mod1.c += -mtls-dialect=$(have-mtls-descriptor)
+CFLAGS-tst-gnu2-tls2mod2.c += -mtls-dialect=$(have-mtls-descriptor)
 endif
+
+$(objpfx)tst-tls23: $(shared-thread-library)
+$(objpfx)tst-tls23.out: $(objpfx)tst-tls23-mod.so
+
+ifneq (no,$(have-test-mtls-traditional))
+CFLAGS-tst-tls23-mod.c += -mtls-dialect=$(have-test-mtls-traditional)
+endif
+
+$(objpfx)tst-recursive-tls: $(objpfx)tst-recursive-tlsmallocmod.so
+# More objects than DTV_SURPLUS, to trigger DTV reallocation.
+$(objpfx)tst-recursive-tls.out: \
+  $(patsubst %,$(objpfx)tst-recursive-tlsmod%.so, \
+    0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15)
+$(objpfx)tst-recursive-tlsmod%.os: tst-recursive-tlsmodN.c
+	$(compile-command.c) -DVAR=thread_$* -DFUNC=get_threadvar_$*
+
+# Order matters here.  The test needs the constructor for
+# tst-dlopen-tlsreinitmod2.so to be called first.
+LDFLAGS-tst-dlopen-tlsreinitmod1.so = -Wl,--no-as-needed
+$(objpfx)tst-dlopen-tlsreinitmod1.so: \
+  $(objpfx)tst-dlopen-tlsreinitmod3.so $(objpfx)tst-dlopen-tlsreinitmod2.so
+LDFLAGS-tst-dlopen-tlsreinit2 = -Wl,--no-as-needed
+$(objpfx)tst-dlopen-tlsreinit2: \
+  $(objpfx)tst-dlopen-tlsreinitmod3.so $(objpfx)tst-dlopen-tlsreinitmod2.so
+LDFLAGS-tst-dlopen-tlsreinit4 = -Wl,--no-as-needed
+$(objpfx)tst-dlopen-tlsreinit4: \
+  $(objpfx)tst-dlopen-tlsreinitmod3.so $(objpfx)tst-dlopen-tlsreinitmod2.so
+# tst-dlopen-tlsreinitmod2.so is underlinked and refers to
+# tst-dlopen-tlsreinitmod3.so.  The dependency is provided via
+# $(objpfx)tst-dlopen-tlsreinitmod1.so.
+tst-dlopen-tlsreinitmod2.so-no-z-defs = yes
+$(objpfx)tst-dlopen-tlsreinit1.out: $(objpfx)tst-dlopen-tlsreinitmod1.so \
+  $(objpfx)tst-dlopen-tlsreinitmod2.so $(objpfx)tst-dlopen-tlsreinitmod3.so
+# Reuse an audit module which provides ample debug logging.
+$(objpfx)tst-dlopen-tlsreinit3.out: $(objpfx)tst-auditmod1.so
+tst-dlopen-tlsreinit3-ENV = LD_AUDIT=$(objpfx)tst-auditmod1.so
+$(objpfx)tst-dlopen-tlsreinit4.out: $(objpfx)tst-auditmod1.so
+tst-dlopen-tlsreinit4-ENV = LD_AUDIT=$(objpfx)tst-auditmod1.so
+
+$(objpfx)tst-dlopen-sgid.out: $(objpfx)tst-dlopen-sgid-mod.so
+
+tst-dlopen-auditdup-ENV = LD_AUDIT=$(objpfx)tst-dlopen-auditdup-auditmod.so
+$(objpfx)tst-dlopen-auditdup.out: \
+  $(objpfx)tst-dlopen-auditdupmod.so $(objpfx)tst-dlopen-auditdup-auditmod.so
+
+# Reuse an audit module which provides ample debug logging.
+tst-rtld-no-malloc-audit-ENV = LD_AUDIT=$(objpfx)tst-auditmod1.so
+
+# Any shared object should do.
+tst-rtld-no-malloc-preload-ENV = LD_PRELOAD=$(objpfx)tst-auditmod1.so
+
+# These rules link and run the special elf/tst-nolink-libc-* tests if
+# a port adds them to the tests variables.  Neither test variant is
+# linked against libc.so, but tst-nolink-libc-1 is linked against
+# ld.so.  The test is always run directly, not under the dynamic
+# linker.
+CFLAGS-tst-nolink-libc.c += $(no-stack-protector)
+$(objpfx)tst-nolink-libc-1: $(objpfx)tst-nolink-libc.o $(objpfx)ld.so
+	$(LINK.o) -nostdlib -nostartfiles -o $@ $< \
+	  -Wl,--dynamic-linker=$(objpfx)ld.so,--no-as-needed $(objpfx)ld.so
+$(objpfx)tst-nolink-libc-1.out: $(objpfx)tst-nolink-libc-1 $(objpfx)ld.so
+	$< > $@ 2>&1; $(evaluate-test)
+$(objpfx)tst-nolink-libc-2: $(objpfx)tst-nolink-libc.o
+	$(LINK.o) -nostdlib -nostartfiles -o $@ $< \
+	  -Wl,--dynamic-linker=$(objpfx)ld.so
+$(objpfx)tst-nolink-libc-2.out: $(objpfx)tst-nolink-libc-2 $(objpfx)ld.so
+	$< > $@ 2>&1; $(evaluate-test)
+
+$(objpfx)tst-version-hash-zero.out: \
+  $(objpfx)tst-version-hash-zero-mod.so \
+  $(objpfx)tst-version-hash-zero-refmod.so
+LDFLAGS-tst-version-hash-zero-mod.so = \
+  -Wl,--version-script=tst-version-hash-zero-mod.map
+# The run-time test module tst-version-hash-zero-refmod.so is linked
+# to a stub module, tst-version-hash-zero-linkmod.so, to produce an
+# expected relocation error.
+$(objpfx)tst-version-hash-zero-refmod.so: \
+  $(objpfx)tst-version-hash-zero-linkmod.so
+LDFLAGS-tst-version-hash-zero-linkmod.so = \
+  -Wl,--version-script=tst-version-hash-zero-linkmod.map \
+  -Wl,--soname=tst-version-hash-zero-mod.so
+$(objpfx)tst-version-hash-zero-refmod.so: \
+  $(objpfx)tst-version-hash-zero-linkmod.so
+tst-version-hash-zero-refmod.so-no-z-defs = yes
+
+$(objpfx)tst-dlopen-constructor-null: \
+  $(objpfx)tst-dlopen-constructor-null-mod1.so \
+  $(objpfx)tst-dlopen-constructor-null-mod2.so
+$(objpfx)tst-dlopen-constructor-null-mod2.so: \
+  $(objpfx)tst-dlopen-constructor-null-mod1.so
diff --git a/elf/cache.c b/elf/cache.c
index 8a618e11fa..62d681df42 100644
--- a/elf/cache.c
+++ b/elf/cache.c
@@ -820,7 +820,7 @@ struct aux_cache_entry
   struct aux_cache_entry *next;
 };
 
-#define AUX_CACHEMAGIC		"glibc-ld.so.auxcache-1.0"
+#define AUX_CACHEMAGIC		"glibc-ld.so.auxcache-2.0"
 
 struct aux_cache_file_entry
 {
diff --git a/elf/dl-close.c b/elf/dl-close.c
index 88226245eb..fb27a1231c 100644
--- a/elf/dl-close.c
+++ b/elf/dl-close.c
@@ -264,6 +264,12 @@ _dl_close_worker (struct link_map *map, bool force)
 	    _dl_catch_exception (NULL, _dl_call_fini, imap);
 
 #ifdef SHARED
+	  /* Auditing checkpoint: we will start deleting objects.
+	     This is supposed to happen before la_objclose (see _dl_fini),
+	     but only once per non-recursive dlclose call.  */
+	  if (!unload_any)
+	    _dl_audit_activity_nsid (nsid, LA_ACT_DELETE);
+
 	  /* Auditing checkpoint: we remove an object.  */
 	  _dl_audit_objclose (imap);
 #endif
@@ -424,15 +430,10 @@ _dl_close_worker (struct link_map *map, bool force)
   if (!unload_any)
     goto out;
 
-#ifdef SHARED
-  /* Auditing checkpoint: we will start deleting objects.  */
-  _dl_audit_activity_nsid (nsid, LA_ACT_DELETE);
-#endif
-
-  /* Notify the debugger we are about to remove some loaded objects.  */
+  /* Notify the debugger we are about to remove some loaded objects.
+     LA_ACT_DELETE has already been signalled above for !unload_any.  */
   struct r_debug *r = _dl_debug_update (nsid);
-  r->r_state = RT_DELETE;
-  _dl_debug_state ();
+  _dl_debug_change_state (r, RT_DELETE);
   LIBC_PROBE (unmap_start, 2, nsid, r);
 
   if (unload_global)
@@ -723,6 +724,10 @@ _dl_close_worker (struct link_map *map, bool force)
   /* TLS is cleaned up for the unloaded modules.  */
   __rtld_lock_unlock_recursive (GL(dl_load_tls_lock));
 
+  /* Notify the debugger those objects are finalized and gone.  */
+  _dl_debug_change_state (r, RT_CONSISTENT);
+  LIBC_PROBE (unmap_complete, 2, nsid, r);
+
 #ifdef SHARED
   /* Auditing checkpoint: we have deleted all objects.  Also, do not notify
      auditors of the cleanup of a failed audit module loading attempt.  */
@@ -735,11 +740,6 @@ _dl_close_worker (struct link_map *map, bool force)
       --GL(dl_nns);
     while (GL(dl_ns)[GL(dl_nns) - 1]._ns_loaded == NULL);
 
-  /* Notify the debugger those objects are finalized and gone.  */
-  r->r_state = RT_CONSISTENT;
-  _dl_debug_state ();
-  LIBC_PROBE (unmap_complete, 2, nsid, r);
-
   /* Recheck if we need to retry, release the lock.  */
  out:
   if (dl_close_state == rerun)
diff --git a/elf/dl-debug-symbols.S b/elf/dl-debug-symbols.S
index 4e35adef5d..33f0fc77de 100644
--- a/elf/dl-debug-symbols.S
+++ b/elf/dl-debug-symbols.S
@@ -38,3 +38,4 @@
 _r_debug:
 _r_debug_extended:
 	.zero	R_DEBUG_EXTENDED_SIZE
+rtld_hidden_def (_r_debug)
diff --git a/elf/dl-debug.c b/elf/dl-debug.c
index ef56de7a29..df36d61dcb 100644
--- a/elf/dl-debug.c
+++ b/elf/dl-debug.c
@@ -16,6 +16,7 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
+#include <assert.h>
 #include <ldsodefs.h>
 
 
@@ -30,23 +31,86 @@ extern const int verify_link_map_members[(VERIFY_MEMBER (l_addr)
 					  && VERIFY_MEMBER (l_prev))
 					 ? 1 : -1];
 
+#ifdef SHARED
+/* r_debug structs for secondary namespaces.  The first namespace is
+   handled separately because its r_debug structure must overlap with
+   the public _r_debug symbol, so the first array element corresponds
+   to LM_ID_BASE + 1.  See elf/dl-debug-symbols.S.  */
+struct r_debug_extended _r_debug_array[DL_NNS - 1];
+
+/* If not null, pointer to the _r_debug in the main executable.  */
+static struct r_debug *_r_debug_main;
+
+void
+_dl_debug_post_relocate (struct link_map *main_map)
+{
+  /* Perform a full symbol search in all objects, to maintain
+     compatibility if interposed _r_debug definitions.  The lookup
+     cannot fail because there is a definition in ld.so, and this
+     function is only called if the ld.so search scope is not empty.  */
+  const ElfW(Sym) *sym = NULL;
+  lookup_t result =_dl_lookup_symbol_x ("_r_debug", main_map, &sym,
+					main_map->l_scope, NULL, 0, 0, NULL);
+  if (sym->st_size >= sizeof (struct r_debug))
+    {
+      struct r_debug *main_r_debug = DL_SYMBOL_ADDRESS (result, sym);
+      if (main_r_debug != &_r_debug_extended.base)
+	{
+	  /* The extended version of the struct is not available in
+	     the main executable because a copy relocation has been
+	     used.  r_map etc. have already been copied as part of the
+	     copy relocation processing.  */
+	  main_r_debug->r_version = 1;
+
+          /* Record that dual updates of the initial link map are
+             required.  */
+          _r_debug_main = main_r_debug;
+	}
+    }
+}
+
+/* Return the r_debug object for the namespace NS.  */
+static inline struct r_debug_extended *
+get_rdebug (Lmid_t ns)
+{
+  if (ns == LM_ID_BASE)
+    return &_r_debug_extended;
+  else
+    return  &_r_debug_array[ns - 1];
+}
+#else /* !SHARED */
+static inline struct r_debug_extended *
+get_rdebug (Lmid_t ns)
+{
+  return &_r_debug_extended; /* There is just one namespace.  */
+}
+#endif  /* !SHARED */
+
 /* Update the `r_map' member and return the address of `struct r_debug'
    of the namespace NS. */
 
 struct r_debug *
 _dl_debug_update (Lmid_t ns)
 {
-  struct r_debug_extended *r;
-  if (ns == LM_ID_BASE)
-    r = &_r_debug_extended;
-  else
-    r = &GL(dl_ns)[ns]._ns_debug;
+  struct r_debug_extended *r = get_rdebug (ns);
   if (r->base.r_map == NULL)
     atomic_store_release (&r->base.r_map,
 			  (void *) GL(dl_ns)[ns]._ns_loaded);
   return &r->base;
 }
 
+void
+_dl_debug_change_state (struct r_debug *r, int state)
+{
+  atomic_store_release (&r->r_state, state);
+#ifdef SHARED
+  if (r == &_r_debug_extended.base && _r_debug_main != NULL)
+    /* Update the copy-relocation of _r_debug.  */
+    atomic_store_release (&_r_debug_main->r_state, state);
+#endif
+  _dl_debug_state ();
+}
+
 /* Initialize _r_debug_extended for the namespace NS.  LDBASE is the
    run-time load address of the dynamic linker, to be put in
    _r_debug_extended.r_ldbase.  Return the address of _r_debug.  */
@@ -54,34 +118,7 @@ _dl_debug_update (Lmid_t ns)
 struct r_debug *
 _dl_debug_initialize (ElfW(Addr) ldbase, Lmid_t ns)
 {
-  struct r_debug_extended *r, **pp = NULL;
-
-  if (ns == LM_ID_BASE)
-    {
-      r = &_r_debug_extended;
-      /* Initialize r_version to 1.  */
-      if (_r_debug_extended.base.r_version == 0)
-	_r_debug_extended.base.r_version = 1;
-    }
-  else if (DL_NNS > 1)
-    {
-      r = &GL(dl_ns)[ns]._ns_debug;
-      if (r->base.r_brk == 0)
-	{
-	  /* Add the new namespace to the linked list.  After a namespace
-	     is initialized, r_brk becomes non-zero.  A namespace becomes
-	     empty (r_map == NULL) when it is unused.  But it is never
-	     removed from the linked list.  */
-	  struct r_debug_extended *p;
-	  for (pp = &_r_debug_extended.r_next;
-	       (p = *pp) != NULL;
-	       pp = &p->r_next)
-	    ;
-
-	  r->base.r_version = 2;
-	}
-    }
-
+  struct r_debug_extended *r = get_rdebug (ns);
   if (r->base.r_brk == 0)
     {
       /* Tell the debugger where to find the map of loaded objects.
@@ -89,30 +126,44 @@ _dl_debug_initialize (ElfW(Addr) ldbase, Lmid_t ns)
 	 only once.  */
       r->base.r_ldbase = ldbase ?: _r_debug_extended.base.r_ldbase;
       r->base.r_brk = (ElfW(Addr)) &_dl_debug_state;
-      r->r_next = NULL;
+
+#ifdef SHARED
+      /* Add the new namespace to the linked list.  This assumes that
+	 namespaces are allocated in increasing order.  After a
+	 namespace is initialized, r_brk becomes non-zero.  A
+	 namespace becomes empty (r_map == NULL) when it is unused.
+	 But it is never removed from the linked list.  */
+
+      if (ns != LM_ID_BASE)
+	{
+	  r->base.r_version = 2;
+	  if (ns - 1 == LM_ID_BASE)
+	    {
+	      atomic_store_release (&_r_debug_extended.r_next, r);
+	      /* Now there are multiple namespaces.  Note that this
+		 deliberately does not update the copy in the main
+		 executable (if it exists).  */
+	      atomic_store_release (&_r_debug_extended.base.r_version, 2);
+	    }
+	  else
+	    /* Update r_debug_extended of the previous namespace.  */
+	    atomic_store_release (&_r_debug_array[ns - 2].r_next, r);
+	}
+      else
+#endif /* SHARED */
+	r->base.r_version = 1;
     }
 
   if (r->base.r_map == NULL)
-    atomic_store_release (&r->base.r_map,
-			  (void *) GL(dl_ns)[ns]._ns_loaded);
-
-  if (pp != NULL)
     {
-      atomic_store_release (pp, r);
-      /* Bump r_version to 2 for the new namespace.  */
-      atomic_store_release (&_r_debug_extended.base.r_version, 2);
+      struct link_map_public *l = (void *) GL(dl_ns)[ns]._ns_loaded;
+      atomic_store_release (&r->base.r_map, l);
+#ifdef SHARED
+      if (ns == LM_ID_BASE && _r_debug_main != NULL)
+	/* Update the copy-relocation of _r_debug.  */
+	atomic_store_release (&_r_debug_main->r_map, l);
+#endif
     }
 
   return &r->base;
 }
-
-
-/* This function exists solely to have a breakpoint set on it by the
-   debugger.  The debugger is supposed to find this function's address by
-   examining the r_brk member of struct r_debug, but GDB 4.15 in fact looks
-   for this particular symbol name in the PT_INTERP file.  */
-void
-_dl_debug_state (void)
-{
-}
-rtld_hidden_def (_dl_debug_state)
diff --git a/elf/dl-debug_state.c b/elf/dl-debug_state.c
new file mode 100644
index 0000000000..40c134a49e
--- /dev/null
+++ b/elf/dl-debug_state.c
@@ -0,0 +1,30 @@
+/* Debugger hook called after dynamic linker updates.
+   Copyright (C) 1996-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <ldsodefs.h>
+
+/* This function exists solely to have a breakpoint set on it by the
+   debugger.  The debugger is supposed to find this function's address by
+   examining the r_brk member of struct r_debug, but GDB 4.15 in fact looks
+   for this particular symbol name in the PT_INTERP file.  Therefore,
+   this function must not be inlined.  */
+void
+_dl_debug_state (void)
+{
+}
+rtld_hidden_def (_dl_debug_state)
diff --git a/elf/dl-diagnostics.c b/elf/dl-diagnostics.c
index 7345ebc4e5..aaf67b87e8 100644
--- a/elf/dl-diagnostics.c
+++ b/elf/dl-diagnostics.c
@@ -235,6 +235,8 @@ _dl_print_diagnostics (char **environ)
   _dl_diagnostics_print_labeled_value ("dl_hwcap", GLRO (dl_hwcap));
   _dl_diagnostics_print_labeled_value ("dl_hwcap_important", HWCAP_IMPORTANT);
   _dl_diagnostics_print_labeled_value ("dl_hwcap2", GLRO (dl_hwcap2));
+  _dl_diagnostics_print_labeled_value ("dl_hwcap3", GLRO (dl_hwcap3));
+  _dl_diagnostics_print_labeled_value ("dl_hwcap4", GLRO (dl_hwcap4));
   _dl_diagnostics_print_labeled_string
     ("dl_hwcaps_subdirs", _dl_hwcaps_subdirs);
   _dl_diagnostics_print_labeled_value
diff --git a/elf/dl-find_object.c b/elf/dl-find_object.c
index 940fa5c223..f258665a71 100644
--- a/elf/dl-find_object.c
+++ b/elf/dl-find_object.c
@@ -465,6 +465,37 @@ _dl_find_object (void *pc1, struct dl_find_object *result)
 }
 rtld_hidden_def (_dl_find_object)
 
+/* Subroutine of _dlfo_process_initial to split out noncontigous link
+   maps.  NODELETE is the number of used _dlfo_nodelete_mappings
+   elements.  It is incremented as needed, and the new NODELETE value
+   is returned.  */
+static size_t
+_dlfo_process_initial_noncontiguous_map (struct link_map *map,
+                                         size_t nodelete)
+{
+  struct dl_find_object_internal dlfo;
+  _dl_find_object_from_map (map, &dlfo);
+
+  /* PT_LOAD segments for a non-contiguous link map are added to the
+     non-closeable mappings.  */
+  const ElfW(Phdr) *ph = map->l_phdr;
+  const ElfW(Phdr) *ph_end = map->l_phdr + map->l_phnum;
+  for (; ph < ph_end; ++ph)
+    if (ph->p_type == PT_LOAD)
+      {
+        if (_dlfo_nodelete_mappings != NULL)
+          {
+            /* Second pass only.  */
+            _dlfo_nodelete_mappings[nodelete] = dlfo;
+            ElfW(Addr) start = ph->p_vaddr + map->l_addr;
+            _dlfo_nodelete_mappings[nodelete].map_start = start;
+            _dlfo_nodelete_mappings[nodelete].map_end = start + ph->p_memsz;
+          }
+        ++nodelete;
+      }
+  return nodelete;
+}
+
 /* _dlfo_process_initial is called twice.  First to compute the array
    sizes from the initial loaded mappings.  Second to fill in the
    bases and infos arrays with the (still unsorted) data.  Returns the
@@ -476,29 +507,8 @@ _dlfo_process_initial (void)
 
   size_t nodelete = 0;
   if (!main_map->l_contiguous)
-    {
-      struct dl_find_object_internal dlfo;
-      _dl_find_object_from_map (main_map, &dlfo);
-
-      /* PT_LOAD segments for a non-contiguous are added to the
-         non-closeable mappings.  */
-      for (const ElfW(Phdr) *ph = main_map->l_phdr,
-             *ph_end = main_map->l_phdr + main_map->l_phnum;
-           ph < ph_end; ++ph)
-        if (ph->p_type == PT_LOAD)
-          {
-            if (_dlfo_nodelete_mappings != NULL)
-              {
-                /* Second pass only.  */
-                _dlfo_nodelete_mappings[nodelete] = dlfo;
-                _dlfo_nodelete_mappings[nodelete].map_start
-                  = ph->p_vaddr + main_map->l_addr;
-                _dlfo_nodelete_mappings[nodelete].map_end
-                  = _dlfo_nodelete_mappings[nodelete].map_start + ph->p_memsz;
-              }
-            ++nodelete;
-          }
-    }
+    /* Contiguous case already handled in _dl_find_object_init.  */
+    nodelete = _dlfo_process_initial_noncontiguous_map (main_map, nodelete);
 
   size_t loaded = 0;
   for (Lmid_t ns = 0; ns < GL(dl_nns); ++ns)
@@ -510,11 +520,22 @@ _dlfo_process_initial (void)
           /* lt_library link maps are implicitly NODELETE.  */
           if (l->l_type == lt_library || l->l_nodelete_active)
             {
-              if (_dlfo_nodelete_mappings != NULL)
-                /* Second pass only.  */
-                _dl_find_object_from_map
-                  (l, _dlfo_nodelete_mappings + nodelete);
-              ++nodelete;
+              /* The kernel may have loaded ld.so with gaps.   */
+              if (!l->l_contiguous
+#ifdef SHARED
+                  && l == &GL(dl_rtld_map)
+#endif
+                  )
+                nodelete
+                  = _dlfo_process_initial_noncontiguous_map (l, nodelete);
+              else
+                {
+                  if (_dlfo_nodelete_mappings != NULL)
+                    /* Second pass only.  */
+                    _dl_find_object_from_map
+                      (l, _dlfo_nodelete_mappings + nodelete);
+                  ++nodelete;
+                }
             }
           else if (l->l_type == lt_loaded)
             {
@@ -661,6 +682,14 @@ _dl_find_object_update_1 (struct link_map **loaded, size_t count)
     = _dlfo_loaded_mappings[!active_idx];
   size_t remaining_to_add = current_used + count;
 
+  /* remaining_to_add can be 0 if (current_used + count) wraps, but in practice
+     this is not possible as it represent counts of link maps.  Link maps have
+     sizes larger than 1 byte, so the sum of any two link map counts will
+     always fit within a size_t without wrapping around.  This check ensures
+     that target_seg is not erroneously considered potentially NULL by GCC. */
+  if (remaining_to_add == 0)
+    __builtin_unreachable ();
+
   /* Ensure that the new segment chain has enough space.  */
   {
     size_t new_allocated
@@ -756,7 +785,6 @@ _dl_find_object_update_1 (struct link_map **loaded, size_t count)
           /* Prefer newly loaded link map.  */
           assert (loaded_index1 > 0);
           _dl_find_object_from_map (loaded[loaded_index1 - 1], dlfo);
-          loaded[loaded_index1 -  1]->l_find_object_processed = 1;
           --loaded_index1;
         }
 
diff --git a/elf/dl-find_object.h b/elf/dl-find_object.h
index 0915065be0..8894c6657c 100644
--- a/elf/dl-find_object.h
+++ b/elf/dl-find_object.h
@@ -87,7 +87,7 @@ _dl_find_object_to_external (struct dl_find_object_internal *internal,
 }
 
 /* Extract the object location data from a link map and writes it to
-   *RESULT using relaxed MO stores.  */
+   *RESULT using relaxed MO stores.  Set L->l_find_object_processed.  */
 static void __attribute__ ((unused))
 _dl_find_object_from_map (struct link_map *l,
                           struct dl_find_object_internal *result)
@@ -100,6 +100,8 @@ _dl_find_object_from_map (struct link_map *l,
   atomic_store_relaxed (&result->eh_dbase, (void *) l->l_info[DT_PLTGOT]);
 #endif
 
+  l->l_find_object_processed = 1;
+
   for (const ElfW(Phdr) *ph = l->l_phdr, *ph_end = l->l_phdr + l->l_phnum;
        ph < ph_end; ++ph)
     if (ph->p_type == DLFO_EH_SEGMENT_TYPE)
diff --git a/elf/dl-fini.c b/elf/dl-fini.c
index db996270de..a1a4c25829 100644
--- a/elf/dl-fini.c
+++ b/elf/dl-fini.c
@@ -69,6 +69,7 @@ _dl_fini (void)
 
 	  unsigned int i;
 	  struct link_map *l;
+	  struct link_map *proxy_link_map = NULL;
 	  assert (nloaded != 0 || GL(dl_ns)[ns]._ns_loaded == NULL);
 	  for (l = GL(dl_ns)[ns]._ns_loaded, i = 0; l != NULL; l = l->l_next)
 	    /* Do not handle ld.so in secondary namespaces.  */
@@ -84,6 +85,11 @@ _dl_fini (void)
 		   are not dlclose()ed from underneath us.  */
 		++l->l_direct_opencount;
 	      }
+	    else
+	      /* Used below to call la_objclose for the ld.so proxy
+		 link map.  */
+	      proxy_link_map = l;
+
 	  assert (ns != LM_ID_BASE || i == nloaded);
 	  assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - 1);
 	  unsigned int nmaps = i;
@@ -122,6 +128,9 @@ _dl_fini (void)
 	      --l->l_direct_opencount;
 	    }
 
+	  if (proxy_link_map != NULL)
+	    _dl_audit_objclose (proxy_link_map);
+
 #ifdef SHARED
 	  _dl_audit_activity_nsid (ns, LA_ACT_CONSISTENT);
 #endif
diff --git a/elf/dl-load.c b/elf/dl-load.c
index ce8fdea302..8b0890499d 100644
--- a/elf/dl-load.c
+++ b/elf/dl-load.c
@@ -929,6 +929,36 @@ _dl_process_pt_gnu_property (struct link_map *l, int fd, const ElfW(Phdr) *ph)
     }
 }
 
+static void
+_dl_notify_new_object (int mode, Lmid_t nsid, struct link_map *l)
+{
+  /* Signal that we are going to add new objects.  */
+  struct r_debug *r = _dl_debug_update (nsid);
+  if (r->r_state == RT_CONSISTENT)
+    {
+#ifdef SHARED
+      /* Auditing checkpoint: we are going to add new objects.  Since this
+         is called after _dl_add_to_namespace_list the namespace is guaranteed
+	 to not be empty.  */
+      if ((mode & __RTLD_AUDIT) == 0)
+	_dl_audit_activity_nsid (nsid, LA_ACT_ADD);
+#endif
+
+      /* Notify the debugger we have added some objects.  We need to
+	 call _dl_debug_initialize in a static program in case dynamic
+	 linking has not been used before.  */
+      _dl_debug_change_state (r, RT_ADD);
+      LIBC_PROBE (map_start, 2, nsid, r);
+    }
+  else
+    assert (r->r_state == RT_ADD);
+
+#ifdef SHARED
+  /* Auditing checkpoint: we have a new object.  */
+  if (!GL(dl_ns)[l->l_ns]._ns_loaded->l_auditing)
+    _dl_audit_objopen (l, nsid);
+#endif
+}
 
 /* Map in the shared object NAME, actually located in REALNAME, and already
    opened on FD.  */
@@ -1029,6 +1059,8 @@ _dl_map_object_from_fd (const char *name, const char *origname, int fd,
       /* Add the map for the mirrored object to the object list.  */
       _dl_add_to_namespace_list (l, nsid);
 
+      _dl_notify_new_object (mode, nsid, l);
+
       return l;
     }
 #endif
@@ -1487,33 +1519,7 @@ cannot enable executable stack as shared object requires");
   if (mode & __RTLD_SPROF)
     return l;
 
-  /* Signal that we are going to add new objects.  */
-  struct r_debug *r = _dl_debug_update (nsid);
-  if (r->r_state == RT_CONSISTENT)
-    {
-#ifdef SHARED
-      /* Auditing checkpoint: we are going to add new objects.  Since this
-         is called after _dl_add_to_namespace_list the namespace is guaranteed
-	 to not be empty.  */
-      if ((mode & __RTLD_AUDIT) == 0)
-	_dl_audit_activity_nsid (nsid, LA_ACT_ADD);
-#endif
-
-      /* Notify the debugger we have added some objects.  We need to
-	 call _dl_debug_initialize in a static program in case dynamic
-	 linking has not been used before.  */
-      r->r_state = RT_ADD;
-      _dl_debug_state ();
-      LIBC_PROBE (map_start, 2, nsid, r);
-    }
-  else
-    assert (r->r_state == RT_ADD);
-
-#ifdef SHARED
-  /* Auditing checkpoint: we have a new object.  */
-  if (!GL(dl_ns)[l->l_ns]._ns_loaded->l_auditing)
-    _dl_audit_objopen (l, nsid);
-#endif
+  _dl_notify_new_object (mode, nsid, l);
 
   return l;
 }
diff --git a/elf/dl-lookup.c b/elf/dl-lookup.c
index 19ad2a25c5..7a70f1df2d 100644
--- a/elf/dl-lookup.c
+++ b/elf/dl-lookup.c
@@ -113,12 +113,22 @@ check_match (const char *const undef_name,
 	  /* We can match the version information or use the
 	     default one if it is not hidden.  */
 	  ElfW(Half) ndx = verstab[symidx] & 0x7fff;
-	  if ((map->l_versions[ndx].hash != version->hash
-	       || strcmp (map->l_versions[ndx].name, version->name))
-	      && (version->hidden || map->l_versions[ndx].hash
-		  || (verstab[symidx] & 0x8000)))
-	    /* It's not the version we want.  */
-	    return NULL;
+	  if (map->l_versions[ndx].hash == version->hash
+	      && strcmp (map->l_versions[ndx].name, version->name) == 0)
+	    /* This is an exact version match.  Return the symbol below.  */
+	    ;
+	  else
+	    {
+	      if (!version->hidden
+		  && map->l_versions[ndx].name[0] == '\0'
+		  && (verstab[symidx] & 0x8000) == 0
+		  && (*num_versions)++ == 0)
+		/* This is the global default version.  Store it as a
+		   fallback match.  */
+		*versioned_sym = sym;
+
+	      return NULL;
+	    }
 	}
     }
   else
diff --git a/elf/dl-open.c b/elf/dl-open.c
index c378da16c0..6f6d3ddbf9 100644
--- a/elf/dl-open.c
+++ b/elf/dl-open.c
@@ -363,17 +363,8 @@ resize_tls_slotinfo (struct link_map *new)
 {
   bool any_tls = false;
   for (unsigned int i = 0; i < new->l_searchlist.r_nlist; ++i)
-    {
-      struct link_map *imap = new->l_searchlist.r_list[i];
-
-      /* Only add TLS memory if this object is loaded now and
-	 therefore is not yet initialized.  */
-      if (! imap->l_init_called && imap->l_tls_blocksize > 0)
-	{
-	  _dl_add_to_slotinfo (imap, false);
-	  any_tls = true;
-	}
-    }
+    if (_dl_add_to_slotinfo (new->l_searchlist.r_list[i], false))
+      any_tls = true;
   return any_tls;
 }
 
@@ -383,22 +374,8 @@ resize_tls_slotinfo (struct link_map *new)
 static void
 update_tls_slotinfo (struct link_map *new)
 {
-  unsigned int first_static_tls = new->l_searchlist.r_nlist;
   for (unsigned int i = 0; i < new->l_searchlist.r_nlist; ++i)
-    {
-      struct link_map *imap = new->l_searchlist.r_list[i];
-
-      /* Only add TLS memory if this object is loaded now and
-	 therefore is not yet initialized.  */
-      if (! imap->l_init_called && imap->l_tls_blocksize > 0)
-	{
-	  _dl_add_to_slotinfo (imap, true);
-
-	  if (imap->l_need_tls_init
-	      && first_static_tls == new->l_searchlist.r_nlist)
-	    first_static_tls = i;
-	}
-    }
+    _dl_add_to_slotinfo (new->l_searchlist.r_list[i], true);
 
   size_t newgen = GL(dl_tls_generation) + 1;
   if (__glibc_unlikely (newgen == 0))
@@ -410,13 +387,11 @@ TLS generation counter wrapped!  Please report this."));
   /* We need a second pass for static tls data, because
      _dl_update_slotinfo must not be run while calls to
      _dl_add_to_slotinfo are still pending.  */
-  for (unsigned int i = first_static_tls; i < new->l_searchlist.r_nlist; ++i)
+  for (unsigned int i = 0; i < new->l_searchlist.r_nlist; ++i)
     {
       struct link_map *imap = new->l_searchlist.r_list[i];
 
-      if (imap->l_need_tls_init
-	  && ! imap->l_init_called
-	  && imap->l_tls_blocksize > 0)
+      if (imap->l_need_tls_init && imap->l_tls_blocksize > 0)
 	{
 	  /* For static TLS we have to allocate the memory here and
 	     now, but we can delay updating the DTV.  */
@@ -601,6 +576,14 @@ dl_open_worker_begin (void *a)
 	_dl_debug_printf ("opening file=%s [%lu]; direct_opencount=%u\n\n",
 			  new->l_name, new->l_ns, new->l_direct_opencount);
 
+#ifdef SHARED
+      /* No relocation processing on this execution path.  But
+	 relocation has not been performed for static
+	 position-dependent executables, so disable the assert for
+	 static linking.  */
+      assert (new->l_relocated);
+#endif
+
       /* If the user requested the object to be in the global
 	 namespace but it is not so far, prepare to add it now.  This
 	 can raise an exception to do a malloc failure.  */
@@ -622,9 +605,15 @@ dl_open_worker_begin (void *a)
       if ((mode & RTLD_GLOBAL) && new->l_global == 0)
 	add_to_global_update (new);
 
-      const int r_state __attribute__ ((unused))
-        = _dl_debug_update (args->nsid)->r_state;
-      assert (r_state == RT_CONSISTENT);
+      /* It is not possible to run the ELF constructor for the new
+	 link map if it has not executed yet: If this dlopen call came
+	 from an ELF constructor that has not put that object into a
+	 consistent state, completing initialization for the entire
+	 scope will expose objects that have this partially
+	 constructed object among its dependencies to this
+	 inconsistent state.  This could happen even with a benign
+	 dlopen (NULL, RTLD_LAZY) call from a constructor of an
+	 initially loaded shared object.  */
 
       return;
     }
@@ -656,17 +645,6 @@ dl_open_worker_begin (void *a)
 #endif
       }
 
-#ifdef SHARED
-  /* Auditing checkpoint: we have added all objects.  */
-  _dl_audit_activity_nsid (new->l_ns, LA_ACT_CONSISTENT);
-#endif
-
-  /* Notify the debugger all new objects are now ready to go.  */
-  struct r_debug *r = _dl_debug_update (args->nsid);
-  r->r_state = RT_CONSISTENT;
-  _dl_debug_state ();
-  LIBC_PROBE (map_complete, 3, args->nsid, r, new);
-
   _dl_open_check (new);
 
   /* Print scope information.  */
@@ -713,6 +691,7 @@ dl_open_worker_begin (void *a)
      created dlmopen namespaces.  Do not do this for static dlopen
      because libc has relocations against ld.so, which may not have
      been relocated at this point.  */
+  struct r_debug *r = _dl_debug_update (args->nsid);
 #ifdef SHARED
   if (GL(dl_ns)[args->nsid].libc_map != NULL)
     _dl_open_relocate_one_object (args, r, GL(dl_ns)[args->nsid].libc_map,
@@ -804,6 +783,25 @@ dl_open_worker (void *a)
 
     __rtld_lock_unlock_recursive (GL(dl_load_tls_lock));
 
+    /* Auditing checkpoint and debugger signalling.  Do this even on
+       error, so that dlopen exists with consistent state.  */
+    if (args->nsid >= 0 || args->map != NULL)
+      {
+	Lmid_t nsid = args->map != NULL ? args->map->l_ns : args->nsid;
+	struct r_debug *r = _dl_debug_update (nsid);
+#ifdef SHARED
+	bool was_not_consistent  = r->r_state != RT_CONSISTENT;
+#endif
+	_dl_debug_change_state (r, RT_CONSISTENT);
+	LIBC_PROBE (map_complete, 3, nsid, r, args->map);
+
+#ifdef SHARED
+	if (was_not_consistent)
+	  /* Avoid redudant/recursive signalling.  */
+	  _dl_audit_activity_nsid (nsid, LA_ACT_CONSISTENT);
+#endif
+      }
+
     if (__glibc_unlikely (ex.errstring != NULL))
       /* Reraise the error.  */
       _dl_signal_exception (err, &ex, NULL);
@@ -872,7 +870,7 @@ no more namespaces available for dlmopen()"));
 	}
 
       GL(dl_ns)[nsid].libc_map = NULL;
-      _dl_debug_update (nsid)->r_state = RT_CONSISTENT;
+      _dl_debug_change_state (_dl_debug_update (nsid), RT_CONSISTENT);
     }
   /* Never allow loading a DSO in a namespace which is empty.  Such
      direct placements is only causing problems.  Also don't allow
diff --git a/elf/dl-reloc.c b/elf/dl-reloc.c
index 4bf7aec88b..76d14830dd 100644
--- a/elf/dl-reloc.c
+++ b/elf/dl-reloc.c
@@ -202,12 +202,9 @@ resolve_map (lookup_t l, struct r_scope_elem *scope[], const ElfW(Sym) **ref,
 #include "dynamic-link.h"
 
 void
-_dl_relocate_object (struct link_map *l, struct r_scope_elem *scope[],
-		     int reloc_mode, int consider_profiling)
+_dl_relocate_object_no_relro (struct link_map *l, struct r_scope_elem *scope[],
+			      int reloc_mode, int consider_profiling)
 {
-  if (l->l_relocated)
-    return;
-
   struct textrels
   {
     caddr_t start;
@@ -220,8 +217,8 @@ _dl_relocate_object (struct link_map *l, struct r_scope_elem *scope[],
   int lazy = reloc_mode & RTLD_LAZY;
   int skip_ifunc = reloc_mode & __RTLD_NOIFUNC;
 
-#ifdef SHARED
   bool consider_symbind = false;
+#ifdef SHARED
   /* If we are auditing, install the same handlers we need for profiling.  */
   if ((reloc_mode & __RTLD_AUDIT) == 0)
     {
@@ -240,9 +237,7 @@ _dl_relocate_object (struct link_map *l, struct r_scope_elem *scope[],
     }
 #elif defined PROF
   /* Never use dynamic linker profiling for gprof profiling code.  */
-# define consider_profiling 0
-#else
-# define consider_symbind 0
+  consider_profiling = 0;
 #endif
 
   /* If DT_BIND_NOW is set relocate all references in this object.  We
@@ -300,7 +295,6 @@ _dl_relocate_object (struct link_map *l, struct r_scope_elem *scope[],
 
     ELF_DYNAMIC_RELOCATE (l, scope, lazy, consider_profiling, skip_ifunc);
 
-#ifndef PROF
     if ((consider_profiling || consider_symbind)
 	&& l->l_info[DT_PLTRELSZ] != NULL)
       {
@@ -321,7 +315,6 @@ _dl_relocate_object (struct link_map *l, struct r_scope_elem *scope[],
 	    _dl_fatal_printf (errstring, RTLD_PROGNAME, l->l_name);
 	  }
       }
-#endif
   }
 
   /* Mark the object so we know this work has been done.  */
@@ -342,17 +335,24 @@ _dl_relocate_object (struct link_map *l, struct r_scope_elem *scope[],
 
       textrels = textrels->next;
     }
-
-  /* In case we can protect the data now that the relocations are
-     done, do it.  */
-  if (l->l_relro_size != 0)
-    _dl_protect_relro (l);
 }
 
+void
+_dl_relocate_object (struct link_map *l, struct r_scope_elem *scope[],
+		     int reloc_mode, int consider_profiling)
+{
+  if (l->l_relocated)
+    return;
+  _dl_relocate_object_no_relro (l, scope, reloc_mode, consider_profiling);
+  _dl_protect_relro (l);
+}
 
 void
 _dl_protect_relro (struct link_map *l)
 {
+  if (l->l_relro_size == 0)
+    return;
+
   ElfW(Addr) start = ALIGN_DOWN((l->l_addr
 				 + l->l_relro_addr),
 				GLRO(dl_pagesize));
diff --git a/elf/dl-support.c b/elf/dl-support.c
index 2f502c8b0d..ee590edf93 100644
--- a/elf/dl-support.c
+++ b/elf/dl-support.c
@@ -158,6 +158,8 @@ const ElfW(Phdr) *_dl_phdr;
 size_t _dl_phnum;
 uint64_t _dl_hwcap;
 uint64_t _dl_hwcap2;
+uint64_t _dl_hwcap3;
+uint64_t _dl_hwcap4;
 
 enum dso_sort_algorithm _dl_dso_sort_algo;
 
@@ -336,8 +338,7 @@ _dl_non_dynamic_init (void)
   call_function_static_weak (_dl_find_object_init);
 
   /* Setup relro on the binary itself.  */
-  if (_dl_main_map.l_relro_size != 0)
-    _dl_protect_relro (&_dl_main_map);
+  _dl_protect_relro (&_dl_main_map);
 }
 
 #ifdef DL_SYSINFO_IMPLEMENTATION
diff --git a/elf/dl-tls.c b/elf/dl-tls.c
index 7b3dd9ab60..b13e752358 100644
--- a/elf/dl-tls.c
+++ b/elf/dl-tls.c
@@ -75,6 +75,31 @@
 /* Default for dl_tls_static_optional.  */
 #define OPTIONAL_TLS 512
 
+/* Used to count the number of threads currently executing dynamic TLS
+   updates.  Used to avoid recursive malloc calls in __tls_get_addr
+   for an interposed malloc that uses global-dynamic TLS (which is not
+   recommended); see _dl_tls_allocate_active checks.  This could be a
+   per-thread flag, but would need TLS access in the dynamic linker.  */
+unsigned int _dl_tls_threads_in_update;
+
+static inline void
+_dl_tls_allocate_begin (void)
+{
+  atomic_fetch_add_relaxed (&_dl_tls_threads_in_update, 1);
+}
+
+static inline void
+_dl_tls_allocate_end (void)
+{
+  atomic_fetch_add_relaxed (&_dl_tls_threads_in_update, -1);
+}
+
+static inline bool
+_dl_tls_allocate_active (void)
+{
+  return atomic_load_relaxed (&_dl_tls_threads_in_update) > 0;
+}
+
 /* Compute the static TLS surplus based on the namespace count and the
    TLS space that can be used for optimizations.  */
 static inline int
@@ -425,12 +450,18 @@ _dl_allocate_tls_storage (void)
   size += TLS_PRE_TCB_SIZE;
 #endif
 
-  /* Perform the allocation.  Reserve space for the required alignment
-     and the pointer to the original allocation.  */
+  /* Reserve space for the required alignment and the pointer to the
+     original allocation.  */
   size_t alignment = GLRO (dl_tls_static_align);
+
+  /* Perform the allocation.  */
+  _dl_tls_allocate_begin ();
   void *allocated = malloc (size + alignment + sizeof (void *));
   if (__glibc_unlikely (allocated == NULL))
-    return NULL;
+    {
+      _dl_tls_allocate_end ();
+      return NULL;
+    }
 
   /* Perform alignment and allocate the DTV.  */
 #if TLS_TCB_AT_TP
@@ -466,6 +497,8 @@ _dl_allocate_tls_storage (void)
   result = allocate_dtv (result);
   if (result == NULL)
     free (allocated);
+
+  _dl_tls_allocate_end ();
   return result;
 }
 
@@ -483,6 +516,7 @@ _dl_resize_dtv (dtv_t *dtv, size_t max_modid)
   size_t newsize = max_modid + DTV_SURPLUS;
   size_t oldsize = dtv[-1].counter;
 
+  _dl_tls_allocate_begin ();
   if (dtv == GL(dl_initial_dtv))
     {
       /* This is the initial dtv that was either statically allocated in
@@ -494,6 +528,13 @@ _dl_resize_dtv (dtv_t *dtv, size_t max_modid)
       if (newp == NULL)
 	oom ();
       memcpy (newp, &dtv[-1], (2 + oldsize) * sizeof (dtv_t));
+#ifdef SHARED
+      /* Auditors can trigger a DTV resize event while the full malloc
+	 is not yet in use.  Mark the new DTV allocation as the
+	 initial allocation.  */
+      if (!__rtld_malloc_is_complete ())
+	GL(dl_initial_dtv) = &newp[1];
+#endif
     }
   else
     {
@@ -502,6 +543,7 @@ _dl_resize_dtv (dtv_t *dtv, size_t max_modid)
       if (newp == NULL)
 	oom ();
     }
+  _dl_tls_allocate_end ();
 
   newp[0].counter = newsize;
 
@@ -517,9 +559,14 @@ _dl_resize_dtv (dtv_t *dtv, size_t max_modid)
 /* Allocate initial TLS.  RESULT should be a non-NULL pointer to storage
    for the TLS space.  The DTV may be resized, and so this function may
    call malloc to allocate that space.  The loader's GL(dl_load_tls_lock)
-   is taken when manipulating global TLS-related data in the loader.  */
+   is taken when manipulating global TLS-related data in the loader.
+
+   If MAIN_THREAD, this is the first call during process
+   initialization.  In this case, TLS initialization for secondary
+   (audit) namespaces is skipped because that has already been handled
+   by dlopen.  */
 void *
-_dl_allocate_tls_init (void *result, bool init_tls)
+_dl_allocate_tls_init (void *result, bool main_thread)
 {
   if (result == NULL)
     /* The memory allocation failed.  */
@@ -592,17 +639,21 @@ _dl_allocate_tls_init (void *result, bool init_tls)
 	     some platforms use in static programs requires it.  */
 	  dtv[map->l_tls_modid].pointer.val = dest;
 
-	  /* Copy the initialization image and clear the BSS part.  For
-	     audit modules or dependencies with initial-exec TLS, we can not
-	     set the initial TLS image on default loader initialization
-	     because it would already be set by the audit setup.  However,
-	     subsequent thread creation would need to follow the default
-	     behaviour.   */
-	  if (map->l_ns != LM_ID_BASE && !init_tls)
+	  /* Copy the initialization image and clear the BSS part.
+	     For audit modules or dependencies with initial-exec TLS,
+	     we can not set the initial TLS image on default loader
+	     initialization because it would already be set by the
+	     audit setup, which uses the dlopen code and already
+	     clears l_need_tls_init.  Calls with !main_thread from
+	     pthread_create need to initialze TLS for the current
+	     thread regardless of namespace.  */
+	  if (map->l_ns != LM_ID_BASE && main_thread)
 	    continue;
 	  memset (__mempcpy (dest, map->l_tls_initimage,
 			     map->l_tls_initimage_size), '\0',
 		  map->l_tls_blocksize - map->l_tls_initimage_size);
+	  if (main_thread)
+	    map->l_need_tls_init = 0;
 	}
 
       total += cnt;
@@ -626,7 +677,7 @@ _dl_allocate_tls (void *mem)
 {
   return _dl_allocate_tls_init (mem == NULL
 				? _dl_allocate_tls_storage ()
-				: allocate_dtv (mem), true);
+				: allocate_dtv (mem), false);
 }
 rtld_hidden_def (_dl_allocate_tls)
 
@@ -676,7 +727,9 @@ allocate_dtv_entry (size_t alignment, size_t size)
   if (powerof2 (alignment) && alignment <= _Alignof (max_align_t))
     {
       /* The alignment is supported by malloc.  */
+      _dl_tls_allocate_begin ();
       void *ptr = malloc (size);
+      _dl_tls_allocate_end ();
       return (struct dtv_pointer) { ptr, ptr };
     }
 
@@ -688,7 +741,10 @@ allocate_dtv_entry (size_t alignment, size_t size)
 
   /* Perform the allocation.  This is the pointer we need to free
      later.  */
+  _dl_tls_allocate_begin ();
   void *start = malloc (alloc_size);
+  _dl_tls_allocate_end ();
+
   if (start == NULL)
     return (struct dtv_pointer) {};
 
@@ -819,7 +875,18 @@ _dl_update_slotinfo (unsigned long int req_modid, size_t new_gen)
 		 dtv entry free it.  Note: this is not AS-safe.  */
 	      /* XXX Ideally we will at some point create a memory
 		 pool.  */
-	      free (dtv[modid].pointer.to_free);
+	      /* Avoid calling free on a null pointer.  Some mallocs
+		 incorrectly use dynamic TLS, and depending on how the
+		 free function was compiled, it could call
+		 __tls_get_addr before the null pointer check in the
+		 free implementation.  Checking here papers over at
+		 least some dynamic TLS usage by interposed mallocs.  */
+	      if (dtv[modid].pointer.to_free != NULL)
+		{
+		  _dl_tls_allocate_begin ();
+		  free (dtv[modid].pointer.to_free);
+		  _dl_tls_allocate_end ();
+		}
 	      dtv[modid].pointer.val = TLS_DTV_UNALLOCATED;
 	      dtv[modid].pointer.to_free = NULL;
 
@@ -949,10 +1016,22 @@ __tls_get_addr (GET_ADDR_ARGS)
   size_t gen = atomic_load_relaxed (&GL(dl_tls_generation));
   if (__glibc_unlikely (dtv[0].counter != gen))
     {
-      /* Update DTV up to the global generation, see CONCURRENCY NOTES
-         in _dl_update_slotinfo.  */
-      gen = atomic_load_acquire (&GL(dl_tls_generation));
-      return update_get_addr (GET_ADDR_PARAM, gen);
+      if (_dl_tls_allocate_active ()
+	  && GET_ADDR_MODULE < _dl_tls_initial_modid_limit)
+	  /* This is a reentrant __tls_get_addr call, but we can
+	     satisfy it because it's an initially-loaded module ID.
+	     These TLS slotinfo slots do not change, so the
+	     out-of-date generation counter does not matter.  However,
+	     if not in a TLS update, still update_get_addr below, to
+	     get off the slow path eventually.  */
+	;
+      else
+	{
+	  /* Update DTV up to the global generation, see CONCURRENCY NOTES
+	     in _dl_update_slotinfo.  */
+	  gen = atomic_load_acquire (&GL(dl_tls_generation));
+	  return update_get_addr (GET_ADDR_PARAM, gen);
+	}
     }
 
   void *p = dtv[GET_ADDR_MODULE].pointer.val;
@@ -962,7 +1041,7 @@ __tls_get_addr (GET_ADDR_ARGS)
 
   return (char *) p + GET_ADDR_OFFSET;
 }
-#endif
+#endif /* SHARED */
 
 
 /* Look up the module's TLS block as for __tls_get_addr,
@@ -1011,10 +1090,52 @@ _dl_tls_get_addr_soft (struct link_map *l)
   return data;
 }
 
+size_t _dl_tls_initial_modid_limit;
 
 void
+_dl_tls_initial_modid_limit_setup (void)
+{
+  struct dtv_slotinfo_list *listp = GL(dl_tls_dtv_slotinfo_list);
+  size_t idx;
+  for (idx = 0; idx < listp->len; ++idx)
+    {
+      struct link_map *l = listp->slotinfo[idx].map;
+      if (l == NULL
+	  /* The object can be unloaded, so its modid can be
+	     reassociated.  */
+	  || !(l->l_type == lt_executable || l->l_type == lt_library))
+	break;
+    }
+  _dl_tls_initial_modid_limit = idx;
+}
+
+
+/* Add module to slot information data.  If DO_ADD is false, only the
+   required memory is allocated.  Must be called with
+   GL (dl_load_tls_lock) acquired.  If the function has already been
+   called for the link map L with !DO_ADD, then this function will not
+   raise an exception, otherwise it is possible that it encounters a
+   memory allocation failure.
+
+   Return false if L has already been added to the slotinfo data, or
+   if L has no TLS data.  If the returned value is true, L has been
+   added with this call (DO_ADD), or has been added in a previous call
+   (!DO_ADD).
+
+   The expected usage is as follows: Call _dl_add_to_slotinfo for
+   several link maps with DO_ADD set to false, and record if any calls
+   result in a true result.  If there was a true result, call
+   _dl_add_to_slotinfo again, this time with DO_ADD set to true.  (For
+   simplicity, it's possible to call the function for link maps where
+   the previous result was false.)  The return value from the second
+   round of calls can be ignored.  If there was true result initially,
+   call _dl_update_slotinfo to update the TLS generation counter.  */
+bool
 _dl_add_to_slotinfo (struct link_map *l, bool do_add)
 {
+  if (l->l_tls_blocksize == 0 || l->l_tls_in_slotinfo)
+    return false;
+
   /* Now that we know the object is loaded successfully add
      modules containing TLS data to the dtv info table.  We
      might have to increase its size.  */
@@ -1043,9 +1164,11 @@ _dl_add_to_slotinfo (struct link_map *l, bool do_add)
 	 the first slot.  */
       assert (idx == 0);
 
+      _dl_tls_allocate_begin ();
       listp = (struct dtv_slotinfo_list *)
 	malloc (sizeof (struct dtv_slotinfo_list)
 		+ TLS_SLOTINFO_SURPLUS * sizeof (struct dtv_slotinfo));
+      _dl_tls_allocate_end ();
       if (listp == NULL)
 	{
 	  /* We ran out of memory while resizing the dtv slotinfo list.  */
@@ -1068,7 +1191,10 @@ cannot create TLS data structures"));
       atomic_store_relaxed (&listp->slotinfo[idx].map, l);
       atomic_store_relaxed (&listp->slotinfo[idx].gen,
 			    GL(dl_tls_generation) + 1);
+      l->l_tls_in_slotinfo = true;
     }
+
+  return true;
 }
 
 #if PTHREAD_IN_LIBC
diff --git a/elf/dl-tunables.c b/elf/dl-tunables.c
index 03e1a68675..614ac9c047 100644
--- a/elf/dl-tunables.c
+++ b/elf/dl-tunables.c
@@ -32,6 +32,7 @@
 #include <ldsodefs.h>
 #include <array_length.h>
 #include <dl-minimal-malloc.h>
+#include <dl-symbol-redir-ifunc.h>
 
 #define TUNABLES_INTERNAL 1
 #include "dl-tunables.h"
@@ -223,6 +224,7 @@ parse_tunables_string (const char *valstring, struct tunable_toset_t *tunables)
 	    {
 	      tunables[ntunables++] =
 		(struct tunable_toset_t) { cur, value, p - value };
+
 	      break;
 	    }
 	}
@@ -234,23 +236,27 @@ parse_tunables_string (const char *valstring, struct tunable_toset_t *tunables)
 static void
 parse_tunables (const char *valstring)
 {
-  struct tunable_toset_t tunables[tunables_list_size];
-  int ntunables = parse_tunables_string (valstring, tunables);
-  if (ntunables == -1)
+  struct tunable_toset_t tunables[tunables_list_size] = { 0 };
+  if (parse_tunables_string (valstring, tunables) == -1)
     {
       _dl_error_printf (
         "WARNING: ld.so: invalid GLIBC_TUNABLES `%s': ignored.\n", valstring);
       return;
     }
 
-  for (int i = 0; i < ntunables; i++)
-    if (!tunable_initialize (tunables[i].t, tunables[i].value,
-			     tunables[i].len))
-      _dl_error_printf ("WARNING: ld.so: invalid GLIBC_TUNABLES value `%.*s' "
-		       "for option `%s': ignored.\n",
-		       (int) tunables[i].len,
-		       tunables[i].value,
-		       tunables[i].t->name);
+  for (int i = 0; i < tunables_list_size; i++)
+    {
+      if (tunables[i].t == NULL)
+	continue;
+
+      if (!tunable_initialize (tunables[i].t, tunables[i].value,
+			       tunables[i].len))
+	_dl_error_printf ("WARNING: ld.so: invalid GLIBC_TUNABLES value `%.*s' "
+			  "for option `%s': ignored.\n",
+			  (int) tunables[i].len,
+			  tunables[i].value,
+			  tunables[i].t->name);
+    }
 }
 
 /* Initialize the tunables list from the environment.  For now we only use the
diff --git a/elf/dl-version.c b/elf/dl-version.c
index 8966d612cc..708b1c94ea 100644
--- a/elf/dl-version.c
+++ b/elf/dl-version.c
@@ -357,6 +357,13 @@ _dl_check_map_versions (struct link_map *map, int verbose, int trace_mode)
 	      ent = (ElfW(Verdef) *) ((char *) ent + ent->vd_next);
 	    }
 	}
+
+      /* The empty string has ELF hash zero.  This avoids a NULL check
+	 before the version string comparison in check_match in
+	 dl-lookup.c.  */
+      for (unsigned int i = 0; i < map->l_nversions; ++i)
+	if (map->l_versions[i].name == NULL)
+	  map->l_versions[i].name = "";
     }
 
   /* When there is a DT_VERNEED entry with libc.so on DT_NEEDED, issue
diff --git a/elf/elf.h b/elf/elf.h
index 455731663c..1c394c64cd 100644
--- a/elf/elf.h
+++ b/elf/elf.h
@@ -1234,6 +1234,10 @@ typedef struct
 #define AT_RSEQ_FEATURE_SIZE	27	/* rseq supported feature size.  */
 #define AT_RSEQ_ALIGN	28		/* rseq allocation alignment.  */
 
+/* More machine-dependent hints about processor capabilities.  */
+#define AT_HWCAP3	29		/* extension of AT_HWCAP.  */
+#define AT_HWCAP4	30		/* extension of AT_HWCAP.  */
+
 #define AT_EXECFN	31		/* Filename of executable.  */
 
 /* Pointer to the global system page used for system calls and other
diff --git a/elf/endswith.h b/elf/endswith.h
new file mode 100644
index 0000000000..3954e57f8e
--- /dev/null
+++ b/elf/endswith.h
@@ -0,0 +1,41 @@
+/* Copyright (C) 2023-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published
+   by the Free Software Foundation; version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _ENDSWITH_H
+#define _ENDSWITH_H
+
+#include <stdbool.h>
+#include <string.h>
+
+/* Return true if the N bytes at NAME end with with the characters in
+   the string SUFFIX.  (NAME[N + 1] does not have to be a null byte.)
+   Expected to be called with a string literal for SUFFIX.  */
+static inline bool
+endswithn (const char *name, size_t n, const char *suffix)
+{
+  return (n >= strlen (suffix)
+	  && memcmp (name + n - strlen (suffix), suffix,
+		     strlen (suffix)) == 0);
+}
+
+/* Same as endswithn, but uses the entire SUBJECT for matching.  */
+static inline bool
+endswith (const char *subject, const char *suffix)
+{
+  return endswithn (subject, strlen (subject), suffix);
+}
+
+#endif /* _ENDSWITH_H */
diff --git a/elf/ldconfig.c b/elf/ldconfig.c
index b64c54b53e..0f3ef707dd 100644
--- a/elf/ldconfig.c
+++ b/elf/ldconfig.c
@@ -40,6 +40,7 @@
 #include <libgen.h>
 
 #include <ldconfig.h>
+#include <endswith.h>
 #include <dl-cache.h>
 #include <dl-hwcaps.h>
 #include <dl-is_dso.h>
@@ -661,17 +662,6 @@ struct dlib_entry
   struct dlib_entry *next;
 };
 
-/* Return true if the N bytes at NAME end with with the characters in
-   the string SUFFIX.  (NAME[N + 1] does not have to be a null byte.)
-   Expected to be called with a string literal for SUFFIX.  */
-static inline bool
-endswithn (const char *name, size_t n, const char *suffix)
-{
-  return (n >= strlen (suffix)
-	  && memcmp (name + n - strlen (suffix), suffix,
-		     strlen (suffix)) == 0);
-}
-
 /* Skip some temporary DSO files.  These files may be partially written
    and lead to ldconfig crashes when examined.  */
 static bool
diff --git a/elf/readlib.c b/elf/readlib.c
index 4d67c74136..32e8b8eb22 100644
--- a/elf/readlib.c
+++ b/elf/readlib.c
@@ -33,6 +33,7 @@
 #include <gnu/lib-names.h>
 
 #include <ldconfig.h>
+#include <endswith.h>
 
 #define Elf32_CLASS ELFCLASS32
 #define Elf64_CLASS ELFCLASS64
@@ -48,7 +49,7 @@ static bool
 is_gdb_python_file (const char *name)
 {
   size_t len = strlen (name);
-  return len > 7 && strcmp (name + len - 7, "-gdb.py") == 0;
+  return endswithn (name, len, "-gdb.py");
 }
 
 /* Returns 0 if everything is ok, != 0 in case of error.  */
diff --git a/elf/rtld.c b/elf/rtld.c
index ac4bb23652..cd790e37f2 100644
--- a/elf/rtld.c
+++ b/elf/rtld.c
@@ -788,6 +788,8 @@ init_tls (size_t naudit)
     _dl_fatal_printf ("\
 cannot allocate TLS data structures for initial thread\n");
 
+  _dl_tls_initial_modid_limit_setup ();
+
   /* Store for detection of the special case by __tls_get_addr
      so it knows not to pass this dtv to the normal realloc.  */
   GL(dl_initial_dtv) = GET_DTV (tcbp);
@@ -1282,6 +1284,60 @@ rtld_setup_main_map (struct link_map *main_map)
   return has_interp;
 }
 
+/* Set up the program header information for the dynamic linker
+   itself.  It can be accessed via _r_debug and dl_iterate_phdr
+   callbacks, and it is used by _dl_find_object.  */
+static void
+rtld_setup_phdr (void)
+{
+  /* Starting from binutils-2.23, the linker will define the magic
+     symbol __ehdr_start to point to our own ELF header if it is
+     visible in a segment that also includes the phdrs.  */
+
+  const ElfW(Ehdr) *rtld_ehdr = &__ehdr_start;
+  assert (rtld_ehdr->e_ehsize == sizeof *rtld_ehdr);
+  assert (rtld_ehdr->e_phentsize == sizeof (ElfW(Phdr)));
+
+  const ElfW(Phdr) *rtld_phdr = (const void *) rtld_ehdr + rtld_ehdr->e_phoff;
+
+  GL(dl_rtld_map).l_phdr = rtld_phdr;
+  GL(dl_rtld_map).l_phnum = rtld_ehdr->e_phnum;
+
+
+  GL(dl_rtld_map).l_contiguous = 1;
+  /* The linker may not have produced a contiguous object.  The kernel
+     will load the object with actual gaps (unlike the glibc loader
+     for shared objects, which always produces a contiguous mapping).
+     See similar logic in rtld_setup_main_map above.  */
+  {
+    ElfW(Addr) expected_load_address = 0;
+    for (const ElfW(Phdr) *ph = rtld_phdr; ph < &rtld_phdr[rtld_ehdr->e_phnum];
+	 ++ph)
+      if (ph->p_type == PT_LOAD)
+	{
+	  ElfW(Addr) mapstart = ph->p_vaddr & ~(GLRO(dl_pagesize) - 1);
+	  if (GL(dl_rtld_map).l_contiguous && expected_load_address != 0
+	      && expected_load_address != mapstart)
+	    GL(dl_rtld_map).l_contiguous = 0;
+	  ElfW(Addr) allocend = ph->p_vaddr + ph->p_memsz;
+	  /* The next expected address is the page following this load
+	     segment.  */
+	  expected_load_address = ((allocend + GLRO(dl_pagesize) - 1)
+				   & ~(GLRO(dl_pagesize) - 1));
+	}
+  }
+
+  /* PT_GNU_RELRO is usually the last phdr.  */
+  size_t cnt = rtld_ehdr->e_phnum;
+  while (cnt-- > 0)
+    if (rtld_phdr[cnt].p_type == PT_GNU_RELRO)
+      {
+	GL(dl_rtld_map).l_relro_addr = rtld_phdr[cnt].p_vaddr;
+	GL(dl_rtld_map).l_relro_size = rtld_phdr[cnt].p_memsz;
+	break;
+      }
+}
+
 /* Adjusts the contents of the stack and related globals for the user
    entry point.  The ld.so processed skip_args arguments and bumped
    _dl_argv and _dl_argc accordingly.  Those arguments are removed from
@@ -1747,33 +1803,7 @@ dl_main (const ElfW(Phdr) *phdr,
   ++GL(dl_ns)[LM_ID_BASE]._ns_nloaded;
   ++GL(dl_load_adds);
 
-  /* Starting from binutils-2.23, the linker will define the magic symbol
-     __ehdr_start to point to our own ELF header if it is visible in a
-     segment that also includes the phdrs.  If that's not available, we use
-     the old method that assumes the beginning of the file is part of the
-     lowest-addressed PT_LOAD segment.  */
-
-  /* Set up the program header information for the dynamic linker
-     itself.  It is needed in the dl_iterate_phdr callbacks.  */
-  const ElfW(Ehdr) *rtld_ehdr = &__ehdr_start;
-  assert (rtld_ehdr->e_ehsize == sizeof *rtld_ehdr);
-  assert (rtld_ehdr->e_phentsize == sizeof (ElfW(Phdr)));
-
-  const ElfW(Phdr) *rtld_phdr = (const void *) rtld_ehdr + rtld_ehdr->e_phoff;
-
-  GL(dl_rtld_map).l_phdr = rtld_phdr;
-  GL(dl_rtld_map).l_phnum = rtld_ehdr->e_phnum;
-
-
-  /* PT_GNU_RELRO is usually the last phdr.  */
-  size_t cnt = rtld_ehdr->e_phnum;
-  while (cnt-- > 0)
-    if (rtld_phdr[cnt].p_type == PT_GNU_RELRO)
-      {
-	GL(dl_rtld_map).l_relro_addr = rtld_phdr[cnt].p_vaddr;
-	GL(dl_rtld_map).l_relro_size = rtld_phdr[cnt].p_memsz;
-	break;
-      }
+  rtld_setup_phdr ();
 
   /* Add the dynamic linker to the TLS list if it also uses TLS.  */
   if (GL(dl_rtld_map).l_tls_blocksize != 0)
@@ -1820,8 +1850,7 @@ dl_main (const ElfW(Phdr) *phdr,
   elf_setup_debug_entry (main_map, r);
 
   /* We start adding objects.  */
-  r->r_state = RT_ADD;
-  _dl_debug_state ();
+  _dl_debug_change_state (r, RT_ADD);
   LIBC_PROBE (init_start, 2, LM_ID_BASE, r);
 
   /* Auditing checkpoint: we are ready to signal that the initial map
@@ -1980,43 +2009,37 @@ dl_main (const ElfW(Phdr) *phdr,
     if (main_map->l_searchlist.r_list[i] == &GL(dl_rtld_map))
       break;
 
-  bool rtld_multiple_ref = false;
-  if (__glibc_likely (i < main_map->l_searchlist.r_nlist))
-    {
-      /* Some DT_NEEDED entry referred to the interpreter object itself, so
-	 put it back in the list of visible objects.  We insert it into the
-	 chain in symbol search order because gdb uses the chain's order as
-	 its symbol search order.  */
-      rtld_multiple_ref = true;
+  /* Insert the link map for the dynamic loader into the chain in
+     symbol search order because gdb uses the chain's order as its
+     symbol search order.  */
 
-      GL(dl_rtld_map).l_prev = main_map->l_searchlist.r_list[i - 1];
-      if (__glibc_likely (state.mode == rtld_mode_normal))
-	{
-	  GL(dl_rtld_map).l_next = (i + 1 < main_map->l_searchlist.r_nlist
-				    ? main_map->l_searchlist.r_list[i + 1]
-				    : NULL);
+  GL(dl_rtld_map).l_prev = main_map->l_searchlist.r_list[i - 1];
+  if (__glibc_likely (state.mode == rtld_mode_normal))
+    {
+      GL(dl_rtld_map).l_next = (i + 1 < main_map->l_searchlist.r_nlist
+				? main_map->l_searchlist.r_list[i + 1]
+				: NULL);
 #ifdef NEED_DL_SYSINFO_DSO
-	  if (GLRO(dl_sysinfo_map) != NULL
-	      && GL(dl_rtld_map).l_prev->l_next == GLRO(dl_sysinfo_map)
-	      && GL(dl_rtld_map).l_next != GLRO(dl_sysinfo_map))
-	    GL(dl_rtld_map).l_prev = GLRO(dl_sysinfo_map);
+      if (GLRO(dl_sysinfo_map) != NULL
+	  && GL(dl_rtld_map).l_prev->l_next == GLRO(dl_sysinfo_map)
+	  && GL(dl_rtld_map).l_next != GLRO(dl_sysinfo_map))
+	GL(dl_rtld_map).l_prev = GLRO(dl_sysinfo_map);
 #endif
-	}
-      else
-	/* In trace mode there might be an invisible object (which we
-	   could not find) after the previous one in the search list.
-	   In this case it doesn't matter much where we put the
-	   interpreter object, so we just initialize the list pointer so
-	   that the assertion below holds.  */
-	GL(dl_rtld_map).l_next = GL(dl_rtld_map).l_prev->l_next;
-
-      assert (GL(dl_rtld_map).l_prev->l_next == GL(dl_rtld_map).l_next);
-      GL(dl_rtld_map).l_prev->l_next = &GL(dl_rtld_map);
-      if (GL(dl_rtld_map).l_next != NULL)
-	{
-	  assert (GL(dl_rtld_map).l_next->l_prev == GL(dl_rtld_map).l_prev);
-	  GL(dl_rtld_map).l_next->l_prev = &GL(dl_rtld_map);
-	}
+    }
+  else
+    /* In trace mode there might be an invisible object (which we
+       could not find) after the previous one in the search list.
+       In this case it doesn't matter much where we put the
+       interpreter object, so we just initialize the list pointer so
+       that the assertion below holds.  */
+    GL(dl_rtld_map).l_next = GL(dl_rtld_map).l_prev->l_next;
+
+  assert (GL(dl_rtld_map).l_prev->l_next == GL(dl_rtld_map).l_next);
+  GL(dl_rtld_map).l_prev->l_next = &GL(dl_rtld_map);
+  if (GL(dl_rtld_map).l_next != NULL)
+    {
+      assert (GL(dl_rtld_map).l_next->l_prev == GL(dl_rtld_map).l_prev);
+      GL(dl_rtld_map).l_next->l_prev = &GL(dl_rtld_map);
     }
 
   /* Now let us see whether all libraries are available in the
@@ -2266,25 +2289,25 @@ dl_main (const ElfW(Phdr) *phdr,
 
   _rtld_main_check (main_map, _dl_argv[0]);
 
-  /* Now we have all the objects loaded.  Relocate them all except for
-     the dynamic linker itself.  We do this in reverse order so that copy
-     relocs of earlier objects overwrite the data written by later
-     objects.  We do not re-relocate the dynamic linker itself in this
-     loop because that could result in the GOT entries for functions we
-     call being changed, and that would break us.  It is safe to relocate
-     the dynamic linker out of order because it has no copy relocations.
-     Likewise for libc, which is relocated early to ensure that IFUNC
-     resolvers in libc work.  */
+  /* Now we have all the objects loaded.  */
 
   int consider_profiling = GLRO(dl_profile) != NULL;
 
   /* If we are profiling we also must do lazy reloaction.  */
   GLRO(dl_lazy) |= consider_profiling;
 
+  /* If libc.so has been loaded, relocate it early, after the dynamic
+     loader itself.  The initial self-relocation of ld.so should be
+     sufficient for IFUNC resolvers in libc.so.  */
   if (GL(dl_ns)[LM_ID_BASE].libc_map != NULL)
-    _dl_relocate_object (GL(dl_ns)[LM_ID_BASE].libc_map,
-			 GL(dl_ns)[LM_ID_BASE].libc_map->l_scope,
-			 GLRO(dl_lazy) ? RTLD_LAZY : 0, consider_profiling);
+    {
+      RTLD_TIMING_VAR (start);
+      rtld_timer_start (&start);
+      _dl_relocate_object (GL(dl_ns)[LM_ID_BASE].libc_map,
+			   GL(dl_ns)[LM_ID_BASE].libc_map->l_scope,
+			   GLRO(dl_lazy) ? RTLD_LAZY : 0, consider_profiling);
+      rtld_timer_accum (&relocate_time, start);
+  }
 
   RTLD_TIMING_VAR (start);
   rtld_timer_start (&start);
@@ -2307,9 +2330,8 @@ dl_main (const ElfW(Phdr) *phdr,
 	/* Also allocated with the fake malloc().  */
 	l->l_free_initfini = 0;
 
-	if (l != &GL(dl_rtld_map))
-	  _dl_relocate_object (l, l->l_scope, GLRO(dl_lazy) ? RTLD_LAZY : 0,
-			       consider_profiling);
+	_dl_relocate_object (l, l->l_scope, GLRO(dl_lazy) ? RTLD_LAZY : 0,
+			     consider_profiling);
 
 	/* Add object to slot information data if necessasy.  */
 	if (l->l_tls_blocksize != 0 && __rtld_tls_init_tp_called)
@@ -2335,7 +2357,7 @@ dl_main (const ElfW(Phdr) *phdr,
      into the main thread's TLS area, which we allocated above.
      Note: thread-local variables must only be accessed after completing
      the next step.  */
-  _dl_allocate_tls_init (tcbp, false);
+  _dl_allocate_tls_init (tcbp, true);
 
   /* And finally install it for the main thread.  */
   if (! __rtld_tls_init_tp_called)
@@ -2344,36 +2366,29 @@ dl_main (const ElfW(Phdr) *phdr,
   /* Make sure no new search directories have been added.  */
   assert (GLRO(dl_init_all_dirs) == GL(dl_all_dirs));
 
-  if (rtld_multiple_ref)
-    {
-      /* There was an explicit ref to the dynamic linker as a shared lib.
-	 Re-relocate ourselves with user-controlled symbol definitions.
-
-	 We must do this after TLS initialization in case after this
-	 re-relocation, we might call a user-supplied function
-	 (e.g. calloc from _dl_relocate_object) that uses TLS data.  */
-
-      /* Set up the object lookup structures.  */
-      _dl_find_object_init ();
-
-      /* The malloc implementation has been relocated, so resolving
-	 its symbols (and potentially calling IFUNC resolvers) is safe
-	 at this point.  */
-      __rtld_malloc_init_real (main_map);
-
-      /* Likewise for the locking implementation.  */
-      __rtld_mutex_init ();
+  /* Set up the object lookup structures.  */
+  _dl_find_object_init ();
 
+  /* If libc.so was loaded, relocate ld.so against it.  Complete ld.so
+     initialization with mutex symbols from libc.so and malloc symbols
+     from the global scope.  */
+  if (GL(dl_ns)[LM_ID_BASE].libc_map != NULL)
+    {
       RTLD_TIMING_VAR (start);
       rtld_timer_start (&start);
+      _dl_relocate_object_no_relro (&GL(dl_rtld_map), main_map->l_scope, 0, 0);
+      rtld_timer_accum (&relocate_time, start);
 
-      /* Mark the link map as not yet relocated again.  */
-      GL(dl_rtld_map).l_relocated = 0;
-      _dl_relocate_object (&GL(dl_rtld_map), main_map->l_scope, 0, 0);
+      __rtld_mutex_init ();
+      __rtld_malloc_init_real (main_map);
 
-      rtld_timer_accum (&relocate_time, start);
+      /* Update copy-relocated _r_debug if necessary.  */
+      _dl_debug_post_relocate (main_map);
     }
 
+  /* All ld.so initialization is complete.  Apply RELRO.  */
+  _dl_protect_relro (&GL(dl_rtld_map));
+
   /* Relocation is complete.  Perform early libc initialization.  This
      is the initial libc, even if audit modules have been loaded with
      other libcs.  */
@@ -2386,16 +2401,15 @@ dl_main (const ElfW(Phdr) *phdr,
      _dl_relocate_object might need to call `mprotect' for DT_TEXTREL.  */
   _dl_sysdep_start_cleanup ();
 
-  /* Auditing checkpoint: we have added all objects.  */
-  _dl_audit_activity_nsid (LM_ID_BASE, LA_ACT_CONSISTENT);
-
   /* Notify the debugger all new objects are now ready to go.  We must re-get
      the address since by now the variable might be in another object.  */
   r = _dl_debug_update (LM_ID_BASE);
-  r->r_state = RT_CONSISTENT;
-  _dl_debug_state ();
+  _dl_debug_change_state (r, RT_CONSISTENT);
   LIBC_PROBE (init_complete, 2, LM_ID_BASE, r);
 
+  /* Auditing checkpoint: we have added all objects.  */
+  _dl_audit_activity_nsid (LM_ID_BASE, LA_ACT_CONSISTENT);
+
 #if defined USE_LDCONFIG && !defined MAP_COPY
   /* We must munmap() the cache file.  */
   _dl_unload_cache ();
diff --git a/elf/tst-audit-tlsdesc-dlopen2.c b/elf/tst-audit-tlsdesc-dlopen2.c
new file mode 100644
index 0000000000..7ba2c4129a
--- /dev/null
+++ b/elf/tst-audit-tlsdesc-dlopen2.c
@@ -0,0 +1,46 @@
+/* Loading TLS-using modules from auditors (bug 32412).  Main program.
+   Copyright (C) 2021-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <support/xdlfcn.h>
+#include <stdio.h>
+
+static int
+do_test (void)
+{
+  puts ("info: start of main program");
+
+  /* Load TLS-using modules, to trigger DTV resizing.  The dynamic
+     linker will load them again (requiring their own TLS) because the
+     dlopen calls from the auditor were in the auditing namespace.  */
+  for (int i = 1; i <= 19; ++i)
+    {
+      char dso[30];
+      snprintf (dso, sizeof (dso), "tst-tlsmod17a%d.so", i);
+      char sym[30];
+      snprintf (sym, sizeof(sym), "tlsmod17a%d", i);
+
+      void *handle = xdlopen (dso, RTLD_LAZY);
+      int (*func) (void) = xdlsym (handle, sym);
+      /* Trigger TLS allocation.  */
+      func ();
+    }
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/elf/tst-audit23.c b/elf/tst-audit23.c
index 32e7c8b2a3..1b76336595 100644
--- a/elf/tst-audit23.c
+++ b/elf/tst-audit23.c
@@ -17,6 +17,7 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include <array_length.h>
+#include <endswith.h>
 #include <errno.h>
 #include <getopt.h>
 #include <link.h>
@@ -30,16 +31,21 @@
 #include <support/xstdio.h>
 #include <support/xdlfcn.h>
 #include <support/support.h>
+#include <support/test-driver.h>
 
 static int restart;
+static int do_dlclose;
 #define CMDLINE_OPTIONS \
-  { "restart", no_argument, &restart, 1 },
+  { "restart", no_argument, &restart, 1 }, \
+  { "dlclose", no_argument, &do_dlclose, 1 }, \
 
 static int
 handle_restart (void)
 {
   xdlopen ("tst-audit23mod.so", RTLD_NOW);
-  xdlmopen (LM_ID_NEWLM, LIBC_SO, RTLD_NOW);
+  void *handle = xdlmopen (LM_ID_NEWLM, LIBC_SO, RTLD_NOW);
+  if (do_dlclose)
+    xdlclose (handle);
 
   return 0;
 }
@@ -59,8 +65,8 @@ is_vdso (const char *str)
 	 || startswith (str, "linux-vdso");
 }
 
-static int
-do_test (int argc, char *argv[])
+static void
+do_one_test (int argc, char *argv[], bool pass_dlclose_flag)
 {
   /* We must have either:
      - One or four parameters left if called initially:
@@ -68,16 +74,15 @@ do_test (int argc, char *argv[])
        + "--library-path"      optional
        + the library path      optional
        + the application name  */
-  if (restart)
-    return handle_restart ();
-
-  char *spargv[9];
+  char *spargv[10];
   TEST_VERIFY_EXIT (((argc - 1) + 3) < array_length (spargv));
   int i = 0;
   for (; i < argc - 1; i++)
     spargv[i] = argv[i + 1];
   spargv[i++] = (char *) "--direct";
   spargv[i++] = (char *) "--restart";
+  if (pass_dlclose_flag)
+    spargv[i++] = (char *) "--dlclose";
   spargv[i] = NULL;
 
   setenv ("LD_AUDIT", "tst-auditmod23.so", 0);
@@ -85,14 +90,30 @@ do_test (int argc, char *argv[])
     = support_capture_subprogram (spargv[0], spargv);
   support_capture_subprocess_check (&result, "tst-audit22", 0, sc_allow_stderr);
 
+  {
+    FILE *fp = fmemopen (result.err.buffer, result.err.length, "r");
+    TEST_VERIFY (fp != NULL);
+    unsigned int line = 0;
+    char *buffer = NULL;
+    size_t buffer_length = 0;
+    puts ("info: *** audit log start ***");
+    while (xgetline (&buffer, &buffer_length, fp))
+      printf ("%6u\t%s", ++line, buffer);
+    puts ("info: *** audit log end ***");
+    free (buffer);
+    xfclose (fp);
+  }
+
   /* The expected la_objopen/la_objclose:
      1. executable
      2. loader
      3. libc.so
-     4. tst-audit23mod.so
-     5. libc.so (LM_ID_NEWLM).
-     6. vdso (optional and ignored).  */
-  enum { max_objs = 6 };
+     4. libgcc_s.so (one some architectures, for libsupport)
+     5. tst-audit23mod.so
+     6. libc.so (LM_ID_NEWLM).
+     7. loader (proxy link map in new namespace)
+        vdso (optional and ignored).  */
+  enum { max_objs = 7 };
   struct la_obj_t
   {
     char *lname;
@@ -115,8 +136,10 @@ do_test (int argc, char *argv[])
   TEST_VERIFY (out != NULL);
   char *buffer = NULL;
   size_t buffer_length = 0;
+  unsigned int line = 0;
   while (xgetline (&buffer, &buffer_length, out))
     {
+      ++line;
       if (startswith (buffer, "la_activity: "))
 	{
 	  uintptr_t cookie;
@@ -127,8 +150,14 @@ do_test (int argc, char *argv[])
 
 	  /* The cookie identifies the object at the head of the link map,
 	     so we only add a new namespace if it changes from the previous
-	     one.  This works since dlmopen is the last in the test body.  */
-	  if (cookie != last_act_cookie && last_act_cookie != -1)
+	     one.  This works since dlmopen is the last in the test body.
+
+	     Currently, this does not work as expected because there
+	     is no head link map if a namespace is completely deleted.
+	     No LA_ACT_CONSISTENT event is generated in that case.
+	     See the comment in _dl_audit_activity_nsid and bug 32068.  */
+	  if (cookie != last_act_cookie && last_act_cookie != -1
+	      && !pass_dlclose_flag)
 	    TEST_COMPARE (last_act, LA_ACT_CONSISTENT);
 
 	  if (this_act == LA_ACT_ADD && acts[nacts] != cookie)
@@ -174,8 +203,8 @@ do_test (int argc, char *argv[])
 	  if (is_vdso (lname))
 	    continue;
 	  if (nobjs == max_objs)
-	    FAIL_EXIT1 ("non expected la_objopen: %s %"PRIxPTR" %ld",
-			lname, laddr, lmid);
+	    FAIL_EXIT1 ("(line %u) non expected la_objopen: %s %"PRIxPTR" %ld",
+			line, lname, laddr, lmid);
 	  objs[nobjs].lname = lname;
 	  objs[nobjs].laddr = laddr;
 	  objs[nobjs].lmid = lmid;
@@ -217,11 +246,26 @@ do_test (int argc, char *argv[])
 	}
     }
 
+  Lmid_t lmid_other = LM_ID_NEWLM;
+  unsigned int other_namespace_count = 0;
   for (size_t i = 0; i < nobjs; i++)
     {
+      if (objs[i].lmid != LM_ID_BASE)
+	{
+	  if (lmid_other == LM_ID_NEWLM)
+	    lmid_other = objs[i].lmid;
+	  TEST_COMPARE (objs[i].lmid, lmid_other);
+	  ++other_namespace_count;
+	  if (!(endswith (objs[i].lname, "/" LIBC_SO)
+		|| endswith (objs[i].lname, "/" LD_SO)))
+	    FAIL ("unexpected object in secondary namespace: %s",
+		  objs[i].lname);
+	}
       TEST_COMPARE (objs[i].closed, true);
       free (objs[i].lname);
     }
+  /* Both libc.so and ld.so should be present.  */
+  TEST_COMPARE (other_namespace_count, 2);
 
   /* la_activity(LA_ACT_CONSISTENT) should be the last callback received.
      Since only one link map may be not-CONSISTENT at a time, this also
@@ -231,7 +275,16 @@ do_test (int argc, char *argv[])
 
   free (buffer);
   xfclose (out);
+}
+
+static int
+do_test (int argc, char *argv[])
+{
+  if (restart)
+    return handle_restart ();
 
+  do_one_test (argc, argv, false);
+  do_one_test (argc, argv, true);
   return 0;
 }
 
diff --git a/elf/tst-auditmod-tlsdesc2.c b/elf/tst-auditmod-tlsdesc2.c
new file mode 100644
index 0000000000..50275cd34d
--- /dev/null
+++ b/elf/tst-auditmod-tlsdesc2.c
@@ -0,0 +1,59 @@
+/* Loading TLS-using modules from auditors (bug 32412).  Audit module.
+   Copyright (C) 2021-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <dlfcn.h>
+#include <link.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <unistd.h>
+
+unsigned int
+la_version (unsigned int version)
+{
+  /* Open some modules, to trigger DTV resizing before the switch to
+     the main malloc.  */
+  for (int i = 1; i <= 19; ++i)
+    {
+      char dso[30];
+      snprintf (dso, sizeof (dso), "tst-tlsmod17a%d.so", i);
+      char sym[30];
+      snprintf (sym, sizeof(sym), "tlsmod17a%d", i);
+
+      void *handle = dlopen (dso, RTLD_LAZY);
+      if (handle == NULL)
+        {
+          printf ("error: dlmopen from auditor: %s\n", dlerror  ());
+          fflush (stdout);
+          _exit (1);
+        }
+      int (*func) (void) = dlsym (handle, sym);
+      if (func == NULL)
+        {
+          printf ("error: dlsym from auditor: %s\n", dlerror  ());
+          fflush (stdout);
+          _exit (1);
+        }
+      /* Trigger TLS allocation.  */
+      func ();
+    }
+
+  puts ("info: TLS-using modules loaded from auditor");
+  fflush (stdout);
+
+  return LAV_CURRENT;
+}
diff --git a/elf/tst-dlmopen4-nonpic.c b/elf/tst-dlmopen4-nonpic.c
new file mode 100644
index 0000000000..ad4e409953
--- /dev/null
+++ b/elf/tst-dlmopen4-nonpic.c
@@ -0,0 +1,2 @@
+#define BUILD_FOR_NONPIC
+#include "tst-dlmopen4.c"
diff --git a/elf/tst-dlmopen4-pic.c b/elf/tst-dlmopen4-pic.c
new file mode 100644
index 0000000000..919fa85c25
--- /dev/null
+++ b/elf/tst-dlmopen4-pic.c
@@ -0,0 +1,2 @@
+#define BUILD_FOR_PIC
+#include "tst-dlmopen4.c"
diff --git a/elf/tst-dlmopen4.c b/elf/tst-dlmopen4.c
index b1c5502621..9e053fbc59 100644
--- a/elf/tst-dlmopen4.c
+++ b/elf/tst-dlmopen4.c
@@ -46,6 +46,15 @@ do_test (void)
   TEST_COMPARE (debug->base.r_version, 1);
   TEST_VERIFY_EXIT (debug->r_next == NULL);
 
+#ifdef BUILD_FOR_PIC
+  /* In a PIC build, using _r_debug directly should give us the same
+     object.  */
+  TEST_VERIFY (&_r_debug == &debug->base);
+#endif
+#ifdef BUILD_FOR_NONPIC
+  TEST_COMPARE (_r_debug.r_version, 1);
+#endif
+
   void *h = xdlmopen (LM_ID_NEWLM, "$ORIGIN/tst-dlmopen1mod.so",
 		      RTLD_LAZY);
 
@@ -57,6 +66,19 @@ do_test (void)
   const char *name = basename (debug->r_next->base.r_map->l_name);
   TEST_COMPARE_STRING (name, "tst-dlmopen1mod.so");
 
+#ifdef BUILD_FOR_NONPIC
+  /* If a copy relocation is used, it must be at version 1.  */
+  if (&_r_debug != &debug->base)
+    {
+      TEST_COMPARE (_r_debug.r_version, 1);
+      TEST_COMPARE ((uintptr_t) _r_debug.r_map,
+		    (uintptr_t) debug->base.r_map);
+      TEST_COMPARE (_r_debug.r_brk, debug->base.r_brk);
+      TEST_COMPARE (_r_debug.r_state, debug->base.r_state);
+      TEST_COMPARE (_r_debug.r_ldbase, debug->base.r_ldbase);
+    }
+#endif
+
   xdlclose (h);
 
   return 0;
diff --git a/elf/tst-dlopen-auditdup-auditmod.c b/elf/tst-dlopen-auditdup-auditmod.c
new file mode 100644
index 0000000000..270a595ec4
--- /dev/null
+++ b/elf/tst-dlopen-auditdup-auditmod.c
@@ -0,0 +1,104 @@
+/* Auditor that opens again an object that just has been opened.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <dlfcn.h>
+#include <link.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+
+unsigned int
+la_version (unsigned int v)
+{
+  return LAV_CURRENT;
+}
+
+static bool trigger_on_la_activity;
+
+unsigned int
+la_objopen (struct link_map *map, Lmid_t lmid, uintptr_t *cookie)
+{
+  printf ("info: la_objopen: \"%s\"\n", map->l_name);
+  if (strstr (map->l_name, "/tst-dlopen-auditdupmod.so") != NULL)
+    trigger_on_la_activity = true;
+  return 0;
+}
+
+void
+la_activity (uintptr_t *cookie, unsigned int flag)
+{
+  static unsigned int calls;
+  ++calls;
+  printf ("info: la_activity: call %u (flag %u)\n", calls, flag);
+  fflush (stdout);
+  if (trigger_on_la_activity)
+    {
+      /* Avoid triggering on the dlmopen call below.  */
+      static bool recursion;
+      if (recursion)
+        return;
+      recursion = true;
+
+      puts ("info: about to dlmopen tst-dlopen-auditdupmod.so");
+      fflush (stdout);
+      void *handle = dlmopen (LM_ID_BASE, "tst-dlopen-auditdupmod.so",
+                              RTLD_NOW);
+      if (handle == NULL)
+        {
+          printf ("error: dlmopen: %s\n", dlerror ());
+          fflush (stdout);
+          _exit (1);
+        }
+
+      /* Check that the constructor has not run.  Running the
+         constructor would require constructing its dependencies, but
+         the constructor call that triggered this auditing activity
+         has not completed, and constructors among the dependencies
+         may not be able to deal with that.  */
+      int *status = dlsym (handle, "auditdupmod_status");
+      if (status == NULL)
+        {
+          printf ("error: dlsym: %s\n", dlerror ());
+          fflush (stdout);
+          _exit (1);
+        }
+      printf ("info: auditdupmod_status == %d\n", *status);
+      if (*status != 0)
+        {
+          puts ("error: auditdupmod_status == 0 expected");
+          fflush (stdout);
+          _exit (1);
+        }
+      /* Checked in the destructor and the main program.  */
+      ++*status;
+      printf ("info: auditdupmod_status == %d\n", *status);
+
+      /* Check that the module has been relocated.  */
+      int **status_address = dlsym (handle, "auditdupmod_status_address");
+      if (status_address == NULL || *status_address != status)
+        {
+          puts ("error: invalid auditdupmod_status address in"
+                " tst-dlopen-auditdupmod.so");
+          fflush (stdout);
+          _exit (1);
+        }
+
+      fflush (stdout);
+    }
+}
diff --git a/elf/tst-dlopen-auditdup.c b/elf/tst-dlopen-auditdup.c
new file mode 100644
index 0000000000..d022c58ae3
--- /dev/null
+++ b/elf/tst-dlopen-auditdup.c
@@ -0,0 +1,36 @@
+/* Test that recursive dlopen from auditor works (bug 31986).
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <stdio.h>
+#include <support/check.h>
+#include <support/xdlfcn.h>
+
+static int
+do_test (void)
+{
+  puts ("info: about to dlopen tst-dlopen-auditdupmod.so");
+  fflush (stdout);
+  void *handle = xdlopen ("tst-dlopen-auditdupmod.so", RTLD_NOW);
+  int *status = xdlsym (handle, "auditdupmod_status");
+  printf ("info: auditdupmod_status == %d (from main)\n", *status);
+  TEST_COMPARE (*status, 2);
+  xdlclose (handle);
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/elf/tst-dlopen-auditdupmod.c b/elf/tst-dlopen-auditdupmod.c
new file mode 100644
index 0000000000..59b7e21daa
--- /dev/null
+++ b/elf/tst-dlopen-auditdupmod.c
@@ -0,0 +1,48 @@
+/* Directly opened test module that gets reopened from the auditor.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <support/xdlfcn.h>
+
+int auditdupmod_status;
+
+/* Used to check for successful relocation processing.  */
+int *auditdupmod_status_address = &auditdupmod_status;
+
+static void __attribute__ ((constructor))
+init (void)
+{
+  ++auditdupmod_status;
+  printf ("info: tst-dlopen-auditdupmod.so constructor called (status %d)\n",
+          auditdupmod_status);
+}
+
+static void __attribute__ ((destructor))
+fini (void)
+{
+  /* The tst-dlopen-auditdup-auditmod.so auditor incremented
+     auditdupmod_status.  */
+  printf ("info: tst-dlopen-auditdupmod.so destructor called (status %d)\n",
+          auditdupmod_status);
+  if (auditdupmod_status != 2)
+    {
+      puts ("error: auditdupmod_status == 2 expected");
+      exit (1);
+    }
+}
diff --git a/elf/tst-dlopen-constructor-null-mod1.c b/elf/tst-dlopen-constructor-null-mod1.c
new file mode 100644
index 0000000000..70a7a0ad46
--- /dev/null
+++ b/elf/tst-dlopen-constructor-null-mod1.c
@@ -0,0 +1,55 @@
+/* Module calling dlopen (NULL, RTLD_LAZY) to obtain the global scope.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <dlfcn.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+int mod1_status;
+
+static void __attribute__ ((constructor))
+init (void)
+{
+  puts ("info: tst-dlopen-constructor-null-mod1.so constructor");
+
+  void *handle = dlopen (NULL, RTLD_LAZY);
+  if (handle == NULL)
+    {
+      printf ("error: %s\n", dlerror ());
+      exit (1);
+    }
+  puts ("info: dlopen returned");
+  if (dlsym (handle, "malloc") != malloc)
+    {
+      puts ("error: dlsym did not produce expected result");
+      exit (1);
+    }
+  dlclose (handle);
+
+  /* Check that the second module's constructor has not executed.   */
+  if (getenv ("mod2_status") != NULL)
+    {
+      printf ("error: mod2_status environment variable set: %s\n",
+              getenv ("mod2_status"));
+      exit (1);
+    }
+
+  /* Communicate to the second module that the constructor executed.   */
+  mod1_status = 1;
+}
diff --git a/elf/tst-dlopen-constructor-null-mod2.c b/elf/tst-dlopen-constructor-null-mod2.c
new file mode 100644
index 0000000000..d6e945beae
--- /dev/null
+++ b/elf/tst-dlopen-constructor-null-mod2.c
@@ -0,0 +1,37 @@
+/* Module whose constructor should not be invoked by dlopen (NULL, RTLD_LAZY).
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+extern int mod1_status;
+int mod2_status;
+
+static void __attribute__ ((constructor))
+init (void)
+{
+  printf ("info: tst-dlopen-constructor-null-mod2.so constructor"
+          " (mod1_status=%d)", mod1_status);
+  if (!(mod1_status == 1 && mod2_status == 0))
+    {
+      puts ("error: mod1_status == 1 && mod2_status == 0 expected");
+      exit (1);
+    }
+  setenv ("mod2_status", "constructed", 1);
+  mod2_status = 1;
+}
diff --git a/elf/tst-dlopen-constructor-null.c b/elf/tst-dlopen-constructor-null.c
new file mode 100644
index 0000000000..db90643325
--- /dev/null
+++ b/elf/tst-dlopen-constructor-null.c
@@ -0,0 +1,38 @@
+/* Verify that dlopen (NULL, RTLD_LAZY) does not complete initialization.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* This test mimics what the glvndSetupPthreads function in libglvnd
+   does. */
+
+#include <stdlib.h>
+#include <support/check.h>
+
+/* Defined and initialized in the shared objects.  */
+extern int mod1_status;
+extern int mod2_status;
+
+static int
+do_test (void)
+{
+  TEST_COMPARE (mod1_status, 1);
+  TEST_COMPARE (mod2_status, 1);
+  TEST_COMPARE_STRING (getenv ("mod2_status"), "constructed");
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/elf/tst-dlopen-sgid-mod.c b/elf/tst-dlopen-sgid-mod.c
new file mode 100644
index 0000000000..5eb79eef48
--- /dev/null
+++ b/elf/tst-dlopen-sgid-mod.c
@@ -0,0 +1 @@
+/* Opening this object should not succeed.  */
diff --git a/elf/tst-dlopen-sgid.c b/elf/tst-dlopen-sgid.c
new file mode 100644
index 0000000000..8aec52e19f
--- /dev/null
+++ b/elf/tst-dlopen-sgid.c
@@ -0,0 +1,106 @@
+/* Test case for ignored LD_LIBRARY_PATH in static startug (bug 32976).
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <dlfcn.h>
+#include <gnu/lib-names.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <support/capture_subprocess.h>
+#include <support/check.h>
+#include <support/support.h>
+#include <support/temp_file.h>
+#include <support/test-driver.h>
+#include <sys/wait.h>
+#include <unistd.h>
+
+/* This is the name of our test object.  Use a custom module for
+   testing, so that this object does not get picked up from the system
+   path.  */
+static const char dso_name[] = "tst-dlopen-sgid-mod.so";
+
+/* Used to mark the recursive invocation.  */
+static const char magic_argument[] = "run-actual-test";
+
+static int
+do_test (void)
+{
+/* Pathname of the directory that receives the shared objects this
+   test attempts to load.  */
+  char *libdir = support_create_temp_directory ("tst-dlopen-sgid-");
+
+  /* This is supposed to be ignored and stripped.  */
+  TEST_COMPARE (setenv ("LD_LIBRARY_PATH", libdir, 1), 0);
+
+  /* Copy of libc.so.6.  */
+  {
+    char *from = xasprintf ("%s/%s", support_objdir_root, LIBC_SO);
+    char *to = xasprintf ("%s/%s", libdir, LIBC_SO);
+    add_temp_file (to);
+    support_copy_file (from, to);
+    free (to);
+    free (from);
+  }
+
+  /* Copy of the test object.   */
+  {
+    char *from = xasprintf ("%s/elf/%s", support_objdir_root, dso_name);
+    char *to = xasprintf ("%s/%s", libdir, dso_name);
+    add_temp_file (to);
+    support_copy_file (from, to);
+    free (to);
+    free (from);
+  }
+
+  free (libdir);
+
+  support_capture_subprogram_self_sgid (magic_argument);
+
+  return 0;
+}
+
+static void
+alternative_main (int argc, char **argv)
+{
+  if (argc == 2 && strcmp (argv[1], magic_argument) == 0)
+    {
+      if (getgid () == getegid ())
+        /* This can happen if the file system is mounted nosuid.  */
+        FAIL_UNSUPPORTED ("SGID failed: GID and EGID match (%jd)\n",
+                          (intmax_t) getgid ());
+
+      /* Should be removed due to SGID.  */
+      TEST_COMPARE_STRING (getenv ("LD_LIBRARY_PATH"), NULL);
+
+      TEST_VERIFY (dlopen (dso_name, RTLD_NOW) == NULL);
+      {
+        const char *message = dlerror ();
+        TEST_COMPARE_STRING (message,
+                             "tst-dlopen-sgid-mod.so:"
+                             " cannot open shared object file:"
+                             " No such file or directory");
+      }
+
+      support_record_failure_barrier ();
+      exit (EXIT_SUCCESS);
+    }
+}
+
+#define PREPARE alternative_main
+#include <support/test-driver.c>
diff --git a/elf/tst-dlopen-tlsreinit1.c b/elf/tst-dlopen-tlsreinit1.c
new file mode 100644
index 0000000000..2016b9b0c6
--- /dev/null
+++ b/elf/tst-dlopen-tlsreinit1.c
@@ -0,0 +1,40 @@
+/* Test that dlopen preserves already accessed TLS (bug 31717).
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <stdbool.h>
+#include <support/check.h>
+#include <support/xdlfcn.h>
+#include <ctype.h>
+
+static int
+do_test (void)
+{
+  void *handle = xdlopen ("tst-dlopen-tlsreinitmod1.so", RTLD_NOW);
+
+  bool *tlsreinitmod3_tested = xdlsym (handle, "tlsreinitmod3_tested");
+  TEST_VERIFY (*tlsreinitmod3_tested);
+
+  xdlclose (handle);
+
+  /* This crashes if the libc.so.6 TLS image has been reverted.  */
+  TEST_VERIFY (!isupper ('@'));
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/elf/tst-dlopen-tlsreinit2.c b/elf/tst-dlopen-tlsreinit2.c
new file mode 100644
index 0000000000..90ad2c7713
--- /dev/null
+++ b/elf/tst-dlopen-tlsreinit2.c
@@ -0,0 +1,39 @@
+/* Test that dlopen preserves already accessed TLS (bug 31717).
+   Variant with initially-linked modules.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <ctype.h>
+#include <stdbool.h>
+#include <support/check.h>
+#include <support/xdlfcn.h>
+
+
+static int
+do_test (void)
+{
+  /* Defined in tst-dlopen-tlsreinitmod3.so.  */
+  extern bool tlsreinitmod3_tested;
+  TEST_VERIFY (tlsreinitmod3_tested);
+
+  /* This crashes if the libc.so.6 TLS image has been reverted.  */
+  TEST_VERIFY (!isupper ('@'));
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/elf/tst-dlopen-tlsreinit3.c b/elf/tst-dlopen-tlsreinit3.c
new file mode 100644
index 0000000000..79bd585aff
--- /dev/null
+++ b/elf/tst-dlopen-tlsreinit3.c
@@ -0,0 +1,2 @@
+/* Same code, but run with LD_AUDIT=tst-auditmod1.so.  */
+#include "tst-dlopen-tlsreinit1.c"
diff --git a/elf/tst-dlopen-tlsreinit4.c b/elf/tst-dlopen-tlsreinit4.c
new file mode 100644
index 0000000000..344c9211ab
--- /dev/null
+++ b/elf/tst-dlopen-tlsreinit4.c
@@ -0,0 +1,2 @@
+/* Same code, but run with LD_AUDIT=tst-auditmod1.so.  */
+#include "tst-dlopen-tlsreinit2.c"
diff --git a/elf/tst-dlopen-tlsreinitmod1.c b/elf/tst-dlopen-tlsreinitmod1.c
new file mode 100644
index 0000000000..354cc3de51
--- /dev/null
+++ b/elf/tst-dlopen-tlsreinitmod1.c
@@ -0,0 +1,20 @@
+/* Test that dlopen preserves already accessed TLS (bug 31717), module 1.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* This module triggers loading of tst-dlopen-tlsreinitmod2.so and
+   tst-dlopen-tlsreinitmod3.so.  */
diff --git a/elf/tst-dlopen-tlsreinitmod2.c b/elf/tst-dlopen-tlsreinitmod2.c
new file mode 100644
index 0000000000..677e69bd35
--- /dev/null
+++ b/elf/tst-dlopen-tlsreinitmod2.c
@@ -0,0 +1,30 @@
+/* Test that dlopen preserves already accessed TLS (bug 31717), module 2.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <stdio.h>
+
+/* Defined in tst-dlopen-tlsreinitmod3.so.  This an underlinked symbol
+   dependency.  */
+extern void call_tlsreinitmod3 (void);
+
+static void __attribute__ ((constructor))
+tlsreinitmod2_init (void)
+{
+  puts ("info: constructor of tst-dlopen-tlsreinitmod2.so invoked");
+  call_tlsreinitmod3 ();
+}
diff --git a/elf/tst-dlopen-tlsreinitmod3.c b/elf/tst-dlopen-tlsreinitmod3.c
new file mode 100644
index 0000000000..ef769c5131
--- /dev/null
+++ b/elf/tst-dlopen-tlsreinitmod3.c
@@ -0,0 +1,102 @@
+/* Test that dlopen preserves already accessed TLS (bug 31717), module 3.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <dlfcn.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <unistd.h>
+
+/* Used to verify from the main program that the test ran.  */
+bool tlsreinitmod3_tested;
+
+/* This TLS variable must not revert back to the initial state after
+   dlopen.  */
+static __thread int tlsreinitmod3_state = 1;
+
+/* Set from the ELF constructor during dlopen.  */
+static bool tlsreinitmod3_constructed;
+
+/* Second half of test, behind a compiler barrier.  The compiler
+   barrier is necessary to prevent carrying over TLS address
+   information from call_tlsreinitmod3 to call_tlsreinitmod3_tail.  */
+void call_tlsreinitmod3_tail (void *self) __attribute__ ((weak));
+
+/* Called from tst-dlopen-tlsreinitmod2.so.  */
+void
+call_tlsreinitmod3 (void)
+{
+  printf ("info: call_tlsreinitmod3 invoked (state=%d)\n",
+          tlsreinitmod3_state);
+
+  if (tlsreinitmod3_constructed)
+    {
+      puts ("error: call_tlsreinitmod3 called after ELF constructor");
+      fflush (stdout);
+      /* Cannot rely on test harness due to dynamic linking.  */
+      _exit (1);
+    }
+
+  tlsreinitmod3_state = 2;
+
+  /* Self-dlopen.  This will run the ELF constructor.   */
+  void *self = dlopen ("tst-dlopen-tlsreinitmod3.so", RTLD_NOW);
+  if (self == NULL)
+    {
+      printf ("error: dlopen: %s\n", dlerror ());
+      fflush (stdout);
+      /* Cannot rely on test harness due to dynamic linking.  */
+      _exit (1);
+    }
+
+  call_tlsreinitmod3_tail (self);
+}
+
+void
+call_tlsreinitmod3_tail (void *self)
+{
+  printf ("info: dlopen returned in tlsreinitmod3 (state=%d)\n",
+          tlsreinitmod3_state);
+
+  if (!tlsreinitmod3_constructed)
+    {
+      puts ("error: dlopen did not call tlsreinitmod3 ELF constructor");
+      fflush (stdout);
+      /* Cannot rely on test harness due to dynamic linking.  */
+      _exit (1);
+    }
+
+  if (tlsreinitmod3_state != 2)
+    {
+      puts ("error: TLS state reverted in tlsreinitmod3");
+      fflush (stdout);
+      /* Cannot rely on test harness due to dynamic linking.  */
+      _exit (1);
+    }
+
+  dlclose (self);
+
+  /* Signal test completion to the main program.  */
+  tlsreinitmod3_tested = true;
+}
+
+static void __attribute__ ((constructor))
+tlsreinitmod3_init (void)
+{
+  puts ("info: constructor of tst-dlopen-tlsreinitmod3.so invoked");
+  tlsreinitmod3_constructed = true;
+}
diff --git a/elf/tst-env-setuid-tunables.c b/elf/tst-env-setuid-tunables.c
index a47219047f..233eec7631 100644
--- a/elf/tst-env-setuid-tunables.c
+++ b/elf/tst-env-setuid-tunables.c
@@ -105,10 +105,7 @@ do_test (int argc, char **argv)
 
       if (ret != 0)
 	exit (1);
-
-      /* Special return code to make sure that the child executed all the way
-	 through.  */
-      exit (42);
+      return 0;
     }
   else
     {
@@ -127,18 +124,7 @@ do_test (int argc, char **argv)
 	      continue;
 	    }
 
-	  int status = support_capture_subprogram_self_sgid (buf);
-
-	  /* Bail out early if unsupported.  */
-	  if (WEXITSTATUS (status) == EXIT_UNSUPPORTED)
-	    return EXIT_UNSUPPORTED;
-
-	  if (WEXITSTATUS (status) != 42)
-	    {
-	      printf ("    [%d] child failed with status %d\n", i,
-		      WEXITSTATUS (status));
-	      support_record_failure ();
-	    }
+	  support_capture_subprogram_self_sgid (buf);
 	}
       return 0;
     }
diff --git a/elf/tst-env-setuid.c b/elf/tst-env-setuid.c
index 43047c48f3..c084aa4c1a 100644
--- a/elf/tst-env-setuid.c
+++ b/elf/tst-env-setuid.c
@@ -148,10 +148,7 @@ do_test (int argc, char **argv)
 
       if (ret != 0)
 	exit (1);
-
-      /* Special return code to make sure that the child executed all the way
-	 through.  */
-      exit (42);
+      return 0;
     }
   else
     {
@@ -175,17 +172,7 @@ do_test (int argc, char **argv)
 	free (profilepath);
       }
 
-      int status = support_capture_subprogram_self_sgid (SETGID_CHILD);
-
-      if (WEXITSTATUS (status) == EXIT_UNSUPPORTED)
-	exit (EXIT_UNSUPPORTED);
-
-      if (WEXITSTATUS (status) != 42)
-	{
-	  printf ("    child failed with status %d\n",
-		  WEXITSTATUS (status));
-	  support_record_failure ();
-	}
+      support_capture_subprogram_self_sgid (SETGID_CHILD);
 
       return 0;
     }
diff --git a/elf/tst-gnu2-tls2.c b/elf/tst-gnu2-tls2.c
new file mode 100644
index 0000000000..7ac04d7f33
--- /dev/null
+++ b/elf/tst-gnu2-tls2.c
@@ -0,0 +1,122 @@
+/* Test TLSDESC relocation.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <dlfcn.h>
+#include <pthread.h>
+#include <support/xdlfcn.h>
+#include <support/xthread.h>
+#include <support/check.h>
+#include <support/test-driver.h>
+#include "tst-gnu2-tls2.h"
+
+#ifndef IS_SUPPORTED
+# define IS_SUPPORTED() true
+#endif
+
+/* An architecture can define it to clobber caller-saved registers in
+   malloc below to verify that the implicit TLSDESC call won't change
+   caller-saved registers.  */
+#ifndef PREPARE_MALLOC
+# define PREPARE_MALLOC()
+#endif
+
+extern void * __libc_malloc (size_t);
+
+size_t malloc_counter = 0;
+
+void *
+malloc (size_t n)
+{
+  PREPARE_MALLOC ();
+  malloc_counter++;
+  return __libc_malloc (n);
+}
+
+static void *mod[3];
+#ifndef MOD
+# define MOD(i) "tst-gnu2-tls2mod" #i ".so"
+#endif
+static const char *modname[3] = { MOD(0), MOD(1), MOD(2) };
+#undef MOD
+
+static void
+open_mod (int i)
+{
+  mod[i] = xdlopen (modname[i], RTLD_LAZY);
+  printf ("open %s\n", modname[i]);
+}
+
+static void
+close_mod (int i)
+{
+  xdlclose (mod[i]);
+  mod[i] = NULL;
+  printf ("close %s\n", modname[i]);
+}
+
+static void
+access_mod (int i, const char *sym)
+{
+  struct tls var = { -1, -1, -1, -1 };
+  struct tls *(*f) (struct tls *) = xdlsym (mod[i], sym);
+  /* Check that our malloc is called.  */
+  malloc_counter = 0;
+  struct tls *p = f (&var);
+  TEST_VERIFY (malloc_counter != 0);
+  printf ("access %s: %s() = %p\n", modname[i], sym, p);
+  TEST_VERIFY_EXIT (memcmp (p, &var, sizeof (var)) == 0);
+  ++(p->a);
+}
+
+static void *
+start (void *arg)
+{
+  /* The DTV generation is at the last dlopen of mod0 and the
+     entry for mod1 is NULL.  */
+
+  open_mod (1); /* Reuse modid of mod1. Uses dynamic TLS.  */
+
+  /* Force the slow path in GNU2 TLS descriptor call.  */
+  access_mod (1, "apply_tls");
+
+  return arg;
+}
+
+static int
+do_test (void)
+{
+  if (!IS_SUPPORTED ())
+    return EXIT_UNSUPPORTED;
+
+  open_mod (0);
+  open_mod (1);
+  open_mod (2);
+  close_mod (0);
+  close_mod (1); /* Create modid gap at mod1.  */
+  open_mod (0); /* Reuse modid of mod0, bump generation count.  */
+
+  /* Create a thread where DTV of mod1 is NULL.  */
+  pthread_t t = xpthread_create (NULL, start, NULL);
+  xpthread_join (t);
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/elf/tst-gnu2-tls2.h b/elf/tst-gnu2-tls2.h
new file mode 100644
index 0000000000..1ade8151e2
--- /dev/null
+++ b/elf/tst-gnu2-tls2.h
@@ -0,0 +1,40 @@
+/* Test TLSDESC relocation.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <stdint.h>
+
+struct tls
+{
+  int64_t a, b, c, d;
+};
+
+extern struct tls *apply_tls (struct tls *);
+
+/* An architecture can define them to verify that clobber caller-saved
+   registers aren't changed by the implicit TLSDESC call.  */
+#ifndef INIT_TLSDESC_CALL
+# define INIT_TLSDESC_CALL()
+#endif
+
+#ifndef BEFORE_TLSDESC_CALL
+# define BEFORE_TLSDESC_CALL()
+#endif
+
+#ifndef AFTER_TLSDESC_CALL
+# define AFTER_TLSDESC_CALL()
+#endif
diff --git a/elf/tst-gnu2-tls2mod0.c b/elf/tst-gnu2-tls2mod0.c
new file mode 100644
index 0000000000..3fe3c14277
--- /dev/null
+++ b/elf/tst-gnu2-tls2mod0.c
@@ -0,0 +1,32 @@
+/* DSO used by tst-gnu2-tls2.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <tst-gnu2-tls2.h>
+
+__thread struct tls tls_var0 __attribute__ ((visibility ("hidden")));
+
+struct tls *
+apply_tls (struct tls *p)
+{
+  INIT_TLSDESC_CALL ();
+  BEFORE_TLSDESC_CALL ();
+  tls_var0 = *p;
+  struct tls *ret = &tls_var0;
+  AFTER_TLSDESC_CALL ();
+  return ret;
+}
diff --git a/elf/tst-gnu2-tls2mod1.c b/elf/tst-gnu2-tls2mod1.c
new file mode 100644
index 0000000000..e210538468
--- /dev/null
+++ b/elf/tst-gnu2-tls2mod1.c
@@ -0,0 +1,32 @@
+/* DSO used by tst-gnu2-tls2.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <tst-gnu2-tls2.h>
+
+__thread struct tls tls_var1[100] __attribute__ ((visibility ("hidden")));
+
+struct tls *
+apply_tls (struct tls *p)
+{
+  INIT_TLSDESC_CALL ();
+  BEFORE_TLSDESC_CALL ();
+  tls_var1[1] = *p;
+  struct tls *ret = &tls_var1[1];
+  AFTER_TLSDESC_CALL ();
+  return ret;
+}
diff --git a/elf/tst-gnu2-tls2mod2.c b/elf/tst-gnu2-tls2mod2.c
new file mode 100644
index 0000000000..6d3031dc5f
--- /dev/null
+++ b/elf/tst-gnu2-tls2mod2.c
@@ -0,0 +1,32 @@
+/* DSO used by tst-gnu2-tls2.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <tst-gnu2-tls2.h>
+
+__thread struct tls tls_var2 __attribute__ ((visibility ("hidden")));
+
+struct tls *
+apply_tls (struct tls *p)
+{
+  INIT_TLSDESC_CALL ();
+  BEFORE_TLSDESC_CALL ();
+  tls_var2 = *p;
+  struct tls *ret = &tls_var2;
+  AFTER_TLSDESC_CALL ();
+  return ret;
+}
diff --git a/elf/tst-link-map-contiguous-ldso.c b/elf/tst-link-map-contiguous-ldso.c
new file mode 100644
index 0000000000..04de808bb2
--- /dev/null
+++ b/elf/tst-link-map-contiguous-ldso.c
@@ -0,0 +1,98 @@
+/* Check that _dl_find_object behavior matches up with gaps.
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <dlfcn.h>
+#include <gnu/lib-names.h>
+#include <link.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <support/check.h>
+#include <support/xdlfcn.h>
+#include <support/xunistd.h>
+#include <sys/mman.h>
+#include <unistd.h>
+
+static int
+do_test (void)
+{
+  struct link_map *l = xdlopen (LD_SO, RTLD_NOW);
+  if (!l->l_contiguous)
+    {
+      puts ("info: ld.so link map is not contiguous");
+
+      /* Try to find holes by probing with mmap.  */
+      int pagesize = getpagesize ();
+      bool gap_found = false;
+      ElfW(Addr) addr = l->l_map_start;
+      TEST_COMPARE (addr % pagesize, 0);
+      while (addr < l->l_map_end)
+        {
+          void *expected = (void *) addr;
+          void *ptr = xmmap (expected, 1, PROT_READ | PROT_WRITE,
+                             MAP_PRIVATE | MAP_ANONYMOUS, -1);
+          struct dl_find_object dlfo;
+          int dlfo_ret = _dl_find_object (expected, &dlfo);
+          if (ptr == expected)
+            {
+              if (dlfo_ret < 0)
+                {
+                  TEST_COMPARE (dlfo_ret, -1);
+                  printf ("info: hole without mapping data found at %p\n", ptr);
+                }
+              else
+                FAIL ("object \"%s\" found in gap at %p",
+                      dlfo.dlfo_link_map->l_name, ptr);
+              gap_found = true;
+            }
+          else if (dlfo_ret == 0)
+            {
+              if ((void *) dlfo.dlfo_link_map != (void *) l)
+                {
+                  printf ("info: object \"%s\" found at %p\n",
+                          dlfo.dlfo_link_map->l_name, ptr);
+                  gap_found = true;
+                }
+            }
+          else
+            TEST_COMPARE (dlfo_ret, -1);
+          xmunmap (ptr, 1);
+          addr += pagesize;
+        }
+      if (!gap_found)
+        FAIL ("no ld.so gap found");
+    }
+  else
+    {
+      puts ("info: ld.so link map is contiguous");
+
+      /* Assert that ld.so is truly contiguous in memory.  */
+      volatile long int *p = (volatile long int *) l->l_map_start;
+      volatile long int *end = (volatile long int *) l->l_map_end;
+      while (p < end)
+        {
+          *p;
+          ++p;
+        }
+    }
+
+  xdlclose (l);
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/elf/tst-link-map-contiguous-libc.c b/elf/tst-link-map-contiguous-libc.c
new file mode 100644
index 0000000000..eb5728c765
--- /dev/null
+++ b/elf/tst-link-map-contiguous-libc.c
@@ -0,0 +1,57 @@
+/* Check that the entire libc.so program image is readable if contiguous.
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <gnu/lib-names.h>
+#include <link.h>
+#include <support/check.h>
+#include <support/xdlfcn.h>
+#include <support/xunistd.h>
+#include <sys/mman.h>
+#include <unistd.h>
+
+static int
+do_test (void)
+{
+  struct link_map *l = xdlopen (LIBC_SO, RTLD_NOW);
+
+  /* The dynamic loader fills holes with PROT_NONE mappings.  */
+  if (!l->l_contiguous)
+    FAIL_EXIT1 ("libc.so link map is not contiguous");
+
+  /* Direct probing does not work because not everything is readable
+     due to PROT_NONE mappings.  */
+  int pagesize = getpagesize ();
+  ElfW(Addr) addr = l->l_map_start;
+  TEST_COMPARE (addr % pagesize, 0);
+  while (addr < l->l_map_end)
+    {
+      void *expected = (void *) addr;
+      void *ptr = xmmap (expected, 1, PROT_READ | PROT_WRITE,
+                         MAP_PRIVATE | MAP_ANONYMOUS, -1);
+      if (ptr == expected)
+        FAIL ("hole in libc.so memory image after %lu bytes",
+              (unsigned long int) (addr - l->l_map_start));
+      xmunmap (ptr, 1);
+      addr += pagesize;
+    }
+
+  xdlclose (l);
+
+  return 0;
+}
+#include <support/test-driver.c>
diff --git a/elf/tst-link-map-contiguous-main.c b/elf/tst-link-map-contiguous-main.c
new file mode 100644
index 0000000000..2d1a054f0f
--- /dev/null
+++ b/elf/tst-link-map-contiguous-main.c
@@ -0,0 +1,45 @@
+/* Check that the entire main program image is readable if contiguous.
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <link.h>
+#include <support/check.h>
+#include <support/xdlfcn.h>
+
+static int
+do_test (void)
+{
+  struct link_map *l = xdlopen ("", RTLD_NOW);
+  if (!l->l_contiguous)
+    FAIL_UNSUPPORTED ("main link map is not contiguous");
+
+  /* This check only works if the kernel loaded the main program.  The
+     dynamic loader replaces gaps with PROT_NONE mappings, resulting
+     in faults.  */
+  volatile long int *p = (volatile long int *) l->l_map_start;
+  volatile long int *end = (volatile long int *) l->l_map_end;
+  while (p < end)
+    {
+      *p;
+      ++p;
+    }
+
+  xdlclose (l);
+
+  return 0;
+}
+#include <support/test-driver.c>
diff --git a/elf/tst-recursive-tls.c b/elf/tst-recursive-tls.c
new file mode 100644
index 0000000000..716d1f783a
--- /dev/null
+++ b/elf/tst-recursive-tls.c
@@ -0,0 +1,60 @@
+/* Test with interposed malloc with dynamic TLS.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <array_length.h>
+#include <stdio.h>
+#include <support/check.h>
+#include <support/xdlfcn.h>
+
+/* Defined in tst-recursive-tlsmallocmod.so.  */
+extern __thread unsigned int malloc_subsytem_counter;
+
+static int
+do_test (void)
+{
+  /* 16 is large enough to exercise the DTV resizing case.  */
+  void *handles[16];
+
+  for (unsigned int i = 0; i < array_length (handles); ++i)
+    {
+      /* Re-use the TLS slot for module 0.  */
+      if (i > 0)
+        xdlclose (handles[0]);
+
+      char soname[30];
+      snprintf (soname, sizeof (soname), "tst-recursive-tlsmod%u.so", i);
+      handles[i] = xdlopen (soname, RTLD_NOW);
+
+      if (i > 0)
+        {
+          handles[0] = xdlopen ("tst-recursive-tlsmod0.so", RTLD_NOW);
+          int (*fptr) (void) = xdlsym (handles[0], "get_threadvar_0");
+          /* May trigger TLS storage allocation using malloc.  */
+          TEST_COMPARE (fptr (), 0);
+        }
+    }
+
+  for (unsigned int i = 0; i < array_length (handles); ++i)
+    xdlclose (handles[i]);
+
+  printf ("info: malloc subsystem calls: %u\n", malloc_subsytem_counter);
+  TEST_VERIFY (malloc_subsytem_counter > 0);
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/elf/tst-recursive-tlsmallocmod.c b/elf/tst-recursive-tlsmallocmod.c
new file mode 100644
index 0000000000..c24e9945d1
--- /dev/null
+++ b/elf/tst-recursive-tlsmallocmod.c
@@ -0,0 +1,64 @@
+/* Interposed malloc with dynamic TLS.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <stdlib.h>
+#include <dlfcn.h>
+
+__thread unsigned int malloc_subsytem_counter;
+
+static __typeof (malloc) *malloc_fptr;
+static __typeof (free) *free_fptr;
+static __typeof (calloc) *calloc_fptr;
+static __typeof (realloc) *realloc_fptr;
+
+static void __attribute__ ((constructor))
+init (void)
+{
+  malloc_fptr = dlsym (RTLD_NEXT, "malloc");
+  free_fptr = dlsym (RTLD_NEXT, "free");
+  calloc_fptr = dlsym (RTLD_NEXT, "calloc");
+  realloc_fptr = dlsym (RTLD_NEXT, "realloc");
+}
+
+void *
+malloc (size_t size)
+{
+  ++malloc_subsytem_counter;
+  return malloc_fptr (size);
+}
+
+void
+free (void *ptr)
+{
+  ++malloc_subsytem_counter;
+  return free_fptr (ptr);
+}
+
+void *
+calloc (size_t a, size_t b)
+{
+  ++malloc_subsytem_counter;
+  return calloc_fptr (a, b);
+}
+
+void *
+realloc (void *ptr, size_t size)
+{
+  ++malloc_subsytem_counter;
+  return realloc_fptr (ptr, size);
+}
diff --git a/elf/tst-recursive-tlsmodN.c b/elf/tst-recursive-tlsmodN.c
new file mode 100644
index 0000000000..bb7592aee6
--- /dev/null
+++ b/elf/tst-recursive-tlsmodN.c
@@ -0,0 +1,28 @@
+/* Test module with global-dynamic TLS.  Used to trigger DTV reallocation.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* Compiled with VAR and FUNC set via -D.  FUNC requires some
+   relocation against TLS variable VAR.  */
+
+__thread int VAR;
+
+int
+FUNC (void)
+{
+  return VAR;
+}
diff --git a/elf/tst-rtld-no-malloc-audit.c b/elf/tst-rtld-no-malloc-audit.c
new file mode 100644
index 0000000000..a028377ad1
--- /dev/null
+++ b/elf/tst-rtld-no-malloc-audit.c
@@ -0,0 +1 @@
+#include "tst-rtld-no-malloc.c"
diff --git a/elf/tst-rtld-no-malloc-preload.c b/elf/tst-rtld-no-malloc-preload.c
new file mode 100644
index 0000000000..a028377ad1
--- /dev/null
+++ b/elf/tst-rtld-no-malloc-preload.c
@@ -0,0 +1 @@
+#include "tst-rtld-no-malloc.c"
diff --git a/elf/tst-rtld-no-malloc.c b/elf/tst-rtld-no-malloc.c
new file mode 100644
index 0000000000..5f24d4bd72
--- /dev/null
+++ b/elf/tst-rtld-no-malloc.c
@@ -0,0 +1,76 @@
+/* Test that program loading does not call malloc.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+
+#include <string.h>
+#include <unistd.h>
+
+static void
+print (const char *s)
+{
+  const char *end = s + strlen (s);
+  while (s < end)
+    {
+      ssize_t ret = write (STDOUT_FILENO, s, end - s);
+      if (ret <= 0)
+        _exit (2);
+      s += ret;
+    }
+}
+
+static void __attribute__ ((noreturn))
+unexpected_call (const char *function)
+{
+  print ("error: unexpected call to ");
+  print (function);
+  print ("\n");
+  _exit (1);
+}
+
+/* These are the malloc functions implement in elf/dl-minimal.c.  */
+
+void
+free (void *ignored)
+{
+  unexpected_call ("free");
+}
+
+void *
+calloc (size_t ignored1, size_t ignored2)
+{
+  unexpected_call ("calloc");
+}
+
+void *
+malloc (size_t ignored)
+{
+  unexpected_call ("malloc");
+}
+
+void *
+realloc (void *ignored1, size_t ignored2)
+{
+  unexpected_call ("realloc");
+}
+
+int
+main (void)
+{
+  /* Do not use the test wrapper, to avoid spurious malloc calls from it.  */
+  return 0;
+}
diff --git a/elf/tst-tls23-mod.c b/elf/tst-tls23-mod.c
new file mode 100644
index 0000000000..3ee4c70e40
--- /dev/null
+++ b/elf/tst-tls23-mod.c
@@ -0,0 +1,32 @@
+/* DSO used by tst-tls23.
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <tst-tls23.h>
+
+__thread struct tls tls_var0 __attribute__ ((visibility ("hidden")));
+
+struct tls *
+apply_tls (struct tls *p)
+{
+  INIT_TLS_CALL ();
+  BEFORE_TLS_CALL ();
+  tls_var0 = *p;
+  struct tls *ret = &tls_var0;
+  AFTER_TLS_CALL ();
+  return ret;
+}
diff --git a/elf/tst-tls23.c b/elf/tst-tls23.c
new file mode 100644
index 0000000000..afe594c067
--- /dev/null
+++ b/elf/tst-tls23.c
@@ -0,0 +1,106 @@
+/* Test that __tls_get_addr preserves caller-saved registers.
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <dlfcn.h>
+#include <pthread.h>
+#include <support/xdlfcn.h>
+#include <support/xthread.h>
+#include <support/check.h>
+#include <support/test-driver.h>
+#include <tst-tls23.h>
+
+#ifndef IS_SUPPORTED
+# define IS_SUPPORTED() true
+#endif
+
+/* An architecture can define it to clobber caller-saved registers in
+   malloc below to verify that __tls_get_addr won't change caller-saved
+   registers.  */
+#ifndef PREPARE_MALLOC
+# define PREPARE_MALLOC()
+#endif
+
+extern void * __libc_malloc (size_t);
+
+size_t malloc_counter = 0;
+
+void *
+malloc (size_t n)
+{
+  PREPARE_MALLOC ();
+  malloc_counter++;
+  return __libc_malloc (n);
+}
+
+static void *mod;
+static const char *modname = "tst-tls23-mod.so";
+
+static void
+open_mod (void)
+{
+  mod = xdlopen (modname, RTLD_LAZY);
+  printf ("open %s\n", modname);
+}
+
+static void
+close_mod (void)
+{
+  xdlclose (mod);
+  mod = NULL;
+  printf ("close %s\n", modname);
+}
+
+static void
+access_mod (const char *sym)
+{
+  struct tls var = { -4, -4, -4, -4 };
+  struct tls *(*f) (struct tls *) = xdlsym (mod, sym);
+  /* Check that our malloc is called.  */
+  malloc_counter = 0;
+  struct tls *p = f (&var);
+  TEST_VERIFY (malloc_counter != 0);
+  printf ("access %s: %s() = %p\n", modname, sym, p);
+  TEST_VERIFY_EXIT (memcmp (p, &var, sizeof (var)) == 0);
+  ++(p->a);
+}
+
+static void *
+start (void *arg)
+{
+  access_mod ("apply_tls");
+  return arg;
+}
+
+static int
+do_test (void)
+{
+  if (!IS_SUPPORTED ())
+    return EXIT_UNSUPPORTED;
+
+  open_mod ();
+  pthread_t t = xpthread_create (NULL, start, NULL);
+  xpthread_join (t);
+  close_mod ();
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/elf/tst-tls23.h b/elf/tst-tls23.h
new file mode 100644
index 0000000000..d0e734569c
--- /dev/null
+++ b/elf/tst-tls23.h
@@ -0,0 +1,40 @@
+/* Test that __tls_get_addr preserves caller-saved registers.
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <stdint.h>
+
+struct tls
+{
+  int64_t a, b, c, d;
+};
+
+extern struct tls *apply_tls (struct tls *);
+
+/* An architecture can define them to verify that caller-saved registers
+   aren't changed by __tls_get_addr.  */
+#ifndef INIT_TLS_CALL
+# define INIT_TLS_CALL()
+#endif
+
+#ifndef BEFORE_TLS_CALL
+# define BEFORE_TLS_CALL()
+#endif
+
+#ifndef AFTER_TLS_CALL
+# define AFTER_TLS_CALL()
+#endif
diff --git a/elf/tst-tunables.c b/elf/tst-tunables.c
index 095b5c81d9..dff34ed748 100644
--- a/elf/tst-tunables.c
+++ b/elf/tst-tunables.c
@@ -17,6 +17,10 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include <array_length.h>
+/* The test uses the tunable_list size, which is only exported for
+   ld.so.  This will result in a copy of tunable_list, which is ununsed by
+   the test itself.  */
+#define TUNABLES_INTERNAL 1
 #include <dl-tunables.h>
 #include <getopt.h>
 #include <intprops.h>
@@ -24,12 +28,13 @@
 #include <stdlib.h>
 #include <support/capture_subprocess.h>
 #include <support/check.h>
+#include <support/support.h>
 
 static int restart;
 #define CMDLINE_OPTIONS \
   { "restart", no_argument, &restart, 1 },
 
-static const struct test_t
+static struct test_t
 {
   const char *name;
   const char *value;
@@ -284,6 +289,29 @@ static const struct test_t
     0,
     0,
   },
+  /* Also check for repeated tunables with a count larger than the total number
+     of tunables.  */
+  {
+    "GLIBC_TUNABLES",
+    NULL,
+    2,
+    0,
+    0,
+  },
+  {
+    "GLIBC_TUNABLES",
+    NULL,
+    1,
+    0,
+    0,
+  },
+  {
+    "GLIBC_TUNABLES",
+    NULL,
+    0,
+    0,
+    0,
+  },
 };
 
 static int
@@ -327,6 +355,37 @@ do_test (int argc, char *argv[])
     spargv[i] = NULL;
   }
 
+  /* Create a tunable line with the duplicate values with a total number
+     larger than the different number of tunables.  */
+  {
+    enum { tunables_list_size = array_length (tunable_list) };
+    const char *value = "";
+    for (int i = 0; i < tunables_list_size; i++)
+      value = xasprintf ("%sglibc.malloc.check=2%c",
+			 value,
+			 i == (tunables_list_size - 1) ? '\0' : ':');
+    tests[33].value = value;
+  }
+  /* Same as before, but the last tunable values is differen than the
+     rest.  */
+  {
+    enum { tunables_list_size = array_length (tunable_list) };
+    const char *value = "";
+    for (int i = 0; i < tunables_list_size - 1; i++)
+      value = xasprintf ("%sglibc.malloc.check=2:", value);
+    value = xasprintf ("%sglibc.malloc.check=1", value);
+    tests[34].value = value;
+  }
+  /* Same as before, but with an invalid last entry.  */
+  {
+    enum { tunables_list_size = array_length (tunable_list) };
+    const char *value = "";
+    for (int i = 0; i < tunables_list_size - 1; i++)
+      value = xasprintf ("%sglibc.malloc.check=2:", value);
+    value = xasprintf ("%sglibc.malloc.check=1=1", value);
+    tests[35].value = value;
+  }
+
   for (int i = 0; i < array_length (tests); i++)
     {
       snprintf (nteststr, sizeof nteststr, "%d", i);
diff --git a/elf/tst-version-hash-zero-linkmod.c b/elf/tst-version-hash-zero-linkmod.c
new file mode 100644
index 0000000000..15e2506d01
--- /dev/null
+++ b/elf/tst-version-hash-zero-linkmod.c
@@ -0,0 +1,22 @@
+/* Stub module for linking tst-version-hash-zero-refmod.so.
+   Copyright (C) 2025  Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, see <https://www.gnu.org/licenses/>.  */
+
+/* The version script assigns a different symbol version for the stub
+   module.  Loading the module with the incorrect version is expected
+   to fail.  */
+#include "tst-version-hash-zero-mod.c"
diff --git a/elf/tst-version-hash-zero-linkmod.map b/elf/tst-version-hash-zero-linkmod.map
new file mode 100644
index 0000000000..2dba7c22d7
--- /dev/null
+++ b/elf/tst-version-hash-zero-linkmod.map
@@ -0,0 +1,7 @@
+Base {
+  local: *;
+};
+
+OTHER_VERSION {
+  global: global_variable;
+} Base;
diff --git a/elf/tst-version-hash-zero-mod.c b/elf/tst-version-hash-zero-mod.c
new file mode 100644
index 0000000000..ac6b0dc4a5
--- /dev/null
+++ b/elf/tst-version-hash-zero-mod.c
@@ -0,0 +1,20 @@
+/* Test module with a zero version symbol hash.
+   Copyright (C) 2025  Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, see <https://www.gnu.org/licenses/>.  */
+
+/* The symbol version is assigned by version script.  */
+int global_variable;
diff --git a/elf/tst-version-hash-zero-mod.map b/elf/tst-version-hash-zero-mod.map
new file mode 100644
index 0000000000..41eaff7914
--- /dev/null
+++ b/elf/tst-version-hash-zero-mod.map
@@ -0,0 +1,13 @@
+Base {
+  local: *;
+};
+
+/* Define the version so that tst-version-hash-zero-refmod.so passes
+   the initial symbol version check.  */
+OTHER_VERSION {
+} Base;
+
+/* This version string hashes to zero.  */
+PPPPPPPPPPPP {
+  global: global_variable;
+} Base;
diff --git a/elf/tst-version-hash-zero-refmod.c b/elf/tst-version-hash-zero-refmod.c
new file mode 100644
index 0000000000..cd8b3dcef5
--- /dev/null
+++ b/elf/tst-version-hash-zero-refmod.c
@@ -0,0 +1,23 @@
+/* Test module that triggers a relocation failure in tst-version-hash-zero.
+   Copyright (C) 2025  Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, see <https://www.gnu.org/licenses/>.  */
+
+/* This is bound to global_variable@@OTHER_VERSION via
+   tst-version-hash-zero-linkmod.so, but at run time, only
+   global_variable@PPPPPPPPPPPP exists.  */
+extern int global_variable;
+int *pointer_variable = &global_variable;
diff --git a/elf/tst-version-hash-zero.c b/elf/tst-version-hash-zero.c
new file mode 100644
index 0000000000..66a0db4f51
--- /dev/null
+++ b/elf/tst-version-hash-zero.c
@@ -0,0 +1,56 @@
+/* Symbols with version hash zero should not match any version (bug 29190).
+   Copyright (C) 2025  Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, see <https://www.gnu.org/licenses/>.  */
+
+#include <support/check.h>
+#include <support/xdlfcn.h>
+#include <stddef.h>
+#include <string.h>
+
+static int
+do_test (void)
+{
+  void *handle = xdlopen ("tst-version-hash-zero-mod.so", RTLD_NOW);
+
+  /* This used to crash because some struct r_found_version entries
+     with hash zero did not have valid version strings.  */
+  TEST_VERIFY (xdlvsym (handle, "global_variable", "PPPPPPPPPPPP") != NULL);
+
+  /* Consistency check.  */
+  TEST_VERIFY (xdlsym (handle, "global_variable")
+               == xdlvsym (handle, "global_variable", "PPPPPPPPPPPP"));
+
+  /* This symbol version is supposed to be missing.  */
+  TEST_VERIFY (dlvsym (handle, "global_variable", "OTHER_VERSION") == NULL);
+
+  /* tst-version-hash-zero-refmod.so references
+     global_variable@@OTHER_VERSION and is expected to fail to load.
+     dlvsym sets the hidden flag during lookup.  Relocation does not,
+     so this exercises a different failure case.  */
+  TEST_VERIFY_EXIT (dlopen ("tst-version-hash-zero-refmod.so", RTLD_NOW)
+                    == NULL);
+  const char *message = dlerror ();
+  if (strstr (message,
+              ": undefined symbol: global_variable, version OTHER_VERSION")
+      == NULL)
+    FAIL_EXIT1 ("unexpected dlopen failure: %s", message);
+
+  xdlclose (handle);
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/iconvdata/Makefile b/iconvdata/Makefile
index ea019ce5c0..7196a8744b 100644
--- a/iconvdata/Makefile
+++ b/iconvdata/Makefile
@@ -75,7 +75,8 @@ ifeq (yes,$(build-shared))
 tests = bug-iconv1 bug-iconv2 tst-loading tst-e2big tst-iconv4 bug-iconv4 \
 	tst-iconv6 bug-iconv5 bug-iconv6 tst-iconv7 bug-iconv8 bug-iconv9 \
 	bug-iconv10 bug-iconv11 bug-iconv12 tst-iconv-big5-hkscs-to-2ucs4 \
-	bug-iconv13 bug-iconv14 bug-iconv15
+	bug-iconv13 bug-iconv14 bug-iconv15 \
+	tst-iconv-iso-2022-cn-ext
 ifeq ($(have-thread-library),yes)
 tests += bug-iconv3
 endif
@@ -330,6 +331,8 @@ $(objpfx)bug-iconv14.out: $(addprefix $(objpfx), $(gconv-modules)) \
 			  $(addprefix $(objpfx),$(modules.so))
 $(objpfx)bug-iconv15.out: $(addprefix $(objpfx), $(gconv-modules)) \
 			  $(addprefix $(objpfx),$(modules.so))
+$(objpfx)tst-iconv-iso-2022-cn-ext.out: $(addprefix $(objpfx), $(gconv-modules)) \
+					$(addprefix $(objpfx),$(modules.so))
 
 $(objpfx)iconv-test.out: run-iconv-test.sh \
 			 $(addprefix $(objpfx), $(gconv-modules)) \
diff --git a/iconvdata/iso-2022-cn-ext.c b/iconvdata/iso-2022-cn-ext.c
index b34c8a36f4..cce29b1969 100644
--- a/iconvdata/iso-2022-cn-ext.c
+++ b/iconvdata/iso-2022-cn-ext.c
@@ -574,6 +574,12 @@ DIAG_IGNORE_Os_NEEDS_COMMENT (5, "-Wmaybe-uninitialized");
 	      {								      \
 		const char *escseq;					      \
 									      \
+		if (outptr + 4 > outend)				      \
+		  {							      \
+		    result = __GCONV_FULL_OUTPUT;			      \
+		    break;						      \
+		  }							      \
+									      \
 		assert (used == CNS11643_2_set); /* XXX */		      \
 		escseq = "*H";						      \
 		*outptr++ = ESC;					      \
@@ -587,6 +593,12 @@ DIAG_IGNORE_Os_NEEDS_COMMENT (5, "-Wmaybe-uninitialized");
 	      {								      \
 		const char *escseq;					      \
 									      \
+		if (outptr + 4 > outend)				      \
+		  {							      \
+		    result = __GCONV_FULL_OUTPUT;			      \
+		    break;						      \
+		  }							      \
+									      \
 		assert ((used >> 5) >= 3 && (used >> 5) <= 7);		      \
 		escseq = "+I+J+K+L+M" + ((used >> 5) - 3) * 2;		      \
 		*outptr++ = ESC;					      \
diff --git a/iconvdata/tst-iconv-iso-2022-cn-ext.c b/iconvdata/tst-iconv-iso-2022-cn-ext.c
new file mode 100644
index 0000000000..96a8765fd5
--- /dev/null
+++ b/iconvdata/tst-iconv-iso-2022-cn-ext.c
@@ -0,0 +1,128 @@
+/* Verify ISO-2022-CN-EXT does not write out of the bounds.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <stdio.h>
+#include <string.h>
+
+#include <errno.h>
+#include <iconv.h>
+#include <sys/mman.h>
+
+#include <support/xunistd.h>
+#include <support/check.h>
+#include <support/support.h>
+
+/* The test sets up a two memory page buffer with the second page marked
+   PROT_NONE to trigger a fault if the conversion writes beyond the exact
+   expected amount.  Then we carry out various conversions and precisely
+   place the start of the output buffer in order to trigger a SIGSEGV if the
+   process writes anywhere between 1 and page sized bytes more (only one
+   PROT_NONE page is setup as a canary) than expected.  These tests exercise
+   all three of the cases in ISO-2022-CN-EXT where the converter must switch
+   character sets and may run out of buffer space while doing the
+   operation.  */
+
+static int
+do_test (void)
+{
+  iconv_t cd = iconv_open ("ISO-2022-CN-EXT", "UTF-8");
+  TEST_VERIFY_EXIT (cd != (iconv_t) -1);
+
+  char *ntf;
+  size_t ntfsize;
+  char *outbufbase;
+  {
+    int pgz = getpagesize ();
+    TEST_VERIFY_EXIT (pgz > 0);
+    ntfsize = 2 * pgz;
+
+    ntf = xmmap (NULL, ntfsize, PROT_READ | PROT_WRITE, MAP_PRIVATE
+		 | MAP_ANONYMOUS, -1);
+    xmprotect (ntf + pgz, pgz, PROT_NONE);
+
+    outbufbase = ntf + pgz;
+  }
+
+  /* Check if SOdesignation escape sequence does not trigger an OOB write.  */
+  {
+    char inbuf[] = "\xe4\xba\xa4\xe6\x8d\xa2";
+
+    for (int i = 0; i < 9; i++)
+      {
+	char *inp = inbuf;
+	size_t inleft = sizeof (inbuf) - 1;
+
+	char *outp = outbufbase - i;
+	size_t outleft = i;
+
+	TEST_VERIFY_EXIT (iconv (cd, &inp, &inleft, &outp, &outleft)
+			  == (size_t) -1);
+	TEST_COMPARE (errno, E2BIG);
+
+	TEST_VERIFY_EXIT (iconv (cd, NULL, NULL, NULL, NULL) == 0);
+      }
+  }
+
+  /* Same as before for SS2designation.  */
+  {
+    char inbuf[] = " \xe3\xb4\xbd";
+
+    for (int i = 0; i < 14; i++)
+      {
+	char *inp = inbuf;
+	size_t inleft = sizeof (inbuf) - 1;
+
+	char *outp = outbufbase - i;
+	size_t outleft = i;
+
+	TEST_VERIFY_EXIT (iconv (cd, &inp, &inleft, &outp, &outleft)
+			  == (size_t) -1);
+	TEST_COMPARE (errno, E2BIG);
+
+	TEST_VERIFY_EXIT (iconv (cd, NULL, NULL, NULL, NULL) == 0);
+      }
+  }
+
+  /* Same as before for SS3designation.  */
+  {
+    char inbuf[] = " \xe5\x8a\x84";
+
+    for (int i = 0; i < 14; i++)
+      {
+	char *inp = inbuf;
+	size_t inleft = sizeof (inbuf) - 1;
+
+	char *outp = outbufbase - i;
+	size_t outleft = i;
+
+	TEST_VERIFY_EXIT (iconv (cd, &inp, &inleft, &outp, &outleft)
+			  == (size_t) -1);
+	TEST_COMPARE (errno, E2BIG);
+
+	TEST_VERIFY_EXIT (iconv (cd, NULL, NULL, NULL, NULL) == 0);
+      }
+  }
+
+  TEST_VERIFY_EXIT (iconv_close (cd) != -1);
+
+  xmunmap (ntf, ntfsize);
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/include/ctype.h b/include/ctype.h
index 493a6f80ce..a15e5b6678 100644
--- a/include/ctype.h
+++ b/include/ctype.h
@@ -24,33 +24,35 @@ libc_hidden_proto (toupper)
    NL_CURRENT_INDIRECT.  */
 
 #  include "../locale/localeinfo.h"
-#  include <libc-tsd.h>
 
 #  ifndef CTYPE_EXTERN_INLINE	/* Used by ctype/ctype-info.c, which see.  */
 #   define CTYPE_EXTERN_INLINE extern inline
 #  endif
 
-__libc_tsd_define (extern, const uint16_t *, CTYPE_B)
-__libc_tsd_define (extern, const int32_t *, CTYPE_TOUPPER)
-__libc_tsd_define (extern, const int32_t *, CTYPE_TOLOWER)
+extern __thread const uint16_t * __libc_tsd_CTYPE_B
+  attribute_hidden attribute_tls_model_ie;
+extern __thread const int32_t * __libc_tsd_CTYPE_TOUPPER
+  attribute_hidden attribute_tls_model_ie;
+extern __thread const int32_t * __libc_tsd_CTYPE_TOLOWER
+  attribute_hidden attribute_tls_model_ie;
 
 
 CTYPE_EXTERN_INLINE const uint16_t ** __attribute__ ((const))
 __ctype_b_loc (void)
 {
-  return __libc_tsd_address (const uint16_t *, CTYPE_B);
+  return &__libc_tsd_CTYPE_B;
 }
 
 CTYPE_EXTERN_INLINE const int32_t ** __attribute__ ((const))
 __ctype_toupper_loc (void)
 {
-  return __libc_tsd_address (const int32_t *, CTYPE_TOUPPER);
+  return &__libc_tsd_CTYPE_TOUPPER;
 }
 
 CTYPE_EXTERN_INLINE const int32_t ** __attribute__ ((const))
 __ctype_tolower_loc (void)
 {
-  return __libc_tsd_address (const int32_t *, CTYPE_TOLOWER);
+  return &__libc_tsd_CTYPE_TOLOWER;
 }
 
 #  ifndef __NO_CTYPE
@@ -64,6 +66,11 @@ __ctype_tolower_loc (void)
 #   define __isdigit_l(c, l) ({ int __c = (c); __c >= '0' && __c <= '9'; })
 #  endif  /* Not __NO_CTYPE.  */
 
+/* For use in initializers.  */
+extern const char _nl_C_LC_CTYPE_class[] attribute_hidden;
+extern const uint32_t _nl_C_LC_CTYPE_toupper[] attribute_hidden;
+extern const uint32_t _nl_C_LC_CTYPE_tolower[] attribute_hidden;
+
 # endif	/* IS_IN (libc).  */
 #endif  /* Not _ISOMAC.  */
 
diff --git a/include/libc-internal.h b/include/libc-internal.h
index 87ac591835..1ef43ffe67 100644
--- a/include/libc-internal.h
+++ b/include/libc-internal.h
@@ -53,6 +53,9 @@ extern __typeof (__profile_frequency) __profile_frequency attribute_hidden;
    is not for an audit module, not loaded via dlmopen, and not loaded
    via static dlopen either).  */
 extern _Bool __libc_initial attribute_hidden;
+#else
+/* The static libc is always the initial namespace.  */
+# define __libc_initial ((_Bool) 1)
 #endif
 
 #endif /* _LIBC_INTERNAL  */
diff --git a/include/link.h b/include/link.h
index cb0d7d8e2f..7ca305f780 100644
--- a/include/link.h
+++ b/include/link.h
@@ -212,6 +212,7 @@ struct link_map
     unsigned int l_find_object_processed:1; /* Zero if _dl_find_object_update
 					       needs to process this
 					       lt_library map.  */
+    unsigned int l_tls_in_slotinfo:1; /* TLS slotinfo updated in dlopen.  */
 
     /* NODELETE status of the map.  Only valid for maps of type
        lt_loaded.  Lazy binding sets l_nodelete_active directly,
@@ -364,6 +365,8 @@ struct auditstate
    dynamic linker.  */
 extern struct r_debug_extended _r_debug_extended attribute_hidden;
 
+rtld_hidden_proto (_r_debug)
+
 #if __ELF_NATIVE_CLASS == 32
 # define symbind symbind32
 # define LA_SYMBIND "la_symbind32"
diff --git a/include/math.h b/include/math.h
index fa11a710a6..035fd160ff 100644
--- a/include/math.h
+++ b/include/math.h
@@ -130,7 +130,10 @@ fabsf128 (_Float128 x)
 }
 # endif
 
-# if !(defined __FINITE_MATH_ONLY__ && __FINITE_MATH_ONLY__ > 0)
+
+/* NB: Internal tests don't have access to internal symbols.  */
+# if !IS_IN (testsuite_internal) \
+     && !(defined __FINITE_MATH_ONLY__ && __FINITE_MATH_ONLY__ > 0)
 #  ifndef NO_MATH_REDIRECT
 /* Declare some functions for use within GLIBC.  Compilers typically
    inline those functions as a single instruction.  Use an asm to
diff --git a/include/rpc/rpc.h b/include/rpc/rpc.h
index f5cee6caef..ba967833ad 100644
--- a/include/rpc/rpc.h
+++ b/include/rpc/rpc.h
@@ -3,8 +3,6 @@
 
 # ifndef _ISOMAC
 
-#include <libc-tsd.h>
-
 /* Now define the internal interfaces.  */
 extern unsigned long _create_xid (void);
 
@@ -47,7 +45,8 @@ extern void __rpc_thread_key_cleanup (void) attribute_hidden;
 
 extern void __rpc_thread_destroy (void) attribute_hidden;
 
-__libc_tsd_define (extern, struct rpc_thread_variables *, RPC_VARS)
+extern __thread struct rpc_thread_variables *__libc_tsd_RPC_VARS
+  attribute_hidden attribute_tls_model_ie;
 
 #define RPC_THREAD_VARIABLE(x) (__rpc_thread_variables()->x)
 
diff --git a/inet/netinet/in.h b/inet/netinet/in.h
index fa57b61079..f684be5beb 100644
--- a/inet/netinet/in.h
+++ b/inet/netinet/in.h
@@ -244,7 +244,7 @@ extern const struct in6_addr in6addr_loopback;   /* ::1 */
 
 
 /* Structure describing an Internet socket address.  */
-struct sockaddr_in
+struct __attribute_struct_may_alias__ sockaddr_in
   {
     __SOCKADDR_COMMON (sin_);
     in_port_t sin_port;			/* Port number.  */
@@ -257,9 +257,11 @@ struct sockaddr_in
 			   - sizeof (struct in_addr)];
   };
 
-#if !__USE_KERNEL_IPV6_DEFS
+#if __USE_KERNEL_IPV6_DEFS
+struct __attribute_struct_may_alias__ sockaddr_in6;
+#else
 /* Ditto, for IPv6.  */
-struct sockaddr_in6
+struct __attribute_struct_may_alias__ sockaddr_in6
   {
     __SOCKADDR_COMMON (sin6_);
     in_port_t sin6_port;	/* Transport layer port # */
diff --git a/io/bits/poll2.h b/io/bits/poll2.h
index 6152a8c5e4..efc8b85403 100644
--- a/io/bits/poll2.h
+++ b/io/bits/poll2.h
@@ -43,7 +43,7 @@ poll (struct pollfd *__fds, nfds_t __nfds, int __timeout)
 
 
 #ifdef __USE_GNU
-# ifdef __USE_TIME_BITS64
+# ifdef __USE_TIME64_REDIRECTS
 extern int __REDIRECT (__ppoll64_alias, (struct pollfd *__fds, nfds_t __nfds,
 				       const struct timespec *__timeout,
 				       const __sigset_t *__ss), __ppoll64);
diff --git a/io/fcntl.h b/io/fcntl.h
index 9cee0b5900..666b7e5eb6 100644
--- a/io/fcntl.h
+++ b/io/fcntl.h
@@ -172,7 +172,7 @@ typedef __pid_t pid_t;
 
    This function is a cancellation point and therefore not marked with
    __THROW.  */
-#ifndef __USE_TIME_BITS64
+#ifndef __USE_TIME64_REDIRECTS
 # ifndef __USE_FILE_OFFSET64
 extern int fcntl (int __fd, int __cmd, ...);
 # else
@@ -185,7 +185,7 @@ extern int __REDIRECT (fcntl, (int __fd, int __cmd, ...), fcntl64);
 # ifdef __USE_LARGEFILE64
 extern int fcntl64 (int __fd, int __cmd, ...);
 # endif
-#else /* __USE_TIME_BITS64 */
+#else /* __USE_TIME64_REDIRECTS */
 # ifdef __REDIRECT
 extern int __REDIRECT_NTH (fcntl, (int __fd, int __request, ...),
 			   __fcntl_time64);
diff --git a/io/fts.h b/io/fts.h
index 61f95bb441..97a031ebbd 100644
--- a/io/fts.h
+++ b/io/fts.h
@@ -187,7 +187,7 @@ FTSENT	*fts_read (FTS *);
 int	 fts_set (FTS *, FTSENT *, int) __THROW;
 #else
 # ifdef __REDIRECT
-#  ifndef __USE_TIME_BITS64
+#  ifndef __USE_TIME64_REDIRECTS
 FTSENT	*__REDIRECT (fts_children, (FTS *, int), fts64_children);
 int	 __REDIRECT (fts_close, (FTS *), fts64_close);
 FTS	*__REDIRECT (fts_open, (char * const *, int,
@@ -206,7 +206,7 @@ int	 __REDIRECT_NTH (fts_set, (FTS *, FTSENT *, int),
 			 __fts64_set_time64);
 #  endif
 # else
-#  ifndef __USE_TIME_BITS64
+#  ifndef __USE_TIME64_REDIRECTS
 #   define fts_children fts64_children
 #   define fts_close fts64_close
 #   define fts_open fts64_open
@@ -217,7 +217,7 @@ int	 __REDIRECT_NTH (fts_set, (FTS *, FTSENT *, int),
 # endif
 #endif
 #ifdef __USE_LARGEFILE64
-# ifndef __USE_TIME_BITS64
+# ifndef __USE_TIME64_REDIRECTS
 FTSENT64 *fts64_children (FTS64 *, int);
 int	  fts64_close (FTS64 *);
 FTS64	 *fts64_open (char * const *, int,
diff --git a/io/ftw.h b/io/ftw.h
index e4d1b84d53..39cf595b27 100644
--- a/io/ftw.h
+++ b/io/ftw.h
@@ -137,7 +137,7 @@ extern int ftw (const char *__dir, __ftw_func_t __func, int __descriptors)
      __nonnull ((1, 2));
 #else
 # ifdef __REDIRECT
-#  ifndef __USE_TIME_BITS64
+#  ifndef __USE_TIME64_REDIRECTS
 extern int __REDIRECT (ftw, (const char *__dir, __ftw_func_t __func,
 			     int __descriptors), ftw64) __nonnull ((1, 2));
 #  else
@@ -146,7 +146,7 @@ extern int __REDIRECT (ftw, (const char *__dir, __ftw_func_t __func,
      __nonnull ((1, 2));
 #  endif
 # else
-#  ifndef __USE_TIME_BITS64
+#  ifndef __USE_TIME64_REDIRECTS
 #   define ftw ftw64
 #  else
 #   define ftw __ftw64_time64
@@ -154,7 +154,7 @@ extern int __REDIRECT (ftw, (const char *__dir, __ftw_func_t __func,
 # endif
 #endif
 #ifdef __USE_LARGEFILE64
-# ifndef __USE_TIME_BITS64
+# ifndef __USE_TIME64_REDIRECTS
 extern int ftw64 (const char *__dir, __ftw64_func_t __func,
 		  int __descriptors) __nonnull ((1, 2));
 # else
@@ -180,7 +180,7 @@ extern int nftw (const char *__dir, __nftw_func_t __func, int __descriptors,
 		 int __flag) __nonnull ((1, 2));
 # else
 #  ifdef __REDIRECT
-#   ifndef __USE_TIME_BITS64
+#   ifndef __USE_TIME64_REDIRECTS
 extern int __REDIRECT (nftw, (const char *__dir, __nftw_func_t __func,
 			      int __descriptors, int __flag), nftw64)
      __nonnull ((1, 2));
@@ -190,7 +190,7 @@ extern int __REDIRECT (nftw, (const char *__dir, __nftw_func_t __func,
      __nonnull ((1, 2));
 #   endif
 #  else
-#   ifndef __USE_TIME_BITS64
+#   ifndef __USE_TIME64_REDIRECTS
 #    define nftw nftw64
 #   else
 #    define nftw __nftw64_time64
@@ -198,7 +198,7 @@ extern int __REDIRECT (nftw, (const char *__dir, __nftw_func_t __func,
 #  endif
 # endif
 # ifdef __USE_LARGEFILE64
-#  ifndef __USE_TIME_BITS64
+#  ifndef __USE_TIME64_REDIRECTS
 extern int nftw64 (const char *__dir, __nftw64_func_t __func,
 		   int __descriptors, int __flag) __nonnull ((1, 2));
 #  else
diff --git a/io/sys/poll.h b/io/sys/poll.h
index 7858fad6b9..c324ff5dad 100644
--- a/io/sys/poll.h
+++ b/io/sys/poll.h
@@ -66,7 +66,7 @@ extern int ppoll (struct pollfd *__fds, nfds_t __nfds,
 		  const __sigset_t *__ss)
     __fortified_attr_access (__write_only__, 1, 2);
 
-# ifdef __USE_TIME_BITS64
+# ifdef __USE_TIME64_REDIRECTS
 #  ifdef __REDIRECT
 extern int __REDIRECT (ppoll, (struct pollfd *__fds, nfds_t __nfds,
                                const struct timespec *__timeout,
diff --git a/io/sys/stat.h b/io/sys/stat.h
index 1fa6d6e62e..3b4ba80132 100644
--- a/io/sys/stat.h
+++ b/io/sys/stat.h
@@ -209,7 +209,7 @@ extern int stat (const char *__restrict __file,
    that file descriptor FD is open on and put them in BUF.  */
 extern int fstat (int __fd, struct stat *__buf) __THROW __nonnull ((2));
 #else
-# ifdef __USE_TIME_BITS64
+# ifdef __USE_TIME64_REDIRECTS
 #  ifdef __REDIRECT_NTH
 extern int __REDIRECT_NTH (stat, (const char *__restrict __file,
 				  struct stat *__restrict __buf),
@@ -236,7 +236,7 @@ extern int __REDIRECT_NTH (fstat, (int __fd, struct stat *__buf), fstat64)
 # endif
 #endif
 #ifdef __USE_LARGEFILE64
-# ifndef __USE_TIME_BITS64
+# ifndef __USE_TIME64_REDIRECTS
 extern int stat64 (const char *__restrict __file,
 		   struct stat64 *__restrict __buf) __THROW __nonnull ((1, 2));
 extern int fstat64 (int __fd, struct stat64 *__buf) __THROW __nonnull ((2));
@@ -265,7 +265,7 @@ extern int fstatat (int __fd, const char *__restrict __file,
 		    struct stat *__restrict __buf, int __flag)
      __THROW __nonnull ((2, 3));
 # else
-#  ifdef __USE_TIME_BITS64
+#  ifdef __USE_TIME64_REDIRECTS
 #   ifdef __REDIRECT_NTH
 extern int __REDIRECT_NTH (fstatat, (int __fd, const char *__restrict __file,
 				     struct stat *__restrict __buf,
@@ -287,7 +287,7 @@ extern int __REDIRECT_NTH (fstatat, (int __fd, const char *__restrict __file,
 # endif
 
 # ifdef __USE_LARGEFILE64
-#  ifndef __USE_TIME_BITS64
+#  ifndef __USE_TIME64_REDIRECTS
 extern int fstatat64 (int __fd, const char *__restrict __file,
 		      struct stat64 *__restrict __buf, int __flag)
      __THROW __nonnull ((2, 3));
@@ -313,7 +313,7 @@ extern int __REDIRECT_NTH (fstatat64, (int __fd,
 extern int lstat (const char *__restrict __file,
 		  struct stat *__restrict __buf) __THROW __nonnull ((1, 2));
 # else
-#  ifdef __USE_TIME_BITS64
+#  ifdef __USE_TIME64_REDIRECTS
 #   ifdef __REDIRECT_NTH
 extern int __REDIRECT_NTH (lstat,
 			   (const char *__restrict __file,
@@ -334,7 +334,7 @@ extern int __REDIRECT_NTH (lstat,
 #  endif
 # endif
 # ifdef __USE_LARGEFILE64
-#  ifndef __USE_TIME_BITS64
+#  ifndef __USE_TIME64_REDIRECTS
 extern int lstat64 (const char *__restrict __file,
 		    struct stat64 *__restrict __buf)
      __THROW __nonnull ((1, 2));
@@ -427,7 +427,7 @@ extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
 #endif
 
 #ifdef __USE_ATFILE
-# ifndef __USE_TIME_BITS64
+# ifndef __USE_TIME64_REDIRECTS
 /* Set file access and modification times relative to directory file
    descriptor.  */
 extern int utimensat (int __fd, const char *__path,
@@ -447,7 +447,7 @@ extern int __REDIRECT_NTH (utimensat, (int fd, const char *__path,
 #endif
 
 #ifdef __USE_XOPEN2K8
-# ifndef __USE_TIME_BITS64
+# ifndef __USE_TIME64_REDIRECTS
 /* Set file access and modification times of the file associated with FD.  */
 extern int futimens (int __fd, const struct timespec __times[2]) __THROW;
 
diff --git a/io/utime.h b/io/utime.h
index c5eacedd6a..1c7587d9c1 100644
--- a/io/utime.h
+++ b/io/utime.h
@@ -35,7 +35,7 @@ __BEGIN_DECLS
 /* Structure describing file times.  */
 struct utimbuf
   {
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
     __time64_t actime;		/* Access time.  */
     __time64_t modtime;		/* Modification time.  */
 #else
@@ -46,7 +46,7 @@ struct utimbuf
 
 /* Set the access and modification times of FILE to those given in
    *FILE_TIMES.  If FILE_TIMES is NULL, set them to the current time.  */
-#ifndef __USE_TIME_BITS64
+#ifndef __USE_TIME64_REDIRECTS
 extern int utime (const char *__file,
 		  const struct utimbuf *__file_times)
      __THROW __nonnull ((1));
diff --git a/libio/Makefile b/libio/Makefile
index 27623c92a9..b189455bb9 100644
--- a/libio/Makefile
+++ b/libio/Makefile
@@ -68,22 +68,80 @@ routines_no_fortify += \
   wprintf \
   # routines_no_fortify
 
-tests = tst_swprintf tst_wprintf tst_swscanf tst_wscanf tst_getwc tst_putwc   \
-	tst_wprintf2 tst-widetext test-fmemopen tst-ext tst-ext2 \
-	tst-fgetws tst-ungetwc1 tst-ungetwc2 tst-swscanf tst-sscanf	      \
-	tst-mmap-setvbuf bug-ungetwc1 bug-ungetwc2 tst-atime tst-eof          \
-	tst-freopen bug-rewind bug-rewind2 bug-ungetc bug-fseek \
-	tst-mmap-eofsync tst-mmap-fflushsync bug-mmap-fflush \
-	tst-mmap2-eofsync tst-mmap-offend bug-fopena+ bug-wfflush \
-	bug-ungetc2 bug-ftell bug-ungetc3 bug-ungetc4 tst-fopenloc2 \
-	tst-memstream1 tst-memstream2 tst-memstream3 tst-memstream4 \
-	tst-wmemstream1 tst-wmemstream2 tst-wmemstream3 tst-wmemstream4 \
-	tst-wmemstream5 bug-memstream1 bug-wmemstream1 \
-	tst-setvbuf1 tst-popen1 tst-fgetwc bug-wsetpos tst-fseek \
-	tst-fwrite-error tst-ftell-partial-wide tst-ftell-active-handler \
-	tst-ftell-append tst-fputws tst-bz22415 tst-fgetc-after-eof \
-	tst-sprintf-ub tst-sprintf-chk-ub tst-bz24051 tst-bz24153 \
-	tst-wfile-sync tst-bz28828 tst-getdelim
+tests = \
+  bug-fopena+ \
+  bug-fseek \
+  bug-ftell \
+  bug-memstream1 \
+  bug-mmap-fflush \
+  bug-rewind \
+  bug-rewind2 \
+  bug-ungetc \
+  bug-ungetc2 \
+  bug-ungetc3 \
+  bug-ungetc4 \
+  bug-ungetwc1 \
+  bug-ungetwc2 \
+  bug-wfflush \
+  bug-wmemstream1 \
+  bug-wsetpos \
+  test-fmemopen \
+  tst-atime \
+  tst-bz22415 \
+  tst-bz24051 \
+  tst-bz24153 \
+  tst-bz28828 \
+  tst-eof \
+  tst-ext \
+  tst-ext2 \
+  tst-fdopen-seek-failure \
+  tst-fgetc-after-eof \
+  tst-fgetwc \
+  tst-fgetws \
+  tst-fopenloc2 \
+  tst-fputws \
+  tst-freopen \
+  tst-fseek \
+  tst-ftell-active-handler \
+  tst-ftell-append \
+  tst-ftell-partial-wide \
+  tst-fwrite-error \
+  tst-getdelim \
+  tst-memstream1 \
+  tst-memstream2 \
+  tst-memstream3 \
+  tst-memstream4 \
+  tst-mmap-eofsync \
+  tst-mmap-fflushsync \
+  tst-mmap-offend \
+  tst-mmap-setvbuf \
+  tst-mmap2-eofsync \
+  tst-popen-fork \
+  tst-popen1 \
+  tst-setvbuf1 \
+  tst-sprintf-chk-ub \
+  tst-sprintf-ub \
+  tst-sscanf \
+  tst-swscanf \
+  tst-ungetwc1 \
+  tst-ungetwc2 \
+  tst-wfile-sync \
+  tst-widetext \
+  tst-wmemstream1 \
+  tst-wmemstream2 \
+  tst-wmemstream3 \
+  tst-wmemstream4 \
+  tst-wmemstream5 \
+  tst_getwc \
+  tst_putwc \
+  tst_swprintf \
+  tst_swscanf \
+  tst_wprintf \
+  tst_wprintf2 \
+  tst_wscanf \
+  # tests
+
+$(objpfx)tst-popen-fork: $(shared-thread-library)
 
 tests-internal = tst-vtables tst-vtables-interposed
 
@@ -196,6 +254,9 @@ tst_wprintf2-ARGS = "Some Text"
 
 test-fmemopen-ENV = MALLOC_TRACE=$(objpfx)test-fmemopen.mtrace \
 		    LD_PRELOAD=$(common-objpfx)/malloc/libc_malloc_debug.so
+tst-fdopen-seek-failure-ENV = \
+  MALLOC_TRACE=$(objpfx)tst-fdopen-seek-failure.mtrace \
+  LD_PRELOAD=$(common-objpfx)/malloc/libc_malloc_debug.so
 tst-fopenloc-ENV = MALLOC_TRACE=$(objpfx)tst-fopenloc.mtrace \
 		   LD_PRELOAD=$(common-objpfx)/malloc/libc_malloc_debug.so
 tst-bz22415-ENV = MALLOC_TRACE=$(objpfx)tst-bz22415.mtrace \
@@ -204,6 +265,7 @@ tst-bz24228-ENV = MALLOC_TRACE=$(objpfx)tst-bz24228.mtrace \
 		  LD_PRELOAD=$(common-objpfx)/malloc/libc_malloc_debug.so
 
 generated += test-fmemopen.mtrace test-fmemopen.check
+generated += tst-fdopen-seek-failure.mtrace tst-fdopen-seek-failure.check
 generated += tst-fopenloc.mtrace tst-fopenloc.check
 generated += tst-bz22415.mtrace tst-bz22415.check
 
@@ -212,6 +274,12 @@ aux	:= fileops genops stdfiles stdio strops
 ifeq ($(build-shared),yes)
 generated += tst-bz24228.mtrace tst-bz24228.check
 aux	+= oldfileops oldstdfiles
+tests += \
+  tst-stderr-compat \
+# tests
+tests-2.0 += \
+  tst-stderr-compat \
+# tests-2.0
 endif
 
 shared-only-routines = oldiofopen oldiofdopen oldiofclose oldfileops	\
@@ -220,8 +288,12 @@ shared-only-routines = oldiofopen oldiofdopen oldiofclose oldfileops	\
 		       oldiofsetpos64
 
 ifeq ($(run-built-tests),yes)
-tests-special += $(objpfx)test-freopen.out $(objpfx)test-fmemopen-mem.out \
-		 $(objpfx)tst-bz22415-mem.out
+tests-special += \
+  $(objpfx)test-fmemopen-mem.out \
+  $(objpfx)test-freopen.out \
+  $(objpfx)tst-bz22415-mem.out \
+  $(objpfx)tst-fdopen-seek-failure-mem.out \
+  # tests-special
 ifeq (yes,$(build-shared))
 # Run tst-fopenloc-cmp.out and tst-openloc-mem.out only if shared
 # library is enabled since they depend on tst-fopenloc.out.
@@ -229,16 +301,26 @@ tests-special += $(objpfx)tst-fopenloc-cmp.out $(objpfx)tst-fopenloc-mem.out \
 		 $(objpfx)tst-bz24228-mem.out
 endif
 
-tests += tst-cleanup-default tst-cleanup-default-static
+tests += \
+  tst-cleanup-default \
+  tst-cleanup-default-static \
+  # tests
 tests-static += tst-cleanup-default-static
 tests-special += $(objpfx)tst-cleanup-default-cmp.out $(objpfx)tst-cleanup-default-static-cmp.out
 LDFLAGS-tst-cleanup-default = -Wl,--gc-sections
 LDFLAGS-tst-cleanup-default-static = -Wl,--gc-sections
 
 ifeq ($(have-gnu-retain)$(have-z-start-stop-gc),yesyes)
-tests += tst-cleanup-start-stop-gc tst-cleanup-start-stop-gc-static \
-		tst-cleanup-nostart-stop-gc tst-cleanup-nostart-stop-gc-static
-tests-static += tst-cleanup-start-stop-gc-static tst-cleanup-nostart-stop-gc-static
+tests += \
+  tst-cleanup-nostart-stop-gc \
+  tst-cleanup-nostart-stop-gc-static \
+  tst-cleanup-start-stop-gc \
+  tst-cleanup-start-stop-gc-static \
+  # tests
+tests-static += \
+  tst-cleanup-nostart-stop-gc-static \
+  tst-cleanup-start-stop-gc-static \
+  # tests-static
 tests-special += $(objpfx)tst-cleanup-start-stop-gc-cmp.out \
 		$(objpfx)tst-cleanup-start-stop-gc-static-cmp.out \
 		$(objpfx)tst-cleanup-nostart-stop-gc-cmp.out \
@@ -299,6 +381,11 @@ $(objpfx)test-fmemopen-mem.out: $(objpfx)test-fmemopen.out
 	$(common-objpfx)malloc/mtrace $(objpfx)test-fmemopen.mtrace > $@; \
 	$(evaluate-test)
 
+$(objpfx)tst-fdopen-seek-failure-mem.out: $(objpfx)tst-fdopen-seek-failure.out
+	$(common-objpfx)malloc/mtrace \
+	  $(objpfx)tst-fdopen-seek-failure.mtrace > $@; \
+	$(evaluate-test)
+
 $(objpfx)tst-fopenloc-mem.out: $(objpfx)tst-fopenloc.out
 	$(common-objpfx)malloc/mtrace $(objpfx)tst-fopenloc.mtrace > $@; \
 	$(evaluate-test)
diff --git a/libio/bits/stdio2.h b/libio/bits/stdio2.h
index f9e8d37610..0dc4e87c65 100644
--- a/libio/bits/stdio2.h
+++ b/libio/bits/stdio2.h
@@ -195,24 +195,24 @@ __fortify_function __wur __fortified_attr_access (__write_only__, 1, 2)
 __nonnull ((3)) char *
 fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
 {
-  size_t sz = __glibc_objsize (__s);
-  if (__glibc_safe_or_unknown_len (__n, sizeof (char), sz))
+  size_t __sz = __glibc_objsize (__s);
+  if (__glibc_safe_or_unknown_len (__n, sizeof (char), __sz))
     return __fgets_alias (__s, __n, __stream);
-  if (__glibc_unsafe_len (__n, sizeof (char), sz))
-    return __fgets_chk_warn (__s, sz, __n, __stream);
-  return __fgets_chk (__s, sz, __n, __stream);
+  if (__glibc_unsafe_len (__n, sizeof (char), __sz))
+    return __fgets_chk_warn (__s, __sz, __n, __stream);
+  return __fgets_chk (__s, __sz, __n, __stream);
 }
 
 __fortify_function __wur __nonnull ((4)) size_t
 fread (void *__restrict __ptr, size_t __size, size_t __n,
        FILE *__restrict __stream)
 {
-  size_t sz = __glibc_objsize0 (__ptr);
-  if (__glibc_safe_or_unknown_len (__n, __size, sz))
+  size_t __sz = __glibc_objsize0 (__ptr);
+  if (__glibc_safe_or_unknown_len (__n, __size, __sz))
     return __fread_alias (__ptr, __size, __n, __stream);
-  if (__glibc_unsafe_len (__n, __size, sz))
-    return __fread_chk_warn (__ptr, sz, __size, __n, __stream);
-  return __fread_chk (__ptr, sz, __size, __n, __stream);
+  if (__glibc_unsafe_len (__n, __size, __sz))
+    return __fread_chk_warn (__ptr, __sz, __size, __n, __stream);
+  return __fread_chk (__ptr, __sz, __size, __n, __stream);
 }
 
 #ifdef __USE_GNU
@@ -220,12 +220,12 @@ __fortify_function __wur __fortified_attr_access (__write_only__, 1, 2)
 __nonnull ((3)) char *
 fgets_unlocked (char *__restrict __s, int __n, FILE *__restrict __stream)
 {
-  size_t sz = __glibc_objsize (__s);
-  if (__glibc_safe_or_unknown_len (__n, sizeof (char), sz))
+  size_t __sz = __glibc_objsize (__s);
+  if (__glibc_safe_or_unknown_len (__n, sizeof (char), __sz))
     return __fgets_unlocked_alias (__s, __n, __stream);
-  if (__glibc_unsafe_len (__n, sizeof (char), sz))
-    return __fgets_unlocked_chk_warn (__s, sz, __n, __stream);
-  return __fgets_unlocked_chk (__s, sz, __n, __stream);
+  if (__glibc_unsafe_len (__n, sizeof (char), __sz))
+    return __fgets_unlocked_chk_warn (__s, __sz, __n, __stream);
+  return __fgets_unlocked_chk (__s, __sz, __n, __stream);
 }
 #endif
 
@@ -235,8 +235,8 @@ __fortify_function __wur __nonnull ((4)) size_t
 fread_unlocked (void *__restrict __ptr, size_t __size, size_t __n,
 		FILE *__restrict __stream)
 {
-  size_t sz = __glibc_objsize0 (__ptr);
-  if (__glibc_safe_or_unknown_len (__n, __size, sz))
+  size_t __sz = __glibc_objsize0 (__ptr);
+  if (__glibc_safe_or_unknown_len (__n, __size, __sz))
     {
 # ifdef __USE_EXTERN_INLINES
       if (__builtin_constant_p (__size)
@@ -261,9 +261,9 @@ fread_unlocked (void *__restrict __ptr, size_t __size, size_t __n,
 # endif
       return __fread_unlocked_alias (__ptr, __size, __n, __stream);
     }
-  if (__glibc_unsafe_len (__n, __size, sz))
-    return __fread_unlocked_chk_warn (__ptr, sz, __size, __n, __stream);
-  return __fread_unlocked_chk (__ptr, sz, __size, __n, __stream);
+  if (__glibc_unsafe_len (__n, __size, __sz))
+    return __fread_unlocked_chk_warn (__ptr, __sz, __size, __n, __stream);
+  return __fread_unlocked_chk (__ptr, __sz, __size, __n, __stream);
 
 }
 #endif
diff --git a/libio/genops.c b/libio/genops.c
index bc45e60a09..02292beed9 100644
--- a/libio/genops.c
+++ b/libio/genops.c
@@ -635,7 +635,7 @@ _IO_sputbackc (FILE *fp, int c)
 {
   int result;
 
-  if (fp->_IO_read_ptr > fp->_IO_read_base
+  if (fp->_IO_read_ptr > fp->_IO_read_base && !_IO_in_backup (fp)
       && (unsigned char)fp->_IO_read_ptr[-1] == (unsigned char)c)
     {
       fp->_IO_read_ptr--;
@@ -789,6 +789,12 @@ _IO_unbuffer_all (void)
 	legacy = 1;
 #endif
 
+      /* Free up the backup area if it was ever allocated.  */
+      if (_IO_have_backup (fp))
+	_IO_free_backup_area (fp);
+      if (!legacy && fp->_mode > 0 && _IO_have_wbackup (fp))
+	_IO_free_wbackup_area (fp);
+
       if (! (fp->_flags & _IO_UNBUFFERED)
 	  /* Iff stream is un-orientated, it wasn't used. */
 	  && (legacy || fp->_mode != 0))
diff --git a/libio/iofdopen.c b/libio/iofdopen.c
index 2583fb8255..14fbc7b257 100644
--- a/libio/iofdopen.c
+++ b/libio/iofdopen.c
@@ -156,7 +156,11 @@ _IO_new_fdopen (int fd, const char *mode)
     {
       off64_t new_pos = _IO_SYSSEEK (&new_f->fp.file, 0, _IO_seek_end);
       if (new_pos == _IO_pos_BAD && errno != ESPIPE)
-	return NULL;
+	{
+	  _IO_un_link (&new_f->fp);
+	  free (new_f);
+	  return NULL;
+	}
     }
   return &new_f->fp.file;
 }
diff --git a/libio/iopopen.c b/libio/iopopen.c
index d01cb0648e..352513a291 100644
--- a/libio/iopopen.c
+++ b/libio/iopopen.c
@@ -57,6 +57,26 @@ unlock (void *not_used)
 }
 #endif
 
+/* These lock/unlock/resetlock functions are used during fork.  */
+
+void
+_IO_proc_file_chain_lock (void)
+{
+  _IO_lock_lock (proc_file_chain_lock);
+}
+
+void
+_IO_proc_file_chain_unlock (void)
+{
+  _IO_lock_unlock (proc_file_chain_lock);
+}
+
+void
+_IO_proc_file_chain_resetlock (void)
+{
+  _IO_lock_init (proc_file_chain_lock);
+}
+
 /* POSIX states popen shall ensure that any streams from previous popen()
    calls that remain open in the parent process should be closed in the new
    child process.
diff --git a/libio/libioP.h b/libio/libioP.h
index 1af287b19f..a83a411fdf 100644
--- a/libio/libioP.h
+++ b/libio/libioP.h
@@ -429,6 +429,12 @@ libc_hidden_proto (_IO_list_resetlock)
 extern void _IO_enable_locks (void) __THROW;
 libc_hidden_proto (_IO_enable_locks)
 
+/* Functions for operating popen's proc_file_chain_lock during fork.  */
+
+extern void _IO_proc_file_chain_lock (void) __THROW attribute_hidden;
+extern void _IO_proc_file_chain_unlock (void) __THROW attribute_hidden;
+extern void _IO_proc_file_chain_resetlock (void) __THROW attribute_hidden;
+
 /* Default jumptable functions. */
 
 extern int _IO_default_underflow (FILE *) __THROW;
@@ -577,8 +583,8 @@ extern void _IO_old_init (FILE *fp, int flags) __THROW;
        ((__fp)->_wide_data->_IO_write_base \
 	= (__fp)->_wide_data->_IO_write_ptr = __p, \
 	(__fp)->_wide_data->_IO_write_end = (__ep))
-#define _IO_have_backup(fp) ((fp)->_IO_save_base != NULL)
-#define _IO_have_wbackup(fp) ((fp)->_wide_data->_IO_save_base != NULL)
+#define _IO_have_backup(fp) ((fp)->_IO_backup_base != NULL)
+#define _IO_have_wbackup(fp) ((fp)->_wide_data->_IO_backup_base != NULL)
 #define _IO_in_backup(fp) ((fp)->_flags & _IO_IN_BACKUP)
 #define _IO_have_markers(fp) ((fp)->_markers != NULL)
 #define _IO_blen(fp) ((fp)->_IO_buf_end - (fp)->_IO_buf_base)
diff --git a/libio/tst-fdopen-seek-failure.c b/libio/tst-fdopen-seek-failure.c
new file mode 100644
index 0000000000..5c4d40ab34
--- /dev/null
+++ b/libio/tst-fdopen-seek-failure.c
@@ -0,0 +1,48 @@
+/* Test for fdopen memory leak without SEEK_END support (bug 31840).
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+
+#include <errno.h>
+#include <fcntl.h>
+#include <mcheck.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <support/check.h>
+#include <support/xunistd.h>
+#include <unistd.h>
+
+static int
+do_test (void)
+{
+  mtrace ();
+
+  /* This file is special because it is seekable, but only
+     with SEEK_SET, not SEEK_END.  */
+  int fd = open ("/proc/self/mem", O_RDWR);
+  if (fd < 0)
+    FAIL_UNSUPPORTED ("/proc/self/mem not found: %m");
+  FILE *fp = fdopen (fd, "a");
+  /* The fdopen call should have failed because it tried to use
+     SEEK_END.  */
+  TEST_VERIFY (fp == NULL);
+  TEST_COMPARE (errno, EINVAL);
+  xclose (fd);
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/libio/tst-popen-fork.c b/libio/tst-popen-fork.c
new file mode 100644
index 0000000000..1df30fc6c0
--- /dev/null
+++ b/libio/tst-popen-fork.c
@@ -0,0 +1,80 @@
+/* Test concurrent popen and fork.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <stdio.h>
+#include <stdatomic.h>
+#include <pthread.h>
+#include <unistd.h>
+#include <sys/wait.h>
+
+#include <support/check.h>
+#include <support/xthread.h>
+#include <support/xunistd.h>
+
+static void
+popen_and_pclose (void)
+{
+  FILE *f = popen ("true", "r");
+  TEST_VERIFY_EXIT (f != NULL);
+  pclose (f);
+  return;
+}
+
+static atomic_bool done = ATOMIC_VAR_INIT (0);
+
+static void *
+popen_and_pclose_forever (__attribute__ ((unused))
+                          void *arg)
+{
+  while (!atomic_load_explicit (&done, memory_order_acquire))
+    popen_and_pclose ();
+  return NULL;
+}
+
+static int
+do_test (void)
+{
+
+  /* Repeatedly call popen in a loop during the entire test.  */
+  pthread_t t = xpthread_create (NULL, popen_and_pclose_forever, NULL);
+
+  /* Repeatedly fork off and reap child processes one-by-one.
+     Each child calls popen once, then exits, leading to the possibility
+     that a child forks *during* our own popen call, thus inheriting any
+     intermediate popen state, possibly including lock state(s).  */
+  for (int i = 0; i < 100; i++)
+    {
+      int cpid = xfork ();
+
+      if (cpid == 0)
+        {
+          popen_and_pclose ();
+          _exit (0);
+        }
+      else
+        xwaitpid (cpid, NULL, 0);
+    }
+
+  /* Stop calling popen.  */
+  atomic_store_explicit (&done, 1, memory_order_release);
+  xpthread_join (t);
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/libio/tst-stderr-compat.c b/libio/tst-stderr-compat.c
new file mode 100644
index 0000000000..8221415cd4
--- /dev/null
+++ b/libio/tst-stderr-compat.c
@@ -0,0 +1,52 @@
+/* Test that fclose works on stderr from glibc 2.0.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <shlib-compat.h>
+
+#if TEST_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)
+# define _LIBC
+# define _IO_USE_OLD_IO_FILE
+# include <stdio.h>
+# include <support/check.h>
+
+extern FILE _IO_stderr_;
+compat_symbol_reference (libc, _IO_stderr_, _IO_stderr_, GLIBC_2_0);
+compat_symbol_reference (libc, fclose, fclose, GLIBC_2_0);
+
+__attribute__ ((weak, noclone, noinline))
+void
+do_fclose (FILE *fp)
+{
+  TEST_VERIFY_EXIT (fclose (fp) == 0);
+}
+
+static int
+do_test (void)
+{
+  do_fclose (&_IO_stderr_);
+  return 0;
+}
+#else
+static int
+do_test (void)
+{
+  return 0;
+}
+#endif
+
+#include <support/test-driver.c>
diff --git a/locale/lc-ctype.c b/locale/lc-ctype.c
index c77ec51cb8..70556acaf0 100644
--- a/locale/lc-ctype.c
+++ b/locale/lc-ctype.c
@@ -64,12 +64,9 @@ _nl_postload_ctype (void)
      in fact using the global locale.  */
   if (_NL_CURRENT_LOCALE == &_nl_global_locale)
     {
-      __libc_tsd_set (const uint16_t *, CTYPE_B,
-		      (void *) _nl_global_locale.__ctype_b);
-      __libc_tsd_set (const int32_t *, CTYPE_TOUPPER,
-		      (void *) _nl_global_locale.__ctype_toupper);
-      __libc_tsd_set (const int32_t *, CTYPE_TOLOWER,
-		      (void *) _nl_global_locale.__ctype_tolower);
+      __libc_tsd_CTYPE_B = _nl_global_locale.__ctype_b;
+      __libc_tsd_CTYPE_TOUPPER = _nl_global_locale.__ctype_toupper;
+      __libc_tsd_CTYPE_TOLOWER = _nl_global_locale.__ctype_tolower;
     }
 
 #include <shlib-compat.h>
diff --git a/locale/localeinfo.h b/locale/localeinfo.h
index ed698faef1..c3249d3715 100644
--- a/locale/localeinfo.h
+++ b/locale/localeinfo.h
@@ -236,10 +236,9 @@ extern struct __locale_struct _nl_global_locale attribute_hidden;
 
 /* This fetches the thread-local locale_t pointer, either one set with
    uselocale or &_nl_global_locale.  */
-#define _NL_CURRENT_LOCALE	(__libc_tsd_get (locale_t, LOCALE))
-#include <libc-tsd.h>
-__libc_tsd_define (extern, locale_t, LOCALE)
-
+#define _NL_CURRENT_LOCALE	__libc_tsd_LOCALE
+extern __thread locale_t __libc_tsd_LOCALE
+  attribute_hidden attribute_tls_model_ie;
 
 /* For static linking it is desireable to avoid always linking in the code
    and data for every category when we can tell at link time that they are
diff --git a/locale/uselocale.c b/locale/uselocale.c
index 8136caf61b..0b247a77d5 100644
--- a/locale/uselocale.c
+++ b/locale/uselocale.c
@@ -34,7 +34,7 @@ __uselocale (locale_t newloc)
     {
       const locale_t locobj
 	= newloc == LC_GLOBAL_LOCALE ? &_nl_global_locale : newloc;
-      __libc_tsd_set (locale_t, LOCALE, locobj);
+      __libc_tsd_LOCALE = locobj;
 
 #ifdef NL_CURRENT_INDIRECT
       /* Now we must update all the per-category thread-local variables to
@@ -62,11 +62,9 @@ __uselocale (locale_t newloc)
 #endif
 
       /* Update the special tsd cache of some locale data.  */
-      __libc_tsd_set (const uint16_t *, CTYPE_B, (void *) locobj->__ctype_b);
-      __libc_tsd_set (const int32_t *, CTYPE_TOLOWER,
-		      (void *) locobj->__ctype_tolower);
-      __libc_tsd_set (const int32_t *, CTYPE_TOUPPER,
-		      (void *) locobj->__ctype_toupper);
+      __libc_tsd_CTYPE_B = locobj->__ctype_b;
+      __libc_tsd_CTYPE_TOLOWER = locobj->__ctype_tolower;
+      __libc_tsd_CTYPE_TOUPPER = locobj->__ctype_toupper;
     }
 
   return oldloc == &_nl_global_locale ? LC_GLOBAL_LOCALE : oldloc;
diff --git a/locale/xlocale.c b/locale/xlocale.c
index f2b9d03303..d11c1cbf8c 100644
--- a/locale/xlocale.c
+++ b/locale/xlocale.c
@@ -18,18 +18,13 @@
 
 #include <locale.h>
 #include "localeinfo.h"
+#include <ctype.h>
 
 #define DEFINE_CATEGORY(category, category_name, items, a) \
 extern struct __locale_data _nl_C_##category;
 #include "categories.def"
 #undef	DEFINE_CATEGORY
 
-/* Defined in locale/C-ctype.c.  */
-extern const char _nl_C_LC_CTYPE_class[] attribute_hidden;
-extern const char _nl_C_LC_CTYPE_toupper[] attribute_hidden;
-extern const char _nl_C_LC_CTYPE_tolower[] attribute_hidden;
-
-
 const struct __locale_struct _nl_C_locobj attribute_hidden =
   {
     .__locales =
diff --git a/localedata/locales/ssy_ER b/localedata/locales/ssy_ER
index 05d94c9f10..43a16e0f54 100644
--- a/localedata/locales/ssy_ER
+++ b/localedata/locales/ssy_ER
@@ -106,7 +106,7 @@ country_ab3   "ERI"
 country_num   232
 country_car   "ER"
 % country_isbn  unknown, Need ISO 2108
-# https://en.wikipedia.org/wiki/Saho_language has "Saaho" as the endonym but CLDR has "Saho"
+% https://en.wikipedia.org/wiki/Saho_language has "Saaho" as the endonym but CLDR has "Saho"
 lang_name     "Saho"
 lang_ab       ""
 lang_term     "ssy"
diff --git a/localedata/tst-ctype.c b/localedata/tst-ctype.c
index 9de979a2d7..a23689719c 100644
--- a/localedata/tst-ctype.c
+++ b/localedata/tst-ctype.c
@@ -21,6 +21,8 @@
 #include <stdio.h>
 #include <string.h>
 
+#include <support/check.h>
+
 
 static const char lower[] = "abcdefghijklmnopqrstuvwxyz";
 static const char upper[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
@@ -53,19 +55,11 @@ static struct classes
 #define nclasses (sizeof (classes) / sizeof (classes[0]))
 
 
-#define FAIL(str, args...) \
-  {									      \
-    printf ("      " str "\n", ##args);					      \
-    ++errors;								      \
-  }
-
-
 static int
 do_test (void)
 {
   const char *cp;
   const char *cp2;
-  int errors = 0;
   char *inpline = NULL;
   size_t inplinelen = 0;
   char *resline = NULL;
@@ -394,11 +388,8 @@ punct = %04x  alnum = %04x\n",
 	    {
 	      if (((__ctype_b[(unsigned int) *inp] & classes[n].mask) != 0)
 		  != (*resp != '0'))
-		{
-		  printf ("    is%s('%c' = '\\x%02x') %s true\n", inpline,
-			  *inp, *inp, *resp == '1' ? "not" : "is");
-		  ++errors;
-		}
+		FAIL ("    is%s('%c' = '\\x%02x') %s true\n", inpline,
+		      *inp, *inp, *resp == '1' ? "not" : "is");
 	      ++inp;
 	      ++resp;
 	    }
@@ -408,11 +399,8 @@ punct = %04x  alnum = %04x\n",
 	  while (*inp != '\0')
 	    {
 	      if (tolower (*inp) != *resp)
-		{
-		  printf ("    tolower('%c' = '\\x%02x') != '%c'\n",
-			  *inp, *inp, *resp);
-		  ++errors;
-		}
+		FAIL ("    tolower('%c' = '\\x%02x') != '%c'\n",
+		      *inp, *inp, *resp);
 	      ++inp;
 	      ++resp;
 	    }
@@ -422,11 +410,8 @@ punct = %04x  alnum = %04x\n",
 	  while (*inp != '\0')
 	    {
 	      if (toupper (*inp) != *resp)
-		{
-		  printf ("    toupper('%c' = '\\x%02x') != '%c'\n",
-			  *inp, *inp, *resp);
-		  ++errors;
-		}
+		FAIL ("    toupper('%c' = '\\x%02x') != '%c'\n",
+		      *inp, *inp, *resp);
 	      ++inp;
 	      ++resp;
 	    }
@@ -436,14 +421,7 @@ punct = %04x  alnum = %04x\n",
     }
 
 
-  if (errors != 0)
-    {
-      printf ("  %d error%s for `%s' locale\n\n\n", errors,
-	      errors == 1 ? "" : "s", setlocale (LC_ALL, NULL));
-      return 1;
-    }
-
-  printf ("  No errors for `%s' locale\n\n\n", setlocale (LC_ALL, NULL));
+  printf ("Completed testing for `%s' locale\n\n\n", setlocale (LC_ALL, NULL));
   return 0;
 }
 
diff --git a/login/Makefile b/login/Makefile
index 1e22008a61..f91190e3dc 100644
--- a/login/Makefile
+++ b/login/Makefile
@@ -44,7 +44,9 @@ subdir-dirs = programs
 vpath %.c programs
 
 tests := tst-utmp tst-utmpx tst-grantpt tst-ptsname tst-getlogin tst-updwtmpx \
-  tst-pututxline-lockfail tst-pututxline-cache
+  tst-pututxline-lockfail tst-pututxline-cache tst-utmp-size tst-utmp-size-64
+
+CFLAGS-tst-utmp-size-64.c += -D_FILE_OFFSET_BITS=64 -D_TIME_BITS=64
 
 # Empty compatibility library for old binaries.
 extra-libs      := libutil
diff --git a/login/tst-utmp-size-64.c b/login/tst-utmp-size-64.c
new file mode 100644
index 0000000000..7a581a4c12
--- /dev/null
+++ b/login/tst-utmp-size-64.c
@@ -0,0 +1,2 @@
+/* The on-disk layout must not change in time64 mode.  */
+#include "tst-utmp-size.c"
diff --git a/login/tst-utmp-size.c b/login/tst-utmp-size.c
new file mode 100644
index 0000000000..1b7f7ff042
--- /dev/null
+++ b/login/tst-utmp-size.c
@@ -0,0 +1,33 @@
+/* Check expected sizes of struct utmp, struct utmpx, struct lastlog.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <utmp.h>
+#include <utmpx.h>
+#include <utmp-size.h>
+
+static int
+do_test (void)
+{
+  _Static_assert (sizeof (struct utmp) == UTMP_SIZE, "struct utmp size");
+  _Static_assert (sizeof (struct utmpx) == UTMP_SIZE, "struct utmpx size");
+  _Static_assert (sizeof (struct lastlog) == LASTLOG_SIZE,
+                  "struct lastlog size");
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/malloc/Makefile b/malloc/Makefile
index c83ade5f10..ef7d4fa866 100644
--- a/malloc/Makefile
+++ b/malloc/Makefile
@@ -24,60 +24,97 @@ include ../Makeconfig
 
 dist-headers := malloc.h
 headers := $(dist-headers) obstack.h mcheck.h
-tests := mallocbug tst-malloc tst-valloc tst-calloc tst-obstack \
-	 tst-malloc-check tst-mallocfork tst-trim1 \
-	 tst-malloc-usable tst-realloc tst-reallocarray tst-posix_memalign \
-	 tst-pvalloc tst-pvalloc-fortify tst-memalign tst-mallopt \
-	 tst-malloc-backtrace tst-malloc-thread-exit \
-	 tst-malloc-thread-fail tst-malloc-fork-deadlock \
-	 tst-mallocfork2 \
-	 tst-mallocfork3 \
-	 tst-interpose-nothread \
-	 tst-interpose-thread \
-	 tst-alloc_buffer \
-	 tst-free-errno \
-	 tst-malloc-tcache-leak \
-	 tst-malloc_info tst-mallinfo2 \
-	 tst-malloc-too-large \
-	 tst-malloc-stats-cancellation \
-	 tst-tcfree1 tst-tcfree2 tst-tcfree3 \
-	 tst-safe-linking \
-	 tst-mallocalign1 \
-	 tst-memalign-2 \
-	 tst-memalign-3 \
-	 tst-aligned-alloc
+tests := \
+  mallocbug \
+  tst-aligned-alloc \
+  tst-aligned-alloc-random \
+  tst-aligned-alloc-random-thread \
+  tst-aligned-alloc-random-thread-cross \
+  tst-alloc_buffer \
+  tst-calloc \
+  tst-free-errno \
+  tst-interpose-nothread \
+  tst-interpose-thread \
+  tst-malloc \
+  tst-malloc-alternate-path \
+  tst-malloc-backtrace \
+  tst-malloc-check \
+  tst-malloc-fork-deadlock \
+  tst-malloc-random \
+  tst-malloc-stats-cancellation \
+  tst-malloc-tcache-leak \
+  tst-malloc-thread-exit \
+  tst-malloc-thread-fail \
+  tst-malloc-too-large \
+  tst-malloc-usable \
+  tst-malloc_info tst-mallinfo2 \
+  tst-mallocalign1 \
+  tst-mallocfork \
+  tst-mallocfork2 \
+  tst-mallocfork3 \
+  tst-mallopt \
+  tst-memalign \
+  tst-memalign-2 \
+  tst-memalign-3 \
+  tst-obstack \
+  tst-posix_memalign \
+  tst-pvalloc \
+  tst-pvalloc-fortify \
+  tst-realloc \
+  tst-reallocarray \
+  tst-safe-linking \
+  tst-tcfree1 tst-tcfree2 tst-tcfree3 \
+  tst-trim1 \
+  tst-valloc \
+# tests
 
 tests-static := \
-	 tst-interpose-static-nothread \
-	 tst-interpose-static-thread \
-	 tst-aligned-alloc-static
+  tst-aligned-alloc-static \
+  tst-interpose-static-nothread \
+  tst-interpose-static-thread \
+# tests-static
 
 # Test for the malloc_set_state symbol removed in glibc 2.25.
 ifeq ($(have-GLIBC_2.23)$(build-shared),yesyes)
-tests += tst-mallocstate tst-compathooks-off tst-compathooks-on
+tests += \
+  tst-compathooks-off \
+  tst-compathooks-on \
+  tst-mallocstate \
+# tests
 endif
 
 tests-internal := tst-scratch_buffer
 
 # The dynarray framework is only available inside glibc.
 tests-internal += \
-	 tst-dynarray \
-	 tst-dynarray-fail \
-	 tst-dynarray-at-fail \
+  tst-dynarray \
+  tst-dynarray-at-fail \
+  tst-dynarray-fail \
+# tests-internal
 
-tests += tst-malloc-usable-tunables tst-mxfast
+tests += \
+  tst-malloc-usable-tunables \
+  tst-mxfast \
+# tests
 
 tests += $(tests-static)
 test-srcs = tst-mtrace
 
 # These tests either are run with MALLOC_CHECK_=3 by default or do not work
 # with MALLOC_CHECK_=3 because they expect a specific failure.
-tests-exclude-malloc-check = tst-malloc-check tst-malloc-usable \
-	tst-mxfast tst-safe-linking \
-	tst-compathooks-off tst-compathooks-on tst-memalign-2 tst-memalign-3 \
-	tst-mallocfork2 \
-	tst-mallocfork3 \
-	tst-malloc-tcache-leak
+tests-exclude-malloc-check = \
+  tst-compathooks-off \
+  tst-compathooks-on \
+  tst-malloc-check \
+  tst-malloc-tcache-leak \
+  tst-malloc-usable \
+  tst-mallocfork2 \
+  tst-mallocfork3 \
+  tst-memalign-2 \
+  tst-memalign-3 \
+  tst-mxfast \
+  tst-safe-linking \
+# tests-exclude-malloc-check
 
 # Run all tests with MALLOC_CHECK_=3
 tests-malloc-check = $(filter-out $(tests-exclude-malloc-check) \
@@ -87,18 +124,19 @@ tests-malloc-check = $(filter-out $(tests-exclude-malloc-check) \
 # the Transparent Huge Pages support (1) or automatic huge page support (2).
 # We need exclude some tests that define the ENV vars.
 tests-exclude-hugetlb1 = \
-	tst-compathooks-off \
-	tst-compathooks-on \
-	tst-interpose-nothread \
-	tst-interpose-thread \
-	tst-interpose-static-nothread \
-	tst-interpose-static-thread \
-	tst-malloc-usable \
-	tst-malloc-usable-tunables \
-	tst-mallocstate \
-	tst-malloc-tcache-leak \
-	tst-mallocfork2 \
-	tst-mallocfork3
+  tst-compathooks-off \
+  tst-compathooks-on \
+  tst-interpose-nothread \
+  tst-interpose-static-nothread \
+  tst-interpose-static-thread \
+  tst-interpose-thread \
+  tst-malloc-tcache-leak \
+  tst-malloc-usable \
+  tst-malloc-usable-tunables \
+  tst-mallocfork2 \
+  tst-mallocfork3 \
+  tst-mallocstate \
+# tests-exclude-hugetlb1
 # The tst-free-errno relies on the used malloc page size to mmap an
 # overlapping region.
 tests-exclude-hugetlb2 = \
@@ -114,22 +152,27 @@ ifeq ($(have-GLIBC_2.23)$(build-shared),yesyes)
 # Tests that don't play well with mcheck.  They are either bugs in mcheck or
 # the tests expect specific internal behavior that is changed due to linking to
 # libmcheck.a.
-tests-exclude-mcheck = tst-mallocstate \
-	tst-safe-linking \
-	tst-malloc-backtrace \
-	tst-malloc-fork-deadlock \
-	tst-malloc-stats-cancellation \
-	tst-malloc-tcache-leak \
-	tst-malloc-thread-exit \
-	tst-malloc-thread-fail \
-	tst-malloc-usable-tunables \
-	tst-malloc_info \
-	tst-compathooks-off tst-compathooks-on \
-	tst-memalign-2 \
-	tst-memalign-3 \
-	tst-mxfast \
-	tst-mallocfork2 \
-	tst-mallocfork3
+tests-exclude-mcheck = \
+  tst-aligned-alloc-random-thread \
+  tst-aligned-alloc-random-thread-cross \
+  tst-compathooks-off \
+  tst-compathooks-on \
+  tst-malloc-backtrace \
+  tst-malloc-fork-deadlock \
+  tst-malloc-stats-cancellation \
+  tst-malloc-tcache-leak \
+  tst-malloc-thread-exit \
+  tst-malloc-thread-fail \
+  tst-malloc-usable-tunables \
+  tst-malloc_info \
+  tst-mallocfork2 \
+  tst-mallocfork3 \
+  tst-mallocstate \
+  tst-memalign-2 \
+  tst-memalign-3 \
+  tst-mxfast \
+  tst-safe-linking \
+# tests-exclude-mcheck
 
 tests-mcheck = $(filter-out $(tests-exclude-mcheck) $(tests-static), $(tests))
 endif
@@ -157,12 +200,18 @@ extra-libs-others = $(extra-libs)
 
 # Helper objects for some tests.
 extra-test-objs += \
+  tst-aligned_alloc-lib.so \
   tst-interpose-aux-nothread.o \
   tst-interpose-aux-thread.o \
+# extra-test-objs
 
 test-extras = \
   tst-interpose-aux-nothread \
   tst-interpose-aux-thread \
+# test-extras
+
+modules-names = \
+  tst-aligned_alloc-lib
 
 libmemusage-routines = memusage
 libmemusage-inhibit-o = $(filter-out .os,$(object-suffixes))
@@ -370,3 +419,13 @@ tst-mallocstate-malloc-check-ENV = LD_PRELOAD=$(objpfx)libc_malloc_debug.so
 # libc_malloc_debug.so.
 $(objpfx)tst-mallocstate: $(objpfx)libc_malloc_debug.so
 $(objpfx)tst-mallocstate-malloc-check: $(objpfx)libc_malloc_debug.so
+
+$(objpfx)tst-aligned-alloc-random.out: $(objpfx)tst-aligned_alloc-lib.so
+$(objpfx)tst-aligned-alloc-random-thread.out: $(objpfx)tst-aligned_alloc-lib.so
+$(objpfx)tst-aligned-alloc-random-thread-cross.out: $(objpfx)tst-aligned_alloc-lib.so
+$(objpfx)tst-malloc-random.out: $(objpfx)tst-aligned_alloc-lib.so
+
+tst-aligned-alloc-random-ENV = LD_PRELOAD=$(objpfx)tst-aligned_alloc-lib.so
+tst-aligned-alloc-random-thread-ENV = LD_PRELOAD=$(objpfx)tst-aligned_alloc-lib.so
+tst-aligned-alloc-random-thread-cross-ENV = LD_PRELOAD=$(objpfx)tst-aligned_alloc-lib.so
+tst-malloc-random-ENV = LD_PRELOAD=$(objpfx)tst-aligned_alloc-lib.so
diff --git a/malloc/memusage.c b/malloc/memusage.c
index e8ae80dc74..f80225b95a 100644
--- a/malloc/memusage.c
+++ b/malloc/memusage.c
@@ -172,7 +172,7 @@ update_data (struct header *result, size_t len, size_t old_len)
     start_sp = __thread_stack_pointer ();
 
   uintptr_t sp = __thread_stack_pointer ();
-#ifdef _STACK_GROWS_UP
+#if _STACK_GROWS_UP
   /* This can happen in threads where we didn't catch the thread's
      stack early enough.  */
   if (__glibc_unlikely (sp < start_sp))
diff --git a/malloc/tst-aligned-alloc-random-thread-cross.c b/malloc/tst-aligned-alloc-random-thread-cross.c
new file mode 100644
index 0000000000..360ecc56ee
--- /dev/null
+++ b/malloc/tst-aligned-alloc-random-thread-cross.c
@@ -0,0 +1,19 @@
+/* multi-threaded memory allocation and cross-thread deallocation test.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, see <https://www.gnu.org/licenses/>.  */
+#define CROSS_THREAD_DEALLOC
+#include "tst-aligned-alloc-random-thread.c"
diff --git a/malloc/tst-aligned-alloc-random-thread.c b/malloc/tst-aligned-alloc-random-thread.c
new file mode 100644
index 0000000000..e95f79250a
--- /dev/null
+++ b/malloc/tst-aligned-alloc-random-thread.c
@@ -0,0 +1,145 @@
+/* multi-threaded memory allocation/deallocation test.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, see <https://www.gnu.org/licenses/>.  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <support/check.h>
+#include <support/support.h>
+#include <support/xthread.h>
+#include <support/test-driver.h>
+#include <sys/sysinfo.h>
+#include <unistd.h>
+
+#ifndef ITERATIONS
+#  define ITERATIONS 16
+#endif
+
+#ifndef NUM_THREADS
+#  define NUM_THREADS 8
+#endif
+
+#ifndef NUM_ALLOCATIONS
+#  define NUM_ALLOCATIONS 2048
+#endif
+
+static pthread_barrier_t barrier;
+
+__thread unsigned int seed;
+
+typedef struct
+{
+  int id;
+  pthread_t thread;
+} thread;
+
+thread threads[NUM_THREADS];
+
+void *allocations[NUM_THREADS][NUM_ALLOCATIONS];
+
+void
+run_thread_dealloc (int id)
+{
+  for (int i = 0; i < NUM_ALLOCATIONS; i++)
+    {
+      free (allocations[id][i]);
+      allocations[id][i] = NULL;
+    }
+}
+
+void
+run_thread_alloc (int id)
+{
+  size_t msb, size;
+  for (int i = 0; i < NUM_ALLOCATIONS; i++)
+    {
+      msb = 1 << rand_r (&seed) % 16;
+      size = msb + rand_r (&seed) % msb;
+      allocations[id][i] = malloc (size);
+      TEST_VERIFY_EXIT (allocations[id][i] != NULL);
+    }
+}
+
+void *
+run_allocations (void *arg)
+{
+  int id = *((int *) arg);
+  seed = time (NULL) + id;
+
+  /* Stage 1: First half o the threads allocating memory and the second
+   * half waiting for them to finish
+   */
+  if (id < NUM_THREADS / 2)
+    run_thread_alloc (id);
+
+  xpthread_barrier_wait (&barrier);
+
+  /* Stage 2: Half of the threads allocationg memory and the other
+   * half deallocating:
+   * - In the non cross-thread dealloc scenario the first half will be
+   *   deallocating the memory allocated by themselves in stage 1 and the
+   *   second half will be allocating memory.
+   * - In the cross-thread dealloc scenario the first half will continue
+   *   to allocate memory and the second half will deallocate the memory
+   *   allocated by the first half in stage 1.
+   */
+  if (id < NUM_THREADS / 2)
+#ifndef CROSS_THREAD_DEALLOC
+    run_thread_dealloc (id);
+#else
+    run_thread_alloc (id + NUM_THREADS / 2);
+#endif
+  else
+#ifndef CROSS_THREAD_DEALLOC
+    run_thread_alloc (id);
+#else
+    run_thread_dealloc (id - NUM_THREADS / 2);
+#endif
+
+  xpthread_barrier_wait (&barrier);
+
+  // Stage 3: Second half of the threads deallocating and the first half
+  // waiting for them to finish.
+  if (id >= NUM_THREADS / 2)
+    run_thread_dealloc (id);
+
+  return NULL;
+}
+
+static int
+do_test (void)
+{
+  xpthread_barrier_init (&barrier, NULL, NUM_THREADS);
+
+  for (int i = 0; i < ITERATIONS; i++)
+    {
+      for (int t = 0; t < NUM_THREADS; t++)
+	{
+	  threads[t].id = t;
+	  threads[t].thread
+	      = xpthread_create (NULL, run_allocations, &threads[t].id);
+	}
+
+      for (int t = 0; t < NUM_THREADS; t++)
+	xpthread_join (threads[t].thread);
+    }
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/malloc/tst-aligned-alloc-random.c b/malloc/tst-aligned-alloc-random.c
new file mode 100644
index 0000000000..f2825ce38f
--- /dev/null
+++ b/malloc/tst-aligned-alloc-random.c
@@ -0,0 +1,43 @@
+/* Test for randomized malloc that calls aligned_alloc
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <stdlib.h>
+#include <support/check.h>
+#include <time.h>
+
+static int
+do_test (void)
+{
+  void *p1;
+  int i;
+
+  srandom (time (NULL));
+
+  for (i = 0; i < 1024; i++)
+  {
+    size_t size = random () & 0xffff;
+
+    p1 = malloc (size);
+    TEST_VERIFY (p1 != NULL);
+  }
+
+  return 0;
+}
+
+
+#include <support/test-driver.c>
diff --git a/malloc/tst-aligned-alloc.c b/malloc/tst-aligned-alloc.c
index 91167d1392..b0f05a8fec 100644
--- a/malloc/tst-aligned-alloc.c
+++ b/malloc/tst-aligned-alloc.c
@@ -25,6 +25,8 @@
 #include <libc-diag.h>
 #include <support/check.h>
 
+#include "tst-malloc-aux.h"
+
 static int
 do_test (void)
 {
diff --git a/malloc/tst-aligned_alloc-lib.c b/malloc/tst-aligned_alloc-lib.c
new file mode 100644
index 0000000000..9ef1f839c1
--- /dev/null
+++ b/malloc/tst-aligned_alloc-lib.c
@@ -0,0 +1,73 @@
+/* Module used for improved aligned_alloc testing.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   Copyright The GNU Toolchain Authors.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, see <https://www.gnu.org/licenses/>.  */
+
+#include <libc-symbols.h>
+#include <stdlib.h>
+#include <time.h>
+
+extern void *__libc_malloc (size_t size);
+extern void *__libc_calloc (size_t n, size_t size);
+
+__thread unsigned int seed = 0;
+
+int aligned_alloc_count = 0;
+int libc_malloc_count = 0;
+int libc_calloc_count = 0;
+
+static void *
+get_random_alloc (size_t size)
+{
+  void *retval;
+  size_t align;
+  struct timespec tp;
+
+  if (seed == 0)
+    {
+      clock_gettime (CLOCK_REALTIME, &tp);
+      seed = tp.tv_nsec;
+    }
+
+  switch (rand_r (&seed) % 3)
+    {
+    case 1:
+      /* Get a random alignment value.  Biased towards the smaller
+       * values up to 16384. Must be a power of 2. */
+      align = 1 << rand_r (&seed) % 15;
+      retval = aligned_alloc (align, size);
+      aligned_alloc_count++;
+      break;
+    case 2:
+      retval = __libc_calloc (1, size);
+      libc_calloc_count++;
+      break;
+    default:
+      retval = __libc_malloc (size);
+      libc_malloc_count++;
+      break;
+    }
+
+  return retval;
+}
+
+void *
+__random_malloc (size_t size)
+{
+  return get_random_alloc (size);
+}
+strong_alias (__random_malloc, malloc)
diff --git a/malloc/tst-calloc.c b/malloc/tst-calloc.c
index 01f17f9e65..5a8c7ab121 100644
--- a/malloc/tst-calloc.c
+++ b/malloc/tst-calloc.c
@@ -23,6 +23,7 @@
 #include <stdio.h>
 #include <libc-diag.h>
 
+#include "tst-malloc-aux.h"
 
 /* Number of samples per size.  */
 #define N 50000
@@ -94,16 +95,19 @@ random_test (void)
 static void
 null_test (void)
 {
+  /* Obscure allocation size from the compiler.  */
+  volatile size_t max_size = UINT_MAX;
+  volatile size_t zero_size = 0;
   /* If the size is 0 the result is implementation defined.  Just make
      sure the program doesn't crash.  The result of calloc is
      deliberately ignored, so do not warn about that.  */
   DIAG_PUSH_NEEDS_COMMENT;
   DIAG_IGNORE_NEEDS_COMMENT (10, "-Wunused-result");
   calloc (0, 0);
-  calloc (0, UINT_MAX);
-  calloc (UINT_MAX, 0);
-  calloc (0, ~((size_t) 0));
-  calloc (~((size_t) 0), 0);
+  calloc (0, max_size);
+  calloc (max_size, 0);
+  calloc (0, ~((size_t) zero_size));
+  calloc (~((size_t) zero_size), 0);
   DIAG_POP_NEEDS_COMMENT;
 }
 
diff --git a/malloc/tst-compathooks-off.c b/malloc/tst-compathooks-off.c
index d0106f3fb7..4cce6e5a80 100644
--- a/malloc/tst-compathooks-off.c
+++ b/malloc/tst-compathooks-off.c
@@ -25,6 +25,8 @@
 #include <support/check.h>
 #include <support/support.h>
 
+#include "tst-malloc-aux.h"
+
 extern void (*volatile __free_hook) (void *, const void *);
 extern void *(*volatile __malloc_hook)(size_t, const void *);
 extern void *(*volatile __realloc_hook)(void *, size_t, const void *);
diff --git a/malloc/tst-mallinfo2.c b/malloc/tst-mallinfo2.c
index 2c02f5f700..f072b9f24b 100644
--- a/malloc/tst-mallinfo2.c
+++ b/malloc/tst-mallinfo2.c
@@ -23,6 +23,8 @@
 #include <stdlib.h>
 #include <support/check.h>
 
+#include "tst-malloc-aux.h"
+
 /* This is not specifically needed for the test, but (1) does
    something to the data so gcc doesn't optimize it away, and (2) may
    help when developing future tests.  */
diff --git a/malloc/tst-malloc-alternate-path.c b/malloc/tst-malloc-alternate-path.c
new file mode 100644
index 0000000000..43ae916815
--- /dev/null
+++ b/malloc/tst-malloc-alternate-path.c
@@ -0,0 +1,72 @@
+/* Test that malloc uses mmap when sbrk or brk fails.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* This test sets up an obstruction to ensure that brk/sbrk fails to
+   grow the heap, then verifies that malloc uses mmap for allocations
+   instead.  */
+
+#include <unistd.h>
+#include <sys/mman.h>
+#include <stdlib.h>
+#include <libc-pointer-arith.h>
+#include <support/check.h>
+#include <stddef.h>
+#include <stdalign.h>
+
+#define LARGE_SIZE (10 * (1 << 20)) // 10 MB
+static long page_size;
+
+static int
+do_test (void)
+{
+  /* Get current program break.  */
+  void *current_brk = sbrk (0);
+
+  page_size = sysconf (_SC_PAGESIZE);
+
+  /* Round up to the next page boundary.  */
+  void *next_page_boundary = PTR_ALIGN_UP (current_brk, page_size);
+
+  /* Place a mapping using mmap at the next page boundary.  */
+  void *obstruction_addr
+  = mmap (next_page_boundary, page_size, PROT_READ,
+    MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
+
+  /* Check if memory obstruction is set up correctly.  */
+  TEST_VERIFY_EXIT (obstruction_addr == next_page_boundary);
+
+  /* Try to extend the heap beyond the obstruction using sbrk */
+  int *ptr = sbrk (page_size);
+  TEST_VERIFY_EXIT (ptr == (void *) -1);
+
+  /* Attempt multiple small allocations using malloc.  */
+  for (size_t i = 0; i < page_size / alignof (max_align_t); i++)
+    {
+      TEST_VERIFY (malloc (alignof (max_align_t)));
+    }
+
+  /* Attempt to allocate a large block of memory using malloc.  */
+  TEST_VERIFY_EXIT (malloc (LARGE_SIZE) != NULL);
+
+  /* Check if malloc changed current program break.  */
+  TEST_VERIFY_EXIT (current_brk == sbrk (0));
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/malloc/tst-malloc-aux.h b/malloc/tst-malloc-aux.h
new file mode 100644
index 0000000000..3e1b61ce34
--- /dev/null
+++ b/malloc/tst-malloc-aux.h
@@ -0,0 +1,56 @@
+/* Wrappers for malloc-like functions to allow testing the implementation
+   without optimization.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef TST_MALLOC_AUX_H
+#define TST_MALLOC_AUX_H
+
+#include <stddef.h>
+#include <stdlib.h>
+#include <malloc.h>
+
+static __typeof (aligned_alloc) * volatile aligned_alloc_indirect
+  = aligned_alloc;
+static __typeof (calloc) * volatile calloc_indirect = calloc;
+static __typeof (malloc) * volatile malloc_indirect = malloc;
+static __typeof (memalign) * volatile memalign_indirect = memalign;
+static __typeof (posix_memalign) * volatile posix_memalign_indirect
+  = posix_memalign;
+static __typeof (pvalloc) * volatile pvalloc_indirect = pvalloc;
+static __typeof (realloc) * volatile realloc_indirect = realloc;
+static __typeof (valloc) * volatile valloc_indirect = valloc;
+
+#undef aligned_alloc
+#undef calloc
+#undef malloc
+#undef memalign
+#undef posix_memalign
+#undef pvalloc
+#undef realloc
+#undef valloc
+
+#define aligned_alloc aligned_alloc_indirect
+#define calloc calloc_indirect
+#define malloc malloc_indirect
+#define memalign memalign_indirect
+#define posix_memalign posix_memalign_indirect
+#define pvalloc pvalloc_indirect
+#define realloc realloc_indirect
+#define valloc valloc_indirect
+
+#endif /* TST_MALLOC_AUX_H */
diff --git a/malloc/tst-malloc-backtrace.c b/malloc/tst-malloc-backtrace.c
index c7b1d65e5c..65fa91f6fd 100644
--- a/malloc/tst-malloc-backtrace.c
+++ b/malloc/tst-malloc-backtrace.c
@@ -22,6 +22,8 @@
 #include <support/support.h>
 #include <libc-diag.h>
 
+#include "tst-malloc-aux.h"
+
 #define SIZE 4096
 
 /* Wrap free with a function to prevent gcc from optimizing it out.  */
diff --git a/malloc/tst-malloc-check.c b/malloc/tst-malloc-check.c
index fde8863ad7..cc88bff3b3 100644
--- a/malloc/tst-malloc-check.c
+++ b/malloc/tst-malloc-check.c
@@ -20,6 +20,8 @@
 #include <stdlib.h>
 #include <libc-diag.h>
 
+#include "tst-malloc-aux.h"
+
 static int errors = 0;
 
 static void
diff --git a/malloc/tst-malloc-random.c b/malloc/tst-malloc-random.c
new file mode 100644
index 0000000000..762b70c918
--- /dev/null
+++ b/malloc/tst-malloc-random.c
@@ -0,0 +1,20 @@
+/* Test malloc with random calls to aligned_alloc and calloc.
+
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "tst-malloc.c"
diff --git a/malloc/tst-malloc-too-large.c b/malloc/tst-malloc-too-large.c
index 8e9e0d5fa2..2b91377e54 100644
--- a/malloc/tst-malloc-too-large.c
+++ b/malloc/tst-malloc-too-large.c
@@ -43,6 +43,7 @@
 #include <unistd.h>
 #include <sys/param.h>
 
+#include "tst-malloc-aux.h"
 
 /* This function prepares for each 'too-large memory allocation' test by
    performing a small successful malloc/free and resetting errno prior to
diff --git a/malloc/tst-malloc.c b/malloc/tst-malloc.c
index a7491d3d00..68af399022 100644
--- a/malloc/tst-malloc.c
+++ b/malloc/tst-malloc.c
@@ -18,7 +18,11 @@
 #include <errno.h>
 #include <malloc.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <libc-diag.h>
+#include <time.h>
+
+#include "tst-malloc-aux.h"
 
 static int errors = 0;
 
@@ -35,6 +39,8 @@ do_test (void)
   void *p, *q;
   int save;
 
+  srandom (time (NULL));
+
   errno = 0;
 
   DIAG_PUSH_NEEDS_COMMENT;
diff --git a/malloc/tst-memalign.c b/malloc/tst-memalign.c
index 563f6413d2..ac9770d3f9 100644
--- a/malloc/tst-memalign.c
+++ b/malloc/tst-memalign.c
@@ -23,6 +23,8 @@
 #include <unistd.h>
 #include <libc-diag.h>
 
+#include "tst-malloc-aux.h"
+
 static int errors = 0;
 
 static void
diff --git a/malloc/tst-realloc.c b/malloc/tst-realloc.c
index f50499ecb1..74a28fb45e 100644
--- a/malloc/tst-realloc.c
+++ b/malloc/tst-realloc.c
@@ -23,6 +23,8 @@
 #include <libc-diag.h>
 #include <support/check.h>
 
+#include "tst-malloc-aux.h"
+
 static int
 do_test (void)
 {
diff --git a/malloc/tst-safe-linking.c b/malloc/tst-safe-linking.c
index 01dd07004d..63a7e2bc8e 100644
--- a/malloc/tst-safe-linking.c
+++ b/malloc/tst-safe-linking.c
@@ -26,6 +26,8 @@
 #include <support/capture_subprocess.h>
 #include <support/check.h>
 
+#include "tst-malloc-aux.h"
+
 /* Run CALLBACK and check that the data on standard error equals
    EXPECTED.  */
 static void
diff --git a/malloc/tst-valloc.c b/malloc/tst-valloc.c
index 9bab8c6470..0243d3dfd4 100644
--- a/malloc/tst-valloc.c
+++ b/malloc/tst-valloc.c
@@ -23,6 +23,8 @@
 #include <unistd.h>
 #include <libc-diag.h>
 
+#include "tst-malloc-aux.h"
+
 static int errors = 0;
 
 static void
diff --git a/manual/creature.texi b/manual/creature.texi
index fa5dd9d6ad..8d19e9dd73 100644
--- a/manual/creature.texi
+++ b/manual/creature.texi
@@ -192,6 +192,12 @@ Linux kernel version on which the system is running. For Linux kernel
 version above @b{5.1} syscalls supporting 64-bit time are used. Otherwise,
 a fallback code is used with legacy (i.e. 32-bit) syscalls.
 
+On such platforms, @theglibc{} will also define @code{__USE_TIME64_REDIRECTS}
+to indicate whether the declarations are expanded to different ones
+(either by redefiniding the symbol name or using symbol aliais).
+For instance, if the symbol @code{clock_gettime} expands to
+@code{__glock_gettime64}.
+
 @item
 If @code{_TIME_BITS} is defined to be 32, @code{time_t} is defined to
 be a 32-bit integer where that is supported.  This is not recommended,
diff --git a/manual/llio.texi b/manual/llio.texi
index 0b61d491f5..a65230d612 100644
--- a/manual/llio.texi
+++ b/manual/llio.texi
@@ -1339,6 +1339,10 @@ will fail and set @code{errno} to @code{EAGAIN} if the operation would block.
 
 @item RWF_APPEND
 Per-IO synchronization as if the file was opened with @code{O_APPEND} flag.
+
+@item RWF_NOAPPEND
+This flag allows an offset to be honored, even if the file was opened with
+@code{O_APPEND} flag.
 @end vtable
 
 When the source file is compiled with @code{_FILE_OFFSET_BITS == 64} the
@@ -1777,7 +1781,7 @@ There is no existing mapping in at least part of the given region.
 
 @end deftypefun
 
-@deftypefun {void *} mremap (void *@var{address}, size_t @var{length}, size_t @var{new_length}, int @var{flag})
+@deftypefun {void *} mremap (void *@var{address}, size_t @var{length}, size_t @var{new_length}, int @var{flag}, ... /* void *@var{new_address} */)
 @standards{GNU, sys/mman.h}
 @safety{@prelim{}@mtsafe{}@assafe{}@acsafe{}}
 
@@ -1786,12 +1790,40 @@ area. @var{address} and @var{length} must cover a region entirely mapped
 in the same @code{mmap} statement.  A new mapping with the same
 characteristics will be returned with the length @var{new_length}.
 
-One option is possible, @code{MREMAP_MAYMOVE}.  If it is given in
-@var{flags}, the system may remove the existing mapping and create a new
-one of the desired length in another location.
+Possible flags are
+
+@table @code
+
+@item MREMAP_MAYMOVE
+If it is given in @var{flags}, the system may remove the existing mapping
+and create a new one of the desired length in another location.
+
+@item MREMAP_FIXED
+If it is given in @var{flags}, @code{mremap} accepts a fifth argument,
+@code{void *new_address}, which specifies a page-aligned address to
+which the mapping must be moved.  Any previous mapping at the address
+range specified by @var{new_address} and @var{new_size} is unmapped.
+
+@code{MREMAP_FIXED} must be used together with @code{MREMAP_MAYMOVE}.
+
+@item MREMAP_DONTUNMAP
+If it is given in @var{flags}, @code{mremap} accepts a fifth argument,
+@code{void *new_address}, which specifies a page-aligned address.  Any
+previous mapping at the address range specified by @var{new_address} and
+@var{new_size} is unmapped.  If @var{new_address} is @code{NULL}, the
+kernel chooses the page-aligned address at which to create the mapping.
+Otherwise, the kernel takes it as a hint about where to place the mapping.
+The mapping at the address range specified by @var{old_address} and
+@var{old_size} isn't unmapped.
+
+@code{MREMAP_DONTUNMAP} must be used together with @code{MREMAP_MAYMOVE}.
+@var{old_size} must be the same as @var{new_size}.  This flag bit is
+Linux-specific.
+
+@end table
 
-The address of the resulting mapping is returned, or @math{-1}.  Possible
-error codes include:
+The address of the resulting mapping is returned, or @code{MAP_FAILED}.
+Possible error codes include:
 
 @table @code
 
@@ -1800,7 +1832,7 @@ There is no existing mapping in at least part of the original region, or
 the region covers two or more distinct mappings.
 
 @item EINVAL
-The address given is misaligned or inappropriate.
+Any arguments are inappropriate, including unknown @var{flags} values.
 
 @item EAGAIN
 The region has pages locked, and if extended it would exceed the
diff --git a/manual/maint.texi b/manual/maint.texi
index 89da704f45..04faa222e2 100644
--- a/manual/maint.texi
+++ b/manual/maint.texi
@@ -491,6 +491,10 @@ derived as in the dual-time configuration case, and which expands to
 the symbol's name.  For instance, the macro @code{__clock_gettime64}
 expands to @code{clock_gettime}.
 
+When @code{__TIMESIZE} is set to 64, @theglibc{} will also define
+the@code{__USE_TIME_BITS64} macro.  It is used by the Linux kernel ABI
+to set the expected @code{time_t} size used on some syscalls.
+
 These macros are purely internal to @theglibc{} and exist only so that
 a single definition of the 64-bit time functions can be used on both
 single-time and dual-time configurations, and so that glibc code can
diff --git a/manual/resource.texi b/manual/resource.texi
index 37462abc9e..743cc94396 100644
--- a/manual/resource.texi
+++ b/manual/resource.texi
@@ -192,8 +192,8 @@ If the sources are compiled with @code{_FILE_OFFSET_BITS == 64} on a
 @standards{BSD, sys/resource.h}
 @safety{@prelim{}@mtsafe{}@assafe{}@acsafe{}}
 @c Direct syscall on most systems; lock-taking critical section on HURD.
-Store the current and maximum limits for the resource @var{resource}
-in @code{*@var{rlp}}.
+Change the current and maximum limits of the process for the resource
+@var{resource} to the values provided in @code{*@var{rlp}}.
 
 The return value is @code{0} on success and @code{-1} on failure.  The
 following @code{errno} error condition is possible:
diff --git a/manual/stdbit.texi b/manual/stdbit.texi
index fe41c671d8..6c75ed9a20 100644
--- a/manual/stdbit.texi
+++ b/manual/stdbit.texi
@@ -32,7 +32,13 @@ and @code{unsigned long long int}.  In addition, there is a
 corresponding type-generic macro (not listed below), named the same as
 the functions but without any suffix such as @samp{_uc}.  The
 type-generic macro can only be used with an argument of an unsigned
-integer type with a width of 8, 16, 32 or 64 bits.
+integer type with a width of 8, 16, 32 or 64 bits, or when using
+a compiler with support for
+@uref{https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html,@code{__builtin_stdc_bit_ceil}},
+etc.@:, built-in functions such as GCC 14.1 or later
+any unsigned integer type those built-in functions support.
+In GCC 14.1 that includes support for @code{unsigned __int128} and
+@code{unsigned _BitInt(@var{n})} if supported by the target.
 
 @deftypefun {unsigned int} stdc_leading_zeros_uc (unsigned char @var{x})
 @deftypefunx {unsigned int} stdc_leading_zeros_us (unsigned short @var{x})
diff --git a/manual/stdio.texi b/manual/stdio.texi
index 002fce7a10..393ed9c665 100644
--- a/manual/stdio.texi
+++ b/manual/stdio.texi
@@ -903,21 +903,17 @@ This function is a GNU extension.
 @deftypefun int putc (int @var{c}, FILE *@var{stream})
 @standards{ISO, stdio.h}
 @safety{@prelim{}@mtsafe{}@asunsafe{@asucorrupt{}}@acunsafe{@acucorrupt{} @aculock{}}}
-This is just like @code{fputc}, except that most systems implement it as
-a macro, making it faster.  One consequence is that it may evaluate the
-@var{stream} argument more than once, which is an exception to the
-general rule for macros.  @code{putc} is usually the best function to
-use for writing a single character.
+This is just like @code{fputc}, except that it may be implemented as
+a macro and may evaluate the @var{stream} argument more than once.
+Therefore, @var{stream} should never be an expression with side-effects.
 @end deftypefun
 
 @deftypefun wint_t putwc (wchar_t @var{wc}, FILE *@var{stream})
 @standards{ISO, wchar.h}
 @safety{@prelim{}@mtsafe{}@asunsafe{@asucorrupt{}}@acunsafe{@acucorrupt{} @aculock{}}}
-This is just like @code{fputwc}, except that it can be implement as
-a macro, making it faster.  One consequence is that it may evaluate the
-@var{stream} argument more than once, which is an exception to the
-general rule for macros.  @code{putwc} is usually the best function to
-use for writing a single wide character.
+This is just like @code{fputwc}, except that it may be implemented as
+a macro and may evaluate the @var{stream} argument more than once.
+Therefore, @var{stream} should never be an expression with side-effects.
 @end deftypefun
 
 @deftypefun int putc_unlocked (int @var{c}, FILE *@var{stream})
@@ -1110,20 +1106,17 @@ This function is a GNU extension.
 @deftypefun int getc (FILE *@var{stream})
 @standards{ISO, stdio.h}
 @safety{@prelim{}@mtsafe{}@asunsafe{@asucorrupt{}}@acunsafe{@aculock{} @acucorrupt{}}}
-This is just like @code{fgetc}, except that it is permissible (and
-typical) for it to be implemented as a macro that evaluates the
-@var{stream} argument more than once.  @code{getc} is often highly
-optimized, so it is usually the best function to use to read a single
-character.
+This is just like @code{fgetc}, except that it may be implemented as
+a macro and may evaluate the @var{stream} argument more than once.
+Therefore, @var{stream} should never be an expression with side-effects.
 @end deftypefun
 
 @deftypefun wint_t getwc (FILE *@var{stream})
 @standards{ISO, wchar.h}
 @safety{@prelim{}@mtsafe{}@asunsafe{@asucorrupt{}}@acunsafe{@aculock{} @acucorrupt{}}}
-This is just like @code{fgetwc}, except that it is permissible for it to
-be implemented as a macro that evaluates the @var{stream} argument more
-than once.  @code{getwc} can be highly optimized, so it is usually the
-best function to use to read a single wide character.
+This is just like @code{fgetwc}, except that it may be implemented as
+a macro and may evaluate the @var{stream} argument more than once.
+Therefore, @var{stream} should never be an expression with side-effects.
 @end deftypefun
 
 @deftypefun int getc_unlocked (FILE *@var{stream})
@@ -1474,11 +1467,9 @@ program; usually @code{ungetc} is used only to unread a character that
 was just read from the same stream.  @Theglibc{} supports this
 even on files opened in binary mode, but other systems might not.
 
-@Theglibc{} only supports one character of pushback---in other
-words, it does not work to call @code{ungetc} twice without doing input
-in between.  Other systems might let you push back multiple characters;
-then reading from the stream retrieves the characters in the reverse
-order that they were pushed.
+@Theglibc{} supports pushing back multiple characters; subsequently
+reading from the stream retrieves the characters in the reverse order
+that they were pushed.
 
 Pushing back characters doesn't alter the file; only the internal
 buffering for the stream is affected.  If a file positioning function
diff --git a/manual/threads.texi b/manual/threads.texi
index e5544ff3da..25e99c9606 100644
--- a/manual/threads.texi
+++ b/manual/threads.texi
@@ -1007,8 +1007,12 @@ This variable is either zero (if restartable sequence registration
 failed or has been disabled) or the size of the restartable sequence
 registration.  This can be different from the size of @code{struct rseq}
 if the kernel has extended the size of the registration.  If
-registration is successful, @code{__rseq_size} is at least 32 (the
-initial size of @code{struct rseq}).
+registration is successful, @code{__rseq_size} is at least 20 (the
+initially active size of @code{struct rseq}).
+
+Previous versions of @theglibc{} set this to 32 even if the kernel only
+supported the initial area of 20 bytes because the value included unused
+padding at the end of the restartable sequence area.
 @end deftypevar
 
 @deftypevar {unsigned int} __rseq_flags
diff --git a/manual/tunables.texi b/manual/tunables.texi
index be97190d67..b255a149d1 100644
--- a/manual/tunables.texi
+++ b/manual/tunables.texi
@@ -52,6 +52,7 @@ glibc.elision.skip_lock_busy: 3 (min: 0, max: 2147483647)
 glibc.malloc.top_pad: 0x20000 (min: 0x0, max: 0xffffffffffffffff)
 glibc.cpu.x86_rep_stosb_threshold: 0x800 (min: 0x1, max: 0xffffffffffffffff)
 glibc.cpu.x86_non_temporal_threshold: 0xc0000 (min: 0x4040, max: 0xfffffffffffffff)
+glibc.cpu.x86_memset_non_temporal_threshold: 0xc0000 (min: 0x4040, max: 0xfffffffffffffff)
 glibc.cpu.x86_shstk:
 glibc.pthread.stack_cache_size: 0x2800000 (min: 0x0, max: 0xffffffffffffffff)
 glibc.cpu.hwcap_mask: 0x6 (min: 0x0, max: 0xffffffffffffffff)
@@ -485,7 +486,8 @@ thread stack originally backup by Huge Pages to default pages.
 @cindex shared_cache_size tunables
 @cindex tunables, shared_cache_size
 @cindex non_temporal_threshold tunables
-@cindex tunables, non_temporal_threshold
+@cindex memset_non_temporal_threshold tunables
+@cindex tunables, non_temporal_threshold, memset_non_temporal_threshold
 
 @deftp {Tunable namespace} glibc.cpu
 Behavior of @theglibc{} can be tuned to assume specific hardware capabilities
@@ -561,6 +563,18 @@ like memmove and memcpy.
 This tunable is specific to i386 and x86-64.
 @end deftp
 
+@deftp Tunable glibc.cpu.x86_memset_non_temporal_threshold
+The @code{glibc.cpu.x86_memset_non_temporal_threshold} tunable allows
+the user to set threshold in bytes for non temporal store in
+memset. Non temporal stores give a hint to the hardware to move data
+directly to memory without displacing other data from the cache. This
+tunable is used by some platforms to determine when to use non
+temporal stores memset.
+
+This tunable is specific to i386 and x86-64.
+@end deftp
+
+
 @deftp Tunable glibc.cpu.x86_rep_movsb_threshold
 The @code{glibc.cpu.x86_rep_movsb_threshold} tunable allows the user to
 set threshold in bytes to start using "rep movsb".  The value must be
diff --git a/math/Makefile b/math/Makefile
index 79ef4ebb65..c98ee4ee0c 100644
--- a/math/Makefile
+++ b/math/Makefile
@@ -261,6 +261,9 @@ tests-static = test-fpucw-static test-fpucw-ieee-static \
 # The tested symbols matherr, _LIB_VERSION have been removed in glibc 2.27.
 ifeq ($(have-GLIBC_2.26)$(build-shared),yesyes)
 tests += test-matherr test-matherr-2
+tests-2.0 += \
+  test-matherr-2 \
+  # tests-2.0
 endif
 
 # These tests use internal (unexported) GMP functions and are linked
@@ -462,6 +465,7 @@ CFLAGS-test-flt-eval-method.c += -fexcess-precision=standard
 CFLAGS-test-fe-snans-always-signal.c += $(config-cflags-signaling-nans)
 
 CFLAGS-test-nan-const.c += -fno-builtin
+CFLAGS-test-nan-payload.c += -fno-builtin
 
 include ../Rules
 
diff --git a/math/auto-libm-test-in b/math/auto-libm-test-in
index d728f97770..5a690023e9 100644
--- a/math/auto-libm-test-in
+++ b/math/auto-libm-test-in
@@ -5354,7 +5354,7 @@ exp2 -0x4.8ce878p-4
 exp2 0xf.93d18bf7be8d272p-4
 
 expm1 0
-expm1 -0 no-mathvec
+expm1 -0
 expm1 1
 expm1 0.75
 expm1 2
@@ -5419,7 +5419,7 @@ expm1 -0x1p-100
 expm1 0x1p-600
 expm1 -0x1p-600
 expm1 0x1p-10000
-expm1 -0x1p-10000 no-mathvec
+expm1 -0x1p-10000
 expm1 0xe.4152ac57cd1ea7ap-60
 expm1 0x6.660247486aed8p-4
 expm1 0x6.289a78p-4
@@ -6577,7 +6577,7 @@ log10 0xf.bf1b2p-4
 log10 0x1.6b5f7ap+96
 
 log1p 0
-log1p -0 no-mathvec
+log1p -0
 log1p e-1
 log1p -0.25
 log1p -0.875
@@ -7318,7 +7318,7 @@ pow 0x1.7ac7cp+5 23
 pow -0x1.7ac7cp+5 23
 
 sin 0
-sin -0 no-mathvec
+sin -0
 sin pi/6
 sin -pi/6
 sin pi/2
@@ -7655,7 +7655,7 @@ sqrt min
 sqrt min_subnorm
 
 tan 0
-tan -0 no-mathvec
+tan -0
 tan pi/4
 tan pi/2
 tan -pi/2
diff --git a/math/auto-libm-test-out-expm1 b/math/auto-libm-test-out-expm1
index 91da41b7f6..8483455801 100644
--- a/math/auto-libm-test-out-expm1
+++ b/math/auto-libm-test-out-expm1
@@ -23,31 +23,31 @@ expm1 0
 = expm1 tonearest ibm128 0x0p+0 : 0x0p+0 : inexact-ok
 = expm1 towardzero ibm128 0x0p+0 : 0x0p+0 : inexact-ok
 = expm1 upward ibm128 0x0p+0 : 0x0p+0 : inexact-ok
-expm1 -0 no-mathvec
-= expm1 downward binary32 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 tonearest binary32 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 towardzero binary32 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 upward binary32 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 downward binary64 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 tonearest binary64 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 towardzero binary64 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 upward binary64 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 downward intel96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 tonearest intel96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 towardzero intel96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 upward intel96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 downward m68k96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 tonearest m68k96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 towardzero m68k96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 upward m68k96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 downward binary128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 tonearest binary128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 towardzero binary128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 upward binary128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 downward ibm128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 tonearest ibm128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 towardzero ibm128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 upward ibm128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
+expm1 -0
+= expm1 downward binary32 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 tonearest binary32 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 towardzero binary32 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 upward binary32 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 downward binary64 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 tonearest binary64 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 towardzero binary64 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 upward binary64 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 downward intel96 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 tonearest intel96 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 towardzero intel96 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 upward intel96 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 downward m68k96 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 tonearest m68k96 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 towardzero m68k96 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 upward m68k96 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 downward binary128 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 tonearest binary128 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 towardzero binary128 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 upward binary128 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 downward ibm128 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 tonearest ibm128 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 towardzero ibm128 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 upward ibm128 -0x0p+0 : -0x0p+0 : inexact-ok
 expm1 1
 = expm1 downward binary32 0x1p+0 : 0x1.b7e15p+0 : inexact-ok
 = expm1 tonearest binary32 0x1p+0 : 0x1.b7e152p+0 : inexact-ok
@@ -1880,87 +1880,87 @@ expm1 0x1p-10000
 = expm1 tonearest binary128 0x1p-10000 : 0x1p-10000 : inexact-ok
 = expm1 towardzero binary128 0x1p-10000 : 0x1p-10000 : inexact-ok
 = expm1 upward binary128 0x1p-10000 : 0x1.0000000000000000000000000001p-10000 : inexact-ok
-expm1 -0x1p-10000 no-mathvec
-= expm1 downward binary32 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 tonearest binary32 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 towardzero binary32 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 upward binary32 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 downward binary64 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 tonearest binary64 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 towardzero binary64 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 upward binary64 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 downward intel96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 tonearest intel96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 towardzero intel96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 upward intel96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 downward m68k96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 tonearest m68k96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 towardzero m68k96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 upward m68k96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 downward binary128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 tonearest binary128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 towardzero binary128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 upward binary128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 downward ibm128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 tonearest ibm128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 towardzero ibm128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 upward ibm128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= expm1 downward binary32 -0x8p-152 : -0x8p-152 : no-mathvec inexact-ok underflow errno-erange-ok
-= expm1 tonearest binary32 -0x8p-152 : -0x8p-152 : no-mathvec inexact-ok underflow errno-erange-ok
-= expm1 towardzero binary32 -0x8p-152 : -0x0p+0 : no-mathvec inexact-ok underflow errno-erange-ok
-= expm1 upward binary32 -0x8p-152 : -0x0p+0 : no-mathvec inexact-ok underflow errno-erange-ok
-= expm1 downward binary64 -0x8p-152 : -0x8p-152 : no-mathvec inexact-ok
-= expm1 tonearest binary64 -0x8p-152 : -0x8p-152 : no-mathvec inexact-ok
-= expm1 towardzero binary64 -0x8p-152 : -0x7.ffffffffffffcp-152 : no-mathvec inexact-ok
-= expm1 upward binary64 -0x8p-152 : -0x7.ffffffffffffcp-152 : no-mathvec inexact-ok
-= expm1 downward intel96 -0x8p-152 : -0x8p-152 : no-mathvec inexact-ok
-= expm1 tonearest intel96 -0x8p-152 : -0x8p-152 : no-mathvec inexact-ok
-= expm1 towardzero intel96 -0x8p-152 : -0x7.fffffffffffffff8p-152 : no-mathvec inexact-ok
-= expm1 upward intel96 -0x8p-152 : -0x7.fffffffffffffff8p-152 : no-mathvec inexact-ok
-= expm1 downward m68k96 -0x8p-152 : -0x8p-152 : no-mathvec inexact-ok
-= expm1 tonearest m68k96 -0x8p-152 : -0x8p-152 : no-mathvec inexact-ok
-= expm1 towardzero m68k96 -0x8p-152 : -0x7.fffffffffffffff8p-152 : no-mathvec inexact-ok
-= expm1 upward m68k96 -0x8p-152 : -0x7.fffffffffffffff8p-152 : no-mathvec inexact-ok
-= expm1 downward binary128 -0x8p-152 : -0x8p-152 : no-mathvec inexact-ok
-= expm1 tonearest binary128 -0x8p-152 : -0x8p-152 : no-mathvec inexact-ok
-= expm1 towardzero binary128 -0x8p-152 : -0x7.fffffffffffffffffffffffffffcp-152 : no-mathvec inexact-ok
-= expm1 upward binary128 -0x8p-152 : -0x7.fffffffffffffffffffffffffffcp-152 : no-mathvec inexact-ok
-= expm1 downward ibm128 -0x8p-152 : -0x8p-152 : no-mathvec inexact-ok
-= expm1 tonearest ibm128 -0x8p-152 : -0x8p-152 : no-mathvec inexact-ok
-= expm1 towardzero ibm128 -0x8p-152 : -0x7.fffffffffffffffffffffffffep-152 : no-mathvec inexact-ok
-= expm1 upward ibm128 -0x8p-152 : -0x7.fffffffffffffffffffffffffep-152 : no-mathvec inexact-ok
-= expm1 downward binary64 -0x4p-1076 : -0x4p-1076 : no-mathvec inexact-ok underflow errno-erange-ok
-= expm1 tonearest binary64 -0x4p-1076 : -0x4p-1076 : no-mathvec inexact-ok underflow errno-erange-ok
-= expm1 towardzero binary64 -0x4p-1076 : -0x0p+0 : no-mathvec inexact-ok underflow errno-erange-ok
-= expm1 upward binary64 -0x4p-1076 : -0x0p+0 : no-mathvec inexact-ok underflow errno-erange-ok
-= expm1 downward intel96 -0x4p-1076 : -0x4p-1076 : no-mathvec inexact-ok
-= expm1 tonearest intel96 -0x4p-1076 : -0x4p-1076 : no-mathvec inexact-ok
-= expm1 towardzero intel96 -0x4p-1076 : -0x3.fffffffffffffffcp-1076 : no-mathvec inexact-ok
-= expm1 upward intel96 -0x4p-1076 : -0x3.fffffffffffffffcp-1076 : no-mathvec inexact-ok
-= expm1 downward m68k96 -0x4p-1076 : -0x4p-1076 : no-mathvec inexact-ok
-= expm1 tonearest m68k96 -0x4p-1076 : -0x4p-1076 : no-mathvec inexact-ok
-= expm1 towardzero m68k96 -0x4p-1076 : -0x3.fffffffffffffffcp-1076 : no-mathvec inexact-ok
-= expm1 upward m68k96 -0x4p-1076 : -0x3.fffffffffffffffcp-1076 : no-mathvec inexact-ok
-= expm1 downward binary128 -0x4p-1076 : -0x4p-1076 : no-mathvec inexact-ok
-= expm1 tonearest binary128 -0x4p-1076 : -0x4p-1076 : no-mathvec inexact-ok
-= expm1 towardzero binary128 -0x4p-1076 : -0x3.fffffffffffffffffffffffffffep-1076 : no-mathvec inexact-ok
-= expm1 upward binary128 -0x4p-1076 : -0x3.fffffffffffffffffffffffffffep-1076 : no-mathvec inexact-ok
-= expm1 downward ibm128 -0x4p-1076 : -0x4p-1076 : no-mathvec xfail:ibm128-libgcc inexact-ok underflow errno-erange-ok
-= expm1 tonearest ibm128 -0x4p-1076 : -0x4p-1076 : no-mathvec inexact-ok underflow errno-erange-ok
-= expm1 towardzero ibm128 -0x4p-1076 : -0x0p+0 : no-mathvec xfail:ibm128-libgcc inexact-ok underflow errno-erange-ok
-= expm1 upward ibm128 -0x4p-1076 : -0x0p+0 : no-mathvec xfail:ibm128-libgcc inexact-ok underflow errno-erange-ok
-= expm1 downward intel96 -0x1p-10000 : -0x1p-10000 : no-mathvec inexact-ok
-= expm1 tonearest intel96 -0x1p-10000 : -0x1p-10000 : no-mathvec inexact-ok
-= expm1 towardzero intel96 -0x1p-10000 : -0xf.fffffffffffffffp-10004 : no-mathvec inexact-ok
-= expm1 upward intel96 -0x1p-10000 : -0xf.fffffffffffffffp-10004 : no-mathvec inexact-ok
-= expm1 downward m68k96 -0x1p-10000 : -0x1p-10000 : no-mathvec inexact-ok
-= expm1 tonearest m68k96 -0x1p-10000 : -0x1p-10000 : no-mathvec inexact-ok
-= expm1 towardzero m68k96 -0x1p-10000 : -0xf.fffffffffffffffp-10004 : no-mathvec inexact-ok
-= expm1 upward m68k96 -0x1p-10000 : -0xf.fffffffffffffffp-10004 : no-mathvec inexact-ok
-= expm1 downward binary128 -0x1p-10000 : -0x1p-10000 : no-mathvec inexact-ok
-= expm1 tonearest binary128 -0x1p-10000 : -0x1p-10000 : no-mathvec inexact-ok
-= expm1 towardzero binary128 -0x1p-10000 : -0xf.fffffffffffffffffffffffffff8p-10004 : no-mathvec inexact-ok
-= expm1 upward binary128 -0x1p-10000 : -0xf.fffffffffffffffffffffffffff8p-10004 : no-mathvec inexact-ok
+expm1 -0x1p-10000
+= expm1 downward binary32 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 tonearest binary32 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 towardzero binary32 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 upward binary32 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 downward binary64 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 tonearest binary64 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 towardzero binary64 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 upward binary64 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 downward intel96 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 tonearest intel96 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 towardzero intel96 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 upward intel96 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 downward m68k96 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 tonearest m68k96 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 towardzero m68k96 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 upward m68k96 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 downward binary128 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 tonearest binary128 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 towardzero binary128 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 upward binary128 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 downward ibm128 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 tonearest ibm128 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 towardzero ibm128 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 upward ibm128 -0x0p+0 : -0x0p+0 : inexact-ok
+= expm1 downward binary32 -0x8p-152 : -0x8p-152 : inexact-ok underflow errno-erange-ok
+= expm1 tonearest binary32 -0x8p-152 : -0x8p-152 : inexact-ok underflow errno-erange-ok
+= expm1 towardzero binary32 -0x8p-152 : -0x0p+0 : inexact-ok underflow errno-erange-ok
+= expm1 upward binary32 -0x8p-152 : -0x0p+0 : inexact-ok underflow errno-erange-ok
+= expm1 downward binary64 -0x8p-152 : -0x8p-152 : inexact-ok
+= expm1 tonearest binary64 -0x8p-152 : -0x8p-152 : inexact-ok
+= expm1 towardzero binary64 -0x8p-152 : -0x7.ffffffffffffcp-152 : inexact-ok
+= expm1 upward binary64 -0x8p-152 : -0x7.ffffffffffffcp-152 : inexact-ok
+= expm1 downward intel96 -0x8p-152 : -0x8p-152 : inexact-ok
+= expm1 tonearest intel96 -0x8p-152 : -0x8p-152 : inexact-ok
+= expm1 towardzero intel96 -0x8p-152 : -0x7.fffffffffffffff8p-152 : inexact-ok
+= expm1 upward intel96 -0x8p-152 : -0x7.fffffffffffffff8p-152 : inexact-ok
+= expm1 downward m68k96 -0x8p-152 : -0x8p-152 : inexact-ok
+= expm1 tonearest m68k96 -0x8p-152 : -0x8p-152 : inexact-ok
+= expm1 towardzero m68k96 -0x8p-152 : -0x7.fffffffffffffff8p-152 : inexact-ok
+= expm1 upward m68k96 -0x8p-152 : -0x7.fffffffffffffff8p-152 : inexact-ok
+= expm1 downward binary128 -0x8p-152 : -0x8p-152 : inexact-ok
+= expm1 tonearest binary128 -0x8p-152 : -0x8p-152 : inexact-ok
+= expm1 towardzero binary128 -0x8p-152 : -0x7.fffffffffffffffffffffffffffcp-152 : inexact-ok
+= expm1 upward binary128 -0x8p-152 : -0x7.fffffffffffffffffffffffffffcp-152 : inexact-ok
+= expm1 downward ibm128 -0x8p-152 : -0x8p-152 : inexact-ok
+= expm1 tonearest ibm128 -0x8p-152 : -0x8p-152 : inexact-ok
+= expm1 towardzero ibm128 -0x8p-152 : -0x7.fffffffffffffffffffffffffep-152 : inexact-ok
+= expm1 upward ibm128 -0x8p-152 : -0x7.fffffffffffffffffffffffffep-152 : inexact-ok
+= expm1 downward binary64 -0x4p-1076 : -0x4p-1076 : inexact-ok underflow errno-erange-ok
+= expm1 tonearest binary64 -0x4p-1076 : -0x4p-1076 : inexact-ok underflow errno-erange-ok
+= expm1 towardzero binary64 -0x4p-1076 : -0x0p+0 : inexact-ok underflow errno-erange-ok
+= expm1 upward binary64 -0x4p-1076 : -0x0p+0 : inexact-ok underflow errno-erange-ok
+= expm1 downward intel96 -0x4p-1076 : -0x4p-1076 : inexact-ok
+= expm1 tonearest intel96 -0x4p-1076 : -0x4p-1076 : inexact-ok
+= expm1 towardzero intel96 -0x4p-1076 : -0x3.fffffffffffffffcp-1076 : inexact-ok
+= expm1 upward intel96 -0x4p-1076 : -0x3.fffffffffffffffcp-1076 : inexact-ok
+= expm1 downward m68k96 -0x4p-1076 : -0x4p-1076 : inexact-ok
+= expm1 tonearest m68k96 -0x4p-1076 : -0x4p-1076 : inexact-ok
+= expm1 towardzero m68k96 -0x4p-1076 : -0x3.fffffffffffffffcp-1076 : inexact-ok
+= expm1 upward m68k96 -0x4p-1076 : -0x3.fffffffffffffffcp-1076 : inexact-ok
+= expm1 downward binary128 -0x4p-1076 : -0x4p-1076 : inexact-ok
+= expm1 tonearest binary128 -0x4p-1076 : -0x4p-1076 : inexact-ok
+= expm1 towardzero binary128 -0x4p-1076 : -0x3.fffffffffffffffffffffffffffep-1076 : inexact-ok
+= expm1 upward binary128 -0x4p-1076 : -0x3.fffffffffffffffffffffffffffep-1076 : inexact-ok
+= expm1 downward ibm128 -0x4p-1076 : -0x4p-1076 : xfail:ibm128-libgcc inexact-ok underflow errno-erange-ok
+= expm1 tonearest ibm128 -0x4p-1076 : -0x4p-1076 : inexact-ok underflow errno-erange-ok
+= expm1 towardzero ibm128 -0x4p-1076 : -0x0p+0 : xfail:ibm128-libgcc inexact-ok underflow errno-erange-ok
+= expm1 upward ibm128 -0x4p-1076 : -0x0p+0 : xfail:ibm128-libgcc inexact-ok underflow errno-erange-ok
+= expm1 downward intel96 -0x1p-10000 : -0x1p-10000 : inexact-ok
+= expm1 tonearest intel96 -0x1p-10000 : -0x1p-10000 : inexact-ok
+= expm1 towardzero intel96 -0x1p-10000 : -0xf.fffffffffffffffp-10004 : inexact-ok
+= expm1 upward intel96 -0x1p-10000 : -0xf.fffffffffffffffp-10004 : inexact-ok
+= expm1 downward m68k96 -0x1p-10000 : -0x1p-10000 : inexact-ok
+= expm1 tonearest m68k96 -0x1p-10000 : -0x1p-10000 : inexact-ok
+= expm1 towardzero m68k96 -0x1p-10000 : -0xf.fffffffffffffffp-10004 : inexact-ok
+= expm1 upward m68k96 -0x1p-10000 : -0xf.fffffffffffffffp-10004 : inexact-ok
+= expm1 downward binary128 -0x1p-10000 : -0x1p-10000 : inexact-ok
+= expm1 tonearest binary128 -0x1p-10000 : -0x1p-10000 : inexact-ok
+= expm1 towardzero binary128 -0x1p-10000 : -0xf.fffffffffffffffffffffffffff8p-10004 : inexact-ok
+= expm1 upward binary128 -0x1p-10000 : -0xf.fffffffffffffffffffffffffff8p-10004 : inexact-ok
 expm1 0xe.4152ac57cd1ea7ap-60
 = expm1 downward binary32 0xe.4152bp-60 : 0xe.4152bp-60 : inexact-ok
 = expm1 tonearest binary32 0xe.4152bp-60 : 0xe.4152bp-60 : inexact-ok
diff --git a/math/auto-libm-test-out-log1p b/math/auto-libm-test-out-log1p
index f83241f51a..f7d3b35e6d 100644
--- a/math/auto-libm-test-out-log1p
+++ b/math/auto-libm-test-out-log1p
@@ -23,31 +23,31 @@ log1p 0
 = log1p tonearest ibm128 0x0p+0 : 0x0p+0 : inexact-ok
 = log1p towardzero ibm128 0x0p+0 : 0x0p+0 : inexact-ok
 = log1p upward ibm128 0x0p+0 : 0x0p+0 : inexact-ok
-log1p -0 no-mathvec
-= log1p downward binary32 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= log1p tonearest binary32 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= log1p towardzero binary32 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= log1p upward binary32 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= log1p downward binary64 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= log1p tonearest binary64 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= log1p towardzero binary64 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= log1p upward binary64 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= log1p downward intel96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= log1p tonearest intel96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= log1p towardzero intel96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= log1p upward intel96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= log1p downward m68k96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= log1p tonearest m68k96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= log1p towardzero m68k96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= log1p upward m68k96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= log1p downward binary128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= log1p tonearest binary128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= log1p towardzero binary128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= log1p upward binary128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= log1p downward ibm128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= log1p tonearest ibm128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= log1p towardzero ibm128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= log1p upward ibm128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
+log1p -0
+= log1p downward binary32 -0x0p+0 : -0x0p+0 : inexact-ok
+= log1p tonearest binary32 -0x0p+0 : -0x0p+0 : inexact-ok
+= log1p towardzero binary32 -0x0p+0 : -0x0p+0 : inexact-ok
+= log1p upward binary32 -0x0p+0 : -0x0p+0 : inexact-ok
+= log1p downward binary64 -0x0p+0 : -0x0p+0 : inexact-ok
+= log1p tonearest binary64 -0x0p+0 : -0x0p+0 : inexact-ok
+= log1p towardzero binary64 -0x0p+0 : -0x0p+0 : inexact-ok
+= log1p upward binary64 -0x0p+0 : -0x0p+0 : inexact-ok
+= log1p downward intel96 -0x0p+0 : -0x0p+0 : inexact-ok
+= log1p tonearest intel96 -0x0p+0 : -0x0p+0 : inexact-ok
+= log1p towardzero intel96 -0x0p+0 : -0x0p+0 : inexact-ok
+= log1p upward intel96 -0x0p+0 : -0x0p+0 : inexact-ok
+= log1p downward m68k96 -0x0p+0 : -0x0p+0 : inexact-ok
+= log1p tonearest m68k96 -0x0p+0 : -0x0p+0 : inexact-ok
+= log1p towardzero m68k96 -0x0p+0 : -0x0p+0 : inexact-ok
+= log1p upward m68k96 -0x0p+0 : -0x0p+0 : inexact-ok
+= log1p downward binary128 -0x0p+0 : -0x0p+0 : inexact-ok
+= log1p tonearest binary128 -0x0p+0 : -0x0p+0 : inexact-ok
+= log1p towardzero binary128 -0x0p+0 : -0x0p+0 : inexact-ok
+= log1p upward binary128 -0x0p+0 : -0x0p+0 : inexact-ok
+= log1p downward ibm128 -0x0p+0 : -0x0p+0 : inexact-ok
+= log1p tonearest ibm128 -0x0p+0 : -0x0p+0 : inexact-ok
+= log1p towardzero ibm128 -0x0p+0 : -0x0p+0 : inexact-ok
+= log1p upward ibm128 -0x0p+0 : -0x0p+0 : inexact-ok
 log1p e-1
 = log1p downward binary32 0x1.b7e152p+0 : 0x1p+0 : inexact-ok
 = log1p tonearest binary32 0x1.b7e152p+0 : 0x1p+0 : inexact-ok
diff --git a/math/auto-libm-test-out-sin b/math/auto-libm-test-out-sin
index e1f6845283..f1d21b179c 100644
--- a/math/auto-libm-test-out-sin
+++ b/math/auto-libm-test-out-sin
@@ -23,31 +23,31 @@ sin 0
 = sin tonearest ibm128 0x0p+0 : 0x0p+0 : inexact-ok
 = sin towardzero ibm128 0x0p+0 : 0x0p+0 : inexact-ok
 = sin upward ibm128 0x0p+0 : 0x0p+0 : inexact-ok
-sin -0 no-mathvec
-= sin downward binary32 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= sin tonearest binary32 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= sin towardzero binary32 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= sin upward binary32 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= sin downward binary64 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= sin tonearest binary64 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= sin towardzero binary64 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= sin upward binary64 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= sin downward intel96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= sin tonearest intel96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= sin towardzero intel96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= sin upward intel96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= sin downward m68k96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= sin tonearest m68k96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= sin towardzero m68k96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= sin upward m68k96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= sin downward binary128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= sin tonearest binary128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= sin towardzero binary128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= sin upward binary128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= sin downward ibm128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= sin tonearest ibm128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= sin towardzero ibm128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= sin upward ibm128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
+sin -0
+= sin downward binary32 -0x0p+0 : -0x0p+0 : inexact-ok
+= sin tonearest binary32 -0x0p+0 : -0x0p+0 : inexact-ok
+= sin towardzero binary32 -0x0p+0 : -0x0p+0 : inexact-ok
+= sin upward binary32 -0x0p+0 : -0x0p+0 : inexact-ok
+= sin downward binary64 -0x0p+0 : -0x0p+0 : inexact-ok
+= sin tonearest binary64 -0x0p+0 : -0x0p+0 : inexact-ok
+= sin towardzero binary64 -0x0p+0 : -0x0p+0 : inexact-ok
+= sin upward binary64 -0x0p+0 : -0x0p+0 : inexact-ok
+= sin downward intel96 -0x0p+0 : -0x0p+0 : inexact-ok
+= sin tonearest intel96 -0x0p+0 : -0x0p+0 : inexact-ok
+= sin towardzero intel96 -0x0p+0 : -0x0p+0 : inexact-ok
+= sin upward intel96 -0x0p+0 : -0x0p+0 : inexact-ok
+= sin downward m68k96 -0x0p+0 : -0x0p+0 : inexact-ok
+= sin tonearest m68k96 -0x0p+0 : -0x0p+0 : inexact-ok
+= sin towardzero m68k96 -0x0p+0 : -0x0p+0 : inexact-ok
+= sin upward m68k96 -0x0p+0 : -0x0p+0 : inexact-ok
+= sin downward binary128 -0x0p+0 : -0x0p+0 : inexact-ok
+= sin tonearest binary128 -0x0p+0 : -0x0p+0 : inexact-ok
+= sin towardzero binary128 -0x0p+0 : -0x0p+0 : inexact-ok
+= sin upward binary128 -0x0p+0 : -0x0p+0 : inexact-ok
+= sin downward ibm128 -0x0p+0 : -0x0p+0 : inexact-ok
+= sin tonearest ibm128 -0x0p+0 : -0x0p+0 : inexact-ok
+= sin towardzero ibm128 -0x0p+0 : -0x0p+0 : inexact-ok
+= sin upward ibm128 -0x0p+0 : -0x0p+0 : inexact-ok
 sin pi/6
 = sin downward binary32 0x8.60a92p-4 : 0x8p-4 : inexact-ok
 = sin tonearest binary32 0x8.60a92p-4 : 0x8p-4 : inexact-ok
diff --git a/math/auto-libm-test-out-tan b/math/auto-libm-test-out-tan
index f46fdc7ec6..7d00d03e1d 100644
--- a/math/auto-libm-test-out-tan
+++ b/math/auto-libm-test-out-tan
@@ -23,31 +23,31 @@ tan 0
 = tan tonearest ibm128 0x0p+0 : 0x0p+0 : inexact-ok
 = tan towardzero ibm128 0x0p+0 : 0x0p+0 : inexact-ok
 = tan upward ibm128 0x0p+0 : 0x0p+0 : inexact-ok
-tan -0 no-mathvec
-= tan downward binary32 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= tan tonearest binary32 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= tan towardzero binary32 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= tan upward binary32 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= tan downward binary64 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= tan tonearest binary64 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= tan towardzero binary64 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= tan upward binary64 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= tan downward intel96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= tan tonearest intel96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= tan towardzero intel96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= tan upward intel96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= tan downward m68k96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= tan tonearest m68k96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= tan towardzero m68k96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= tan upward m68k96 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= tan downward binary128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= tan tonearest binary128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= tan towardzero binary128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= tan upward binary128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= tan downward ibm128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= tan tonearest ibm128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= tan towardzero ibm128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
-= tan upward ibm128 -0x0p+0 : -0x0p+0 : no-mathvec inexact-ok
+tan -0
+= tan downward binary32 -0x0p+0 : -0x0p+0 : inexact-ok
+= tan tonearest binary32 -0x0p+0 : -0x0p+0 : inexact-ok
+= tan towardzero binary32 -0x0p+0 : -0x0p+0 : inexact-ok
+= tan upward binary32 -0x0p+0 : -0x0p+0 : inexact-ok
+= tan downward binary64 -0x0p+0 : -0x0p+0 : inexact-ok
+= tan tonearest binary64 -0x0p+0 : -0x0p+0 : inexact-ok
+= tan towardzero binary64 -0x0p+0 : -0x0p+0 : inexact-ok
+= tan upward binary64 -0x0p+0 : -0x0p+0 : inexact-ok
+= tan downward intel96 -0x0p+0 : -0x0p+0 : inexact-ok
+= tan tonearest intel96 -0x0p+0 : -0x0p+0 : inexact-ok
+= tan towardzero intel96 -0x0p+0 : -0x0p+0 : inexact-ok
+= tan upward intel96 -0x0p+0 : -0x0p+0 : inexact-ok
+= tan downward m68k96 -0x0p+0 : -0x0p+0 : inexact-ok
+= tan tonearest m68k96 -0x0p+0 : -0x0p+0 : inexact-ok
+= tan towardzero m68k96 -0x0p+0 : -0x0p+0 : inexact-ok
+= tan upward m68k96 -0x0p+0 : -0x0p+0 : inexact-ok
+= tan downward binary128 -0x0p+0 : -0x0p+0 : inexact-ok
+= tan tonearest binary128 -0x0p+0 : -0x0p+0 : inexact-ok
+= tan towardzero binary128 -0x0p+0 : -0x0p+0 : inexact-ok
+= tan upward binary128 -0x0p+0 : -0x0p+0 : inexact-ok
+= tan downward ibm128 -0x0p+0 : -0x0p+0 : inexact-ok
+= tan tonearest ibm128 -0x0p+0 : -0x0p+0 : inexact-ok
+= tan towardzero ibm128 -0x0p+0 : -0x0p+0 : inexact-ok
+= tan upward ibm128 -0x0p+0 : -0x0p+0 : inexact-ok
 tan pi/4
 = tan downward binary32 0xc.90fdbp-4 : 0x1p+0 : inexact-ok
 = tan tonearest binary32 0xc.90fdbp-4 : 0x1p+0 : inexact-ok
diff --git a/math/gen-auto-libm-tests.c b/math/gen-auto-libm-tests.c
index c35242b356..48227248e4 100644
--- a/math/gen-auto-libm-tests.c
+++ b/math/gen-auto-libm-tests.c
@@ -96,8 +96,7 @@
    zero and infinite results should be ignored; "xfail" indicates the
    test is disabled as expected to produce incorrect results,
    "xfail-rounding" indicates the test is disabled only in rounding
-   modes other than round-to-nearest; "no-mathvec" indicates the test
-   is disabled in vector math libraries.  Otherwise, test flags are of
+   modes other than round-to-nearest.  Otherwise, test flags are of
    the form "spurious-<exception>" and "missing-<exception>", for any
    exception ("overflow", "underflow", "inexact", "invalid",
    "divbyzero"), "spurious-errno" and "missing-errno", to indicate
@@ -353,7 +352,6 @@ typedef enum
     flag_missing_overflow,
     flag_missing_underflow,
     flag_missing_errno,
-    flag_no_mathvec,
     num_input_flag_types,
     flag_first_flag = 0,
     flag_spurious_first = flag_spurious_divbyzero,
@@ -379,7 +377,6 @@ static const char *const input_flags[num_input_flag_types] =
     "missing-overflow",
     "missing-underflow",
     "missing-errno",
-    "no-mathvec",
   };
 
 /* An input flag, possibly conditional.  */
@@ -2052,7 +2049,6 @@ output_for_one_input_case (FILE *fp, const char *filename, test_function *tf,
 		  {
 		  case flag_ignore_zero_inf_sign:
 		  case flag_xfail:
-		  case flag_no_mathvec:
 		    if (fprintf (fp, " %s%s",
 				 input_flags[it->flags[i].type],
 				 (it->flags[i].cond
diff --git a/math/gen-libm-test.py b/math/gen-libm-test.py
index 397dbd3259..6e8bb56437 100755
--- a/math/gen-libm-test.py
+++ b/math/gen-libm-test.py
@@ -93,8 +93,7 @@ BEAUTIFY_MAP = {'minus_zero': '-0',
 
 # Flags in auto-libm-test-out that map directly to C flags.
 FLAGS_SIMPLE = {'ignore-zero-inf-sign': 'IGNORE_ZERO_INF_SIGN',
-                'xfail': 'XFAIL_TEST',
-                'no-mathvec': 'NO_TEST_MATHVEC'}
+                'xfail': 'XFAIL_TEST'}
 
 # Exceptions in auto-libm-test-out, and their corresponding C flags
 # for being required, OK or required to be absent.
diff --git a/math/libm-test-support.c b/math/libm-test-support.c
index 1d60ac783b..315229cfc8 100644
--- a/math/libm-test-support.c
+++ b/math/libm-test-support.c
@@ -684,7 +684,7 @@ check_float_internal (const char *test_name, FLOAT computed, FLOAT expected,
       ulps = ULPDIFF (computed, expected);
       set_max_error (ulps, curr_max_error);
       print_diff = 1;
-      if ((exceptions & IGNORE_ZERO_INF_SIGN) == 0
+      if (((exceptions & IGNORE_ZERO_INF_SIGN) == 0) && !flag_test_mathvec
 	  && computed == 0.0 && expected == 0.0
 	  && signbit(computed) != signbit (expected))
 	ok = 0;
diff --git a/math/test-nan-payload.c b/math/test-nan-payload.c
index 4a81dc348b..413791e09f 100644
--- a/math/test-nan-payload.c
+++ b/math/test-nan-payload.c
@@ -16,6 +16,9 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
+#define _LIBC_TEST 1
+#define __STDC_WANT_IEC_60559_TYPES_EXT__
+#include <errno.h>
 #include <float.h>
 #include <math.h>
 #include <stdio.h>
@@ -31,7 +34,7 @@
 #define CHECK_IS_NAN(TYPE, A)			\
   do						\
     {						\
-      if (isnan (A))				\
+      if (isnan (A) && !issignaling (A))	\
 	puts ("PASS: " #TYPE " " #A);		\
       else					\
 	{					\
@@ -41,6 +44,19 @@
     }						\
   while (0)
 
+#define CHECK_PAYLOAD(TYPE, FUNC, A, P)		\
+  do						\
+    {						\
+      if (FUNC (&(A)) == (P))			\
+	puts ("PASS: " #TYPE " payload " #A);	\
+      else					\
+	{					\
+	  puts ("FAIL: " #TYPE " payload " #A);	\
+	  result = 1;				\
+	}					\
+    }						\
+  while (0)
+
 #define CHECK_SAME_NAN(TYPE, A, B)			\
   do							\
     {							\
@@ -67,33 +83,97 @@
     }							\
   while (0)
 
+#define CLEAR_ERRNO				\
+  do						\
+    {						\
+      errno = 12345;				\
+    }						\
+  while (0)
+
+#define CHECK_ERRNO(TYPE, A)				\
+  do							\
+    {							\
+      if (errno == 12345)				\
+	puts ("PASS: " #TYPE " " #A " errno");		\
+      else						\
+	{						\
+	  puts ("FAIL: " #TYPE " " #A " errno");	\
+	  result = 1;					\
+	}						\
+    }							\
+  while (0)
+
 /* Cannot test payloads by memcmp for formats where NaNs have padding
    bits.  */
 #define CAN_TEST_EQ(MANT_DIG) ((MANT_DIG) != 64 && (MANT_DIG) != 106)
 
-#define RUN_TESTS(TYPE, SFUNC, FUNC, MANT_DIG)		\
+#define RUN_TESTS(TYPE, SFUNC, FUNC, PLFUNC, MANT_DIG)	\
   do							\
     {							\
+     CLEAR_ERRNO;					\
      TYPE n123 = WRAP_NAN (FUNC, "123");		\
+     CHECK_ERRNO (TYPE, n123);				\
      CHECK_IS_NAN (TYPE, n123);				\
+     CLEAR_ERRNO;					\
      TYPE s123 = WRAP_STRTO (SFUNC, "NAN(123)");	\
+     CHECK_ERRNO (TYPE, s123);				\
      CHECK_IS_NAN (TYPE, s123);				\
+     CLEAR_ERRNO;					\
      TYPE n456 = WRAP_NAN (FUNC, "456");		\
+     CHECK_ERRNO (TYPE, n456);				\
      CHECK_IS_NAN (TYPE, n456);				\
+     CLEAR_ERRNO;					\
      TYPE s456 = WRAP_STRTO (SFUNC, "NAN(456)");	\
+     CHECK_ERRNO (TYPE, s456);				\
      CHECK_IS_NAN (TYPE, s456);				\
+     CLEAR_ERRNO;					\
+     TYPE nh123 = WRAP_NAN (FUNC, "0x123");		\
+     CHECK_ERRNO (TYPE, nh123);				\
+     CHECK_IS_NAN (TYPE, nh123);			\
+     CLEAR_ERRNO;					\
+     TYPE sh123 = WRAP_STRTO (SFUNC, "NAN(0x123)");	\
+     CHECK_ERRNO (TYPE, sh123);				\
+     CHECK_IS_NAN (TYPE, sh123);			\
+     CLEAR_ERRNO;					\
      TYPE n123x = WRAP_NAN (FUNC, "123)");		\
+     CHECK_ERRNO (TYPE, n123x);				\
      CHECK_IS_NAN (TYPE, n123x);			\
+     CLEAR_ERRNO;					\
      TYPE nemp = WRAP_NAN (FUNC, "");			\
+     CHECK_ERRNO (TYPE, nemp);				\
      CHECK_IS_NAN (TYPE, nemp);				\
+     CLEAR_ERRNO;					\
      TYPE semp = WRAP_STRTO (SFUNC, "NAN()");		\
+     CHECK_ERRNO (TYPE, semp);				\
      CHECK_IS_NAN (TYPE, semp);				\
+     CLEAR_ERRNO;					\
      TYPE sx = WRAP_STRTO (SFUNC, "NAN");		\
+     CHECK_ERRNO (TYPE, sx);				\
      CHECK_IS_NAN (TYPE, sx);				\
+     CLEAR_ERRNO;					\
+     TYPE novf = WRAP_NAN (FUNC, "9999999999"		\
+			   "99999999999999999999"	\
+			   "9999999999");		\
+     CHECK_ERRNO (TYPE, novf);				\
+     CHECK_IS_NAN (TYPE, novf);				\
+     CLEAR_ERRNO;					\
+     TYPE sovf = WRAP_STRTO (SFUNC, "NAN(9999999999"	\
+			     "99999999999999999999"	\
+			     "9999999999)");		\
+     CHECK_ERRNO (TYPE, sovf);				\
+     CHECK_IS_NAN (TYPE, sovf);				\
      if (CAN_TEST_EQ (MANT_DIG))			\
        CHECK_SAME_NAN (TYPE, n123, s123);		\
+     CHECK_PAYLOAD (TYPE, PLFUNC, n123, 123);		\
+     CHECK_PAYLOAD (TYPE, PLFUNC, s123, 123);		\
      if (CAN_TEST_EQ (MANT_DIG))			\
        CHECK_SAME_NAN (TYPE, n456, s456);		\
+     CHECK_PAYLOAD (TYPE, PLFUNC, n456, 456);		\
+     CHECK_PAYLOAD (TYPE, PLFUNC, s456, 456);		\
+     if (CAN_TEST_EQ (MANT_DIG))			\
+       CHECK_SAME_NAN (TYPE, nh123, sh123);		\
+     CHECK_PAYLOAD (TYPE, PLFUNC, nh123, 0x123);	\
+     CHECK_PAYLOAD (TYPE, PLFUNC, sh123, 0x123);	\
      if (CAN_TEST_EQ (MANT_DIG))			\
        CHECK_SAME_NAN (TYPE, nemp, semp);		\
      if (CAN_TEST_EQ (MANT_DIG))			\
@@ -110,9 +190,31 @@ static int
 do_test (void)
 {
   int result = 0;
-  RUN_TESTS (float, strtof, nanf, FLT_MANT_DIG);
-  RUN_TESTS (double, strtod, nan, DBL_MANT_DIG);
-  RUN_TESTS (long double, strtold, nanl, LDBL_MANT_DIG);
+  RUN_TESTS (float, strtof, nanf, getpayloadf, FLT_MANT_DIG);
+  RUN_TESTS (double, strtod, nan, getpayload, DBL_MANT_DIG);
+  RUN_TESTS (long double, strtold, nanl, getpayloadl, LDBL_MANT_DIG);
+#if __HAVE_FLOAT16
+  RUN_TESTS (_Float16, strtof16, nanf16, getpayloadf16, FLT16_MANT_DIG);
+#endif
+#if __HAVE_FLOAT32
+  RUN_TESTS (_Float32, strtof32, nanf32, getpayloadf32, FLT32_MANT_DIG);
+#endif
+#if __HAVE_FLOAT64
+  RUN_TESTS (_Float64, strtof64, nanf64, getpayloadf64, FLT64_MANT_DIG);
+#endif
+#if __HAVE_FLOAT128
+  RUN_TESTS (_Float128, strtof128, nanf128, getpayloadf128, FLT128_MANT_DIG);
+#endif
+#if __HAVE_FLOAT32X
+  RUN_TESTS (_Float32x, strtof32x, nanf32x, getpayloadf32x, FLT32X_MANT_DIG);
+#endif
+#if __HAVE_FLOAT64X
+  RUN_TESTS (_Float64x, strtof64x, nanf64x, getpayloadf64x, FLT64X_MANT_DIG);
+#endif
+#if __HAVE_FLOAT128X
+  RUN_TESTS (_Float128x, strtof128x, nanf128x, getpayloadf128x,
+	     FLT128X_MANT_DIG);
+#endif
   return result;
 }
 
diff --git a/math/test-tgmath2.c b/math/test-tgmath2.c
index 37afa8a08a..4aeb877b8e 100644
--- a/math/test-tgmath2.c
+++ b/math/test-tgmath2.c
@@ -24,6 +24,8 @@
 #include <string.h>
 #include <tgmath.h>
 
+#include <support/check.h>
+
 //#define DEBUG
 
 typedef complex float cfloat;
@@ -87,13 +89,6 @@ enum
 int count;
 int counts[Tlast][C_last];
 
-#define FAIL(str) \
-  do								\
-    {								\
-      printf ("%s failure on line %d\n", (str), __LINE__);	\
-      result = 1;						\
-    }								\
-  while (0)
 #define TEST_TYPE_ONLY(expr, rettype) \
   do								\
     {								\
@@ -133,8 +128,6 @@ int counts[Tlast][C_last];
 int
 test_cos (const int Vint4, const long long int Vllong4)
 {
-  int result = 0;
-
   TEST (cos (vfloat1), float, cos);
   TEST (cos (vdouble1), double, cos);
   TEST (cos (vldouble1), ldouble, cos);
@@ -152,7 +145,7 @@ test_cos (const int Vint4, const long long int Vllong4)
   TEST (cos (Vcdouble1), cdouble, cos);
   TEST (cos (Vcldouble1), cldouble, cos);
 
-  return result;
+  return 0;
 }
 
 int
diff --git a/misc/Makefile b/misc/Makefile
index c273ec6974..235fc7eacb 100644
--- a/misc/Makefile
+++ b/misc/Makefile
@@ -251,6 +251,8 @@ tests := \
   tst-mntent-blank-passno \
   tst-mntent-escape \
   tst-mntent2 \
+  tst-mremap1 \
+  tst-mremap2 \
   tst-preadvwritev \
   tst-preadvwritev2 \
   tst-preadvwritev64 \
diff --git a/misc/sys/cdefs.h b/misc/sys/cdefs.h
index 520231dbea..399ee7d24c 100644
--- a/misc/sys/cdefs.h
+++ b/misc/sys/cdefs.h
@@ -720,4 +720,13 @@ _Static_assert (0, "IEEE 128-bits long double requires redirection on this platf
 # define __attribute_returns_twice__ /* Ignore.  */
 #endif
 
+/* Mark struct types as aliasable.  Restricted to compilers that
+   support forward declarations of structs in the presence of the
+   attribute.  */
+#if __GNUC_PREREQ (7, 1) || defined __clang__
+# define __attribute_struct_may_alias__ __attribute__ ((__may_alias__))
+#else
+# define __attribute_struct_may_alias__
+#endif
+
 #endif	 /* sys/cdefs.h */
diff --git a/misc/sys/ioctl.h b/misc/sys/ioctl.h
index 3f2338ddd3..ea6583e122 100644
--- a/misc/sys/ioctl.h
+++ b/misc/sys/ioctl.h
@@ -38,7 +38,7 @@ __BEGIN_DECLS
 /* Perform the I/O control operation specified by REQUEST on FD.
    One argument may follow; its presence and type depend on REQUEST.
    Return value depends on REQUEST.  Usually -1 indicates error.  */
-#ifndef __USE_TIME_BITS64
+#ifndef __USE_TIME64_REDIRECTS
 extern int ioctl (int __fd, unsigned long int __request, ...) __THROW;
 #else
 # ifdef __REDIRECT
diff --git a/misc/sys/select.h b/misc/sys/select.h
index e6a0c1b8b2..2e45e94bc1 100644
--- a/misc/sys/select.h
+++ b/misc/sys/select.h
@@ -98,7 +98,7 @@ __BEGIN_DECLS
 
    This function is a cancellation point and therefore not marked with
    __THROW.  */
-#ifndef __USE_TIME_BITS64
+#ifndef __USE_TIME64_REDIRECTS
 extern int select (int __nfds, fd_set *__restrict __readfds,
 		   fd_set *__restrict __writefds,
 		   fd_set *__restrict __exceptfds,
@@ -123,7 +123,7 @@ extern int __REDIRECT (select,
 
    This function is a cancellation point and therefore not marked with
    __THROW.  */
-# ifndef __USE_TIME_BITS64
+# ifndef __USE_TIME64_REDIRECTS
 extern int pselect (int __nfds, fd_set *__restrict __readfds,
 		    fd_set *__restrict __writefds,
 		    fd_set *__restrict __exceptfds,
diff --git a/misc/tst-mremap1.c b/misc/tst-mremap1.c
new file mode 100644
index 0000000000..0469991a6c
--- /dev/null
+++ b/misc/tst-mremap1.c
@@ -0,0 +1,46 @@
+/* Test mremap with MREMAP_MAYMOVE.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <sys/mman.h>
+#include <support/xstdlib.h>
+#include <support/xunistd.h>
+#include <support/check.h>
+#include <support/test-driver.h>
+
+static int
+do_test (void)
+{
+  size_t old_size = getpagesize ();
+  char *old_addr = xmmap (NULL, old_size, PROT_READ | PROT_WRITE,
+			  MAP_PRIVATE | MAP_ANONYMOUS, -1);
+  old_addr[0] = 1;
+  old_addr[old_size - 1] = 2;
+
+  /* Test MREMAP_MAYMOVE.  */
+  size_t new_size = old_size + old_size;
+  char *new_addr = mremap (old_addr, old_size, new_size, MREMAP_MAYMOVE);
+  TEST_VERIFY_EXIT (new_addr != MAP_FAILED);
+  new_addr[0] = 1;
+  new_addr[new_size - 1] = 2;
+  xmunmap (new_addr, new_size);
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/misc/tst-mremap2.c b/misc/tst-mremap2.c
new file mode 100644
index 0000000000..45be7f0369
--- /dev/null
+++ b/misc/tst-mremap2.c
@@ -0,0 +1,54 @@
+/* Test mremap with MREMAP_FIXED.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <sys/mman.h>
+#include <support/xstdlib.h>
+#include <support/xunistd.h>
+#include <support/test-driver.h>
+#include <mremap-failure.h>
+
+static int
+do_test (void)
+{
+  size_t old_size = getpagesize ();
+  size_t new_size = old_size + old_size;
+  char *old_addr = xmmap (NULL, old_size, PROT_READ | PROT_WRITE,
+			  MAP_PRIVATE | MAP_ANONYMOUS, -1);
+  old_addr[0] = 1;
+  old_addr[old_size - 1] = 2;
+
+  char *fixed_addr = xmmap (NULL, new_size, PROT_READ | PROT_WRITE,
+			    MAP_PRIVATE | MAP_ANONYMOUS, -1);
+  fixed_addr[0] = 1;
+  fixed_addr[new_size - 1] = 2;
+
+  /* Test MREMAP_FIXED.  */
+  char *new_addr = mremap (old_addr, old_size, new_size,
+			   MREMAP_FIXED | MREMAP_MAYMOVE,
+			   fixed_addr);
+  if (new_addr == MAP_FAILED)
+    return mremap_failure_exit (errno);
+  new_addr[0] = 1;
+  new_addr[new_size - 1] = 2;
+  xmunmap (new_addr, new_size);
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/misc/tst-preadvwritev2-common.c b/misc/tst-preadvwritev2-common.c
index b5f19f002c..8e04ff7282 100644
--- a/misc/tst-preadvwritev2-common.c
+++ b/misc/tst-preadvwritev2-common.c
@@ -34,8 +34,11 @@
 #ifndef RWF_APPEND
 # define RWF_APPEND 0
 #endif
+#ifndef RWF_NOAPPEND
+# define RWF_NOAPPEND 0
+#endif
 #define RWF_SUPPORTED	(RWF_HIPRI | RWF_DSYNC | RWF_SYNC | RWF_NOWAIT \
-			 | RWF_APPEND)
+			 | RWF_APPEND | RWF_NOAPPEND)
 
 /* Generic uio_lim.h does not define IOV_MAX.  */
 #ifndef IOV_MAX
diff --git a/nptl/allocatestack.c b/nptl/allocatestack.c
index f35a8369bd..2cb562f8ea 100644
--- a/nptl/allocatestack.c
+++ b/nptl/allocatestack.c
@@ -139,7 +139,7 @@ get_cached_stack (size_t *sizep, void **memp)
   memset (dtv, '\0', (dtv[-1].counter + 1) * sizeof (dtv_t));
 
   /* Re-initialize the TLS.  */
-  _dl_allocate_tls_init (TLS_TPADJ (result), true);
+  _dl_allocate_tls_init (TLS_TPADJ (result), false);
 
   return result;
 }
diff --git a/nptl/descr.h b/nptl/descr.h
index 8cef95810c..c4bdd7757a 100644
--- a/nptl/descr.h
+++ b/nptl/descr.h
@@ -414,6 +414,8 @@ struct pthread
     {
       uint32_t cpu_id_start;
       uint32_t cpu_id;
+      uint64_t rseq_cs;
+      uint32_t flags;
     };
     char pad[32];		/* Original rseq area size.  */
   } rseq_area __attribute__ ((aligned (32)));
diff --git a/nptl/pthread_cond_broadcast.c b/nptl/pthread_cond_broadcast.c
index aada91639a..51afa62adf 100644
--- a/nptl/pthread_cond_broadcast.c
+++ b/nptl/pthread_cond_broadcast.c
@@ -57,10 +57,10 @@ ___pthread_cond_broadcast (pthread_cond_t *cond)
     {
       /* Add as many signals as the remaining size of the group.  */
       atomic_fetch_add_relaxed (cond->__data.__g_signals + g1,
-				cond->__data.__g_size[g1] << 1);
+				cond->__data.__g_size[g1]);
       cond->__data.__g_size[g1] = 0;
 
-      /* We need to wake G1 waiters before we quiesce G1 below.  */
+      /* We need to wake G1 waiters before we switch G1 below.  */
       /* TODO Only set it if there are indeed futex waiters.  We could
 	 also try to move this out of the critical section in cases when
 	 G2 is empty (and we don't need to quiesce).  */
@@ -69,11 +69,11 @@ ___pthread_cond_broadcast (pthread_cond_t *cond)
 
   /* G1 is complete.  Step (2) is next unless there are no waiters in G2, in
      which case we can stop.  */
-  if (__condvar_quiesce_and_switch_g1 (cond, wseq, &g1, private))
+  if (__condvar_switch_g1 (cond, wseq, &g1, private))
     {
       /* Step (3): Send signals to all waiters in the old G2 / new G1.  */
       atomic_fetch_add_relaxed (cond->__data.__g_signals + g1,
-				cond->__data.__g_size[g1] << 1);
+				cond->__data.__g_size[g1]);
       cond->__data.__g_size[g1] = 0;
       /* TODO Only set it if there are indeed futex waiters.  */
       do_futex_wake = true;
diff --git a/nptl/pthread_cond_common.c b/nptl/pthread_cond_common.c
index 3487557bb8..389402913c 100644
--- a/nptl/pthread_cond_common.c
+++ b/nptl/pthread_cond_common.c
@@ -189,19 +189,17 @@ __condvar_get_private (int flags)
     return FUTEX_SHARED;
 }
 
-/* This closes G1 (whose index is in G1INDEX), waits for all futex waiters to
-   leave G1, converts G1 into a fresh G2, and then switches group roles so that
-   the former G2 becomes the new G1 ending at the current __wseq value when we
-   eventually make the switch (WSEQ is just an observation of __wseq by the
-   signaler).
+/* This closes G1 (whose index is in G1INDEX), converts G1 into a fresh G2,
+   and then switches group roles so that the former G2 becomes the new G1
+   ending at the current __wseq value when we eventually make the switch
+   (WSEQ is just an observation of __wseq by the signaler).
    If G2 is empty, it will not switch groups because then it would create an
    empty G1 which would require switching groups again on the next signal.
    Returns false iff groups were not switched because G2 was empty.  */
 static bool __attribute__ ((unused))
-__condvar_quiesce_and_switch_g1 (pthread_cond_t *cond, uint64_t wseq,
+__condvar_switch_g1 (pthread_cond_t *cond, uint64_t wseq,
     unsigned int *g1index, int private)
 {
-  const unsigned int maxspin = 0;
   unsigned int g1 = *g1index;
 
   /* If there is no waiter in G2, we don't do anything.  The expression may
@@ -210,96 +208,23 @@ __condvar_quiesce_and_switch_g1 (pthread_cond_t *cond, uint64_t wseq,
      behavior.
      Note that this works correctly for a zero-initialized condvar too.  */
   unsigned int old_orig_size = __condvar_get_orig_size (cond);
-  uint64_t old_g1_start = __condvar_load_g1_start_relaxed (cond) >> 1;
-  if (((unsigned) (wseq - old_g1_start - old_orig_size)
-	  + cond->__data.__g_size[g1 ^ 1]) == 0)
+  uint64_t old_g1_start = __condvar_load_g1_start_relaxed (cond);
+  uint64_t new_g1_start = old_g1_start + old_orig_size;
+  if (((unsigned) (wseq - new_g1_start) + cond->__data.__g_size[g1 ^ 1]) == 0)
 	return false;
 
-  /* Now try to close and quiesce G1.  We have to consider the following kinds
-     of waiters:
+  /* We have to consider the following kinds of waiters:
      * Waiters from less recent groups than G1 are not affected because
        nothing will change for them apart from __g1_start getting larger.
      * New waiters arriving concurrently with the group switching will all go
        into G2 until we atomically make the switch.  Waiters existing in G2
        are not affected.
-     * Waiters in G1 will be closed out immediately by setting a flag in
-       __g_signals, which will prevent waiters from blocking using a futex on
-       __g_signals and also notifies them that the group is closed.  As a
-       result, they will eventually remove their group reference, allowing us
-       to close switch group roles.  */
+     * Waiters in G1 have already received a signal and been woken.  */
 
-  /* First, set the closed flag on __g_signals.  This tells waiters that are
-     about to wait that they shouldn't do that anymore.  This basically
-     serves as an advance notification of the upcoming change to __g1_start;
-     waiters interpret it as if __g1_start was larger than their waiter
-     sequence position.  This allows us to change __g1_start after waiting
-     for all existing waiters with group references to leave, which in turn
-     makes recovery after stealing a signal simpler because it then can be
-     skipped if __g1_start indicates that the group is closed (otherwise,
-     we would have to recover always because waiters don't know how big their
-     groups are).  Relaxed MO is fine.  */
-  atomic_fetch_or_relaxed (cond->__data.__g_signals + g1, 1);
-
-  /* Wait until there are no group references anymore.  The fetch-or operation
-     injects us into the modification order of __g_refs; release MO ensures
-     that waiters incrementing __g_refs after our fetch-or see the previous
-     changes to __g_signals and to __g1_start that had to happen before we can
-     switch this G1 and alias with an older group (we have two groups, so
-     aliasing requires switching group roles twice).  Note that nobody else
-     can have set the wake-request flag, so we do not have to act upon it.
-
-     Also note that it is harmless if older waiters or waiters from this G1
-     get a group reference after we have quiesced the group because it will
-     remain closed for them either because of the closed flag in __g_signals
-     or the later update to __g1_start.  New waiters will never arrive here
-     but instead continue to go into the still current G2.  */
-  unsigned r = atomic_fetch_or_release (cond->__data.__g_refs + g1, 0);
-  while ((r >> 1) > 0)
-    {
-      for (unsigned int spin = maxspin; ((r >> 1) > 0) && (spin > 0); spin--)
-	{
-	  /* TODO Back off.  */
-	  r = atomic_load_relaxed (cond->__data.__g_refs + g1);
-	}
-      if ((r >> 1) > 0)
-	{
-	  /* There is still a waiter after spinning.  Set the wake-request
-	     flag and block.  Relaxed MO is fine because this is just about
-	     this futex word.
-
-	     Update r to include the set wake-request flag so that the upcoming
-	     futex_wait only blocks if the flag is still set (otherwise, we'd
-	     violate the basic client-side futex protocol).  */
-	  r = atomic_fetch_or_relaxed (cond->__data.__g_refs + g1, 1) | 1;
-
-	  if ((r >> 1) > 0)
-	    futex_wait_simple (cond->__data.__g_refs + g1, r, private);
-	  /* Reload here so we eventually see the most recent value even if we
-	     do not spin.   */
-	  r = atomic_load_relaxed (cond->__data.__g_refs + g1);
-	}
-    }
-  /* Acquire MO so that we synchronize with the release operation that waiters
-     use to decrement __g_refs and thus happen after the waiters we waited
-     for.  */
-  atomic_thread_fence_acquire ();
-
-  /* Update __g1_start, which finishes closing this group.  The value we add
-     will never be negative because old_orig_size can only be zero when we
-     switch groups the first time after a condvar was initialized, in which
-     case G1 will be at index 1 and we will add a value of 1.  See above for
-     why this takes place after waiting for quiescence of the group.
-     Relaxed MO is fine because the change comes with no additional
-     constraints that others would have to observe.  */
-  __condvar_add_g1_start_relaxed (cond,
-      (old_orig_size << 1) + (g1 == 1 ? 1 : - 1));
-
-  /* Now reopen the group, thus enabling waiters to again block using the
-     futex controlled by __g_signals.  Release MO so that observers that see
-     no signals (and thus can block) also see the write __g1_start and thus
-     that this is now a new group (see __pthread_cond_wait_common for the
-     matching acquire MO loads).  */
-  atomic_store_release (cond->__data.__g_signals + g1, 0);
+  /* Update __g1_start, which closes this group.  Relaxed MO is fine because
+     the change comes with no additional constraints that others would have
+     to observe.  */
+  __condvar_add_g1_start_relaxed (cond, old_orig_size);
 
   /* At this point, the old G1 is now a valid new G2 (but not in use yet).
      No old waiter can neither grab a signal nor acquire a reference without
@@ -311,9 +236,13 @@ __condvar_quiesce_and_switch_g1 (pthread_cond_t *cond, uint64_t wseq,
   g1 ^= 1;
   *g1index ^= 1;
 
+  /* Now advance the new G1 g_signals to the new g1_start, giving it
+     an effective signal count of 0 to start.  */
+  atomic_store_release (cond->__data.__g_signals + g1, (unsigned)new_g1_start);
+
   /* These values are just observed by signalers, and thus protected by the
      lock.  */
-  unsigned int orig_size = wseq - (old_g1_start + old_orig_size);
+  unsigned int orig_size = wseq - new_g1_start;
   __condvar_set_orig_size (cond, orig_size);
   /* Use and addition to not loose track of cancellations in what was
      previously G2.  */
diff --git a/nptl/pthread_cond_signal.c b/nptl/pthread_cond_signal.c
index 43d6286ecd..fa3a5c3d8f 100644
--- a/nptl/pthread_cond_signal.c
+++ b/nptl/pthread_cond_signal.c
@@ -69,19 +69,18 @@ ___pthread_cond_signal (pthread_cond_t *cond)
   bool do_futex_wake = false;
 
   /* If G1 is still receiving signals, we put the signal there.  If not, we
-     check if G2 has waiters, and if so, quiesce and switch G1 to the former
-     G2; if this results in a new G1 with waiters (G2 might have cancellations
-     already, see __condvar_quiesce_and_switch_g1), we put the signal in the
-     new G1.  */
+     check if G2 has waiters, and if so, switch G1 to the former G2; if this
+     results in a new G1 with waiters (G2 might have cancellations already,
+     see __condvar_switch_g1), we put the signal in the new G1. */
   if ((cond->__data.__g_size[g1] != 0)
-      || __condvar_quiesce_and_switch_g1 (cond, wseq, &g1, private))
+      || __condvar_switch_g1 (cond, wseq, &g1, private))
     {
       /* Add a signal.  Relaxed MO is fine because signaling does not need to
-	 establish a happens-before relation (see above).  We do not mask the
-	 release-MO store when initializing a group in
-	 __condvar_quiesce_and_switch_g1 because we use an atomic
-	 read-modify-write and thus extend that store's release sequence.  */
-      atomic_fetch_add_relaxed (cond->__data.__g_signals + g1, 2);
+         establish a happens-before relation (see above).  We do not mask the
+         release-MO store when initializing a group in __condvar_switch_g1
+         because we use an atomic read-modify-write and thus extend that
+         store's release sequence.  */
+      atomic_fetch_add_relaxed (cond->__data.__g_signals + g1, 1);
       cond->__data.__g_size[g1]--;
       /* TODO Only set it if there are indeed futex waiters.  */
       do_futex_wake = true;
diff --git a/nptl/pthread_cond_wait.c b/nptl/pthread_cond_wait.c
index 66786c7b90..0f1dfcb595 100644
--- a/nptl/pthread_cond_wait.c
+++ b/nptl/pthread_cond_wait.c
@@ -84,7 +84,7 @@ __condvar_cancel_waiting (pthread_cond_t *cond, uint64_t seq, unsigned int g,
      not hold a reference on the group.  */
   __condvar_acquire_lock (cond, private);
 
-  uint64_t g1_start = __condvar_load_g1_start_relaxed (cond) >> 1;
+  uint64_t g1_start = __condvar_load_g1_start_relaxed (cond);
   if (g1_start > seq)
     {
       /* Our group is closed, so someone provided enough signals for it.
@@ -143,23 +143,6 @@ __condvar_cancel_waiting (pthread_cond_t *cond, uint64_t seq, unsigned int g,
     }
 }
 
-/* Wake up any signalers that might be waiting.  */
-static void
-__condvar_dec_grefs (pthread_cond_t *cond, unsigned int g, int private)
-{
-  /* Release MO to synchronize-with the acquire load in
-     __condvar_quiesce_and_switch_g1.  */
-  if (atomic_fetch_add_release (cond->__data.__g_refs + g, -2) == 3)
-    {
-      /* Clear the wake-up request flag before waking up.  We do not need more
-	 than relaxed MO and it doesn't matter if we apply this for an aliased
-	 group because we wake all futex waiters right after clearing the
-	 flag.  */
-      atomic_fetch_and_relaxed (cond->__data.__g_refs + g, ~(unsigned int) 1);
-      futex_wake (cond->__data.__g_refs + g, INT_MAX, private);
-    }
-}
-
 /* Clean-up for cancellation of waiters waiting for normal signals.  We cancel
    our registration as a waiter, confirm we have woken up, and re-acquire the
    mutex.  */
@@ -171,8 +154,6 @@ __condvar_cleanup_waiting (void *arg)
   pthread_cond_t *cond = cbuffer->cond;
   unsigned g = cbuffer->wseq & 1;
 
-  __condvar_dec_grefs (cond, g, cbuffer->private);
-
   __condvar_cancel_waiting (cond, cbuffer->wseq >> 1, g, cbuffer->private);
   /* FIXME With the current cancellation implementation, it is possible that
      a thread is cancelled after it has returned from a syscall.  This could
@@ -238,9 +219,7 @@ __condvar_cleanup_waiting (void *arg)
    signaled), and a reference count.
 
    The group reference count is used to maintain the number of waiters that
-   are using the group's futex.  Before a group can change its role, the
-   reference count must show that no waiters are using the futex anymore; this
-   prevents ABA issues on the futex word.
+   are using the group's futex.
 
    To represent which intervals in the waiter sequence the groups cover (and
    thus also which group slot contains G1 or G2), we use a 64b counter to
@@ -251,7 +230,7 @@ __condvar_cleanup_waiting (void *arg)
    figure out whether they are in a group that has already been completely
    signaled (i.e., if the current G1 starts at a later position that the
    waiter's position).  Waiters cannot determine whether they are currently
-   in G2 or G1 -- but they do not have too because all they are interested in
+   in G2 or G1 -- but they do not have to because all they are interested in
    is whether there are available signals, and they always start in G2 (whose
    group slot they know because of the bit in the waiter sequence.  Signalers
    will simply fill the right group until it is completely signaled and can
@@ -280,7 +259,6 @@ __condvar_cleanup_waiting (void *arg)
      * Waiters fetch-add while having acquire the mutex associated with the
        condvar.  Signalers load it and fetch-xor it concurrently.
    __g1_start: Starting position of G1 (inclusive)
-     * LSB is index of current G2.
      * Modified by signalers while having acquired the condvar-internal lock
        and observed concurrently by waiters.
    __g1_orig_size: Initial size of G1
@@ -300,11 +278,10 @@ __condvar_cleanup_waiting (void *arg)
        last reference.
      * Reference count used by waiters concurrently with signalers that have
        acquired the condvar-internal lock.
-   __g_signals: The number of signals that can still be consumed.
+   __g_signals: The number of signals that can still be consumed, relative to
+     the current g1_start.  (i.e. g1_start with the signal count added)
      * Used as a futex word by waiters.  Used concurrently by waiters and
        signalers.
-     * LSB is true iff this group has been completely signaled (i.e., it is
-       closed).
    __g_size: Waiters remaining in this group (i.e., which have not been
      signaled yet.
      * Accessed by signalers and waiters that cancel waiting (both do so only
@@ -328,27 +305,6 @@ __condvar_cleanup_waiting (void *arg)
    sufficient because if a waiter can see a sufficiently large value, it could
    have also consume a signal in the waiters group.
 
-   Waiters try to grab a signal from __g_signals without holding a reference
-   count, which can lead to stealing a signal from a more recent group after
-   their own group was already closed.  They cannot always detect whether they
-   in fact did because they do not know when they stole, but they can
-   conservatively add a signal back to the group they stole from; if they
-   did so unnecessarily, all that happens is a spurious wake-up.  To make this
-   even less likely, __g1_start contains the index of the current g2 too,
-   which allows waiters to check if there aliasing on the group slots; if
-   there wasn't, they didn't steal from the current G1, which means that the
-   G1 they stole from must have been already closed and they do not need to
-   fix anything.
-
-   It is essential that the last field in pthread_cond_t is __g_signals[1]:
-   The previous condvar used a pointer-sized field in pthread_cond_t, so a
-   PTHREAD_COND_INITIALIZER from that condvar implementation might only
-   initialize 4 bytes to zero instead of the 8 bytes we need (i.e., 44 bytes
-   in total instead of the 48 we need).  __g_signals[1] is not accessed before
-   the first group switch (G2 starts at index 0), which will set its value to
-   zero after a harmless fetch-or whose return value is ignored.  This
-   effectively completes initialization.
-
 
    Limitations:
    * This condvar isn't designed to allow for more than
@@ -379,7 +335,6 @@ static __always_inline int
 __pthread_cond_wait_common (pthread_cond_t *cond, pthread_mutex_t *mutex,
     clockid_t clockid, const struct __timespec64 *abstime)
 {
-  const int maxspin = 0;
   int err;
   int result = 0;
 
@@ -396,8 +351,7 @@ __pthread_cond_wait_common (pthread_cond_t *cond, pthread_mutex_t *mutex,
      because we do not need to establish any happens-before relation with
      signalers (see __pthread_cond_signal); modification order alone
      establishes a total order of waiters/signals.  We do need acquire MO
-     to synchronize with group reinitialization in
-     __condvar_quiesce_and_switch_g1.  */
+     to synchronize with group reinitialization in __condvar_switch_g1.  */
   uint64_t wseq = __condvar_fetch_add_wseq_acquire (cond, 2);
   /* Find our group's index.  We always go into what was G2 when we acquired
      our position.  */
@@ -424,178 +378,64 @@ __pthread_cond_wait_common (pthread_cond_t *cond, pthread_mutex_t *mutex,
       return err;
     }
 
-  /* Now wait until a signal is available in our group or it is closed.
-     Acquire MO so that if we observe a value of zero written after group
-     switching in __condvar_quiesce_and_switch_g1, we synchronize with that
-     store and will see the prior update of __g1_start done while switching
-     groups too.  */
-  unsigned int signals = atomic_load_acquire (cond->__data.__g_signals + g);
 
-  do
+  while (1)
     {
-      while (1)
-	{
-	  /* Spin-wait first.
-	     Note that spinning first without checking whether a timeout
-	     passed might lead to what looks like a spurious wake-up even
-	     though we should return ETIMEDOUT (e.g., if the caller provides
-	     an absolute timeout that is clearly in the past).  However,
-	     (1) spurious wake-ups are allowed, (2) it seems unlikely that a
-	     user will (ab)use pthread_cond_wait as a check for whether a
-	     point in time is in the past, and (3) spinning first without
-	     having to compare against the current time seems to be the right
-	     choice from a performance perspective for most use cases.  */
-	  unsigned int spin = maxspin;
-	  while (signals == 0 && spin > 0)
-	    {
-	      /* Check that we are not spinning on a group that's already
-		 closed.  */
-	      if (seq < (__condvar_load_g1_start_relaxed (cond) >> 1))
-		goto done;
-
-	      /* TODO Back off.  */
-
-	      /* Reload signals.  See above for MO.  */
-	      signals = atomic_load_acquire (cond->__data.__g_signals + g);
-	      spin--;
-	    }
-
-	  /* If our group will be closed as indicated by the flag on signals,
-	     don't bother grabbing a signal.  */
-	  if (signals & 1)
-	    goto done;
-
-	  /* If there is an available signal, don't block.  */
-	  if (signals != 0)
-	    break;
-
-	  /* No signals available after spinning, so prepare to block.
-	     We first acquire a group reference and use acquire MO for that so
-	     that we synchronize with the dummy read-modify-write in
-	     __condvar_quiesce_and_switch_g1 if we read from that.  In turn,
-	     in this case this will make us see the closed flag on __g_signals
-	     that designates a concurrent attempt to reuse the group's slot.
-	     We use acquire MO for the __g_signals check to make the
-	     __g1_start check work (see spinning above).
-	     Note that the group reference acquisition will not mask the
-	     release MO when decrementing the reference count because we use
-	     an atomic read-modify-write operation and thus extend the release
-	     sequence.  */
-	  atomic_fetch_add_acquire (cond->__data.__g_refs + g, 2);
-	  if (((atomic_load_acquire (cond->__data.__g_signals + g) & 1) != 0)
-	      || (seq < (__condvar_load_g1_start_relaxed (cond) >> 1)))
-	    {
-	      /* Our group is closed.  Wake up any signalers that might be
-		 waiting.  */
-	      __condvar_dec_grefs (cond, g, private);
-	      goto done;
-	    }
-
-	  // Now block.
-	  struct _pthread_cleanup_buffer buffer;
-	  struct _condvar_cleanup_buffer cbuffer;
-	  cbuffer.wseq = wseq;
-	  cbuffer.cond = cond;
-	  cbuffer.mutex = mutex;
-	  cbuffer.private = private;
-	  __pthread_cleanup_push (&buffer, __condvar_cleanup_waiting, &cbuffer);
-
-	  err = __futex_abstimed_wait_cancelable64 (
-	    cond->__data.__g_signals + g, 0, clockid, abstime, private);
-
-	  __pthread_cleanup_pop (&buffer, 0);
-
-	  if (__glibc_unlikely (err == ETIMEDOUT || err == EOVERFLOW))
-	    {
-	      __condvar_dec_grefs (cond, g, private);
-	      /* If we timed out, we effectively cancel waiting.  Note that
-		 we have decremented __g_refs before cancellation, so that a
-		 deadlock between waiting for quiescence of our group in
-		 __condvar_quiesce_and_switch_g1 and us trying to acquire
-		 the lock during cancellation is not possible.  */
-	      __condvar_cancel_waiting (cond, seq, g, private);
-	      result = err;
-	      goto done;
-	    }
-	  else
-	    __condvar_dec_grefs (cond, g, private);
-
-	  /* Reload signals.  See above for MO.  */
-	  signals = atomic_load_acquire (cond->__data.__g_signals + g);
+      /* Now wait until a signal is available in our group or it is closed.
+         Acquire MO so that if we observe (signals == lowseq) after group
+         switching in __condvar_switch_g1, we synchronize with that store and
+         will see the prior update of __g1_start done while switching groups
+         too.  */
+      unsigned int signals = atomic_load_acquire (cond->__data.__g_signals + g);
+      uint64_t g1_start = __condvar_load_g1_start_relaxed (cond);
+
+      if (seq < g1_start)
+        {
+          /* If the group is closed already,
+             then this waiter originally had enough extra signals to
+             consume, up until the time its group was closed.  */
+           break;
+        }
+
+      /* If there is an available signal, don't block.
+         If __g1_start has advanced at all, then we must be in G1
+         by now, perhaps in the process of switching back to an older
+         G2, but in either case we're allowed to consume the available
+         signal and should not block anymore.  */
+      if ((int)(signals - (unsigned int)g1_start) > 0)
+        {
+	  /* Try to grab a signal.  See above for MO.  (if we do another loop
+	     iteration we need to see the correct value of g1_start)  */
+	    if (atomic_compare_exchange_weak_acquire (
+			cond->__data.__g_signals + g,
+			&signals, signals - 1))
+	      break;
+	    else
+	      continue;
 	}
 
+      // Now block.
+      struct _pthread_cleanup_buffer buffer;
+      struct _condvar_cleanup_buffer cbuffer;
+      cbuffer.wseq = wseq;
+      cbuffer.cond = cond;
+      cbuffer.mutex = mutex;
+      cbuffer.private = private;
+      __pthread_cleanup_push (&buffer, __condvar_cleanup_waiting, &cbuffer);
+
+      err = __futex_abstimed_wait_cancelable64 (
+        cond->__data.__g_signals + g, signals, clockid, abstime, private);
+
+      __pthread_cleanup_pop (&buffer, 0);
+
+      if (__glibc_unlikely (err == ETIMEDOUT || err == EOVERFLOW))
+        {
+          /* If we timed out, we effectively cancel waiting.  */
+          __condvar_cancel_waiting (cond, seq, g, private);
+          result = err;
+          break;
+        }
     }
-  /* Try to grab a signal.  Use acquire MO so that we see an up-to-date value
-     of __g1_start below (see spinning above for a similar case).  In
-     particular, if we steal from a more recent group, we will also see a
-     more recent __g1_start below.  */
-  while (!atomic_compare_exchange_weak_acquire (cond->__data.__g_signals + g,
-						&signals, signals - 2));
-
-  /* We consumed a signal but we could have consumed from a more recent group
-     that aliased with ours due to being in the same group slot.  If this
-     might be the case our group must be closed as visible through
-     __g1_start.  */
-  uint64_t g1_start = __condvar_load_g1_start_relaxed (cond);
-  if (seq < (g1_start >> 1))
-    {
-      /* We potentially stole a signal from a more recent group but we do not
-	 know which group we really consumed from.
-	 We do not care about groups older than current G1 because they are
-	 closed; we could have stolen from these, but then we just add a
-	 spurious wake-up for the current groups.
-	 We will never steal a signal from current G2 that was really intended
-	 for G2 because G2 never receives signals (until it becomes G1).  We
-	 could have stolen a signal from G2 that was conservatively added by a
-	 previous waiter that also thought it stole a signal -- but given that
-	 that signal was added unnecessarily, it's not a problem if we steal
-	 it.
-	 Thus, the remaining case is that we could have stolen from the current
-	 G1, where "current" means the __g1_start value we observed.  However,
-	 if the current G1 does not have the same slot index as we do, we did
-	 not steal from it and do not need to undo that.  This is the reason
-	 for putting a bit with G2's index into__g1_start as well.  */
-      if (((g1_start & 1) ^ 1) == g)
-	{
-	  /* We have to conservatively undo our potential mistake of stealing
-	     a signal.  We can stop trying to do that when the current G1
-	     changes because other spinning waiters will notice this too and
-	     __condvar_quiesce_and_switch_g1 has checked that there are no
-	     futex waiters anymore before switching G1.
-	     Relaxed MO is fine for the __g1_start load because we need to
-	     merely be able to observe this fact and not have to observe
-	     something else as well.
-	     ??? Would it help to spin for a little while to see whether the
-	     current G1 gets closed?  This might be worthwhile if the group is
-	     small or close to being closed.  */
-	  unsigned int s = atomic_load_relaxed (cond->__data.__g_signals + g);
-	  while (__condvar_load_g1_start_relaxed (cond) == g1_start)
-	    {
-	      /* Try to add a signal.  We don't need to acquire the lock
-		 because at worst we can cause a spurious wake-up.  If the
-		 group is in the process of being closed (LSB is true), this
-		 has an effect similar to us adding a signal.  */
-	      if (((s & 1) != 0)
-		  || atomic_compare_exchange_weak_relaxed
-		       (cond->__data.__g_signals + g, &s, s + 2))
-		{
-		  /* If we added a signal, we also need to add a wake-up on
-		     the futex.  We also need to do that if we skipped adding
-		     a signal because the group is being closed because
-		     while __condvar_quiesce_and_switch_g1 could have closed
-		     the group, it might still be waiting for futex waiters to
-		     leave (and one of those waiters might be the one we stole
-		     the signal from, which cause it to block using the
-		     futex).  */
-		  futex_wake (cond->__data.__g_signals + g, 1, private);
-		  break;
-		}
-	      /* TODO Back off.  */
-	    }
-	}
-    }
-
- done:
 
   /* Confirm that we have been woken.  We do that before acquiring the mutex
      to allow for execution of pthread_cond_destroy while having acquired the
diff --git a/nptl/tst-cond22.c b/nptl/tst-cond22.c
index 1336e9c79d..bdcb45c536 100644
--- a/nptl/tst-cond22.c
+++ b/nptl/tst-cond22.c
@@ -106,13 +106,13 @@ do_test (void)
       status = 1;
     }
 
-  printf ("cond = { 0x%x:%x, 0x%x:%x, %u/%u/%u, %u/%u/%u, %u, %u }\n",
+  printf ("cond = { 0x%x:%x, 0x%x:%x, %u/%u, %u/%u, %u, %u }\n",
 	  c.__data.__wseq.__value32.__high,
 	  c.__data.__wseq.__value32.__low,
 	  c.__data.__g1_start.__value32.__high,
 	  c.__data.__g1_start.__value32.__low,
-	  c.__data.__g_signals[0], c.__data.__g_refs[0], c.__data.__g_size[0],
-	  c.__data.__g_signals[1], c.__data.__g_refs[1], c.__data.__g_size[1],
+	  c.__data.__g_signals[0], c.__data.__g_size[0],
+	  c.__data.__g_signals[1], c.__data.__g_size[1],
 	  c.__data.__g1_orig_size, c.__data.__wrefs);
 
   if (pthread_create (&th, NULL, tf, (void *) 1l) != 0)
@@ -152,13 +152,13 @@ do_test (void)
       status = 1;
     }
 
-  printf ("cond = { 0x%x:%x, 0x%x:%x, %u/%u/%u, %u/%u/%u, %u, %u }\n",
+  printf ("cond = { 0x%x:%x, 0x%x:%x, %u/%u, %u/%u, %u, %u }\n",
 	  c.__data.__wseq.__value32.__high,
 	  c.__data.__wseq.__value32.__low,
 	  c.__data.__g1_start.__value32.__high,
 	  c.__data.__g1_start.__value32.__low,
-	  c.__data.__g_signals[0], c.__data.__g_refs[0], c.__data.__g_size[0],
-	  c.__data.__g_signals[1], c.__data.__g_refs[1], c.__data.__g_size[1],
+	  c.__data.__g_signals[0], c.__data.__g_size[0],
+	  c.__data.__g_signals[1], c.__data.__g_size[1],
 	  c.__data.__g1_orig_size, c.__data.__wrefs);
 
   return status;
diff --git a/nscd/netgroupcache.c b/nscd/netgroupcache.c
index 0c6e46f15c..01d554af9c 100644
--- a/nscd/netgroupcache.c
+++ b/nscd/netgroupcache.c
@@ -23,6 +23,7 @@
 #include <stdlib.h>
 #include <unistd.h>
 #include <sys/mman.h>
+#include <scratch_buffer.h>
 
 #include "../nss/netgroup.h"
 #include "nscd.h"
@@ -65,6 +66,16 @@ struct dataset
   char strdata[0];
 };
 
+/* Send a notfound response to FD.  Always returns -1 to indicate an
+   ephemeral error.  */
+static time_t
+send_notfound (int fd)
+{
+  if (fd != -1)
+    TEMP_FAILURE_RETRY (send (fd, &notfound, sizeof (notfound), MSG_NOSIGNAL));
+  return -1;
+}
+
 /* Sends a notfound message and prepares a notfound dataset to write to the
    cache.  Returns true if there was enough memory to allocate the dataset and
    returns the dataset in DATASETP, total bytes to write in TOTALP and the
@@ -83,8 +94,7 @@ do_notfound (struct database_dyn *db, int fd, request_header *req,
   total = sizeof (notfound);
   timeout = time (NULL) + db->negtimeout;
 
-  if (fd != -1)
-    TEMP_FAILURE_RETRY (send (fd, &notfound, total, MSG_NOSIGNAL));
+  send_notfound (fd);
 
   dataset = mempool_alloc (db, sizeof (struct dataset) + req->key_len, 1);
   /* If we cannot permanently store the result, so be it.  */
@@ -109,11 +119,78 @@ do_notfound (struct database_dyn *db, int fd, request_header *req,
   return cacheable;
 }
 
+struct addgetnetgrentX_scratch
+{
+  /* This is the result that the caller should use.  It can be NULL,
+     point into buffer, or it can be in the cache.  */
+  struct dataset *dataset;
+
+  struct scratch_buffer buffer;
+
+  /* Used internally in addgetnetgrentX as a staging area.  */
+  struct scratch_buffer tmp;
+
+  /* Number of bytes in buffer that are actually used.  */
+  size_t buffer_used;
+};
+
+static void
+addgetnetgrentX_scratch_init (struct addgetnetgrentX_scratch *scratch)
+{
+  scratch->dataset = NULL;
+  scratch_buffer_init (&scratch->buffer);
+  scratch_buffer_init (&scratch->tmp);
+
+  /* Reserve space for the header.  */
+  scratch->buffer_used = sizeof (struct dataset);
+  static_assert (sizeof (struct dataset) < sizeof (scratch->tmp.__space),
+		 "initial buffer space");
+  memset (scratch->tmp.data, 0, sizeof (struct dataset));
+}
+
+static void
+addgetnetgrentX_scratch_free (struct addgetnetgrentX_scratch *scratch)
+{
+  scratch_buffer_free (&scratch->buffer);
+  scratch_buffer_free (&scratch->tmp);
+}
+
+/* Copy LENGTH bytes from S into SCRATCH.  Returns NULL if SCRATCH
+   could not be resized, otherwise a pointer to the copy.  */
+static char *
+addgetnetgrentX_append_n (struct addgetnetgrentX_scratch *scratch,
+			  const char *s, size_t length)
+{
+  while (true)
+    {
+      size_t remaining = scratch->buffer.length - scratch->buffer_used;
+      if (remaining >= length)
+	break;
+      if (!scratch_buffer_grow_preserve (&scratch->buffer))
+	return NULL;
+    }
+  char *copy = scratch->buffer.data + scratch->buffer_used;
+  memcpy (copy, s, length);
+  scratch->buffer_used += length;
+  return copy;
+}
+
+/* Copy S into SCRATCH, including its null terminator.  Returns false
+   if SCRATCH could not be resized.  */
+static bool
+addgetnetgrentX_append (struct addgetnetgrentX_scratch *scratch, const char *s)
+{
+  if (s == NULL)
+    s = "";
+  return addgetnetgrentX_append_n (scratch, s, strlen (s) + 1) != NULL;
+}
+
+/* Caller must initialize and free *SCRATCH.  If the return value is
+   negative, this function has sent a notfound response.  */
 static time_t
 addgetnetgrentX (struct database_dyn *db, int fd, request_header *req,
 		 const char *key, uid_t uid, struct hashentry *he,
-		 struct datahead *dh, struct dataset **resultp,
-		 void **tofreep)
+		 struct datahead *dh, struct addgetnetgrentX_scratch *scratch)
 {
   if (__glibc_unlikely (debug_level > 0))
     {
@@ -132,14 +209,10 @@ addgetnetgrentX (struct database_dyn *db, int fd, request_header *req,
 
   char *key_copy = NULL;
   struct __netgrent data;
-  size_t buflen = MAX (1024, sizeof (*dataset) + req->key_len);
-  size_t buffilled = sizeof (*dataset);
-  char *buffer = NULL;
   size_t nentries = 0;
   size_t group_len = strlen (key) + 1;
   struct name_list *first_needed
     = alloca (sizeof (struct name_list) + group_len);
-  *tofreep = NULL;
 
   if (netgroup_database == NULL
       && !__nss_database_get (nss_database_netgroup, &netgroup_database))
@@ -147,12 +220,10 @@ addgetnetgrentX (struct database_dyn *db, int fd, request_header *req,
       /* No such service.  */
       cacheable = do_notfound (db, fd, req, key, &dataset, &total, &timeout,
 			       &key_copy);
-      goto writeout;
+      goto maybe_cache_add;
     }
 
   memset (&data, '\0', sizeof (data));
-  buffer = xmalloc (buflen);
-  *tofreep = buffer;
   first_needed->next = first_needed;
   memcpy (first_needed->name, key, group_len);
   data.needed_groups = first_needed;
@@ -195,8 +266,8 @@ addgetnetgrentX (struct database_dyn *db, int fd, request_header *req,
 		while (1)
 		  {
 		    int e;
-		    status = getfct.f (&data, buffer + buffilled,
-				       buflen - buffilled - req->key_len, &e);
+		    status = getfct.f (&data, scratch->tmp.data,
+				       scratch->tmp.length, &e);
 		    if (status == NSS_STATUS_SUCCESS)
 		      {
 			if (data.type == triple_val)
@@ -204,68 +275,10 @@ addgetnetgrentX (struct database_dyn *db, int fd, request_header *req,
 			    const char *nhost = data.val.triple.host;
 			    const char *nuser = data.val.triple.user;
 			    const char *ndomain = data.val.triple.domain;
-
-			    size_t hostlen = strlen (nhost ?: "") + 1;
-			    size_t userlen = strlen (nuser ?: "") + 1;
-			    size_t domainlen = strlen (ndomain ?: "") + 1;
-
-			    if (nhost == NULL || nuser == NULL || ndomain == NULL
-				|| nhost > nuser || nuser > ndomain)
-			      {
-				const char *last = nhost;
-				if (last == NULL
-				    || (nuser != NULL && nuser > last))
-				  last = nuser;
-				if (last == NULL
-				    || (ndomain != NULL && ndomain > last))
-				  last = ndomain;
-
-				size_t bufused
-				  = (last == NULL
-				     ? buffilled
-				     : last + strlen (last) + 1 - buffer);
-
-				/* We have to make temporary copies.  */
-				size_t needed = hostlen + userlen + domainlen;
-
-				if (buflen - req->key_len - bufused < needed)
-				  {
-				    buflen += MAX (buflen, 2 * needed);
-				    /* Save offset in the old buffer.  We don't
-				       bother with the NULL check here since
-				       we'll do that later anyway.  */
-				    size_t nhostdiff = nhost - buffer;
-				    size_t nuserdiff = nuser - buffer;
-				    size_t ndomaindiff = ndomain - buffer;
-
-				    char *newbuf = xrealloc (buffer, buflen);
-				    /* Fix up the triplet pointers into the new
-				       buffer.  */
-				    nhost = (nhost ? newbuf + nhostdiff
-					     : NULL);
-				    nuser = (nuser ? newbuf + nuserdiff
-					     : NULL);
-				    ndomain = (ndomain ? newbuf + ndomaindiff
-					       : NULL);
-				    *tofreep = buffer = newbuf;
-				  }
-
-				nhost = memcpy (buffer + bufused,
-						nhost ?: "", hostlen);
-				nuser = memcpy ((char *) nhost + hostlen,
-						nuser ?: "", userlen);
-				ndomain = memcpy ((char *) nuser + userlen,
-						  ndomain ?: "", domainlen);
-			      }
-
-			    char *wp = buffer + buffilled;
-			    wp = memmove (wp, nhost ?: "", hostlen);
-			    wp += hostlen;
-			    wp = memmove (wp, nuser ?: "", userlen);
-			    wp += userlen;
-			    wp = memmove (wp, ndomain ?: "", domainlen);
-			    wp += domainlen;
-			    buffilled = wp - buffer;
+			    if (!(addgetnetgrentX_append (scratch, nhost)
+				  && addgetnetgrentX_append (scratch, nuser)
+				  && addgetnetgrentX_append (scratch, ndomain)))
+			      return send_notfound (fd);
 			    ++nentries;
 			  }
 			else
@@ -317,8 +330,8 @@ addgetnetgrentX (struct database_dyn *db, int fd, request_header *req,
 		      }
 		    else if (status == NSS_STATUS_TRYAGAIN && e == ERANGE)
 		      {
-			buflen *= 2;
-			*tofreep = buffer = xrealloc (buffer, buflen);
+			if (!scratch_buffer_grow (&scratch->tmp))
+			  return send_notfound (fd);
 		      }
 		    else if (status == NSS_STATUS_RETURN
 			     || status == NSS_STATUS_NOTFOUND
@@ -348,13 +361,20 @@ addgetnetgrentX (struct database_dyn *db, int fd, request_header *req,
     {
       cacheable = do_notfound (db, fd, req, key, &dataset, &total, &timeout,
 			       &key_copy);
-      goto writeout;
+      goto maybe_cache_add;
     }
 
-  total = buffilled;
+  /* Capture the result size without the key appended.   */
+  total = scratch->buffer_used;
+
+  /* Make a copy of the key.  The scratch buffer must not move after
+     this point.  */
+  key_copy = addgetnetgrentX_append_n (scratch, key, req->key_len);
+  if (key_copy == NULL)
+    return send_notfound (fd);
 
   /* Fill in the dataset.  */
-  dataset = (struct dataset *) buffer;
+  dataset = scratch->buffer.data;
   timeout = datahead_init_pos (&dataset->head, total + req->key_len,
 			       total - offsetof (struct dataset, resp),
 			       he == NULL ? 0 : dh->nreloads + 1,
@@ -363,11 +383,7 @@ addgetnetgrentX (struct database_dyn *db, int fd, request_header *req,
   dataset->resp.version = NSCD_VERSION;
   dataset->resp.found = 1;
   dataset->resp.nresults = nentries;
-  dataset->resp.result_len = buffilled - sizeof (*dataset);
-
-  assert (buflen - buffilled >= req->key_len);
-  key_copy = memcpy (buffer + buffilled, key, req->key_len);
-  buffilled += req->key_len;
+  dataset->resp.result_len = total - sizeof (*dataset);
 
   /* Now we can determine whether on refill we have to create a new
      record or not.  */
@@ -398,7 +414,7 @@ addgetnetgrentX (struct database_dyn *db, int fd, request_header *req,
     if (__glibc_likely (newp != NULL))
       {
 	/* Adjust pointer into the memory block.  */
-	key_copy = (char *) newp + (key_copy - buffer);
+	key_copy = (char *) newp + (key_copy - (char *) dataset);
 
 	dataset = memcpy (newp, dataset, total + req->key_len);
 	cacheable = true;
@@ -410,14 +426,12 @@ addgetnetgrentX (struct database_dyn *db, int fd, request_header *req,
   }
 
   if (he == NULL && fd != -1)
-    {
-      /* We write the dataset before inserting it to the database
-	 since while inserting this thread might block and so would
-	 unnecessarily let the receiver wait.  */
-    writeout:
+    /* We write the dataset before inserting it to the database since
+       while inserting this thread might block and so would
+       unnecessarily let the receiver wait.  */
       writeall (fd, &dataset->resp, dataset->head.recsize);
-    }
 
+ maybe_cache_add:
   if (cacheable)
     {
       /* If necessary, we also propagate the data to disk.  */
@@ -441,7 +455,7 @@ addgetnetgrentX (struct database_dyn *db, int fd, request_header *req,
     }
 
  out:
-  *resultp = dataset;
+  scratch->dataset = dataset;
 
   return timeout;
 }
@@ -462,6 +476,9 @@ addinnetgrX (struct database_dyn *db, int fd, request_header *req,
   if (user != NULL)
     key = strchr (key, '\0') + 1;
   const char *domain = *key++ ? key : NULL;
+  struct addgetnetgrentX_scratch scratch;
+
+  addgetnetgrentX_scratch_init (&scratch);
 
   if (__glibc_unlikely (debug_level > 0))
     {
@@ -477,12 +494,8 @@ addinnetgrX (struct database_dyn *db, int fd, request_header *req,
 							    group, group_len,
 							    db, uid);
   time_t timeout;
-  void *tofree;
   if (result != NULL)
-    {
-      timeout = result->head.timeout;
-      tofree = NULL;
-    }
+    timeout = result->head.timeout;
   else
     {
       request_header req_get =
@@ -491,7 +504,10 @@ addinnetgrX (struct database_dyn *db, int fd, request_header *req,
 	  .key_len = group_len
 	};
       timeout = addgetnetgrentX (db, -1, &req_get, group, uid, NULL, NULL,
-				 &result, &tofree);
+				 &scratch);
+      result = scratch.dataset;
+      if (timeout < 0)
+	goto out;
     }
 
   struct indataset
@@ -502,24 +518,26 @@ addinnetgrX (struct database_dyn *db, int fd, request_header *req,
       = (struct indataset *) mempool_alloc (db,
 					    sizeof (*dataset) + req->key_len,
 					    1);
-  struct indataset dataset_mem;
   bool cacheable = true;
   if (__glibc_unlikely (dataset == NULL))
     {
       cacheable = false;
-      dataset = &dataset_mem;
+      /* The alloca is safe because nscd_run_worker verfies that
+	 key_len is not larger than MAXKEYLEN.  */
+      dataset = alloca (sizeof (*dataset) + req->key_len);
     }
 
   datahead_init_pos (&dataset->head, sizeof (*dataset) + req->key_len,
 		     sizeof (innetgroup_response_header),
-		     he == NULL ? 0 : dh->nreloads + 1, result->head.ttl);
+		     he == NULL ? 0 : dh->nreloads + 1,
+		     result == NULL ? db->negtimeout : result->head.ttl);
   /* Set the notfound status and timeout based on the result from
      getnetgrent.  */
-  dataset->head.notfound = result->head.notfound;
+  dataset->head.notfound = result == NULL || result->head.notfound;
   dataset->head.timeout = timeout;
 
   dataset->resp.version = NSCD_VERSION;
-  dataset->resp.found = result->resp.found;
+  dataset->resp.found = result != NULL && result->resp.found;
   /* Until we find a matching entry the result is 0.  */
   dataset->resp.result = 0;
 
@@ -567,7 +585,9 @@ addinnetgrX (struct database_dyn *db, int fd, request_header *req,
       goto out;
     }
 
-  if (he == NULL)
+  /* addgetnetgrentX may have already sent a notfound response.  Do
+     not send another one.  */
+  if (he == NULL && dataset->resp.found)
     {
       /* We write the dataset before inserting it to the database
 	 since while inserting this thread might block and so would
@@ -601,7 +621,7 @@ addinnetgrX (struct database_dyn *db, int fd, request_header *req,
     }
 
  out:
-  free (tofree);
+  addgetnetgrentX_scratch_free (&scratch);
   return timeout;
 }
 
@@ -611,11 +631,12 @@ addgetnetgrentX_ignore (struct database_dyn *db, int fd, request_header *req,
 			const char *key, uid_t uid, struct hashentry *he,
 			struct datahead *dh)
 {
-  struct dataset *ignore;
-  void *tofree;
-  time_t timeout = addgetnetgrentX (db, fd, req, key, uid, he, dh,
-				    &ignore, &tofree);
-  free (tofree);
+  struct addgetnetgrentX_scratch scratch;
+  addgetnetgrentX_scratch_init (&scratch);
+  time_t timeout = addgetnetgrentX (db, fd, req, key, uid, he, dh, &scratch);
+  addgetnetgrentX_scratch_free (&scratch);
+  if (timeout < 0)
+    timeout = 0;
   return timeout;
 }
 
@@ -659,5 +680,9 @@ readdinnetgr (struct database_dyn *db, struct hashentry *he,
       .key_len = he->len
     };
 
-  return addinnetgrX (db, -1, &req, db->data + he->key, he->owner, he, dh);
+  time_t timeout = addinnetgrX (db, -1, &req, db->data + he->key, he->owner,
+				he, dh);
+  if (timeout < 0)
+    timeout = 0;
+  return timeout;
 }
diff --git a/nss/getXXbyYY_r.c b/nss/getXXbyYY_r.c
index fe7d5b7d0e..3a15b1a4ae 100644
--- a/nss/getXXbyYY_r.c
+++ b/nss/getXXbyYY_r.c
@@ -157,19 +157,15 @@ __merge_einval (LOOKUP_TYPE *a,
 
 #define CHECK_MERGE(err, status)		\
   ({						\
-    do						\
+    if (err)					\
       {						\
-	if (err)				\
-	  {					\
-	    __set_errno (err);			\
-	    if (err == ERANGE)			\
-	      status = NSS_STATUS_TRYAGAIN;	\
-	    else				\
-	      status = NSS_STATUS_UNAVAIL;	\
-	    break;				\
-	  }					\
+	__set_errno (err);			\
+	if (err == ERANGE)			\
+	  status = NSS_STATUS_TRYAGAIN;		\
+	else					\
+	  status = NSS_STATUS_UNAVAIL;		\
+	break;					\
       }						\
-    while (0);					\
   })
 
 /* Type of the lookup function we need here.  */
diff --git a/posix/Makefile b/posix/Makefile
index a1e84853a8..18ddb8c341 100644
--- a/posix/Makefile
+++ b/posix/Makefile
@@ -303,6 +303,7 @@ tests := \
   tst-posix_spawn-setsid \
   tst-preadwrite \
   tst-preadwrite64 \
+  tst-regcomp-bracket-free \
   tst-regcomp-truncated \
   tst-regex \
   tst-regex2 \
diff --git a/posix/fork.c b/posix/fork.c
index 298765a1ff..cf9b80e7c0 100644
--- a/posix/fork.c
+++ b/posix/fork.c
@@ -62,6 +62,7 @@ __libc_fork (void)
       call_function_static_weak (__nss_database_fork_prepare_parent,
 				 &nss_database_data);
 
+      _IO_proc_file_chain_lock ();
       _IO_list_lock ();
 
       /* Acquire malloc locks.  This needs to come last because fork
@@ -92,6 +93,7 @@ __libc_fork (void)
 
 	  /* Reset locks in the I/O code.  */
 	  _IO_list_resetlock ();
+	  _IO_proc_file_chain_resetlock ();
 
 	  call_function_static_weak (__nss_database_fork_subprocess,
 				     &nss_database_data);
@@ -121,6 +123,7 @@ __libc_fork (void)
 
 	  /* We execute this even if the 'fork' call failed.  */
 	  _IO_list_unlock ();
+	  _IO_proc_file_chain_unlock ();
 	}
 
       /* Run the handlers registered for the parent.  */
diff --git a/posix/glob.h b/posix/glob.h
index 3406662840..b6bba0fbcd 100644
--- a/posix/glob.h
+++ b/posix/glob.h
@@ -150,7 +150,7 @@ extern int glob (const char *__restrict __pattern, int __flags,
 /* Free storage allocated in PGLOB by a previous `glob' call.  */
 extern void globfree (glob_t *__pglob) __THROW;
 #else
-# ifdef __USE_TIME_BITS64
+# ifdef __USE_TIME64_REDIRECTS
 extern int __REDIRECT_NTHNL (glob, (const char *__restrict __pattern,
 				    int __flags,
 				    int (*__errfunc) (const char *, int),
@@ -170,7 +170,7 @@ extern void __REDIRECT_NTH (globfree, (glob_t *__pglob), globfree64);
 #endif
 
 #ifdef __USE_LARGEFILE64
-# ifdef __USE_TIME_BITS64
+# ifdef __USE_TIME64_REDIRECTS
 extern int __REDIRECT_NTHNL (glob64, (const char *__restrict __pattern,
 				      int __flags,
 				      int (*__errfunc) (const char *, int),
diff --git a/posix/regcomp.c b/posix/regcomp.c
index 5380d3c7b9..6595bb3c0d 100644
--- a/posix/regcomp.c
+++ b/posix/regcomp.c
@@ -3384,6 +3384,7 @@ parse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,
     {
 #ifdef RE_ENABLE_I18N
       free_charset (mbcset);
+      mbcset = NULL;
 #endif
       /* Build a tree for simple bracket.  */
       br_token.type = SIMPLE_BRACKET;
@@ -3399,7 +3400,8 @@ parse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,
  parse_bracket_exp_free_return:
   re_free (sbcset);
 #ifdef RE_ENABLE_I18N
-  free_charset (mbcset);
+  if (__glibc_likely (mbcset != NULL))
+    free_charset (mbcset);
 #endif /* RE_ENABLE_I18N */
   return NULL;
 }
diff --git a/posix/sched.h b/posix/sched.h
index 3eac206f35..49f504a488 100644
--- a/posix/sched.h
+++ b/posix/sched.h
@@ -74,7 +74,7 @@ extern int sched_get_priority_max (int __algorithm) __THROW;
 extern int sched_get_priority_min (int __algorithm) __THROW;
 
 /* Get the SCHED_RR interval for the named process.  */
-#ifndef __USE_TIME_BITS64
+#ifndef __USE_TIME64_REDIRECTS
 extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) __THROW;
 #else
 # ifdef __REDIRECT_NTH
diff --git a/posix/sys/wait.h b/posix/sys/wait.h
index edbb7b4392..1f44ee1145 100644
--- a/posix/sys/wait.h
+++ b/posix/sys/wait.h
@@ -139,7 +139,7 @@ struct rusage;
    nil, store information about the child's resource usage there.  If the
    WUNTRACED bit is set in OPTIONS, return status for stopped children;
    otherwise don't.  */
-# ifndef __USE_TIME_BITS64
+# ifndef __USE_TIME64_REDIRECTS
 extern __pid_t wait3 (int *__stat_loc, int __options,
 		      struct rusage * __usage) __THROWNL;
 # else
@@ -154,7 +154,7 @@ extern __pid_t __REDIRECT_NTHNL (wait3, (int *__stat_loc, int __options,
 #endif
 
 #ifdef __USE_MISC
-# ifndef __USE_TIME_BITS64
+# ifndef __USE_TIME64_REDIRECTS
 /* PID is like waitpid.  Other args are like wait3.  */
 extern __pid_t wait4 (__pid_t __pid, int *__stat_loc, int __options,
 		      struct rusage *__usage) __THROWNL;
diff --git a/posix/tst-regcomp-bracket-free.c b/posix/tst-regcomp-bracket-free.c
new file mode 100644
index 0000000000..3c091d8c44
--- /dev/null
+++ b/posix/tst-regcomp-bracket-free.c
@@ -0,0 +1,176 @@
+/* Test regcomp bracket parsing with injected allocation failures (bug 33185).
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* This test invokes regcomp multiple times, failing one memory
+   allocation in each call.  The function call should fail with
+   REG_ESPACE (or succeed if it can recover from the allocation
+   failure).  Previously, there was double-free bug.  */
+
+#include <errno.h>
+#include <regex.h>
+#include <stdio.h>
+#include <string.h>
+#include <support/check.h>
+#include <support/namespace.h>
+#include <support/support.h>
+
+/* Data structure allocated via MAP_SHARED, so that writes from the
+   subprocess are visible.  */
+struct shared_data
+{
+  /* Number of tracked allocations performed so far.  */
+  volatile unsigned int allocation_count;
+
+  /* If this number is reached, one allocation fails.  */
+  volatile unsigned int failing_allocation;
+
+  /* The subprocess stores the expected name here.  */
+  char name[100];
+};
+
+/* Allocation count in shared mapping.  */
+static struct shared_data *shared;
+
+/* Returns true if a failure should be injected for this allocation.  */
+static bool
+fail_this_allocation (void)
+{
+  if (shared != NULL)
+    {
+      unsigned int count = shared->allocation_count;
+      shared->allocation_count = count + 1;
+      return count == shared->failing_allocation;
+    }
+  else
+    return false;
+}
+
+/* Failure-injecting wrappers for allocation functions used by glibc.  */
+
+void *
+malloc (size_t size)
+{
+  if (fail_this_allocation ())
+    {
+      errno = ENOMEM;
+      return NULL;
+    }
+  extern __typeof (malloc) __libc_malloc;
+  return __libc_malloc (size);
+}
+
+void *
+calloc (size_t a, size_t b)
+{
+  if (fail_this_allocation ())
+    {
+      errno = ENOMEM;
+      return NULL;
+    }
+  extern __typeof (calloc) __libc_calloc;
+  return __libc_calloc (a, b);
+}
+
+void *
+realloc (void *ptr, size_t size)
+{
+  if (fail_this_allocation ())
+    {
+      errno = ENOMEM;
+      return NULL;
+    }
+  extern __typeof (realloc) __libc_realloc;
+  return __libc_realloc (ptr, size);
+}
+
+/* No-op subprocess to verify that support_isolate_in_subprocess does
+   not perform any heap allocations.  */
+static void
+no_op (void *ignored)
+{
+}
+
+/* Perform a regcomp call in a subprocess.  Used to count its
+   allocations.  */
+static void
+initialize (void *regexp1)
+{
+  const char *regexp = regexp1;
+
+  shared->allocation_count = 0;
+
+  regex_t reg;
+  TEST_COMPARE (regcomp (&reg, regexp, 0), 0);
+}
+
+/* Perform regcomp in a subprocess with fault injection.  */
+static void
+test_in_subprocess (void *regexp1)
+{
+  const char *regexp = regexp1;
+  unsigned int inject_at = shared->failing_allocation;
+
+  regex_t reg;
+  int ret = regcomp (&reg, regexp, 0);
+
+  if (ret != 0)
+    {
+      TEST_COMPARE (ret, REG_ESPACE);
+      printf ("info: allocation %u failure results in return value %d,"
+              " error %s (%d)\n",
+              inject_at, ret, strerrorname_np (errno), errno);
+    }
+}
+
+static int
+do_test (void)
+{
+  char regexp[] = "[:alpha:]";
+
+  shared = support_shared_allocate (sizeof (*shared));
+
+  /* Disable fault injection.  */
+  shared->failing_allocation = ~0U;
+
+  support_isolate_in_subprocess (no_op, NULL);
+  TEST_COMPARE (shared->allocation_count, 0);
+
+  support_isolate_in_subprocess (initialize, regexp);
+
+  /* The number of allocations in the successful case, plus some
+     slack.  Once the number of expected allocations is exceeded,
+     injecting further failures does not make a difference.  */
+  unsigned int maximum_allocation_count = shared->allocation_count;
+  printf ("info: successful call performs %u allocations\n",
+          maximum_allocation_count);
+  maximum_allocation_count += 10;
+
+  for (unsigned int inject_at = 0; inject_at <= maximum_allocation_count;
+       ++inject_at)
+    {
+      shared->allocation_count = 0;
+      shared->failing_allocation = inject_at;
+      support_isolate_in_subprocess (test_in_subprocess, regexp);
+    }
+
+  support_shared_free (shared);
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/posix/tst-spawn2.c b/posix/tst-spawn2.c
index bb507204a2..b2bad3f1f7 100644
--- a/posix/tst-spawn2.c
+++ b/posix/tst-spawn2.c
@@ -26,6 +26,7 @@
 #include <stdio.h>
 
 #include <support/check.h>
+#include <support/descriptors.h>
 #include <tst-spawn.h>
 
 int
@@ -38,38 +39,53 @@ do_test (void)
   char * const args[] = { 0 };
   PID_T_TYPE pid = -1;
 
-  int ret = POSIX_SPAWN (&pid, program, 0, 0, args, environ);
-  if (ret != ENOENT)
-    {
-      errno = ret;
-      FAIL_EXIT1 ("posix_spawn: %m");
-    }
-
-  /* POSIX states the value returned on pid variable in case of an error
-     is not specified.  GLIBC will update the value iff the child
-     execution is successful.  */
-  if (pid != -1)
-    FAIL_EXIT1 ("posix_spawn returned pid != -1 (%i)", (int) pid);
-
-  /* Check if no child is actually created.  */
-  TEST_COMPARE (WAITID (P_ALL, 0, NULL, WEXITED), -1);
-  TEST_COMPARE (errno, ECHILD);
-
-  /* Same as before, but with posix_spawnp.  */
-  char *args2[] = { (char*) program, 0 };
-
-  ret = POSIX_SPAWNP (&pid, args2[0], 0, 0, args2, environ);
-  if (ret != ENOENT)
-    {
-      errno = ret;
-      FAIL_EXIT1 ("posix_spawnp: %m");
-    }
-
-  if (pid != -1)
-    FAIL_EXIT1 ("posix_spawnp returned pid != -1 (%i)", (int) pid);
-
-  TEST_COMPARE (WAITID (P_ALL, 0, NULL, WEXITED), -1);
-  TEST_COMPARE (errno, ECHILD);
+  {
+    struct support_descriptors *descrs = support_descriptors_list ();
+
+    int ret = POSIX_SPAWN (&pid, program, 0, 0, args, environ);
+    if (ret != ENOENT)
+      {
+	errno = ret;
+	FAIL_EXIT1 ("posix_spawn: %m");
+      }
+
+    /* POSIX states the value returned on pid variable in case of an error
+       is not specified.  GLIBC will update the value iff the child
+       execution is successful.  */
+    if (pid != -1)
+      FAIL_EXIT1 ("posix_spawn returned pid != -1 (%i)", (int) pid);
+
+    /* Check if no child is actually created.  */
+    TEST_COMPARE (WAITID (P_ALL, 0, NULL, WEXITED), -1);
+    TEST_COMPARE (errno, ECHILD);
+
+    /* Also check if there is no leak descriptors.  */
+    support_descriptors_check (descrs);
+    support_descriptors_free (descrs);
+  }
+
+  {
+    /* Same as before, but with posix_spawnp.  */
+    char *args2[] = { (char*) program, 0 };
+
+    struct support_descriptors *descrs = support_descriptors_list ();
+
+    int ret = POSIX_SPAWNP (&pid, args2[0], 0, 0, args2, environ);
+    if (ret != ENOENT)
+      {
+	errno = ret;
+	FAIL_EXIT1 ("posix_spawnp: %m");
+      }
+
+    if (pid != -1)
+      FAIL_EXIT1 ("posix_spawnp returned pid != -1 (%i)", (int) pid);
+
+    TEST_COMPARE (WAITID (P_ALL, 0, NULL, WEXITED), -1);
+    TEST_COMPARE (errno, ECHILD);
+
+    support_descriptors_check (descrs);
+    support_descriptors_free (descrs);
+  }
 
   return 0;
 }
diff --git a/posix/tst-truncate-common.c b/posix/tst-truncate-common.c
index b774fa46b8..b8c561ffdb 100644
--- a/posix/tst-truncate-common.c
+++ b/posix/tst-truncate-common.c
@@ -21,6 +21,8 @@
 #include <sys/stat.h>
 #include <unistd.h>
 
+#include <support/check.h>
+
 static void do_prepare (void);
 #define PREPARE(argc, argv)     do_prepare ()
 static int do_test (void);
@@ -42,9 +44,6 @@ do_prepare (void)
     }
 }
 
-#define FAIL(str) \
-  do { printf ("error: %s (line %d)\n", str, __LINE__); return 1; } while (0)
-
 static int
 do_test_with_offset (off_t offset)
 {
@@ -54,35 +53,35 @@ do_test_with_offset (off_t offset)
   memset (buf, 0xcf, sizeof (buf));
 
   if (pwrite (temp_fd, buf, sizeof (buf), offset) != sizeof (buf))
-    FAIL ("write failed");
+    FAIL_RET ("write failed");
   if (fstat (temp_fd, &st) < 0 || st.st_size != (offset + sizeof (buf)))
-    FAIL ("initial size wrong");
+    FAIL_RET ("initial size wrong");
 
   if (ftruncate (temp_fd, offset + 800) < 0)
-    FAIL ("size reduction with ftruncate failed");
+    FAIL_RET ("size reduction with ftruncate failed");
   if (fstat (temp_fd, &st) < 0 || st.st_size != (offset + 800))
-    FAIL ("size after reduction with ftruncate is incorrect");
+    FAIL_RET ("size after reduction with ftruncate is incorrect");
 
   /* The following test covers more than POSIX.  POSIX does not require
      that ftruncate() can increase the file size.  But we are testing
      Unix systems.  */
   if (ftruncate (temp_fd, offset + 1200) < 0)
-    FAIL ("size increate with ftruncate failed");
+    FAIL_RET ("size increate with ftruncate failed");
   if (fstat (temp_fd, &st) < 0 || st.st_size != (offset + 1200))
-    FAIL ("size after increase is incorrect");
+    FAIL_RET ("size after increase is incorrect");
 
   if (truncate (temp_filename, offset + 800) < 0)
-    FAIL ("size reduction with truncate failed");
+    FAIL_RET ("size reduction with truncate failed");
   if (fstat (temp_fd, &st) < 0 || st.st_size != (offset + 800))
-    FAIL ("size after reduction with truncate incorrect");
+    FAIL_RET ("size after reduction with truncate incorrect");
 
   /* The following test covers more than POSIX.  POSIX does not require
      that truncate() can increase the file size.  But we are testing
      Unix systems.  */
   if (truncate (temp_filename, (offset + 1200)) < 0)
-    FAIL ("size increase with truncate failed");
+    FAIL_RET ("size increase with truncate failed");
   if (fstat (temp_fd, &st) < 0 || st.st_size != (offset + 1200))
-    FAIL ("size increase with truncate is incorrect");
+    FAIL_RET ("size increase with truncate is incorrect");
 
   return 0;
 }
diff --git a/resolv/Makefile b/resolv/Makefile
index 5f44f5896b..abff7fc007 100644
--- a/resolv/Makefile
+++ b/resolv/Makefile
@@ -106,6 +106,8 @@ tests += \
   tst-resolv-nondecimal \
   tst-resolv-res_init-multi \
   tst-resolv-search \
+  tst-resolv-semi-failure \
+  tst-resolv-short-response \
   tst-resolv-trailing \
 
 # This test calls __res_context_send directly, which is not exported
@@ -299,6 +301,10 @@ $(objpfx)tst-resolv-nondecimal: $(objpfx)libresolv.so $(shared-thread-library)
 $(objpfx)tst-resolv-qtypes: $(objpfx)libresolv.so $(shared-thread-library)
 $(objpfx)tst-resolv-rotate: $(objpfx)libresolv.so $(shared-thread-library)
 $(objpfx)tst-resolv-search: $(objpfx)libresolv.so $(shared-thread-library)
+$(objpfx)tst-resolv-semi-failure: $(objpfx)libresolv.so \
+  $(shared-thread-library)
+$(objpfx)tst-resolv-short-response: $(objpfx)libresolv.so \
+  $(shared-thread-library)
 $(objpfx)tst-resolv-trailing: $(objpfx)libresolv.so $(shared-thread-library)
 $(objpfx)tst-resolv-threads: $(objpfx)libresolv.so $(shared-thread-library)
 $(objpfx)tst-resolv-txnid-collision: $(objpfx)libresolv.a \
diff --git a/resolv/netdb.h b/resolv/netdb.h
index 14228b0d95..b7f473fafe 100644
--- a/resolv/netdb.h
+++ b/resolv/netdb.h
@@ -701,7 +701,7 @@ extern int getaddrinfo_a (int __mode, struct gaicb *__list[__restrict_arr],
 extern int gai_suspend (const struct gaicb *const __list[], int __ent,
 			const struct timespec *__timeout);
 
-# ifdef __USE_TIME_BITS64
+# ifdef __USE_TIME64_REDIRECTS
 #  if defined(__REDIRECT)
 extern int __REDIRECT (gai_suspend, (const struct gaicb *const __list[],
                                      int __ent,
diff --git a/resolv/res_send.c b/resolv/res_send.c
index fb0217204a..9c77613f37 100644
--- a/resolv/res_send.c
+++ b/resolv/res_send.c
@@ -947,9 +947,11 @@ send_dg(res_state statp,
 		seconds /= statp->nscount;
 	if (seconds <= 0)
 		seconds = 1;
-	bool single_request_reopen = (statp->options & RES_SNGLKUPREOP) != 0;
-	bool single_request = (((statp->options & RES_SNGLKUP) != 0)
-			       | single_request_reopen);
+	bool single_request_reopen = ((statp->options & RES_SNGLKUPREOP)
+				      || (statp->_flags & RES_F_SNGLKUPREOP));
+	bool single_request = ((statp->options & RES_SNGLKUP)
+			       || (statp->_flags & RES_F_SNGLKUP)
+			       || single_request_reopen);
 	int save_gotsomewhere = *gotsomewhere;
 
 	int retval;
@@ -1006,14 +1008,14 @@ send_dg(res_state statp,
 		       have received the first answer.  */
 		    if (!single_request)
 		      {
-			statp->options |= RES_SNGLKUP;
+			statp->_flags |= RES_F_SNGLKUP;
 			single_request = true;
 			*gotsomewhere = save_gotsomewhere;
 			goto retry;
 		      }
 		    else if (!single_request_reopen)
 		      {
-			statp->options |= RES_SNGLKUPREOP;
+			statp->_flags |= RES_F_SNGLKUPREOP;
 			single_request_reopen = true;
 			*gotsomewhere = save_gotsomewhere;
 			__res_iclose (statp, false);
@@ -1197,19 +1199,30 @@ send_dg(res_state statp,
 		}
 
 		/* Check for the correct header layout and a matching
-		   question.  */
+		   question.  Some recursive resolvers send REFUSED
+		   without copying back the question section
+		   (producing a response that is only HFIXEDSZ bytes
+		   long).  Skip query matching in this case.  */
+		bool thisansp_error = (anhp->rcode == SERVFAIL ||
+				       anhp->rcode == NOTIMP ||
+				       anhp->rcode == REFUSED);
+		bool skip_query_match = (*thisresplenp == HFIXEDSZ
+					 && ntohs (anhp->qdcount) == 0
+					 && thisansp_error);
 		int matching_query = 0; /* Default to no matching query.  */
 		if (!recvresp1
 		    && anhp->id == hp->id
-		    && __libc_res_queriesmatch (buf, buf + buflen,
-						*thisansp,
-						*thisansp + *thisanssizp))
+		    && (skip_query_match
+			|| __libc_res_queriesmatch (buf, buf + buflen,
+						    *thisansp,
+						    *thisansp + *thisanssizp)))
 		  matching_query = 1;
 		if (!recvresp2
 		    && anhp->id == hp2->id
-		    && __libc_res_queriesmatch (buf2, buf2 + buflen2,
-						*thisansp,
-						*thisansp + *thisanssizp))
+		    && (skip_query_match
+			|| __libc_res_queriesmatch (buf2, buf2 + buflen2,
+						    *thisansp,
+						    *thisansp + *thisanssizp)))
 		  matching_query = 2;
 		if (matching_query == 0)
 		  /* Spurious UDP packet.  Drop it and continue
@@ -1219,15 +1232,13 @@ send_dg(res_state statp,
 		    goto wait;
 		  }
 
-		if (anhp->rcode == SERVFAIL ||
-		    anhp->rcode == NOTIMP ||
-		    anhp->rcode == REFUSED) {
+		if (thisansp_error) {
 		next_ns:
 			if (recvresp1 || (buf2 != NULL && recvresp2)) {
 			  *resplen2 = 0;
 			  return resplen;
 			}
-			if (buf2 != NULL)
+			if (buf2 != NULL && !single_request)
 			  {
 			    /* No data from the first reply.  */
 			    resplen = 0;
diff --git a/resolv/resolv-internal.h b/resolv/resolv-internal.h
index 24b164f6b5..944af3ee76 100644
--- a/resolv/resolv-internal.h
+++ b/resolv/resolv-internal.h
@@ -26,6 +26,8 @@
 #define RES_F_VC        0x00000001 /* Socket is TCP.  */
 #define RES_F_CONN      0x00000002 /* Socket is connected.  */
 #define RES_F_EDNS0ERR  0x00000004 /* EDNS0 caused errors.  */
+#define RES_F_SNGLKUP	0x00200000 /* Private version of RES_SNGLKUP.  */
+#define RES_F_SNGLKUPREOP 0x00400000 /* Private version of RES_SNGLKUPREOP.  */
 
 /* The structure HEADER is normally aligned on a word boundary.  In
    some code, we need to access this structure when it may be aligned
diff --git a/resolv/tst-resolv-semi-failure.c b/resolv/tst-resolv-semi-failure.c
new file mode 100644
index 0000000000..aa9798b5a7
--- /dev/null
+++ b/resolv/tst-resolv-semi-failure.c
@@ -0,0 +1,133 @@
+/* Test parallel failure/success responses (bug 30081).
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <resolv.h>
+#include <support/check.h>
+#include <support/resolv_test.h>
+#include <support/check_nss.h>
+
+/* The rcode in the initial response.  */
+static volatile int rcode;
+
+/* Whether to fail the initial A query (!fail_aaaa) or the initial
+   AAAA query (fail_aaaa).  */
+static volatile bool fail_aaaa;
+
+static void
+response (const struct resolv_response_context *ctx,
+          struct resolv_response_builder *b,
+          const char *qname, uint16_t qclass, uint16_t qtype)
+{
+  /* Handle the failing query.  */
+  if ((fail_aaaa && qtype == T_AAAA) && ctx->server_index == 0)
+    {
+      struct resolv_response_flags flags = {.rcode = rcode};
+      resolv_response_init (b, flags);
+      return;
+    }
+
+  /* Otherwise produce a response.  */
+  resolv_response_init (b, (struct resolv_response_flags) {});
+  resolv_response_add_question (b, qname, qclass, qtype);
+  resolv_response_section (b, ns_s_an);
+  resolv_response_open_record (b, qname, qclass, qtype, 0);
+  switch (qtype)
+    {
+    case T_A:
+      {
+        char ipv4[4] = {192, 0, 2, 17};
+        resolv_response_add_data (b, &ipv4, sizeof (ipv4));
+      }
+      break;
+    case T_AAAA:
+      {
+        char ipv6[16]
+          = {0x20, 0x01, 0xd, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};
+        resolv_response_add_data (b, &ipv6, sizeof (ipv6));
+      }
+      break;
+    default:
+      FAIL_EXIT1 ("unexpected TYPE%d query", qtype);
+    }
+  resolv_response_close_record (b);
+}
+
+static void
+check_one (void)
+{
+
+  /* The buggy 1-second query timeout results in 30 seconds of delay,
+     which triggers are test timeout failure.  */
+  for (int i = 0;  i < 30; ++i)
+    {
+      static const struct addrinfo hints =
+        {
+          .ai_family = AF_UNSPEC,
+          .ai_socktype = SOCK_STREAM,
+        };
+      struct addrinfo *ai;
+      int ret = getaddrinfo ("www.example", "80", &hints, &ai);
+      const char *expected;
+      if (ret == 0 && ai->ai_next != NULL)
+        expected = ("address: STREAM/TCP 192.0.2.17 80\n"
+                    "address: STREAM/TCP 2001:db8::1 80\n");
+      else
+        /* Only one response because the AAAA lookup failure is
+           treated as an ignoreable error.  */
+        expected = "address: STREAM/TCP 192.0.2.17 80\n";
+      check_addrinfo ("www.example", ai, ret, expected);
+      if (ret == 0)
+        freeaddrinfo (ai);
+    }
+}
+
+static int
+do_test (void)
+{
+  for (int do_single_lookup = 0; do_single_lookup < 2; ++do_single_lookup)
+    {
+      struct resolv_test *aux = resolv_test_start
+        ((struct resolv_redirect_config)
+         {
+           .response_callback = response,
+         });
+
+      if (do_single_lookup)
+        _res.options |= RES_SNGLKUP;
+
+      for (int do_fail_aaaa = 0; do_fail_aaaa < 2; ++do_fail_aaaa)
+        {
+          fail_aaaa = do_fail_aaaa;
+
+          rcode = 2; /* SERVFAIL.  */
+          check_one ();
+
+          rcode = 4; /* NOTIMP.  */
+          check_one ();
+
+          rcode = 5; /* REFUSED.  */
+          check_one ();
+        }
+
+      resolv_test_end (aux);
+    }
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/resolv/tst-resolv-short-response.c b/resolv/tst-resolv-short-response.c
new file mode 100644
index 0000000000..9b06b0c176
--- /dev/null
+++ b/resolv/tst-resolv-short-response.c
@@ -0,0 +1,126 @@
+/* Test for spurious timeouts with short 12-byte responses (bug 31890).
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <resolv.h>
+#include <support/check.h>
+#include <support/resolv_test.h>
+#include <support/check_nss.h>
+
+/* The rcode in the initial response.  */
+static volatile int rcode;
+
+static void
+response (const struct resolv_response_context *ctx,
+          struct resolv_response_builder *b,
+          const char *qname, uint16_t qclass, uint16_t qtype)
+{
+  switch (ctx->server_index)
+    {
+    case 0:
+      /* First server times out.  */
+      {
+        struct resolv_response_flags flags = {.rcode = rcode};
+        resolv_response_init (b, flags);
+      }
+      break;
+    case 1:
+      /* Second server sends reply.  */
+      resolv_response_init (b, (struct resolv_response_flags) {});
+      resolv_response_add_question (b, qname, qclass, qtype);
+      resolv_response_section (b, ns_s_an);
+      resolv_response_open_record (b, qname, qclass, qtype, 0);
+      switch (qtype)
+        {
+        case T_A:
+          {
+            char ipv4[4] = {192, 0, 2, 17};
+            resolv_response_add_data (b, &ipv4, sizeof (ipv4));
+          }
+          break;
+        case T_AAAA:
+          {
+            char ipv6[16]
+              = {0x20, 0x01, 0xd, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};
+            resolv_response_add_data (b, &ipv6, sizeof (ipv6));
+          }
+          break;
+        default:
+          FAIL_EXIT1 ("unexpected TYPE%d query", qtype);
+        }
+      resolv_response_close_record (b);
+      break;
+    default:
+      FAIL_EXIT1 ("unexpected query to server %d", ctx->server_index);
+    }
+}
+
+static void
+check_one (void)
+{
+
+  /* The buggy 1-second query timeout results in 30 seconds of delay,
+     which triggers a test timeout failure.  */
+  for (int i = 0;  i < 10; ++i)
+    {
+      check_hostent ("www.example", gethostbyname ("www.example"),
+                     "name: www.example\n"
+                     "address: 192.0.2.17\n");
+      check_hostent ("www.example", gethostbyname2 ("www.example", AF_INET6),
+                     "name: www.example\n"
+                     "address: 2001:db8::1\n");
+      static const struct addrinfo hints =
+        {
+          .ai_family = AF_UNSPEC,
+          .ai_socktype = SOCK_STREAM,
+        };
+      struct addrinfo *ai;
+      int ret = getaddrinfo ("www.example", "80", &hints, &ai);
+      check_addrinfo ("www.example", ai, ret,
+                      "address: STREAM/TCP 192.0.2.17 80\n"
+                      "address: STREAM/TCP 2001:db8::1 80\n");
+      if (ret == 0)
+        freeaddrinfo (ai);
+    }
+}
+
+static int
+do_test (void)
+{
+  struct resolv_test *aux = resolv_test_start
+    ((struct resolv_redirect_config)
+     {
+       .response_callback = response,
+     });
+
+  _res.options |= RES_SNGLKUP;
+
+  rcode = 2; /* SERVFAIL.  */
+  check_one ();
+
+  rcode = 4; /* NOTIMP.  */
+  check_one ();
+
+  rcode = 5; /* REFUSED.  */
+  check_one ();
+
+  resolv_test_end (aux);
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/resource/sys/resource.h b/resource/sys/resource.h
index a5634ba715..b0bf751e92 100644
--- a/resource/sys/resource.h
+++ b/resource/sys/resource.h
@@ -88,7 +88,7 @@ extern int setrlimit64 (__rlimit_resource_t __resource,
    and put it in *USAGE.  Returns 0 for success, -1 for failure.  */
 extern int getrusage (__rusage_who_t __who, struct rusage *__usage) __THROW;
 
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # if defined(__REDIRECT_NTH)
 extern int __REDIRECT_NTH (getrusage, (__rusage_who_t __who,
                                        struct rusage *__usage),
diff --git a/rt/aio.h b/rt/aio.h
index 37d19abf16..e71435733f 100644
--- a/rt/aio.h
+++ b/rt/aio.h
@@ -193,7 +193,7 @@ extern __ssize_t __REDIRECT_NTH (aio_return, (struct aiocb *__aiocbp),
 extern int __REDIRECT_NTH (aio_cancel,
 			   (int __fildes, struct aiocb *__aiocbp),
 			   aio_cancel64);
-#  ifdef __USE_TIME_BITS64
+#  ifdef __USE_TIME64_REDIRECTS
 extern int __REDIRECT_NTH (aio_suspend,
 			   (const struct aiocb *const __list[], int __nent,
 			    const struct timespec *__restrict __timeout),
@@ -215,7 +215,7 @@ extern int __REDIRECT_NTH (aio_fsync,
 #  define aio_error aio_error64
 #  define aio_return aio_return64
 #  define aio_cancel aio_cancel64
-#  ifdef __USE_TIME_BITS64
+#  ifdef __USE_TIME64_REDIRECTS
 #   define aio_suspend __aio_suspend_time64
 #  else
 #   define aio_suspend aio_suspend64
diff --git a/rt/mqueue.h b/rt/mqueue.h
index 787cc36df2..fd6fff4bb2 100644
--- a/rt/mqueue.h
+++ b/rt/mqueue.h
@@ -71,7 +71,7 @@ extern int mq_send (mqd_t __mqdes, const char *__msg_ptr, size_t __msg_len,
 		    unsigned int __msg_prio) __nonnull ((2));
 
 #ifdef __USE_XOPEN2K
-# ifndef __USE_TIME_BITS64
+# ifndef __USE_TIME64_REDIRECTS
 /* Receive the oldest from highest priority messages in message queue
    MQDES, stop waiting if ABS_TIMEOUT expires.  */
 extern ssize_t mq_timedreceive (mqd_t __mqdes, char *__restrict __msg_ptr,
diff --git a/scripts/check-local-headers.sh b/scripts/check-local-headers.sh
index 5d3e61f889..ad23840333 100755
--- a/scripts/check-local-headers.sh
+++ b/scripts/check-local-headers.sh
@@ -33,7 +33,7 @@ exec ${AWK} -v includedir="$includedir" '
 BEGIN {
   status = 0
   exclude = "^" includedir \
-    "/(.*-.*-.*/|.*-.*/|)(asm[-/]|arch|linux/|selinux/|mach/|mach_debug/|device/|hurd/(((hurd|ioctl)_types|paths)\\.h|ioctls\\.defs|ihash\\.h|version\\.h)|gd|nss3/|nspr4?/|c\\+\\+/|sys/(capability|sdt(|-config))\\.h|libaudit\\.h)"
+    "/(.*-.*-.*/|.*-.*/|)(asm[-/]|arch|linux/|selinux/|mach/|mach_debug/|device/|hurd/(((hurd|ioctl)_types|paths)\\.h|ioctls\\.defs|ihash\\.h|version\\.h)|gd|nss3/|nspr4?/|c\\+\\+/|sys/(capability|sdt(|-config))\\.h|libaudit\\.h|audit(_logging|-records)\\.h)"
 }
 /^[^ ]/ && $1 ~ /.*:/ { obj = $1 }
 {
diff --git a/scripts/localplt.awk b/scripts/localplt.awk
index fe79ca01ab..621ae7d8e8 100644
--- a/scripts/localplt.awk
+++ b/scripts/localplt.awk
@@ -10,7 +10,8 @@ BEGIN {
 }
 
 FILENAME != lastfile {
-  if (lastfile && jmprel_offset == 0 && rela_offset == 0 && rel_offset == 0) {
+  if (lastfile && jmprel_offset == 0 && rela_offset == 0 && rel_offset == 0 \
+      && relr_offset == 0) {
     print FILENAME ": *** failed to find expected output (readelf -WSdr)";
     result = 2;
   }
@@ -22,6 +23,7 @@ FILENAME != lastfile {
   jmprel_offset = 0;
   rela_offset = 0;
   rel_offset = 0;
+  relr_offset = 0;
   pltrelsz = -1;
   delete section_offset_by_address;
 }
@@ -77,6 +79,8 @@ in_relocs && relocs_offset == rel_offset && NF >= 5 {
   }
 }
 
+# No need to handle DT_RELR (all packed relocations are relative).
+
 in_relocs { next }
 
 $1 == "Relocation" && $2 == "section" && $5 == "offset" {
@@ -121,4 +125,14 @@ $2 == "(REL)" {
   }
   next
 }
+
+$2 == "(RELR)" {
+  relr_addr = strtonum($3);
+  if (relr_addr in section_offset_by_address) {
+    relr_offset = section_offset_by_address[relr_addr];
+  } else {
+    print FILENAME ": *** DT_RELR does not match any section's address";
+    result = 2;
+  }
+}
 END { exit(result) }
diff --git a/scripts/sort-makefile-lines.py b/scripts/sort-makefile-lines.py
index f65ee40e27..b2249aef6d 100755
--- a/scripts/sort-makefile-lines.py
+++ b/scripts/sort-makefile-lines.py
@@ -129,7 +129,7 @@ def sort_makefile_lines():
     for i in range(len(lines)):
         # Look for things like "var = \", "var := \" or "var += \"
         # to start the sorted list.
-        var = re.search(r'^([a-zA-Z0-9-]*) [\+:]?\= \\$', lines[i])
+        var = re.search(r'^([-_a-zA-Z0-9]*) [\+:]?\= \\$', lines[i])
         if var:
             # Remember the index and the name.
             startmarks.append((i, var.group(1)))
@@ -140,7 +140,7 @@ def sort_makefile_lines():
     rangemarks = []
     for sm in startmarks:
         # Look for things like "  # var" to end the sorted list.
-        reg = r'^  # ' + sm[1] + r'$'
+        reg = r'^ *# ' + sm[1] + r'$'
         for j in range(sm[0] + 1, len(lines)):
             if re.search(reg, lines[j]):
                 # Remember the block to sort (inclusive).
diff --git a/signal/signal.h b/signal/signal.h
index f37499ce60..8e07b041b1 100644
--- a/signal/signal.h
+++ b/signal/signal.h
@@ -269,7 +269,7 @@ extern int sigwaitinfo (const sigset_t *__restrict __set,
 
    This function is a cancellation point and therefore not marked with
    __THROW.  */
-#  ifndef __USE_TIME_BITS64
+#  ifndef __USE_TIME64_REDIRECTS
 extern int sigtimedwait (const sigset_t *__restrict __set,
 			 siginfo_t *__restrict __info,
 			 const struct timespec *__restrict __timeout)
diff --git a/socket/Makefile b/socket/Makefile
index 74ca5b8452..fc1bd0a260 100644
--- a/socket/Makefile
+++ b/socket/Makefile
@@ -70,6 +70,7 @@ tests := \
   tst-accept4 \
   tst-cmsg_cloexec \
   tst-cmsghdr \
+  tst-connect \
   tst-sockopt \
   # tests
 
diff --git a/socket/bits/socket2.h b/socket/bits/socket2.h
index a88cb64370..71f8d9c741 100644
--- a/socket/bits/socket2.h
+++ b/socket/bits/socket2.h
@@ -33,12 +33,12 @@ extern ssize_t __REDIRECT (__recv_chk_warn,
 __fortify_function ssize_t
 recv (int __fd, void *__buf, size_t __n, int __flags)
 {
-  size_t sz = __glibc_objsize0 (__buf);
-  if (__glibc_safe_or_unknown_len (__n, sizeof (char), sz))
+  size_t __sz = __glibc_objsize0 (__buf);
+  if (__glibc_safe_or_unknown_len (__n, sizeof (char), __sz))
     return __recv_alias (__fd, __buf, __n, __flags);
-  if (__glibc_unsafe_len (__n, sizeof (char), sz))
-    return __recv_chk_warn (__fd, __buf, __n, sz, __flags);
-  return __recv_chk (__fd, __buf, __n, sz, __flags);
+  if (__glibc_unsafe_len (__n, sizeof (char), __sz))
+    return __recv_chk_warn (__fd, __buf, __n, __sz, __flags);
+  return __recv_chk (__fd, __buf, __n, __sz, __flags);
 }
 
 extern ssize_t __recvfrom_chk (int __fd, void *__restrict __buf, size_t __n,
@@ -61,11 +61,11 @@ __fortify_function ssize_t
 recvfrom (int __fd, void *__restrict __buf, size_t __n, int __flags,
 	  __SOCKADDR_ARG __addr, socklen_t *__restrict __addr_len)
 {
-  size_t sz = __glibc_objsize0 (__buf);
-  if (__glibc_safe_or_unknown_len (__n, sizeof (char), sz))
+  size_t __sz = __glibc_objsize0 (__buf);
+  if (__glibc_safe_or_unknown_len (__n, sizeof (char), __sz))
     return __recvfrom_alias (__fd, __buf, __n, __flags, __addr, __addr_len);
-  if (__glibc_unsafe_len (__n, sizeof (char), sz))
-    return __recvfrom_chk_warn (__fd, __buf, __n, sz, __flags, __addr,
+  if (__glibc_unsafe_len (__n, sizeof (char), __sz))
+    return __recvfrom_chk_warn (__fd, __buf, __n, __sz, __flags, __addr,
 				__addr_len);
-  return __recvfrom_chk (__fd, __buf, __n, sz, __flags, __addr, __addr_len);
+  return __recvfrom_chk (__fd, __buf, __n, __sz, __flags, __addr, __addr_len);
 }
diff --git a/socket/sys/socket.h b/socket/sys/socket.h
index 366eaab845..463cf3291b 100644
--- a/socket/sys/socket.h
+++ b/socket/sys/socket.h
@@ -170,7 +170,7 @@ extern ssize_t recvfrom (int __fd, void *__restrict __buf, size_t __n,
 
    This function is a cancellation point and therefore not marked with
    __THROW.  */
-#ifndef __USE_TIME_BITS64
+#ifndef __USE_TIME64_REDIRECTS
 extern ssize_t sendmsg (int __fd, const struct msghdr *__message,
 			int __flags);
 #else
@@ -191,7 +191,7 @@ extern ssize_t __sendmsg64 (int __fd, const struct msghdr *__message,
 
    This function is a cancellation point and therefore not marked with
    __THROW.  */
-# ifndef __USE_TIME_BITS64
+# ifndef __USE_TIME64_REDIRECTS
 extern int sendmmsg (int __fd, struct mmsghdr *__vmessages,
 		     unsigned int __vlen, int __flags);
 # else
@@ -204,7 +204,7 @@ extern int __sendmmsg64 (int __fd, struct mmsghdr *__vmessages,
 			 unsigned int __vlen, int __flags);
 #   define sendmmsg __sendmmsg64
 #  endif
-# endif	 /* __USE_TIME_BITS64 */
+# endif	 /* __USE_TIME64_REDIRECTS */
 #endif /* __USE_GNU */
 
 /* Receive a message as described by MESSAGE from socket FD.
@@ -212,7 +212,7 @@ extern int __sendmmsg64 (int __fd, struct mmsghdr *__vmessages,
 
    This function is a cancellation point and therefore not marked with
    __THROW.  */
-#ifndef __USE_TIME_BITS64
+#ifndef __USE_TIME64_REDIRECTS
 extern ssize_t recvmsg (int __fd, struct msghdr *__message, int __flags);
 #else
 # ifdef __REDIRECT
@@ -231,7 +231,7 @@ extern ssize_t __recvmsg64 (int __fd, struct msghdr *__message, int __flags);
 
    This function is a cancellation point and therefore not marked with
    __THROW.  */
-# ifndef __USE_TIME_BITS64
+# ifndef __USE_TIME64_REDIRECTS
 extern int recvmmsg (int __fd, struct mmsghdr *__vmessages,
 		     unsigned int __vlen, int __flags,
 		     struct timespec *__tmo);
@@ -251,7 +251,7 @@ extern int __REDIRECT (recvmmsg, (int __fd, struct mmsghdr *__vmessages,
 /* Put the current value for socket FD's option OPTNAME at protocol level LEVEL
    into OPTVAL (which is *OPTLEN bytes long), and set *OPTLEN to the value's
    actual length.  Returns 0 on success, -1 for errors.  */
-#ifndef __USE_TIME_BITS64
+#ifndef __USE_TIME64_REDIRECTS
 extern int getsockopt (int __fd, int __level, int __optname,
 		       void *__restrict __optval,
 		       socklen_t *__restrict __optlen) __THROW;
@@ -273,7 +273,7 @@ extern int __getsockopt64 (int __fd, int __level, int __optname,
 /* Set socket FD's option OPTNAME at protocol level LEVEL
    to *OPTVAL (which is OPTLEN bytes long).
    Returns 0 on success, -1 for errors.  */
-#ifndef __USE_TIME_BITS64
+#ifndef __USE_TIME64_REDIRECTS
 extern int setsockopt (int __fd, int __level, int __optname,
 		       const void *__optval, socklen_t __optlen) __THROW;
 #else
diff --git a/socket/sys/un.h b/socket/sys/un.h
index bf03b7d6ce..ff9cbd6efa 100644
--- a/socket/sys/un.h
+++ b/socket/sys/un.h
@@ -26,7 +26,7 @@
 __BEGIN_DECLS
 
 /* Structure describing the address of an AF_LOCAL (aka AF_UNIX) socket.  */
-struct sockaddr_un
+struct __attribute_struct_may_alias__ sockaddr_un
   {
     __SOCKADDR_COMMON (sun_);
     char sun_path[108];		/* Path name.  */
diff --git a/socket/tst-connect.c b/socket/tst-connect.c
new file mode 100644
index 0000000000..ec2fdd92c0
--- /dev/null
+++ b/socket/tst-connect.c
@@ -0,0 +1,113 @@
+/* Test the connect function.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <arpa/inet.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <stdbool.h>
+#include <support/check.h>
+#include <support/xsocket.h>
+#include <support/xunistd.h>
+#include <sys/socket.h>
+#include <stdio.h>
+
+static struct sockaddr_in server_address;
+
+int
+open_socket_inet_tcp (void)
+{
+  int fd = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
+  if (fd < 0)
+    {
+      if (errno == EAFNOSUPPORT)
+        FAIL_UNSUPPORTED ("The host does not support IPv4");
+      else
+        FAIL_EXIT1 ("socket (AF_INET, SOCK_STREAM, IPPROTO_TCP): %m\n");
+    }
+  return fd;
+}
+
+static pid_t
+start_server (void)
+{
+  server_address.sin_family = AF_INET;
+  server_address.sin_port = 0;
+  server_address.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
+
+  int server_sock = open_socket_inet_tcp ();
+
+  xbind (server_sock, (struct sockaddr *) &server_address,
+         sizeof (server_address));
+
+  socklen_t sa_len = sizeof (server_address);
+  xgetsockname (server_sock, (struct sockaddr *) &server_address, &sa_len);
+  xlisten (server_sock, 5);
+
+  pid_t my_pid = xfork ();
+  if (my_pid > 0)
+    {
+      xclose (server_sock);
+      return my_pid;
+    }
+
+  struct sockaddr_in client_address;
+  socklen_t ca_len = sizeof (server_address);
+  int client_sock = xaccept (server_sock, (struct sockaddr *) &client_address,
+                             &ca_len);
+  printf ("socket accepted %d\n", client_sock);
+
+  _exit (0);
+}
+
+static int
+do_test (void)
+{
+  pid_t serv_pid;
+  struct sockaddr_in peer;
+  socklen_t peer_len;
+
+  serv_pid = start_server ();
+  int client_sock = open_socket_inet_tcp ();
+  xconnect (client_sock, (const struct sockaddr *) &server_address,
+            sizeof (server_address));
+
+  /* A second connect with same arguments should fail with EISCONN.  */
+  int result = connect (client_sock,
+                        (const struct sockaddr *) &server_address,
+                        sizeof (server_address));
+  if (result == 0 || errno != EISCONN)
+    FAIL_EXIT1 ("Second connect (%d), should fail with EISCONN: %m",
+                client_sock);
+
+  peer_len = sizeof (peer);
+  xgetpeername (client_sock, (struct sockaddr *) &peer, &peer_len);
+  TEST_COMPARE (peer_len, sizeof (peer));
+  TEST_COMPARE (peer.sin_port, server_address.sin_port);
+  TEST_COMPARE_BLOB (&peer.sin_addr, sizeof (peer.sin_addr),
+                     &server_address.sin_addr,
+                     sizeof (server_address.sin_addr));
+
+  int status;
+  xwaitpid (serv_pid, &status, 0);
+  TEST_COMPARE (status, 0);
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/stdio-common/Makefile b/stdio-common/Makefile
index e312565f3b..c822434293 100644
--- a/stdio-common/Makefile
+++ b/stdio-common/Makefile
@@ -206,6 +206,7 @@ tests := \
   tst-cookie \
   tst-dprintf-length \
   tst-fdopen \
+  tst-fdopen2 \
   tst-ferror \
   tst-fgets \
   tst-fileno \
@@ -215,6 +216,7 @@ tests := \
   tst-fmemopen4 \
   tst-fphex \
   tst-fphex-wide \
+  tst-fread \
   tst-fseek \
   tst-fwrite \
   tst-gets \
@@ -243,6 +245,7 @@ tests := \
   tst-scanf-binary-c2x \
   tst-scanf-binary-gnu11 \
   tst-scanf-binary-gnu89 \
+  tst-scanf-bz27650 \
   tst-scanf-intn \
   tst-scanf-round \
   tst-scanf-to_inpunct \
@@ -256,6 +259,7 @@ tests := \
   tst-swscanf \
   tst-tmpnam \
   tst-ungetc \
+  tst-ungetc-leak \
   tst-unlockedio \
   tst-vfprintf-mbs-prec \
   tst-vfprintf-user-type \
@@ -300,6 +304,7 @@ tests-special += \
   $(objpfx)tst-printfsz-islongdouble.out \
   $(objpfx)tst-setvbuf1-cmp.out \
   $(objpfx)tst-unbputc.out \
+  $(objpfx)tst-ungetc-leak-mem.out \
   $(objpfx)tst-vfprintf-width-prec-mem.out \
   # tests-special
 
@@ -313,6 +318,9 @@ generated += \
   tst-printf-fp-free.mtrace \
   tst-printf-fp-leak-mem.out \
   tst-printf-fp-leak.mtrace \
+  tst-scanf-bz27650.mtrace \
+  tst-ungetc-leak-mem.out \
+  tst-ungetc-leak.mtrace \
   tst-vfprintf-width-prec-mem.out \
   tst-vfprintf-width-prec.mtrace \
   # generated
@@ -402,6 +410,12 @@ tst-printf-fp-free-ENV = \
 tst-printf-fp-leak-ENV = \
   MALLOC_TRACE=$(objpfx)tst-printf-fp-leak.mtrace \
   LD_PRELOAD=$(common-objpfx)/malloc/libc_malloc_debug.so
+tst-scanf-bz27650-ENV = \
+  MALLOC_TRACE=$(objpfx)tst-scanf-bz27650.mtrace \
+  LD_PRELOAD=$(common-objpfx)malloc/libc_malloc_debug.so
+tst-ungetc-leak-ENV = \
+  MALLOC_TRACE=$(objpfx)tst-ungetc-leak.mtrace \
+  LD_PRELOAD=$(common-objpfx)malloc/libc_malloc_debug.so
 
 $(objpfx)tst-unbputc.out: tst-unbputc.sh $(objpfx)tst-unbputc
 	$(SHELL) $< $(common-objpfx) '$(test-program-prefix)'; \
diff --git a/stdio-common/printf-parsemb.c b/stdio-common/printf-parsemb.c
index ab9fafb5ec..8db18f11b3 100644
--- a/stdio-common/printf-parsemb.c
+++ b/stdio-common/printf-parsemb.c
@@ -17,6 +17,7 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include <ctype.h>
+#include <errno.h>
 #include <limits.h>
 #include <stdlib.h>
 #include <string.h>
diff --git a/stdio-common/tst-fdopen2.c b/stdio-common/tst-fdopen2.c
new file mode 100644
index 0000000000..0c6625f258
--- /dev/null
+++ b/stdio-common/tst-fdopen2.c
@@ -0,0 +1,246 @@
+/* Test the fdopen function.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <stdio.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <support/check.h>
+#include <support/support.h>
+#include <support/xunistd.h>
+#include <support/temp_file.h>
+
+char *tmp_dir;
+char *path_to_file;
+
+void
+prepare_tmp_dir (void)
+{
+  tmp_dir = support_create_temp_directory ("tst-fdopen2");
+  path_to_file = xasprintf ("%s/tst-fdopen2.txt", tmp_dir);
+}
+
+/* open temp file descriptor with mode.  */
+int
+open_tmp_fd (int mode)
+{
+  int fd = xopen (path_to_file, mode, 0644);
+  return fd;
+}
+
+
+/* close and remove temp file with close.  */
+void
+close_tmp_fd (int fd)
+{
+  xclose (fd);
+  xunlink (path_to_file);
+}
+
+/* close and remove temp file with fclose.  */
+void
+close_tmp_fp (FILE *fp)
+{
+  fclose (fp);
+  xunlink (path_to_file);
+}
+
+/* test "w" fdopen mode.  */
+void
+do_test_fdopen_w (void)
+{
+  int fd, ret;
+  FILE *fp;
+  fd = open_tmp_fd (O_WRONLY | O_CREAT | O_TRUNC);
+
+  /* test mode mismatch.  */
+  fp = fdopen (fd, "r");
+  if (fp != NULL || errno != EINVAL)
+    {
+      close_tmp_fd (fd);
+      FAIL_EXIT1 ("fdopen (%d, r) should fail with EINVAL: %m", fd);
+    }
+
+  fp = fdopen (fd, "w");
+  if (fp == NULL)
+    {
+      close_tmp_fd (fd);
+      FAIL_EXIT1 ("fdopen (%d, w): %m", fd);
+    }
+
+  const void *buf = "AAAA";
+  ret = fwrite (buf, 1, 4, fp);
+  if (ret != 4)
+    {
+      close_tmp_fp (fp);
+      FAIL_EXIT1 ("fwrite (): %m");
+    }
+
+  unsigned char buf2[4];
+  rewind (fp);
+  clearerr (fp);
+  /* fread should fail in "w" mode  */
+  ret = fread (buf2, 1, 4, fp);
+  if (ret != 0 || ferror (fp) == 0)
+    {
+      close_tmp_fp (fp);
+      FAIL_EXIT1 ("fread should fail in \"w\" mode");
+    }
+
+  fclose (fp);
+}
+
+/* test "r" fdopen mode. */
+void
+do_test_fdopen_r (void)
+{
+  int fd, ret;
+  FILE *fp;
+  fd = open_tmp_fd (O_RDONLY);
+
+  /* test mode mismatch. */
+  fp = fdopen (fd, "w");
+  if (fp != NULL || errno != EINVAL)
+    {
+      close_tmp_fd (fd);
+      FAIL_EXIT1 ("fdopen (%d, w) should fail with EINVAL: %m", fd);
+    }
+
+  fp = fdopen (fd, "r");
+  if (fp == NULL)
+    {
+      close_tmp_fd (fd);
+      FAIL_EXIT1 ("fdopen (%d, w): %m", fd);
+    }
+
+  const void *buf = "BBBB";
+  /* fwrite should fail in "r" mode.  */
+  ret = fwrite (buf, 1, 4, fp);
+  if (ret != 0 || ferror (fp) == 0)
+    {
+      close_tmp_fp (fp);
+      FAIL_EXIT1 ("fwrite should fail in \"r\" mode");
+    }
+
+  unsigned char buf2[4];
+  ret = fread (buf2, 1, 4, fp);
+  if (ret != 4)
+    {
+      close_tmp_fp (fp);
+      FAIL_EXIT1 ("fread (): %m");
+    }
+
+  fclose (fp);
+}
+
+/* test "a" fdopen mode.  */
+void
+do_test_fdopen_a (void)
+{
+  int fd, ret;
+  FILE *fp;
+  fd = open_tmp_fd (O_WRONLY | O_CREAT | O_APPEND);
+
+  /* test mode mismatch.  */
+  fp = fdopen (fd, "r+");
+  if (fp != NULL || errno != EINVAL)
+    {
+      close_tmp_fd (fd);
+      FAIL_EXIT1 ("fdopen (%d, \"r+\") should fail with EINVAL: %m", fd);
+    }
+
+  fp = fdopen (fd, "a");
+  if (fp == NULL)
+    {
+      close_tmp_fd (fd);
+      FAIL_EXIT1 ("fdopen (%d, w): %m", fd);
+    }
+
+  const void *buf = "CCCC";
+  ret = fwrite (buf, 1, 4, fp);
+  if (ret != 4)
+    {
+      close_tmp_fp (fp);
+      FAIL_EXIT1 ("fwrite (): %m");
+    }
+
+  /* fread should fail in "a" mode.  */
+  unsigned char buf2[4];
+  clearerr (fp);
+  ret = fread (buf2, 1, 4, fp);
+  if (ret != 0 || ferror (fp) == 0)
+    {
+      close_tmp_fp (fp);
+      FAIL_EXIT1 ("fread should fail \"a\" mode");
+    }
+
+  fclose (fp);
+}
+
+void
+do_test_fdopen_mode (int mode, const char *fmode)
+{
+  int fd, ret;
+  FILE *fp;
+  fd = open_tmp_fd (mode);
+
+  fp = fdopen (fd, fmode);
+  if (fp == NULL)
+    {
+      close_tmp_fd (fd);
+      FAIL_EXIT1 ("fdopen (%d, %s): %m", fd, fmode);
+    }
+
+  const void *buf = "EEEE";
+  ret = fwrite (buf, 1, 4, fp);
+  if (ret != 4)
+    {
+      close_tmp_fp (fp);
+      FAIL_EXIT1 ("fwrite () in mode:%s returns %d: %m", fmode, ret);
+    }
+
+  rewind (fp);
+  unsigned char buf2[4];
+  ret = fread (buf2, 1, 4, fp);
+  if (ret != 4)
+    {
+      close_tmp_fp (fp);
+      FAIL_EXIT1 ("fread () in mode:%s returns %d: %m", fmode, ret);
+    }
+
+  fclose (fp);
+}
+
+static int
+do_test (void)
+{
+
+  prepare_tmp_dir ();
+
+  do_test_fdopen_w ();
+  do_test_fdopen_r ();
+  do_test_fdopen_a ();
+
+  /* test r+ w+ a+ fdopen modes.  */
+  do_test_fdopen_mode (O_RDWR, "r+");
+  do_test_fdopen_mode (O_RDWR | O_CREAT | O_TRUNC, "w+");
+  do_test_fdopen_mode (O_RDWR | O_CREAT | O_APPEND, "a+");
+  xunlink (path_to_file);
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/stdio-common/tst-fread.c b/stdio-common/tst-fread.c
new file mode 100644
index 0000000000..4d9a7895f6
--- /dev/null
+++ b/stdio-common/tst-fread.c
@@ -0,0 +1,134 @@
+/* Test fread.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <support/check.h>
+#include <support/support.h>
+#include <support/temp_file.h>
+#include <support/test-driver.h>
+#include <support/xstdio.h>
+#include <support/xunistd.h>
+
+int
+do_test (void)
+{
+  char *temp_dir = support_create_temp_directory ("tst-fread");
+  char *file1 = xasprintf ("%s/file1", temp_dir);
+  support_write_file_string (file1, "file1");
+  add_temp_file (file1);
+  FILE *fp;
+  size_t ret;
+  char buf[1024];
+
+  verbose_printf ("test single-byte reads\n");
+  fp = xfopen (file1, "r");
+  memset (buf, 0, sizeof buf);
+  ret = fread (buf, 1, 2, fp);
+  TEST_COMPARE (ret, 2);
+  TEST_COMPARE (buf[0], 'f');
+  TEST_COMPARE (buf[1], 'i');
+  TEST_COMPARE (feof (fp), 0);
+  TEST_COMPARE (ftell (fp), 2);
+  memset (buf, 0, sizeof buf);
+  ret = fread (buf, 1, 3, fp);
+  TEST_COMPARE (ret, 3);
+  TEST_COMPARE (buf[0], 'l');
+  TEST_COMPARE (buf[1], 'e');
+  TEST_COMPARE (buf[2], '1');
+  TEST_COMPARE (ftell (fp), 5);
+  TEST_COMPARE (feof (fp), 0);
+  memset (buf, 0, sizeof buf);
+  ret = fread (buf, 1, 1, fp);
+  TEST_COMPARE (ret, 0);
+  TEST_COMPARE (!!feof (fp), 1);
+  TEST_COMPARE (ferror (fp), 0);
+  TEST_COMPARE (ftell (fp), 5);
+  xfclose (fp);
+
+  verbose_printf ("test single-byte reads, EOF part way through\n");
+  fp = xfopen (file1, "r");
+  memset (buf, 0, sizeof buf);
+  ret = fread (buf, 1, sizeof buf, fp);
+  TEST_COMPARE (ret, 5);
+  TEST_COMPARE (buf[0], 'f');
+  TEST_COMPARE (buf[1], 'i');
+  TEST_COMPARE (buf[2], 'l');
+  TEST_COMPARE (buf[3], 'e');
+  TEST_COMPARE (buf[4], '1');
+  TEST_COMPARE (!!feof (fp), 1);
+  TEST_COMPARE (ferror (fp), 0);
+  TEST_COMPARE (ftell (fp), 5);
+  xfclose (fp);
+
+  verbose_printf ("test multi-byte reads\n");
+  fp = xfopen (file1, "r");
+  memset (buf, 0, sizeof buf);
+  ret = fread (buf, 2, 2, fp);
+  TEST_COMPARE (ret, 2);
+  TEST_COMPARE (buf[0], 'f');
+  TEST_COMPARE (buf[1], 'i');
+  TEST_COMPARE (buf[2], 'l');
+  TEST_COMPARE (buf[3], 'e');
+  TEST_COMPARE (feof (fp), 0);
+  TEST_COMPARE (ftell (fp), 4);
+  memset (buf, 0, sizeof buf);
+  ret = fread (buf, 3, 3, fp);
+  TEST_COMPARE (ret, 0);
+  /* The bytes written for a partial element read are unspecified.  */
+  TEST_COMPARE (!!feof (fp), 1);
+  TEST_COMPARE (ferror (fp), 0);
+  TEST_COMPARE (ftell (fp), 5);
+  xfclose (fp);
+
+  verbose_printf ("test read error\n");
+  fp = xfopen (file1, "r");
+  xclose (fileno (fp));
+  memset (buf, 0, sizeof buf);
+  ret = fread (buf, 1, sizeof buf, fp);
+  TEST_COMPARE (ret, 0);
+  TEST_COMPARE (feof (fp), 0);
+  TEST_COMPARE (!!ferror (fp), 1);
+  fclose (fp);
+
+  verbose_printf ("test zero size\n");
+  fp = xfopen (file1, "r");
+  ret = fread (buf, 0, SIZE_MAX, fp);
+  TEST_COMPARE (ret, 0);
+  TEST_COMPARE (feof (fp), 0);
+  TEST_COMPARE (ferror (fp), 0);
+  TEST_COMPARE (ftell (fp), 0);
+  xfclose (fp);
+
+  verbose_printf ("test zero items\n");
+  fp = xfopen (file1, "r");
+  ret = fread (buf, SIZE_MAX, 0, fp);
+  TEST_COMPARE (ret, 0);
+  TEST_COMPARE (feof (fp), 0);
+  TEST_COMPARE (ferror (fp), 0);
+  TEST_COMPARE (ftell (fp), 0);
+  xfclose (fp);
+
+  free (temp_dir);
+  free (file1);
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/stdio-common/tst-scanf-bz27650.c b/stdio-common/tst-scanf-bz27650.c
new file mode 100644
index 0000000000..3a742bc865
--- /dev/null
+++ b/stdio-common/tst-scanf-bz27650.c
@@ -0,0 +1,108 @@
+/* Test for BZ #27650, formatted input matching beyond INT_MAX.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <error.h>
+#include <errno.h>
+#include <limits.h>
+#include <mcheck.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <sys/types.h>
+
+#include <support/check.h>
+#include <support/test-driver.h>
+
+/* Produce a stream of more than INT_MAX characters via buffer BUF of
+   size SIZE according to bookkeeping in COOKIE and then return EOF.  */
+
+static ssize_t
+io_read (void *cookie, char *buf, size_t size)
+{
+  unsigned int *written = cookie;
+  unsigned int w = *written;
+
+  if (w > INT_MAX)
+    return 0;
+
+  memset (buf, 'a', size);
+  *written = w + size;
+  return size;
+}
+
+/* Consume a stream of more than INT_MAX characters from an artificial
+   input stream of which none is the new line character.  The call to
+   fscanf is supposed to complete upon the EOF condition of input,
+   however in the presence of BZ #27650 it will terminate prematurely
+   with characters still outstanding in input.  Diagnose the condition
+   and return status accordingly.  */
+
+int
+do_test (void)
+{
+  static cookie_io_functions_t io_funcs = { .read = io_read };
+  unsigned int written = 0;
+  FILE *in;
+  int v;
+
+  mtrace ();
+
+  in = fopencookie (&written, "r", io_funcs);
+  if (in == NULL)
+    {
+      FAIL ("fopencookie: %m");
+      goto out;
+    }
+
+  v = fscanf (in, "%*[^\n]");
+  if (ferror (in))
+    {
+      FAIL ("fscanf: input failure, at %u: %m", written);
+      goto out_close;
+    }
+  else if (v == EOF)
+    {
+      FAIL ("fscanf: unexpected end of file, at %u", written);
+      goto out_close;
+    }
+
+  if (!feof (in))
+    {
+      v = fgetc (in);
+      if (ferror (in))
+	FAIL ("fgetc: input failure: %m");
+      else if (v == EOF)
+	FAIL ("fgetc: unexpected end of file after missing end of file");
+      else if (v == '\n')
+	FAIL ("unexpected new line character received");
+      else
+	FAIL ("character received after end of file expected: \\x%02x", v);
+    }
+
+out_close:
+  if (fclose (in) != 0)
+    FAIL ("fclose: %m");
+
+out:
+  return EXIT_SUCCESS;
+}
+
+#define TIMEOUT (DEFAULT_TIMEOUT * 8)
+#include <support/test-driver.c>
diff --git a/stdio-common/tst-ungetc-leak.c b/stdio-common/tst-ungetc-leak.c
new file mode 100644
index 0000000000..6c5152b43f
--- /dev/null
+++ b/stdio-common/tst-ungetc-leak.c
@@ -0,0 +1,32 @@
+/* Test for memory leak with ungetc when stream is unused.
+   Copyright The GNU Toolchain Authors.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <stdio.h>
+#include <mcheck.h>
+#include <support/check.h>
+#include <support/support.h>
+
+static int
+do_test (void)
+{
+  mtrace ();
+  TEST_COMPARE (ungetc('y', stdin), 'y');
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/stdio-common/tst-ungetc.c b/stdio-common/tst-ungetc.c
index 1344b2b591..388b202493 100644
--- a/stdio-common/tst-ungetc.c
+++ b/stdio-common/tst-ungetc.c
@@ -1,70 +1,74 @@
-/* Test for ungetc bugs.  */
+/* Test for ungetc bugs.
+   Copyright (C) 1996-2024 Free Software Foundation, Inc.
+   Copyright The GNU Toolchain Authors.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
 
 #include <stdio.h>
 #include <stdlib.h>
-#include <unistd.h>
-
-#undef assert
-#define assert(x) \
-  if (!(x)) \
-    { \
-      fputs ("test failed: " #x "\n", stderr); \
-      retval = 1; \
-      goto the_end; \
-    }
+#include <support/check.h>
+#include <support/support.h>
+#include <support/temp_file.h>
+#include <support/xstdio.h>
+#include <support/xunistd.h>
 
-int
-main (int argc, char *argv[])
+static int
+do_test (void)
 {
-  char name[] = "/tmp/tst-ungetc.XXXXXX";
+  char *name = NULL;
   FILE *fp = NULL;
-  int retval = 0;
   int c;
   char buffer[64];
 
-  int fd = mkstemp (name);
+  int fd = create_temp_file ("tst-ungetc.", &name);
   if (fd == -1)
-    {
-      printf ("mkstemp failed: %m\n");
-      return 1;
-    }
-  close (fd);
-  fp = fopen (name, "w");
-  assert (fp != NULL)
-  fputs ("bla", fp);
-  fclose (fp);
-  fp = NULL;
+    FAIL_EXIT1 ("cannot create temporary file: %m");
+  xclose (fd);
 
-  fp = fopen (name, "r");
-  assert (fp != NULL);
-  assert (ungetc ('z', fp) == 'z');
-  assert (getc (fp) == 'z');
-  assert (getc (fp) == 'b');
-  assert (getc (fp) == 'l');
-  assert (ungetc ('m', fp) == 'm');
-  assert (getc (fp) == 'm');
-  assert ((c = getc (fp)) == 'a');
-  assert (getc (fp) == EOF);
-  assert (ungetc (c, fp) == c);
-  assert (feof (fp) == 0);
-  assert (getc (fp) == c);
-  assert (getc (fp) == EOF);
-  fclose (fp);
-  fp = NULL;
+  fp = xfopen (name, "w");
+  fputs ("bla", fp);
+  xfclose (fp);
 
-  fp = fopen (name, "r");
-  assert (fp != NULL);
-  assert (getc (fp) == 'b');
-  assert (getc (fp) == 'l');
-  assert (ungetc ('b', fp) == 'b');
-  assert (fread (buffer, 1, 64, fp) == 2);
-  assert (buffer[0] == 'b');
-  assert (buffer[1] == 'a');
+  fp = xfopen (name, "r");
+  TEST_VERIFY_EXIT (ungetc ('z', fp) == 'z');
+  TEST_VERIFY_EXIT (getc (fp) == 'z');
+  TEST_VERIFY_EXIT (getc (fp) == 'b');
+  TEST_VERIFY_EXIT (getc (fp) == 'l');
+  TEST_VERIFY_EXIT (ungetc ('m', fp) == 'm');
+  TEST_VERIFY_EXIT (ungetc ('n', fp) == 'n');
+  TEST_VERIFY_EXIT (getc (fp) == 'n');
+  TEST_VERIFY_EXIT (getc (fp) == 'm');
+  TEST_VERIFY_EXIT ((c = getc (fp)) == 'a');
+  TEST_VERIFY_EXIT (getc (fp) == EOF);
+  TEST_VERIFY_EXIT (ungetc (c, fp) == c);
+  TEST_VERIFY_EXIT (feof (fp) == 0);
+  TEST_VERIFY_EXIT (getc (fp) == c);
+  TEST_VERIFY_EXIT (getc (fp) == EOF);
+  xfclose (fp);
 
-the_end:
-  if (fp != NULL)
-    fclose (fp);
-  unlink (name);
+  fp = xfopen (name, "r");
+  TEST_VERIFY_EXIT (getc (fp) == 'b');
+  TEST_VERIFY_EXIT (getc (fp) == 'l');
+  TEST_VERIFY_EXIT (ungetc ('b', fp) == 'b');
+  TEST_VERIFY_EXIT (fread (buffer, 1, 64, fp) == 2);
+  TEST_VERIFY_EXIT (buffer[0] == 'b');
+  TEST_VERIFY_EXIT (buffer[1] == 'a');
+  xfclose (fp);
 
-  return retval;
+  return 0;
 }
+
+#include <support/test-driver.c>
diff --git a/stdlib/Makefile b/stdlib/Makefile
index d587f054d1..992b7325dc 100644
--- a/stdlib/Makefile
+++ b/stdlib/Makefile
@@ -307,7 +307,9 @@ tests := \
   tst-setcontext9 \
   tst-setcontext10 \
   tst-setcontext11 \
+  tst-setenv-environ \
   tst-stdbit-Wconversion \
+  tst-stdbit-builtins \
   tst-stdc_bit_ceil \
   tst-stdc_bit_floor \
   tst-stdc_bit_width \
@@ -601,6 +603,8 @@ $(objpfx)bug-strtod2: $(libm)
 $(objpfx)tst-strtod-round: $(libm)
 $(objpfx)tst-tininess: $(libm)
 $(objpfx)tst-strtod-underflow: $(libm)
+$(objpfx)tst-strtod5: $(libm)
+$(objpfx)tst-strtod5i: $(libm)
 $(objpfx)tst-strtod6: $(libm)
 $(objpfx)tst-strtod-nan-locale: $(libm)
 $(objpfx)tst-strtod-nan-sign: $(libm)
diff --git a/stdlib/arc4random.c b/stdlib/arc4random.c
index 3ae8fc1302..7818cb9cf6 100644
--- a/stdlib/arc4random.c
+++ b/stdlib/arc4random.c
@@ -51,7 +51,7 @@ __arc4random_buf (void *p, size_t n)
 	  n -= l;
 	  continue; /* Interrupted by a signal; keep going.  */
 	}
-      else if (l == -ENOSYS)
+      else if (l < 0 && errno == ENOSYS)
 	break; /* No syscall, so fallback to /dev/urandom.  */
       arc4random_getrandom_failure ();
     }
diff --git a/stdlib/bits/stdlib.h b/stdlib/bits/stdlib.h
index 1c7191ba57..32f7ef5020 100644
--- a/stdlib/bits/stdlib.h
+++ b/stdlib/bits/stdlib.h
@@ -36,16 +36,16 @@ extern char *__REDIRECT_NTH (__realpath_chk_warn,
 __fortify_function __wur char *
 __NTH (realpath (const char *__restrict __name, char *__restrict __resolved))
 {
-  size_t sz = __glibc_objsize (__resolved);
+  size_t __sz = __glibc_objsize (__resolved);
 
-  if (sz == (size_t) -1)
+  if (__sz == (size_t) -1)
     return __realpath_alias (__name, __resolved);
 
 #if defined _LIBC_LIMITS_H_ && defined PATH_MAX
-  if (__glibc_unsafe_len (PATH_MAX, sizeof (char), sz))
-    return __realpath_chk_warn (__name, __resolved, sz);
+  if (__glibc_unsafe_len (PATH_MAX, sizeof (char), __sz))
+    return __realpath_chk_warn (__name, __resolved, __sz);
 #endif
-  return __realpath_chk (__name, __resolved, sz);
+  return __realpath_chk (__name, __resolved, __sz);
 }
 
 
diff --git a/stdlib/gen-tst-strtod-round.c b/stdlib/gen-tst-strtod-round.c
index e48bf4d6ea..7ce735f81d 100644
--- a/stdlib/gen-tst-strtod-round.c
+++ b/stdlib/gen-tst-strtod-round.c
@@ -46,6 +46,7 @@ static int
 string_to_fp (mpfr_t f, const char *s, mpfr_rnd_t rnd)
 {
   mpfr_clear_overflow ();
+  mpfr_clear_underflow ();
 #ifdef WORKAROUND
   mpfr_t f2;
   mpfr_init2 (f2, 100000);
@@ -53,12 +54,16 @@ string_to_fp (mpfr_t f, const char *s, mpfr_rnd_t rnd)
   int r = mpfr_set (f, f2, rnd);
   r |= mpfr_subnormalize (f, r, rnd);
   mpfr_clear (f2);
-  return r0 | r;
+  r |= r0;
 #else
   int r = mpfr_strtofr (f, s, NULL, 0, rnd);
   r |= mpfr_subnormalize (f, r, rnd);
-  return r;
 #endif
+  if (r == 0)
+    /* The MPFR underflow flag is set for exact subnormal results,
+       which is not wanted here.  */
+    mpfr_clear_underflow ();
+  return r;
 }
 
 void
@@ -70,6 +75,21 @@ print_fp (FILE *fout, mpfr_t f, const char *suffix)
     mpfr_fprintf (fout, "\t%Ra%s", f, suffix);
 }
 
+static const char *
+suffix_to_print (bool overflow, bool underflow, bool underflow_before_rounding,
+		 bool with_comma)
+{
+  if (overflow)
+    return with_comma ? ", true, false,\n" : ", true, false";
+  if (underflow)
+    return with_comma ? ", false, true,\n" : ", false, true";
+  if (underflow_before_rounding)
+    return (with_comma
+	    ? ", false, !TININESS_AFTER_ROUNDING,\n"
+	    : ", false, !TININESS_AFTER_ROUNDING");
+  return with_comma ? ", false, false,\n" : ", false, false";
+}
+
 static void
 round_str (FILE *fout, const char *s, int prec, int emin, int emax,
 	   bool ibm_ld)
@@ -80,8 +100,11 @@ round_str (FILE *fout, const char *s, int prec, int emin, int emax,
   mpfr_set_emin (emin);
   mpfr_set_emax (emax);
   mpfr_init (f);
+  string_to_fp (f, s, MPFR_RNDZ);
+  bool underflow_before_rounding = mpfr_underflow_p () != 0;
   int r = string_to_fp (f, s, MPFR_RNDD);
   bool overflow = mpfr_overflow_p () != 0;
+  bool underflow = mpfr_underflow_p () != 0;
   if (ibm_ld)
     {
       assert (prec == 106 && emin == -1073 && emax == 1024);
@@ -97,19 +120,27 @@ round_str (FILE *fout, const char *s, int prec, int emin, int emax,
 	}
     }
   mpfr_fprintf (fout, "\t%s,\n", r ? "false" : "true");
-  print_fp (fout, f, overflow ? ", true,\n" : ", false,\n");
+  print_fp (fout, f,
+	    suffix_to_print (overflow, underflow, underflow_before_rounding,
+			     true));
   string_to_fp (f, s, MPFR_RNDN);
   overflow = (mpfr_overflow_p () != 0
 	      || (ibm_ld && mpfr_cmpabs (f, max_value) > 0));
-  print_fp (fout, f, overflow ? ", true,\n" : ", false,\n");
+  print_fp (fout, f,
+	    suffix_to_print (overflow, underflow, underflow_before_rounding,
+			     true));
   string_to_fp (f, s, MPFR_RNDZ);
   overflow = (mpfr_overflow_p () != 0
 	      || (ibm_ld && mpfr_cmpabs (f, max_value) > 0));
-  print_fp (fout, f, overflow ? ", true,\n" : ", false,\n");
+  print_fp (fout, f,
+	    suffix_to_print (overflow, underflow, underflow_before_rounding,
+			     true));
   string_to_fp (f, s, MPFR_RNDU);
   overflow = (mpfr_overflow_p () != 0
 	      || (ibm_ld && mpfr_cmpabs (f, max_value) > 0));
-  print_fp (fout, f, overflow ? ", true" : ", false");
+  print_fp (fout, f,
+	    suffix_to_print (overflow, underflow, underflow_before_rounding,
+			     false));
   mpfr_clear (f);
   if (ibm_ld)
     mpfr_clear (max_value);
diff --git a/stdlib/stdbit.h b/stdlib/stdbit.h
index f334eb174d..2801590c63 100644
--- a/stdlib/stdbit.h
+++ b/stdlib/stdbit.h
@@ -64,9 +64,13 @@ extern unsigned int stdc_leading_zeros_ul (unsigned long int __x)
 __extension__
 extern unsigned int stdc_leading_zeros_ull (unsigned long long int __x)
      __THROW __attribute_const__;
-#define stdc_leading_zeros(x)				\
+#if __glibc_has_builtin (__builtin_stdc_leading_zeros)
+# define stdc_leading_zeros(x) (__builtin_stdc_leading_zeros (x))
+#else
+# define stdc_leading_zeros(x)				\
   (stdc_leading_zeros_ull (x)				\
    - (unsigned int) (8 * (sizeof (0ULL) - sizeof (x))))
+#endif
 
 #if __GNUC_PREREQ (3, 4) || __glibc_has_builtin (__builtin_clzll)
 static __always_inline unsigned int
@@ -116,9 +120,13 @@ extern unsigned int stdc_leading_ones_ul (unsigned long int __x)
 __extension__
 extern unsigned int stdc_leading_ones_ull (unsigned long long int __x)
      __THROW __attribute_const__;
-#define stdc_leading_ones(x)					\
+#if __glibc_has_builtin (__builtin_stdc_leading_ones)
+# define stdc_leading_ones(x) (__builtin_stdc_leading_ones (x))
+#else
+# define stdc_leading_ones(x)					\
   (stdc_leading_ones_ull ((unsigned long long int) (x)		\
 			  << 8 * (sizeof (0ULL) - sizeof (x))))
+#endif
 
 #if __GNUC_PREREQ (3, 4) || __glibc_has_builtin (__builtin_clzll)
 static __always_inline unsigned int
@@ -168,11 +176,15 @@ extern unsigned int stdc_trailing_zeros_ul (unsigned long int __x)
 __extension__
 extern unsigned int stdc_trailing_zeros_ull (unsigned long long int __x)
      __THROW __attribute_const__;
-#define stdc_trailing_zeros(x)				\
+#if __glibc_has_builtin (__builtin_stdc_trailing_zeros)
+# define stdc_trailing_zeros(x) (__builtin_stdc_trailing_zeros (x))
+#else
+# define stdc_trailing_zeros(x)				\
   (sizeof (x) == 8 ? stdc_trailing_zeros_ull (x)	\
    : sizeof (x) == 4 ? stdc_trailing_zeros_ui (x)	\
    : sizeof (x) == 2 ? stdc_trailing_zeros_us (__pacify_uint16 (x))	\
    : stdc_trailing_zeros_uc (__pacify_uint8 (x)))
+#endif
 
 #if __GNUC_PREREQ (3, 4) || __glibc_has_builtin (__builtin_ctzll)
 static __always_inline unsigned int
@@ -222,7 +234,11 @@ extern unsigned int stdc_trailing_ones_ul (unsigned long int __x)
 __extension__
 extern unsigned int stdc_trailing_ones_ull (unsigned long long int __x)
      __THROW __attribute_const__;
-#define stdc_trailing_ones(x) (stdc_trailing_ones_ull (x))
+#if __glibc_has_builtin (__builtin_stdc_trailing_ones)
+# define stdc_trailing_ones(x) (__builtin_stdc_trailing_ones (x))
+#else
+# define stdc_trailing_ones(x) (stdc_trailing_ones_ull (x))
+#endif
 
 #if __GNUC_PREREQ (3, 4) || __glibc_has_builtin (__builtin_ctzll)
 static __always_inline unsigned int
@@ -272,11 +288,15 @@ extern unsigned int stdc_first_leading_zero_ul (unsigned long int __x)
 __extension__
 extern unsigned int stdc_first_leading_zero_ull (unsigned long long int __x)
      __THROW __attribute_const__;
-#define stdc_first_leading_zero(x)			\
+#if __glibc_has_builtin (__builtin_stdc_first_leading_zero)
+# define stdc_first_leading_zero(x) (__builtin_stdc_first_leading_zero (x))
+#else
+# define stdc_first_leading_zero(x)			\
   (sizeof (x) == 8 ? stdc_first_leading_zero_ull (x)	\
    : sizeof (x) == 4 ? stdc_first_leading_zero_ui (x)	\
    : sizeof (x) == 2 ? stdc_first_leading_zero_us (__pacify_uint16 (x))	\
    : stdc_first_leading_zero_uc (__pacify_uint8 (x)))
+#endif
 
 #if __GNUC_PREREQ (3, 4) || __glibc_has_builtin (__builtin_clzll)
 static __always_inline unsigned int
@@ -326,11 +346,15 @@ extern unsigned int stdc_first_leading_one_ul (unsigned long int __x)
 __extension__
 extern unsigned int stdc_first_leading_one_ull (unsigned long long int __x)
      __THROW __attribute_const__;
-#define stdc_first_leading_one(x)			\
+#if __glibc_has_builtin (__builtin_stdc_first_leading_one)
+# define stdc_first_leading_one(x) (__builtin_stdc_first_leading_one (x))
+#else
+# define stdc_first_leading_one(x)			\
   (sizeof (x) == 8 ? stdc_first_leading_one_ull (x)	\
    : sizeof (x) == 4 ? stdc_first_leading_one_ui (x)	\
    : sizeof (x) == 2 ? stdc_first_leading_one_us (__pacify_uint16 (x))	\
    : stdc_first_leading_one_uc (__pacify_uint8 (x)))
+#endif
 
 #if __GNUC_PREREQ (3, 4) || __glibc_has_builtin (__builtin_clzll)
 static __always_inline unsigned int
@@ -380,11 +404,15 @@ extern unsigned int stdc_first_trailing_zero_ul (unsigned long int __x)
 __extension__
 extern unsigned int stdc_first_trailing_zero_ull (unsigned long long int __x)
      __THROW __attribute_const__;
-#define stdc_first_trailing_zero(x)			\
+#if __glibc_has_builtin (__builtin_stdc_first_trailing_zero)
+# define stdc_first_trailing_zero(x) (__builtin_stdc_first_trailing_zero (x))
+#else
+# define stdc_first_trailing_zero(x)			\
   (sizeof (x) == 8 ? stdc_first_trailing_zero_ull (x)	\
    : sizeof (x) == 4 ? stdc_first_trailing_zero_ui (x)	\
    : sizeof (x) == 2 ? stdc_first_trailing_zero_us (__pacify_uint16 (x)) \
    : stdc_first_trailing_zero_uc (__pacify_uint8 (x)))
+#endif
 
 #if __GNUC_PREREQ (3, 4) || __glibc_has_builtin (__builtin_ctzll)
 static __always_inline unsigned int
@@ -434,11 +462,15 @@ extern unsigned int stdc_first_trailing_one_ul (unsigned long int __x)
 __extension__
 extern unsigned int stdc_first_trailing_one_ull (unsigned long long int __x)
      __THROW __attribute_const__;
-#define stdc_first_trailing_one(x)			\
+#if __glibc_has_builtin (__builtin_stdc_first_trailing_one)
+# define stdc_first_trailing_one(x) (__builtin_stdc_first_trailing_one (x))
+#else
+# define stdc_first_trailing_one(x)			\
   (sizeof (x) == 8 ? stdc_first_trailing_one_ull (x)	\
    : sizeof (x) == 4 ? stdc_first_trailing_one_ui (x)	\
    : sizeof (x) == 2 ? stdc_first_trailing_one_us (__pacify_uint16 (x))	\
    : stdc_first_trailing_one_uc (__pacify_uint8 (x)))
+#endif
 
 #if __GNUC_PREREQ (3, 4) || __glibc_has_builtin (__builtin_ctzll)
 static __always_inline unsigned int
@@ -488,9 +520,13 @@ extern unsigned int stdc_count_zeros_ul (unsigned long int __x)
 __extension__
 extern unsigned int stdc_count_zeros_ull (unsigned long long int __x)
      __THROW __attribute_const__;
-#define stdc_count_zeros(x)				\
+#if __glibc_has_builtin (__builtin_stdc_count_zeros)
+# define stdc_count_zeros(x) (__builtin_stdc_count_zeros (x))
+#else
+# define stdc_count_zeros(x)				\
   (stdc_count_zeros_ull (x)				\
    - (unsigned int) (8 * (sizeof (0ULL) - sizeof (x))))
+#endif
 
 #if __GNUC_PREREQ (3, 4) || __glibc_has_builtin (__builtin_popcountll)
 static __always_inline unsigned int
@@ -540,7 +576,11 @@ extern unsigned int stdc_count_ones_ul (unsigned long int __x)
 __extension__
 extern unsigned int stdc_count_ones_ull (unsigned long long int __x)
      __THROW __attribute_const__;
-#define stdc_count_ones(x) (stdc_count_ones_ull (x))
+#if __glibc_has_builtin (__builtin_stdc_count_ones)
+# define stdc_count_ones(x) (__builtin_stdc_count_ones (x))
+#else
+# define stdc_count_ones(x) (stdc_count_ones_ull (x))
+#endif
 
 #if __GNUC_PREREQ (3, 4) || __glibc_has_builtin (__builtin_popcountll)
 static __always_inline unsigned int
@@ -590,10 +630,14 @@ extern bool stdc_has_single_bit_ul (unsigned long int __x)
 __extension__
 extern bool stdc_has_single_bit_ull (unsigned long long int __x)
      __THROW __attribute_const__;
-#define stdc_has_single_bit(x)				\
+#if __glibc_has_builtin (__builtin_stdc_has_single_bit)
+# define stdc_has_single_bit(x) (__builtin_stdc_has_single_bit (x))
+#else
+# define stdc_has_single_bit(x)				\
   ((bool) (sizeof (x) <= sizeof (unsigned int)		\
 	   ? stdc_has_single_bit_ui (x)			\
 	   : stdc_has_single_bit_ull (x)))
+#endif
 
 static __always_inline bool
 __hsb64_inline (uint64_t __x)
@@ -641,7 +685,11 @@ extern unsigned int stdc_bit_width_ul (unsigned long int __x)
 __extension__
 extern unsigned int stdc_bit_width_ull (unsigned long long int __x)
      __THROW __attribute_const__;
-#define stdc_bit_width(x) (stdc_bit_width_ull (x))
+#if __glibc_has_builtin (__builtin_stdc_bit_width)
+# define stdc_bit_width(x) (__builtin_stdc_bit_width (x))
+#else
+# define stdc_bit_width(x) (stdc_bit_width_ull (x))
+#endif
 
 #if __GNUC_PREREQ (3, 4) || __glibc_has_builtin (__builtin_clzll)
 static __always_inline unsigned int
@@ -691,7 +739,11 @@ extern unsigned long int stdc_bit_floor_ul (unsigned long int __x)
 __extension__
 extern unsigned long long int stdc_bit_floor_ull (unsigned long long int __x)
      __THROW __attribute_const__;
-#define stdc_bit_floor(x) ((__typeof (x)) stdc_bit_floor_ull (x))
+#if __glibc_has_builtin (__builtin_stdc_bit_floor)
+# define stdc_bit_floor(x) (__builtin_stdc_bit_floor (x))
+#else
+# define stdc_bit_floor(x) ((__typeof (x)) stdc_bit_floor_ull (x))
+#endif
 
 #if __GNUC_PREREQ (3, 4) || __glibc_has_builtin (__builtin_clzll)
 static __always_inline uint64_t
@@ -743,7 +795,11 @@ extern unsigned long int stdc_bit_ceil_ul (unsigned long int __x)
 __extension__
 extern unsigned long long int stdc_bit_ceil_ull (unsigned long long int __x)
      __THROW __attribute_const__;
-#define stdc_bit_ceil(x) ((__typeof (x)) stdc_bit_ceil_ull (x))
+#if __glibc_has_builtin (__builtin_stdc_bit_ceil)
+# define stdc_bit_ceil(x) (__builtin_stdc_bit_ceil (x))
+#else
+# define stdc_bit_ceil(x) ((__typeof (x)) stdc_bit_ceil_ull (x))
+#endif
 
 #if __GNUC_PREREQ (3, 4) || __glibc_has_builtin (__builtin_clzll)
 static __always_inline uint64_t
diff --git a/stdlib/strtod_l.c b/stdlib/strtod_l.c
index be515ce659..beb97b3d0c 100644
--- a/stdlib/strtod_l.c
+++ b/stdlib/strtod_l.c
@@ -222,6 +222,7 @@ round_and_return (mp_limb_t *retval, intmax_t exponent, int negative,
 
       mp_size_t shift = MIN_EXP - 1 - exponent;
       bool is_tiny = true;
+      bool old_half_bit = (round_limb & (((mp_limb_t) 1) << round_bit)) != 0;
 
       more_bits |= (round_limb & ((((mp_limb_t) 1) << round_bit) - 1)) != 0;
       if (shift == MANT_DIG)
@@ -292,6 +293,7 @@ round_and_return (mp_limb_t *retval, intmax_t exponent, int negative,
 	  round_bit = shift - 1;
 	  (void) __mpn_rshift (retval, retval, RETURN_LIMB_SIZE, shift);
 	}
+      more_bits |= old_half_bit;
       /* This is a hook for the m68k long double format, where the
 	 exponent bias is the same for normalized and denormalized
 	 numbers.  */
diff --git a/stdlib/strtod_nan_main.c b/stdlib/strtod_nan_main.c
index 4cb286d2b3..39fb7e9f75 100644
--- a/stdlib/strtod_nan_main.c
+++ b/stdlib/strtod_nan_main.c
@@ -16,6 +16,7 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
+#include <errno.h>
 #include <ieee754.h>
 #include <locale.h>
 #include <math.h>
@@ -50,7 +51,9 @@ STRTOD_NAN (const STRING_TYPE *str, STRING_TYPE **endptr, STRING_TYPE endc)
   STRING_TYPE *endp;
   unsigned long long int mant;
 
+  int save_errno = errno;
   mant = STRTOULL (str, &endp, 0);
+  __set_errno (save_errno);
   if (endp == cp)
     SET_NAN_PAYLOAD (retval, mant);
 
diff --git a/stdlib/tst-secure-getenv.c b/stdlib/tst-secure-getenv.c
index cc26ed6d15..cefee58d46 100644
--- a/stdlib/tst-secure-getenv.c
+++ b/stdlib/tst-secure-getenv.c
@@ -57,13 +57,7 @@ do_test (void)
       exit (1);
     }
 
-  int status = support_capture_subprogram_self_sgid (MAGIC_ARGUMENT);
-
-  if (WEXITSTATUS (status) == EXIT_UNSUPPORTED)
-    return EXIT_UNSUPPORTED;
-
-  if (!WIFEXITED (status))
-    FAIL_EXIT1 ("Unexpected exit status %d from child process\n", status);
+  support_capture_subprogram_self_sgid (MAGIC_ARGUMENT);
 
   return 0;
 }
@@ -82,6 +76,7 @@ alternative_main (int argc, char **argv)
       if (secure_getenv ("PATH") != NULL)
 	FAIL_EXIT (4, "PATH variable not filtered out\n");
 
+      support_record_failure_barrier ();
       exit (EXIT_SUCCESS);
     }
 }
diff --git a/stdlib/tst-setenv-environ.c b/stdlib/tst-setenv-environ.c
new file mode 100644
index 0000000000..02fcef96d0
--- /dev/null
+++ b/stdlib/tst-setenv-environ.c
@@ -0,0 +1,36 @@
+/* Test using setenv with updated environ.
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <stdlib.h>
+#include <support/check.h>
+
+extern char **environ;
+
+int
+do_test (void)
+{
+  char *valp;
+  static char *dummy_environ[] = { NULL };
+  environ = dummy_environ;
+  setenv ("A", "1", 0);
+  valp = getenv ("A");
+  TEST_VERIFY_EXIT (valp[0] == '1' && valp[1] == '\0');
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/stdlib/tst-stdbit-builtins.c b/stdlib/tst-stdbit-builtins.c
new file mode 100644
index 0000000000..536841ca8a
--- /dev/null
+++ b/stdlib/tst-stdbit-builtins.c
@@ -0,0 +1,778 @@
+/* Test <stdbit.h> type-generic macros with compiler __builtin_stdc_* support.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <stdbit.h>
+#include <limits.h>
+#include <support/check.h>
+
+#if __glibc_has_builtin (__builtin_stdc_leading_zeros) \
+    && __glibc_has_builtin (__builtin_stdc_leading_ones) \
+    && __glibc_has_builtin (__builtin_stdc_trailing_zeros) \
+    && __glibc_has_builtin (__builtin_stdc_trailing_ones) \
+    && __glibc_has_builtin (__builtin_stdc_first_leading_zero) \
+    && __glibc_has_builtin (__builtin_stdc_first_leading_one) \
+    && __glibc_has_builtin (__builtin_stdc_first_trailing_zero) \
+    && __glibc_has_builtin (__builtin_stdc_first_trailing_one) \
+    && __glibc_has_builtin (__builtin_stdc_count_zeros) \
+    && __glibc_has_builtin (__builtin_stdc_count_ones) \
+    && __glibc_has_builtin (__builtin_stdc_has_single_bit) \
+    && __glibc_has_builtin (__builtin_stdc_bit_width) \
+    && __glibc_has_builtin (__builtin_stdc_bit_floor) \
+    && __glibc_has_builtin (__builtin_stdc_bit_ceil)
+
+# if !defined (BITINT_MAXWIDTH) && defined (__BITINT_MAXWIDTH__)
+#  define BITINT_MAXWIDTH __BITINT_MAXWIDTH__
+# endif
+
+typedef unsigned char uc;
+typedef unsigned short us;
+typedef unsigned int ui;
+typedef unsigned long int ul;
+typedef unsigned long long int ull;
+
+# define expr_has_type(e, t) _Generic (e, default : 0, t : 1)
+
+static int
+do_test (void)
+{
+  TEST_COMPARE (stdc_leading_zeros ((uc) 0), CHAR_BIT);
+  TEST_COMPARE (expr_has_type (stdc_leading_zeros ((uc) 0), ui), 1);
+  TEST_COMPARE (stdc_leading_zeros ((us) 0), sizeof (short) * CHAR_BIT);
+  TEST_COMPARE (expr_has_type (stdc_leading_zeros ((us) 0), ui), 1);
+  TEST_COMPARE (stdc_leading_zeros (0U), sizeof (int) * CHAR_BIT);
+  TEST_COMPARE (expr_has_type (stdc_leading_zeros (0U), ui), 1);
+  TEST_COMPARE (stdc_leading_zeros (0UL), sizeof (long int) * CHAR_BIT);
+  TEST_COMPARE (expr_has_type (stdc_leading_zeros (0UL), ui), 1);
+  TEST_COMPARE (stdc_leading_zeros (0ULL), sizeof (long long int) * CHAR_BIT);
+  TEST_COMPARE (expr_has_type (stdc_leading_zeros (0ULL), ui), 1);
+  TEST_COMPARE (stdc_leading_zeros ((uc) ~0U), 0);
+  TEST_COMPARE (stdc_leading_zeros ((us) ~0U), 0);
+  TEST_COMPARE (stdc_leading_zeros (~0U), 0);
+  TEST_COMPARE (stdc_leading_zeros (~0UL), 0);
+  TEST_COMPARE (stdc_leading_zeros (~0ULL), 0);
+  TEST_COMPARE (stdc_leading_zeros ((uc) 3), CHAR_BIT - 2);
+  TEST_COMPARE (stdc_leading_zeros ((us) 9), sizeof (short) * CHAR_BIT - 4);
+  TEST_COMPARE (stdc_leading_zeros (34U), sizeof (int) * CHAR_BIT - 6);
+  TEST_COMPARE (stdc_leading_zeros (130UL), sizeof (long int) * CHAR_BIT - 8);
+  TEST_COMPARE (stdc_leading_zeros (512ULL),
+		sizeof (long long int) * CHAR_BIT - 10);
+  TEST_COMPARE (stdc_leading_ones ((uc) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_leading_ones ((uc) 0), ui), 1);
+  TEST_COMPARE (stdc_leading_ones ((us) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_leading_ones ((us) 0), ui), 1);
+  TEST_COMPARE (stdc_leading_ones (0U), 0);
+  TEST_COMPARE (expr_has_type (stdc_leading_ones (0U), ui), 1);
+  TEST_COMPARE (stdc_leading_ones (0UL), 0);
+  TEST_COMPARE (expr_has_type (stdc_leading_ones (0UL), ui), 1);
+  TEST_COMPARE (stdc_leading_ones (0ULL), 0);
+  TEST_COMPARE (expr_has_type (stdc_leading_ones (0ULL), ui), 1);
+  TEST_COMPARE (stdc_leading_ones ((uc) ~0U), CHAR_BIT);
+  TEST_COMPARE (stdc_leading_ones ((us) ~0U), sizeof (short) * CHAR_BIT);
+  TEST_COMPARE (stdc_leading_ones (~0U), sizeof (int) * CHAR_BIT);
+  TEST_COMPARE (stdc_leading_ones (~0UL), sizeof (long int) * CHAR_BIT);
+  TEST_COMPARE (stdc_leading_ones (~0ULL), sizeof (long long int) * CHAR_BIT);
+  TEST_COMPARE (stdc_leading_ones ((uc) ~3), CHAR_BIT - 2);
+  TEST_COMPARE (stdc_leading_ones ((us) ~9), sizeof (short) * CHAR_BIT - 4);
+  TEST_COMPARE (stdc_leading_ones (~34U), sizeof (int) * CHAR_BIT - 6);
+  TEST_COMPARE (stdc_leading_ones (~130UL), sizeof (long int) * CHAR_BIT - 8);
+  TEST_COMPARE (stdc_leading_ones (~512ULL),
+		sizeof (long long int) * CHAR_BIT - 10);
+  TEST_COMPARE (stdc_trailing_zeros ((uc) 0), CHAR_BIT);
+  TEST_COMPARE (expr_has_type (stdc_trailing_zeros ((uc) 0), ui), 1);
+  TEST_COMPARE (stdc_trailing_zeros ((us) 0), sizeof (short) * CHAR_BIT);
+  TEST_COMPARE (expr_has_type (stdc_trailing_zeros ((us) 0), ui), 1);
+  TEST_COMPARE (stdc_trailing_zeros (0U), sizeof (int) * CHAR_BIT);
+  TEST_COMPARE (expr_has_type (stdc_trailing_zeros (0U), ui), 1);
+  TEST_COMPARE (stdc_trailing_zeros (0UL), sizeof (long int) * CHAR_BIT);
+  TEST_COMPARE (expr_has_type (stdc_trailing_zeros (0UL), ui), 1);
+  TEST_COMPARE (stdc_trailing_zeros (0ULL), sizeof (long long int) * CHAR_BIT);
+  TEST_COMPARE (expr_has_type (stdc_trailing_zeros (0ULL), ui), 1);
+  TEST_COMPARE (stdc_trailing_zeros ((uc) ~0U), 0);
+  TEST_COMPARE (stdc_trailing_zeros ((us) ~0U), 0);
+  TEST_COMPARE (stdc_trailing_zeros (~0U), 0);
+  TEST_COMPARE (stdc_trailing_zeros (~0UL), 0);
+  TEST_COMPARE (stdc_trailing_zeros (~0ULL), 0);
+  TEST_COMPARE (stdc_trailing_zeros ((uc) 2), 1);
+  TEST_COMPARE (stdc_trailing_zeros ((us) 24), 3);
+  TEST_COMPARE (stdc_trailing_zeros (32U), 5);
+  TEST_COMPARE (stdc_trailing_zeros (128UL), 7);
+  TEST_COMPARE (stdc_trailing_zeros (512ULL), 9);
+  TEST_COMPARE (stdc_trailing_ones ((uc) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_trailing_ones ((uc) 0), ui), 1);
+  TEST_COMPARE (stdc_trailing_ones ((us) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_trailing_ones ((us) 0), ui), 1);
+  TEST_COMPARE (stdc_trailing_ones (0U), 0);
+  TEST_COMPARE (expr_has_type (stdc_trailing_ones (0U), ui), 1);
+  TEST_COMPARE (stdc_trailing_ones (0UL), 0);
+  TEST_COMPARE (expr_has_type (stdc_trailing_ones (0UL), ui), 1);
+  TEST_COMPARE (stdc_trailing_ones (0ULL), 0);
+  TEST_COMPARE (expr_has_type (stdc_trailing_ones (0ULL), ui), 1);
+  TEST_COMPARE (stdc_trailing_ones ((uc) ~0U), CHAR_BIT);
+  TEST_COMPARE (stdc_trailing_ones ((us) ~0U), sizeof (short) * CHAR_BIT);
+  TEST_COMPARE (stdc_trailing_ones (~0U), sizeof (int) * CHAR_BIT);
+  TEST_COMPARE (stdc_trailing_ones (~0UL), sizeof (long int) * CHAR_BIT);
+  TEST_COMPARE (stdc_trailing_ones (~0ULL), sizeof (long long int) * CHAR_BIT);
+  TEST_COMPARE (stdc_trailing_ones ((uc) 5), 1);
+  TEST_COMPARE (stdc_trailing_ones ((us) 15), 4);
+  TEST_COMPARE (stdc_trailing_ones (127U), 7);
+  TEST_COMPARE (stdc_trailing_ones (511UL), 9);
+  TEST_COMPARE (stdc_trailing_ones (~0ULL >> 2),
+		sizeof (long long int) * CHAR_BIT - 2);
+  TEST_COMPARE (stdc_first_leading_zero ((uc) 0), 1);
+  TEST_COMPARE (expr_has_type (stdc_first_leading_zero ((uc) 0), ui), 1);
+  TEST_COMPARE (stdc_first_leading_zero ((us) 0), 1);
+  TEST_COMPARE (expr_has_type (stdc_first_leading_zero ((us) 0), ui), 1);
+  TEST_COMPARE (stdc_first_leading_zero (0U), 1);
+  TEST_COMPARE (expr_has_type (stdc_first_leading_zero (0U), ui), 1);
+  TEST_COMPARE (stdc_first_leading_zero (0UL), 1);
+  TEST_COMPARE (expr_has_type (stdc_first_leading_zero (0UL), ui), 1);
+  TEST_COMPARE (stdc_first_leading_zero (0ULL), 1);
+  TEST_COMPARE (expr_has_type (stdc_first_leading_zero (0ULL), ui), 1);
+  TEST_COMPARE (stdc_first_leading_zero ((uc) ~0U), 0);
+  TEST_COMPARE (stdc_first_leading_zero ((us) ~0U), 0);
+  TEST_COMPARE (stdc_first_leading_zero (~0U), 0);
+  TEST_COMPARE (stdc_first_leading_zero (~0UL), 0);
+  TEST_COMPARE (stdc_first_leading_zero (~0ULL), 0);
+  TEST_COMPARE (stdc_first_leading_zero ((uc) ~3U), CHAR_BIT - 1);
+  TEST_COMPARE (stdc_first_leading_zero ((us) ~15U),
+		sizeof (short) * CHAR_BIT - 3);
+  TEST_COMPARE (stdc_first_leading_zero (~63U), sizeof (int) * CHAR_BIT - 5);
+  TEST_COMPARE (stdc_first_leading_zero (~255UL),
+		sizeof (long int) * CHAR_BIT - 7);
+  TEST_COMPARE (stdc_first_leading_zero (~1023ULL),
+		sizeof (long long int) * CHAR_BIT - 9);
+  TEST_COMPARE (stdc_first_leading_one ((uc) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_first_leading_one ((uc) 0), ui), 1);
+  TEST_COMPARE (stdc_first_leading_one ((us) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_first_leading_one ((us) 0), ui), 1);
+  TEST_COMPARE (stdc_first_leading_one (0U), 0);
+  TEST_COMPARE (expr_has_type (stdc_first_leading_one (0U), ui), 1);
+  TEST_COMPARE (stdc_first_leading_one (0UL), 0);
+  TEST_COMPARE (expr_has_type (stdc_first_leading_one (0UL), ui), 1);
+  TEST_COMPARE (stdc_first_leading_one (0ULL), 0);
+  TEST_COMPARE (expr_has_type (stdc_first_leading_one (0ULL), ui), 1);
+  TEST_COMPARE (stdc_first_leading_one ((uc) ~0U), 1);
+  TEST_COMPARE (stdc_first_leading_one ((us) ~0U), 1);
+  TEST_COMPARE (stdc_first_leading_one (~0U), 1);
+  TEST_COMPARE (stdc_first_leading_one (~0UL), 1);
+  TEST_COMPARE (stdc_first_leading_one (~0ULL), 1);
+  TEST_COMPARE (stdc_first_leading_one ((uc) 3), CHAR_BIT - 1);
+  TEST_COMPARE (stdc_first_leading_one ((us) 9),
+		sizeof (short) * CHAR_BIT - 3);
+  TEST_COMPARE (stdc_first_leading_one (34U), sizeof (int) * CHAR_BIT - 5);
+  TEST_COMPARE (stdc_first_leading_one (130UL),
+		sizeof (long int) * CHAR_BIT - 7);
+  TEST_COMPARE (stdc_first_leading_one (512ULL),
+		sizeof (long long int) * CHAR_BIT - 9);
+  TEST_COMPARE (stdc_first_trailing_zero ((uc) 0), 1);
+  TEST_COMPARE (expr_has_type (stdc_first_trailing_zero ((uc) 0), ui), 1);
+  TEST_COMPARE (stdc_first_trailing_zero ((us) 0), 1);
+  TEST_COMPARE (expr_has_type (stdc_first_trailing_zero ((us) 0), ui), 1);
+  TEST_COMPARE (stdc_first_trailing_zero (0U), 1);
+  TEST_COMPARE (expr_has_type (stdc_first_trailing_zero (0U), ui), 1);
+  TEST_COMPARE (stdc_first_trailing_zero (0UL), 1);
+  TEST_COMPARE (expr_has_type (stdc_first_trailing_zero (0UL), ui), 1);
+  TEST_COMPARE (stdc_first_trailing_zero (0ULL), 1);
+  TEST_COMPARE (expr_has_type (stdc_first_trailing_zero (0ULL), ui), 1);
+  TEST_COMPARE (stdc_first_trailing_zero ((uc) ~0U), 0);
+  TEST_COMPARE (stdc_first_trailing_zero ((us) ~0U), 0);
+  TEST_COMPARE (stdc_first_trailing_zero (~0U), 0);
+  TEST_COMPARE (stdc_first_trailing_zero (~0UL), 0);
+  TEST_COMPARE (stdc_first_trailing_zero (~0ULL), 0);
+  TEST_COMPARE (stdc_first_trailing_zero ((uc) 2), 1);
+  TEST_COMPARE (stdc_first_trailing_zero ((us) 15), 5);
+  TEST_COMPARE (stdc_first_trailing_zero (63U), 7);
+  TEST_COMPARE (stdc_first_trailing_zero (128UL), 1);
+  TEST_COMPARE (stdc_first_trailing_zero (511ULL), 10);
+  TEST_COMPARE (stdc_first_trailing_one ((uc) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_first_trailing_one ((uc) 0), ui), 1);
+  TEST_COMPARE (stdc_first_trailing_one ((us) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_first_trailing_one ((us) 0), ui), 1);
+  TEST_COMPARE (stdc_first_trailing_one (0U), 0);
+  TEST_COMPARE (expr_has_type (stdc_first_trailing_one (0U), ui), 1);
+  TEST_COMPARE (stdc_first_trailing_one (0UL), 0);
+  TEST_COMPARE (expr_has_type (stdc_first_trailing_one (0UL), ui), 1);
+  TEST_COMPARE (stdc_first_trailing_one (0ULL), 0);
+  TEST_COMPARE (expr_has_type (stdc_first_trailing_one (0ULL), ui), 1);
+  TEST_COMPARE (stdc_first_trailing_one ((uc) ~0U), 1);
+  TEST_COMPARE (stdc_first_trailing_one ((us) ~0U), 1);
+  TEST_COMPARE (stdc_first_trailing_one (~0U), 1);
+  TEST_COMPARE (stdc_first_trailing_one (~0UL), 1);
+  TEST_COMPARE (stdc_first_trailing_one (~0ULL), 1);
+  TEST_COMPARE (stdc_first_trailing_one ((uc) 4), 3);
+  TEST_COMPARE (stdc_first_trailing_one ((us) 96), 6);
+  TEST_COMPARE (stdc_first_trailing_one (127U), 1);
+  TEST_COMPARE (stdc_first_trailing_one (511UL), 1);
+  TEST_COMPARE (stdc_first_trailing_one (~0ULL << 12), 13);
+  TEST_COMPARE (stdc_count_zeros ((uc) 0), CHAR_BIT);
+  TEST_COMPARE (expr_has_type (stdc_count_zeros ((uc) 0), ui), 1);
+  TEST_COMPARE (stdc_count_zeros ((us) 0), sizeof (short) * CHAR_BIT);
+  TEST_COMPARE (expr_has_type (stdc_count_zeros ((us) 0), ui), 1);
+  TEST_COMPARE (stdc_count_zeros (0U), sizeof (int) * CHAR_BIT);
+  TEST_COMPARE (expr_has_type (stdc_count_zeros (0U), ui), 1);
+  TEST_COMPARE (stdc_count_zeros (0UL), sizeof (long int) * CHAR_BIT);
+  TEST_COMPARE (expr_has_type (stdc_count_zeros (0UL), ui), 1);
+  TEST_COMPARE (stdc_count_zeros (0ULL), sizeof (long long int) * CHAR_BIT);
+  TEST_COMPARE (expr_has_type (stdc_count_zeros (0ULL), ui), 1);
+  TEST_COMPARE (stdc_count_zeros ((uc) ~0U), 0);
+  TEST_COMPARE (stdc_count_zeros ((us) ~0U), 0);
+  TEST_COMPARE (stdc_count_zeros (~0U), 0);
+  TEST_COMPARE (stdc_count_zeros (~0UL), 0);
+  TEST_COMPARE (stdc_count_zeros (~0ULL), 0);
+  TEST_COMPARE (stdc_count_zeros ((uc) 1U), CHAR_BIT - 1);
+  TEST_COMPARE (stdc_count_zeros ((us) 42), sizeof (short) * CHAR_BIT - 3);
+  TEST_COMPARE (stdc_count_zeros (291U), sizeof (int) * CHAR_BIT - 4);
+  TEST_COMPARE (stdc_count_zeros (~1315UL), 5);
+  TEST_COMPARE (stdc_count_zeros (3363ULL),
+		sizeof (long long int) * CHAR_BIT - 6);
+  TEST_COMPARE (stdc_count_ones ((uc) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_count_ones ((uc) 0), ui), 1);
+  TEST_COMPARE (stdc_count_ones ((us) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_count_ones ((us) 0), ui), 1);
+  TEST_COMPARE (stdc_count_ones (0U), 0);
+  TEST_COMPARE (expr_has_type (stdc_count_ones (0U), ui), 1);
+  TEST_COMPARE (stdc_count_ones (0UL), 0);
+  TEST_COMPARE (expr_has_type (stdc_count_ones (0UL), ui), 1);
+  TEST_COMPARE (stdc_count_ones (0ULL), 0);
+  TEST_COMPARE (expr_has_type (stdc_count_ones (0ULL), ui), 1);
+  TEST_COMPARE (stdc_count_ones ((uc) ~0U), CHAR_BIT);
+  TEST_COMPARE (stdc_count_ones ((us) ~0U), sizeof (short) * CHAR_BIT);
+  TEST_COMPARE (stdc_count_ones (~0U), sizeof (int) * CHAR_BIT);
+  TEST_COMPARE (stdc_count_ones (~0UL), sizeof (long int) * CHAR_BIT);
+  TEST_COMPARE (stdc_count_ones (~0ULL), sizeof (long long int) * CHAR_BIT);
+  TEST_COMPARE (stdc_count_ones ((uc) ~1U), CHAR_BIT - 1);
+  TEST_COMPARE (stdc_count_ones ((us) ~42), sizeof (short) * CHAR_BIT - 3);
+  TEST_COMPARE (stdc_count_ones (~291U), sizeof (int) * CHAR_BIT - 4);
+  TEST_COMPARE (stdc_count_ones (1315UL), 5);
+  TEST_COMPARE (stdc_count_ones (~3363ULL),
+		sizeof (long long int) * CHAR_BIT - 6);
+  TEST_COMPARE (stdc_has_single_bit ((uc) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_has_single_bit ((uc) 0), _Bool), 1);
+  TEST_COMPARE (stdc_has_single_bit ((us) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_has_single_bit ((us) 0), _Bool), 1);
+  TEST_COMPARE (stdc_has_single_bit (0U), 0);
+  TEST_COMPARE (expr_has_type (stdc_has_single_bit (0U), _Bool), 1);
+  TEST_COMPARE (stdc_has_single_bit (0UL), 0);
+  TEST_COMPARE (expr_has_type (stdc_has_single_bit (0UL), _Bool), 1);
+  TEST_COMPARE (stdc_has_single_bit (0ULL), 0);
+  TEST_COMPARE (expr_has_type (stdc_has_single_bit (0ULL), _Bool), 1);
+  TEST_COMPARE (stdc_has_single_bit ((uc) 2), 1);
+  TEST_COMPARE (stdc_has_single_bit ((us) 8), 1);
+  TEST_COMPARE (stdc_has_single_bit (32U), 1);
+  TEST_COMPARE (stdc_has_single_bit (128UL), 1);
+  TEST_COMPARE (stdc_has_single_bit (512ULL), 1);
+  TEST_COMPARE (stdc_has_single_bit ((uc) 7), 0);
+  TEST_COMPARE (stdc_has_single_bit ((us) 96), 0);
+  TEST_COMPARE (stdc_has_single_bit (513U), 0);
+  TEST_COMPARE (stdc_has_single_bit (1022UL), 0);
+  TEST_COMPARE (stdc_has_single_bit (12ULL), 0);
+  TEST_COMPARE (stdc_bit_width ((uc) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_bit_width ((uc) 0), ui), 1);
+  TEST_COMPARE (stdc_bit_width ((us) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_bit_width ((us) 0), ui), 1);
+  TEST_COMPARE (stdc_bit_width (0U), 0);
+  TEST_COMPARE (expr_has_type (stdc_bit_width (0U), ui), 1);
+  TEST_COMPARE (stdc_bit_width (0UL), 0);
+  TEST_COMPARE (expr_has_type (stdc_bit_width (0UL), ui), 1);
+  TEST_COMPARE (stdc_bit_width (0ULL), 0);
+  TEST_COMPARE (expr_has_type (stdc_bit_width (0ULL), ui), 1);
+  TEST_COMPARE (stdc_bit_width ((uc) ~0U), CHAR_BIT);
+  TEST_COMPARE (stdc_bit_width ((us) ~0U), sizeof (short) * CHAR_BIT);
+  TEST_COMPARE (stdc_bit_width (~0U), sizeof (int) * CHAR_BIT);
+  TEST_COMPARE (stdc_bit_width (~0UL), sizeof (long int) * CHAR_BIT);
+  TEST_COMPARE (stdc_bit_width (~0ULL), sizeof (long long int) * CHAR_BIT);
+  TEST_COMPARE (stdc_bit_width ((uc) ((uc) ~0U >> 1)), CHAR_BIT - 1);
+  TEST_COMPARE (stdc_bit_width ((uc) 6), 3);
+  TEST_COMPARE (stdc_bit_width ((us) 12U), 4);
+  TEST_COMPARE (stdc_bit_width ((us) ((us) ~0U >> 5)),
+		sizeof (short) * CHAR_BIT - 5);
+  TEST_COMPARE (stdc_bit_width (137U), 8);
+  TEST_COMPARE (stdc_bit_width (269U), 9);
+  TEST_COMPARE (stdc_bit_width (39UL), 6);
+  TEST_COMPARE (stdc_bit_width (~0UL >> 2), sizeof (long int) * CHAR_BIT - 2);
+  TEST_COMPARE (stdc_bit_width (1023ULL), 10);
+  TEST_COMPARE (stdc_bit_width (1024ULL), 11);
+  TEST_COMPARE (stdc_bit_floor ((uc) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_bit_floor ((uc) 0), uc), 1);
+  TEST_COMPARE (stdc_bit_floor ((us) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_bit_floor ((us) 0), us), 1);
+  TEST_COMPARE (stdc_bit_floor (0U), 0U);
+  TEST_COMPARE (expr_has_type (stdc_bit_floor (0U), ui), 1);
+  TEST_COMPARE (stdc_bit_floor (0UL), 0UL);
+  TEST_COMPARE (expr_has_type (stdc_bit_floor (0UL), ul), 1);
+  TEST_COMPARE (stdc_bit_floor (0ULL), 0ULL);
+  TEST_COMPARE (expr_has_type (stdc_bit_floor (0ULL), ull), 1);
+  TEST_COMPARE (stdc_bit_floor ((uc) ~0U), (1U << (CHAR_BIT - 1)));
+  TEST_COMPARE (stdc_bit_floor ((us) ~0U),
+		(1U << (sizeof (short) * CHAR_BIT - 1)));
+  TEST_COMPARE (stdc_bit_floor (~0U), (1U << (sizeof (int) * CHAR_BIT - 1)));
+  TEST_COMPARE (stdc_bit_floor (~0UL),
+		(1UL << (sizeof (long int) * CHAR_BIT - 1)));
+  TEST_COMPARE (stdc_bit_floor (~0ULL),
+		(1ULL << (sizeof (long long int) * CHAR_BIT - 1)));
+  TEST_COMPARE (stdc_bit_floor ((uc) 4), 4);
+  TEST_COMPARE (stdc_bit_floor ((uc) 7), 4);
+  TEST_COMPARE (stdc_bit_floor ((us) 8U), 8);
+  TEST_COMPARE (stdc_bit_floor ((us) 31U), 16);
+  TEST_COMPARE (stdc_bit_floor (137U), 128U);
+  TEST_COMPARE (stdc_bit_floor (269U), 256U);
+  TEST_COMPARE (stdc_bit_floor (511UL), 256UL);
+  TEST_COMPARE (stdc_bit_floor (512UL), 512UL);
+  TEST_COMPARE (stdc_bit_floor (513UL), 512ULL);
+  TEST_COMPARE (stdc_bit_floor (1024ULL), 1024ULL);
+  TEST_COMPARE (stdc_bit_ceil ((uc) 0), 1);
+  TEST_COMPARE (expr_has_type (stdc_bit_ceil ((uc) 0), uc), 1);
+  TEST_COMPARE (stdc_bit_ceil ((us) 0), 1);
+  TEST_COMPARE (expr_has_type (stdc_bit_ceil ((us) 0), us), 1);
+  TEST_COMPARE (stdc_bit_ceil (0U), 1U);
+  TEST_COMPARE (expr_has_type (stdc_bit_ceil (0U), ui), 1);
+  TEST_COMPARE (stdc_bit_ceil (0UL), 1UL);
+  TEST_COMPARE (expr_has_type (stdc_bit_ceil (0UL), ul), 1);
+  TEST_COMPARE (stdc_bit_ceil (0ULL), 1ULL);
+  TEST_COMPARE (expr_has_type (stdc_bit_ceil (0ULL), ull), 1);
+  TEST_COMPARE (stdc_bit_ceil ((uc) ~0U), 0);
+  TEST_COMPARE (stdc_bit_ceil ((us) ~0U), 0);
+  TEST_COMPARE (stdc_bit_ceil (~0U), 0U);
+  TEST_COMPARE (stdc_bit_ceil (~0UL), 0UL);
+  TEST_COMPARE (stdc_bit_ceil (~0ULL), 0ULL);
+  TEST_COMPARE (stdc_bit_ceil ((uc) ((uc) ~0U >> 1)), (1U << (CHAR_BIT - 1)));
+  TEST_COMPARE (stdc_bit_ceil ((uc) ((uc) ~0U >> 1)), (1U << (CHAR_BIT - 1)));
+  TEST_COMPARE (stdc_bit_ceil ((us) ((us) ~0U >> 1)),
+		(1U << (sizeof (short) * CHAR_BIT - 1)));
+  TEST_COMPARE (stdc_bit_ceil ((us) ((us) ~0U >> 1)),
+		(1U << (sizeof (short) * CHAR_BIT - 1)));
+  TEST_COMPARE (stdc_bit_ceil (~0U >> 1),
+		(1U << (sizeof (int) * CHAR_BIT - 1)));
+  TEST_COMPARE (stdc_bit_ceil (1U << (sizeof (int) * CHAR_BIT - 1)),
+		(1U << (sizeof (int) * CHAR_BIT - 1)));
+  TEST_COMPARE (stdc_bit_ceil (~0UL >> 1),
+		(1UL << (sizeof (long int) * CHAR_BIT - 1)));
+  TEST_COMPARE (stdc_bit_ceil (~0UL >> 1),
+		(1UL << (sizeof (long int) * CHAR_BIT - 1)));
+  TEST_COMPARE (stdc_bit_ceil (1ULL
+			       << (sizeof (long long int) * CHAR_BIT - 1)),
+		(1ULL << (sizeof (long long int) * CHAR_BIT - 1)));
+  TEST_COMPARE (stdc_bit_ceil (~0ULL >> 1),
+		(1ULL << (sizeof (long long int) * CHAR_BIT - 1)));
+  TEST_COMPARE (stdc_bit_ceil ((uc) 1), 1);
+  TEST_COMPARE (stdc_bit_ceil ((uc) 2), 2);
+  TEST_COMPARE (stdc_bit_ceil ((us) 3U), 4);
+  TEST_COMPARE (stdc_bit_ceil ((us) 4U), 4);
+  TEST_COMPARE (stdc_bit_ceil (5U), 8U);
+  TEST_COMPARE (stdc_bit_ceil (269U), 512U);
+  TEST_COMPARE (stdc_bit_ceil (511UL), 512UL);
+  TEST_COMPARE (stdc_bit_ceil (512UL), 512UL);
+  TEST_COMPARE (stdc_bit_ceil (513ULL), 1024ULL);
+  TEST_COMPARE (stdc_bit_ceil (1025ULL), 2048ULL);
+# ifdef __SIZEOF_INT128__
+  TEST_COMPARE (stdc_leading_zeros ((unsigned __int128) 0),
+		sizeof (__int128) * CHAR_BIT);
+  TEST_COMPARE (expr_has_type (stdc_leading_zeros ((unsigned __int128) 0), ui),
+		1);
+  TEST_COMPARE (stdc_leading_zeros (~(unsigned __int128) 0), 0);
+  TEST_COMPARE (stdc_leading_ones ((unsigned __int128) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_leading_ones ((unsigned __int128) 0), ui),
+		1);
+  TEST_COMPARE (stdc_leading_ones (~(unsigned __int128) 0),
+		sizeof (__int128) * CHAR_BIT);
+  TEST_COMPARE (stdc_trailing_zeros ((unsigned __int128) 0),
+		sizeof (__int128) * CHAR_BIT);
+  TEST_COMPARE (expr_has_type (stdc_trailing_zeros ((unsigned __int128) 0),
+			       ui), 1);
+  TEST_COMPARE (stdc_trailing_zeros (~(unsigned __int128) 0), 0);
+  TEST_COMPARE (stdc_trailing_ones ((unsigned __int128) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_trailing_ones ((unsigned __int128) 0), ui),
+		1);
+  TEST_COMPARE (stdc_trailing_ones (~(unsigned __int128) 0),
+		sizeof (__int128) * CHAR_BIT);
+  TEST_COMPARE (stdc_first_leading_zero ((unsigned __int128) 0), 1);
+  TEST_COMPARE (expr_has_type (stdc_first_leading_zero ((unsigned __int128) 0),
+			       ui), 1);
+  TEST_COMPARE (stdc_first_leading_zero (~(unsigned __int128) 0), 0);
+  TEST_COMPARE (stdc_first_leading_one ((unsigned __int128) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_first_leading_one ((unsigned __int128) 0),
+			       ui), 1);
+  TEST_COMPARE (stdc_first_leading_one (~(unsigned __int128) 0), 1);
+  TEST_COMPARE (stdc_first_trailing_zero ((unsigned __int128) 0), 1);
+  TEST_COMPARE (expr_has_type (stdc_first_trailing_zero ((unsigned __int128)
+							 0), ui), 1);
+  TEST_COMPARE (stdc_first_trailing_zero (~(unsigned __int128) 0), 0);
+  TEST_COMPARE (stdc_first_trailing_one ((unsigned __int128) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_first_trailing_one ((unsigned __int128) 0),
+			       ui), 1);
+  TEST_COMPARE (stdc_first_trailing_one (~(unsigned __int128) 0), 1);
+  TEST_COMPARE (stdc_count_zeros ((unsigned __int128) 0),
+		sizeof (__int128) * CHAR_BIT);
+  TEST_COMPARE (expr_has_type (stdc_count_zeros ((unsigned __int128) 0), ui),
+		1);
+  TEST_COMPARE (stdc_count_zeros (~(unsigned __int128) 0), 0);
+  TEST_COMPARE (stdc_count_ones ((unsigned __int128) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_count_ones ((unsigned __int128) 0), ui),
+		1);
+  TEST_COMPARE (stdc_count_ones (~(unsigned __int128) 0),
+		sizeof (__int128) * CHAR_BIT);
+  TEST_COMPARE (stdc_has_single_bit ((unsigned __int128) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_has_single_bit ((unsigned __int128) 0),
+		_Bool), 1);
+  TEST_COMPARE (stdc_has_single_bit (~(unsigned __int128) 0), 0);
+  TEST_COMPARE (stdc_bit_width ((unsigned __int128) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_bit_width ((unsigned __int128) 0), ui), 1);
+  TEST_COMPARE (stdc_bit_width (~(unsigned __int128) 0),
+		sizeof (__int128) * CHAR_BIT);
+  TEST_COMPARE (stdc_bit_floor ((unsigned __int128) 0) != 0, 0);
+  TEST_COMPARE (expr_has_type (stdc_bit_floor ((unsigned __int128) 0),
+			       unsigned __int128), 1);
+  TEST_COMPARE (stdc_bit_floor (~(unsigned __int128) 0)
+		!= ((unsigned __int128) 1) << (sizeof (__int128)
+					       * CHAR_BIT - 1), 0);
+  TEST_COMPARE (stdc_bit_ceil ((unsigned __int128) 0) != 1, 0);
+  TEST_COMPARE (expr_has_type (stdc_bit_ceil ((unsigned __int128) 0),
+			       unsigned __int128), 1);
+  TEST_COMPARE (stdc_bit_ceil ((unsigned __int128) 1) != 1, 0);
+  TEST_COMPARE (stdc_bit_ceil ((~(unsigned __int128) 0) >> 1)
+		!= ((unsigned __int128) 1) << (sizeof (__int128)
+					       * CHAR_BIT - 1), 0);
+  TEST_COMPARE (stdc_bit_ceil (~(unsigned __int128) 0) != 0, 0);
+# endif
+  uc a = 0;
+  TEST_COMPARE (stdc_bit_width (a++), 0);
+  TEST_COMPARE (a, 1);
+  ull b = 0;
+  TEST_COMPARE (stdc_bit_width (b++), 0);
+  TEST_COMPARE (b, 1);
+  TEST_COMPARE (stdc_bit_floor (a++), 1);
+  TEST_COMPARE (a, 2);
+  TEST_COMPARE (stdc_bit_floor (b++), 1);
+  TEST_COMPARE (b, 2);
+  TEST_COMPARE (stdc_bit_ceil (a++), 2);
+  TEST_COMPARE (a, 3);
+  TEST_COMPARE (stdc_bit_ceil (b++), 2);
+  TEST_COMPARE (b, 3);
+  TEST_COMPARE (stdc_leading_zeros (a++), CHAR_BIT - 2);
+  TEST_COMPARE (a, 4);
+  TEST_COMPARE (stdc_leading_zeros (b++),
+		sizeof (long long int) * CHAR_BIT - 2);
+  TEST_COMPARE (b, 4);
+  TEST_COMPARE (stdc_leading_ones (a++), 0);
+  TEST_COMPARE (a, 5);
+  TEST_COMPARE (stdc_leading_ones (b++), 0);
+  TEST_COMPARE (b, 5);
+  TEST_COMPARE (stdc_trailing_zeros (a++), 0);
+  TEST_COMPARE (a, 6);
+  TEST_COMPARE (stdc_trailing_zeros (b++), 0);
+  TEST_COMPARE (b, 6);
+  TEST_COMPARE (stdc_trailing_ones (a++), 0);
+  TEST_COMPARE (a, 7);
+  TEST_COMPARE (stdc_trailing_ones (b++), 0);
+  TEST_COMPARE (b, 7);
+  TEST_COMPARE (stdc_first_leading_zero (a++), 1);
+  TEST_COMPARE (a, 8);
+  TEST_COMPARE (stdc_first_leading_zero (b++), 1);
+  TEST_COMPARE (b, 8);
+  TEST_COMPARE (stdc_first_leading_one (a++), CHAR_BIT - 3);
+  TEST_COMPARE (a, 9);
+  TEST_COMPARE (stdc_first_leading_one (b++),
+		sizeof (long long int) * CHAR_BIT - 3);
+  TEST_COMPARE (b, 9);
+  TEST_COMPARE (stdc_first_trailing_zero (a++), 2);
+  TEST_COMPARE (a, 10);
+  TEST_COMPARE (stdc_first_trailing_zero (b++), 2);
+  TEST_COMPARE (b, 10);
+  TEST_COMPARE (stdc_first_trailing_one (a++), 2);
+  TEST_COMPARE (a, 11);
+  TEST_COMPARE (stdc_first_trailing_one (b++), 2);
+  TEST_COMPARE (b, 11);
+  TEST_COMPARE (stdc_count_zeros (a++), CHAR_BIT - 3);
+  TEST_COMPARE (a, 12);
+  TEST_COMPARE (stdc_count_zeros (b++),
+		sizeof (long long int) * CHAR_BIT - 3);
+  TEST_COMPARE (b, 12);
+  TEST_COMPARE (stdc_count_ones (a++), 2);
+  TEST_COMPARE (a, 13);
+  TEST_COMPARE (stdc_count_ones (b++), 2);
+  TEST_COMPARE (b, 13);
+  TEST_COMPARE (stdc_has_single_bit (a++), 0);
+  TEST_COMPARE (a, 14);
+  TEST_COMPARE (stdc_has_single_bit (b++), 0);
+  TEST_COMPARE (b, 14);
+# ifdef BITINT_MAXWIDTH
+#  if BITINT_MAXWIDTH >= 64
+  TEST_COMPARE (stdc_leading_zeros (0uwb), 1);
+  TEST_COMPARE (expr_has_type (stdc_leading_zeros (0uwb), ui), 1);
+  TEST_COMPARE (stdc_leading_zeros (1uwb), 0);
+  TEST_COMPARE (expr_has_type (stdc_leading_zeros (1uwb), ui), 1);
+  TEST_COMPARE (stdc_leading_ones (0uwb), 0);
+  TEST_COMPARE (expr_has_type (stdc_leading_ones (0uwb), ui), 1);
+  TEST_COMPARE (stdc_leading_ones (1uwb), 1);
+  TEST_COMPARE (expr_has_type (stdc_leading_ones (1uwb), ui), 1);
+  TEST_COMPARE (stdc_trailing_zeros (0uwb), 1);
+  TEST_COMPARE (expr_has_type (stdc_trailing_zeros (0uwb), ui), 1);
+  TEST_COMPARE (stdc_trailing_zeros (1uwb), 0);
+  TEST_COMPARE (expr_has_type (stdc_trailing_zeros (1uwb), ui), 1);
+  TEST_COMPARE (stdc_trailing_ones (0uwb), 0);
+  TEST_COMPARE (expr_has_type (stdc_trailing_ones (0uwb), ui), 1);
+  TEST_COMPARE (stdc_trailing_ones (1uwb), 1);
+  TEST_COMPARE (expr_has_type (stdc_trailing_ones (1uwb), ui), 1);
+  TEST_COMPARE (stdc_first_leading_zero (0uwb), 1);
+  TEST_COMPARE (expr_has_type (stdc_first_leading_zero (0uwb), ui), 1);
+  TEST_COMPARE (stdc_first_leading_zero (1uwb), 0);
+  TEST_COMPARE (expr_has_type (stdc_first_leading_zero (1uwb), ui), 1);
+  TEST_COMPARE (stdc_first_leading_one (0uwb), 0);
+  TEST_COMPARE (expr_has_type (stdc_first_leading_one (0uwb), ui), 1);
+  TEST_COMPARE (stdc_first_leading_one (1uwb), 1);
+  TEST_COMPARE (expr_has_type (stdc_first_leading_one (1uwb), ui), 1);
+  TEST_COMPARE (stdc_first_trailing_zero (0uwb), 1);
+  TEST_COMPARE (expr_has_type (stdc_first_trailing_zero (0uwb), ui), 1);
+  TEST_COMPARE (stdc_first_trailing_zero (1uwb), 0);
+  TEST_COMPARE (expr_has_type (stdc_first_trailing_zero (1uwb), ui), 1);
+  TEST_COMPARE (stdc_first_trailing_one (0uwb), 0);
+  TEST_COMPARE (expr_has_type (stdc_first_trailing_one (0uwb), ui), 1);
+  TEST_COMPARE (stdc_first_trailing_one (1uwb), 1);
+  TEST_COMPARE (expr_has_type (stdc_first_trailing_one (1uwb), ui), 1);
+  TEST_COMPARE (stdc_count_zeros (0uwb), 1);
+  TEST_COMPARE (expr_has_type (stdc_count_zeros (0uwb), ui), 1);
+  TEST_COMPARE (stdc_count_zeros (1uwb), 0);
+  TEST_COMPARE (expr_has_type (stdc_count_zeros (1uwb), ui), 1);
+  TEST_COMPARE (stdc_count_ones (0uwb), 0);
+  TEST_COMPARE (expr_has_type (stdc_count_ones (0uwb), ui), 1);
+  TEST_COMPARE (stdc_count_ones (1uwb), 1);
+  TEST_COMPARE (expr_has_type (stdc_count_ones (1uwb), ui), 1);
+  TEST_COMPARE (stdc_has_single_bit (0uwb), 0);
+  TEST_COMPARE (expr_has_type (stdc_has_single_bit (0uwb), _Bool), 1);
+  TEST_COMPARE (stdc_has_single_bit (1uwb), 1);
+  TEST_COMPARE (expr_has_type (stdc_has_single_bit (1uwb), _Bool), 1);
+  TEST_COMPARE (stdc_bit_width (0uwb), 0);
+  TEST_COMPARE (expr_has_type (stdc_bit_width (0uwb), ui), 1);
+  TEST_COMPARE (stdc_bit_width (1uwb), 1);
+  TEST_COMPARE (expr_has_type (stdc_bit_width (1uwb), ui), 1);
+  TEST_COMPARE (stdc_bit_floor (0uwb), 0);
+  TEST_COMPARE (expr_has_type (stdc_bit_floor (0uwb), unsigned _BitInt(1)), 1);
+  TEST_COMPARE (stdc_bit_floor (1uwb), 1);
+  TEST_COMPARE (expr_has_type (stdc_bit_floor (1uwb), unsigned _BitInt(1)), 1);
+  TEST_COMPARE (stdc_bit_ceil (0uwb), 1);
+  TEST_COMPARE (expr_has_type (stdc_bit_ceil (0uwb), unsigned _BitInt(1)), 1);
+  TEST_COMPARE (stdc_bit_ceil (1uwb), 1);
+  TEST_COMPARE (expr_has_type (stdc_bit_ceil (1uwb), unsigned _BitInt(1)), 1);
+  unsigned _BitInt(1) c = 0;
+  TEST_COMPARE (stdc_bit_floor (c++), 0);
+  TEST_COMPARE (c, 1);
+  TEST_COMPARE (stdc_bit_floor (c++), 1);
+  TEST_COMPARE (c, 0);
+  TEST_COMPARE (stdc_bit_ceil (c++), 1);
+  TEST_COMPARE (c, 1);
+  TEST_COMPARE (stdc_bit_ceil (c++), 1);
+  TEST_COMPARE (c, 0);
+#  endif
+#  if BITINT_MAXWIDTH >= 512
+  TEST_COMPARE (stdc_leading_zeros ((unsigned _BitInt(512)) 0), 512);
+  TEST_COMPARE (expr_has_type (stdc_leading_zeros ((unsigned _BitInt(512)) 0),
+			       ui), 1);
+  TEST_COMPARE (stdc_leading_zeros ((unsigned _BitInt(373)) 0), 373);
+  TEST_COMPARE (expr_has_type (stdc_leading_zeros ((unsigned _BitInt(373)) 0),
+			       ui), 1);
+  TEST_COMPARE (stdc_leading_zeros (~(unsigned _BitInt(512)) 0), 0);
+  TEST_COMPARE (stdc_leading_zeros (~(unsigned _BitInt(373)) 0), 0);
+  TEST_COMPARE (stdc_leading_zeros ((unsigned _BitInt(512)) 275), 512 - 9);
+  TEST_COMPARE (stdc_leading_zeros ((unsigned _BitInt(373)) 512), 373 - 10);
+  TEST_COMPARE (stdc_leading_ones ((unsigned _BitInt(512)) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_leading_ones ((unsigned _BitInt(512)) 0),
+			       ui), 1);
+  TEST_COMPARE (stdc_leading_ones ((unsigned _BitInt(373)) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_leading_ones ((unsigned _BitInt(373)) 0),
+			       ui), 1);
+  TEST_COMPARE (stdc_leading_ones (~(unsigned _BitInt(512)) 0), 512);
+  TEST_COMPARE (stdc_leading_ones (~(unsigned _BitInt(373)) 0), 373);
+  TEST_COMPARE (stdc_leading_ones (~(unsigned _BitInt(512)) 275), 512 - 9);
+  TEST_COMPARE (stdc_leading_ones (~(unsigned _BitInt(373)) 512), 373 - 10);
+  TEST_COMPARE (stdc_trailing_zeros ((unsigned _BitInt(512)) 0), 512);
+  TEST_COMPARE (expr_has_type (stdc_trailing_zeros ((unsigned _BitInt(512)) 0),
+			       ui), 1);
+  TEST_COMPARE (stdc_trailing_zeros ((unsigned _BitInt(373)) 0), 373);
+  TEST_COMPARE (expr_has_type (stdc_trailing_zeros ((unsigned _BitInt(373)) 0),
+			       ui), 1);
+  TEST_COMPARE (stdc_trailing_zeros (~(unsigned _BitInt(512)) 0), 0);
+  TEST_COMPARE (stdc_trailing_zeros (~(unsigned _BitInt(373)) 0), 0);
+  TEST_COMPARE (stdc_trailing_zeros ((unsigned _BitInt(512)) 256), 8);
+  TEST_COMPARE (stdc_trailing_zeros ((unsigned _BitInt(373)) 512), 9);
+  TEST_COMPARE (stdc_trailing_ones ((unsigned _BitInt(512)) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_trailing_ones ((unsigned _BitInt(512)) 0),
+			       ui), 1);
+  TEST_COMPARE (stdc_trailing_ones ((unsigned _BitInt(373)) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_trailing_ones ((unsigned _BitInt(373)) 0),
+			       ui), 1);
+  TEST_COMPARE (stdc_trailing_ones (~(unsigned _BitInt(512)) 0), 512);
+  TEST_COMPARE (stdc_trailing_ones (~(unsigned _BitInt(373)) 0), 373);
+  TEST_COMPARE (stdc_trailing_ones ((unsigned _BitInt(512)) 255), 8);
+  TEST_COMPARE (stdc_trailing_ones ((~(unsigned _BitInt(373)) 0) >> 2),
+		373 - 2);
+  TEST_COMPARE (stdc_first_leading_zero ((unsigned _BitInt(512)) 0), 1);
+  TEST_COMPARE (expr_has_type (stdc_first_leading_zero ((unsigned _BitInt(512))
+							0), ui), 1);
+  TEST_COMPARE (stdc_first_leading_zero ((unsigned _BitInt(373)) 0), 1);
+  TEST_COMPARE (expr_has_type (stdc_first_leading_zero ((unsigned _BitInt(373))
+							0), ui), 1);
+  TEST_COMPARE (stdc_first_leading_zero (~(unsigned _BitInt(512)) 0), 0);
+  TEST_COMPARE (stdc_first_leading_zero (~(unsigned _BitInt(373)) 0), 0);
+  TEST_COMPARE (stdc_first_leading_zero (~(unsigned _BitInt(512)) 511),
+		512 - 8);
+  TEST_COMPARE (stdc_first_leading_zero (~(unsigned _BitInt(373)) 1023),
+		373 - 9);
+  TEST_COMPARE (stdc_first_leading_one ((unsigned _BitInt(512)) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_first_leading_one ((unsigned _BitInt(512))
+						       0), ui), 1);
+  TEST_COMPARE (stdc_first_leading_one ((unsigned _BitInt(373)) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_first_leading_one ((unsigned _BitInt(373))
+						       0), ui), 1);
+  TEST_COMPARE (stdc_first_leading_one (~(unsigned _BitInt(512)) 0), 1);
+  TEST_COMPARE (stdc_first_leading_one (~(unsigned _BitInt(373)) 0), 1);
+  TEST_COMPARE (stdc_first_leading_one ((unsigned _BitInt(512)) 275), 512 - 8);
+  TEST_COMPARE (stdc_first_leading_one ((unsigned _BitInt(373)) 512), 373 - 9);
+  TEST_COMPARE (stdc_first_trailing_zero ((unsigned _BitInt(512)) 0), 1);
+  TEST_COMPARE (expr_has_type (stdc_first_trailing_zero ((unsigned
+							  _BitInt(512)) 0),
+			       ui), 1);
+  TEST_COMPARE (stdc_first_trailing_zero ((unsigned _BitInt(373)) 0), 1);
+  TEST_COMPARE (expr_has_type (stdc_first_trailing_zero ((unsigned
+							  _BitInt(373)) 0),
+			       ui), 1);
+  TEST_COMPARE (stdc_first_trailing_zero (~(unsigned _BitInt(512)) 0), 0);
+  TEST_COMPARE (stdc_first_trailing_zero (~(unsigned _BitInt(373)) 0), 0);
+  TEST_COMPARE (stdc_first_trailing_zero ((unsigned _BitInt(512)) 255), 9);
+  TEST_COMPARE (stdc_first_trailing_zero ((unsigned _BitInt(373)) 511), 10);
+  TEST_COMPARE (stdc_first_trailing_one ((unsigned _BitInt(512)) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_first_trailing_one ((unsigned _BitInt(512))
+							0), ui), 1);
+  TEST_COMPARE (stdc_first_trailing_one ((unsigned _BitInt(373)) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_first_trailing_one ((unsigned _BitInt(373))
+							0), ui), 1);
+  TEST_COMPARE (stdc_first_trailing_one (~(unsigned _BitInt(512)) 0), 1);
+  TEST_COMPARE (stdc_first_trailing_one (~(unsigned _BitInt(373)) 0), 1);
+  TEST_COMPARE (stdc_first_trailing_one (((unsigned _BitInt(512)) 255) << 175),
+		176);
+  TEST_COMPARE (stdc_first_trailing_one ((~(unsigned _BitInt(373)) 0) << 311),
+		312);
+  TEST_COMPARE (stdc_count_zeros ((unsigned _BitInt(512)) 0), 512);
+  TEST_COMPARE (expr_has_type (stdc_count_zeros ((unsigned _BitInt(512)) 0),
+			       ui), 1);
+  TEST_COMPARE (stdc_count_zeros ((unsigned _BitInt(373)) 0), 373);
+  TEST_COMPARE (expr_has_type (stdc_count_zeros ((unsigned _BitInt(373)) 0),
+			       ui), 1);
+  TEST_COMPARE (stdc_count_zeros (~(unsigned _BitInt(512)) 0), 0);
+  TEST_COMPARE (stdc_count_zeros (~(unsigned _BitInt(373)) 0), 0);
+  TEST_COMPARE (stdc_count_zeros ((unsigned _BitInt(512)) 1315), 512 - 5);
+  TEST_COMPARE (stdc_count_zeros ((unsigned _BitInt(373)) 3363), 373 - 6);
+  TEST_COMPARE (stdc_count_ones ((unsigned _BitInt(512)) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_count_ones ((unsigned _BitInt(512)) 0),
+			       ui), 1);
+  TEST_COMPARE (stdc_count_ones ((unsigned _BitInt(373)) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_count_ones ((unsigned _BitInt(373)) 0),
+			       ui), 1);
+  TEST_COMPARE (stdc_count_ones (~(unsigned _BitInt(512)) 0), 512);
+  TEST_COMPARE (stdc_count_ones (~(unsigned _BitInt(373)) 0), 373);
+  TEST_COMPARE (stdc_count_ones (~(unsigned _BitInt(512)) 1315), 512 - 5);
+  TEST_COMPARE (stdc_count_ones (~(unsigned _BitInt(373)) 3363), 373 - 6);
+  TEST_COMPARE (stdc_has_single_bit ((unsigned _BitInt(512)) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_has_single_bit ((unsigned _BitInt(512)) 0),
+			       _Bool), 1);
+  TEST_COMPARE (stdc_has_single_bit ((unsigned _BitInt(373)) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_has_single_bit ((unsigned _BitInt(373)) 0),
+			       _Bool), 1);
+  TEST_COMPARE (stdc_has_single_bit (~(unsigned _BitInt(512)) 0), 0);
+  TEST_COMPARE (stdc_has_single_bit (~(unsigned _BitInt(373)) 0), 0);
+  TEST_COMPARE (stdc_has_single_bit (((unsigned _BitInt(512)) 1022) << 279),
+		0);
+  TEST_COMPARE (stdc_has_single_bit (((unsigned _BitInt(373)) 12) << 305), 0);
+  TEST_COMPARE (stdc_bit_width ((unsigned _BitInt(512)) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_bit_width ((unsigned _BitInt(512)) 0),
+			       ui), 1);
+  TEST_COMPARE (stdc_bit_width ((unsigned _BitInt(373)) 0), 0);
+  TEST_COMPARE (expr_has_type (stdc_bit_width ((unsigned _BitInt(373)) 0),
+			       ui), 1);
+  TEST_COMPARE (stdc_bit_width (~(unsigned _BitInt(512)) 0), 512);
+  TEST_COMPARE (stdc_bit_width (~(unsigned _BitInt(373)) 0), 373);
+  TEST_COMPARE (stdc_bit_width (((unsigned _BitInt(512)) 1023) << 405),
+		405 + 10);
+  TEST_COMPARE (stdc_bit_width (((unsigned _BitInt(373)) 1024) << 242),
+		242 + 11);
+  TEST_COMPARE (stdc_bit_floor ((unsigned _BitInt(512)) 0) != 0, 0);
+  TEST_COMPARE (expr_has_type (stdc_bit_floor ((unsigned _BitInt(512)) 0),
+			       unsigned _BitInt(512)), 1);
+  TEST_COMPARE (stdc_bit_floor ((unsigned _BitInt(373)) 0) != 0, 0);
+  TEST_COMPARE (expr_has_type (stdc_bit_floor ((unsigned _BitInt(373)) 0),
+			       unsigned _BitInt(373)), 1);
+  TEST_COMPARE (stdc_bit_floor (~(unsigned _BitInt(512)) 0)
+		!= ((unsigned _BitInt(512)) 1) << (512 - 1), 0);
+  TEST_COMPARE (stdc_bit_floor (~(unsigned _BitInt(373)) 0)
+		!= ((unsigned _BitInt(373)) 1) << (373 - 1), 0);
+  TEST_COMPARE (stdc_bit_floor (((unsigned _BitInt(512)) 511) << 405)
+		!= (((unsigned _BitInt(512)) 256) << 405), 0);
+  TEST_COMPARE (stdc_bit_floor (((unsigned _BitInt(373)) 512) << 242)
+		!= (((unsigned _BitInt(512)) 512) << 242), 0);
+  TEST_COMPARE (stdc_bit_ceil ((unsigned _BitInt(512)) 0) != 1, 0);
+  TEST_COMPARE (expr_has_type (stdc_bit_ceil ((unsigned _BitInt(512)) 0),
+			       unsigned _BitInt(512)), 1);
+  TEST_COMPARE (stdc_bit_ceil ((unsigned _BitInt(373)) 0) != 1, 0);
+  TEST_COMPARE (expr_has_type (stdc_bit_ceil ((unsigned _BitInt(373)) 0),
+			       unsigned _BitInt(373)), 1);
+  TEST_COMPARE (stdc_bit_ceil (~(unsigned _BitInt(512)) 0) != 0, 0);
+  TEST_COMPARE (stdc_bit_ceil (~(unsigned _BitInt(373)) 0) != 0, 0);
+  TEST_COMPARE (stdc_bit_ceil (((unsigned _BitInt(512)) 1) << (512 - 1))
+		!= ((unsigned _BitInt(512)) 1) << (512 - 1), 0);
+  TEST_COMPARE (stdc_bit_ceil ((~(unsigned _BitInt(373)) 0) >> 1)
+		!= ((unsigned _BitInt(373)) 1) << (373 - 1), 0);
+  TEST_COMPARE (stdc_bit_ceil (((unsigned _BitInt(512)) 512) << 405)
+		!= (((unsigned _BitInt(512)) 512) << 405), 0);
+  TEST_COMPARE (stdc_bit_ceil (((unsigned _BitInt(373)) 513) << 242)
+		!= (((unsigned _BitInt(512)) 1024) << 242), 0);
+  TEST_COMPARE (stdc_bit_floor ((unsigned _BitInt(BITINT_MAXWIDTH)) 0) != 0,
+		0);
+  TEST_COMPARE (stdc_bit_floor (~(unsigned _BitInt(BITINT_MAXWIDTH)) 0)
+		!= ((unsigned _BitInt(BITINT_MAXWIDTH)) 1) << (BITINT_MAXWIDTH
+							       - 1), 0);
+  TEST_COMPARE (stdc_bit_floor (((unsigned _BitInt(BITINT_MAXWIDTH)) 511)
+				<< 405)
+		!= (((unsigned _BitInt(BITINT_MAXWIDTH)) 256) << 405), 0);
+  TEST_COMPARE (stdc_bit_floor (((unsigned _BitInt(BITINT_MAXWIDTH)) 512)
+				<< 405)
+		!= (((unsigned _BitInt(BITINT_MAXWIDTH)) 512) << 405), 0);
+  TEST_COMPARE (stdc_bit_ceil ((unsigned _BitInt(BITINT_MAXWIDTH)) 0) != 1, 0);
+  TEST_COMPARE (stdc_bit_ceil (~(unsigned _BitInt(BITINT_MAXWIDTH)) 0) != 0,
+		0);
+  TEST_COMPARE (stdc_bit_ceil (((unsigned _BitInt(BITINT_MAXWIDTH)) 1)
+			       << (BITINT_MAXWIDTH - 1))
+		!= ((unsigned _BitInt(BITINT_MAXWIDTH)) 1) << (BITINT_MAXWIDTH
+							       - 1), 0);
+  TEST_COMPARE (stdc_bit_ceil (((unsigned _BitInt(BITINT_MAXWIDTH)) 512)
+			       << 405)
+		!= (((unsigned _BitInt(BITINT_MAXWIDTH)) 512) << 405), 0);
+  TEST_COMPARE (stdc_bit_ceil (((unsigned _BitInt(BITINT_MAXWIDTH)) 513)
+			       << 405)
+		!= (((unsigned _BitInt(BITINT_MAXWIDTH)) 1024) << 405), 0);
+#  endif
+# endif
+  return 0;
+}
+#else
+static int
+do_test (void)
+{
+  return 0;
+}
+#endif
+
+#include <support/test-driver.c>
diff --git a/stdlib/tst-strtod-round-data b/stdlib/tst-strtod-round-data
index 84ab705709..9489fbcc9c 100644
--- a/stdlib/tst-strtod-round-data
+++ b/stdlib/tst-strtod-round-data
@@ -265,3 +265,15 @@
 1.000000000000000000000000000000000385185988877447170611195588516985463707620329643077639047987759113311767578125
 1.0000000000000000000000000000000001925929944387235853055977942584927318538101648215388195239938795566558837890625
 1.00000000000000000000000000000000009629649721936179265279889712924636592690508241076940976199693977832794189453125
+0x30000002222225p-1077
+0x0.7fffffffffffeap-1022
+0x0.7fffffffffffe9p-1022
+0x0.7ffffd4p-126
+0x0.7ffffffffffffffd4p-16382
+0x0.7ffffffffffffffd4p-16383
+0x0.7ffffffffffffffffffffffffffeap-16382
+0x0.7000004p-126
+0x0.70000000000002p-1022
+0x0.70000000000000004p-16382
+0x0.70000000000000004p-16383
+0x0.70000000000000000000000000002p-16382
diff --git a/stdlib/tst-strtod-round-data.h b/stdlib/tst-strtod-round-data.h
index 8899d15f9b..ed50eb2537 100644
--- a/stdlib/tst-strtod-round-data.h
+++ b/stdlib/tst-strtod-round-data.h
@@ -2,1852 +2,1852 @@
 static const struct test tests[] = {
   TEST ("3.518437208883201171875E+013",
 	false,
-	0x2p+44, false,
-	0x2p+44, false,
-	0x2p+44, false,
-	0x2.000004p+44, false,
-	false,
-	0x2.0000000000002p+44, false,
-	0x2.0000000000004p+44, false,
-	0x2.0000000000002p+44, false,
-	0x2.0000000000004p+44, false,
-	true,
-	0x2.0000000000003p+44, false,
-	0x2.0000000000003p+44, false,
-	0x2.0000000000003p+44, false,
-	0x2.0000000000003p+44, false,
-	true,
-	0x2.0000000000003p+44, false,
-	0x2.0000000000003p+44, false,
-	0x2.0000000000003p+44, false,
-	0x2.0000000000003p+44, false,
-	true,
-	0x2.0000000000003p+44, false,
-	0x2.0000000000003p+44, false,
-	0x2.0000000000003p+44, false,
-	0x2.0000000000003p+44, false,
-	true,
-	0x2.0000000000003p+44, false,
-	0x2.0000000000003p+44, false,
-	0x2.0000000000003p+44, false,
-	0x2.0000000000003p+44, false),
+	0x2p+44, false, false,
+	0x2p+44, false, false,
+	0x2p+44, false, false,
+	0x2.000004p+44, false, false,
+	false,
+	0x2.0000000000002p+44, false, false,
+	0x2.0000000000004p+44, false, false,
+	0x2.0000000000002p+44, false, false,
+	0x2.0000000000004p+44, false, false,
+	true,
+	0x2.0000000000003p+44, false, false,
+	0x2.0000000000003p+44, false, false,
+	0x2.0000000000003p+44, false, false,
+	0x2.0000000000003p+44, false, false,
+	true,
+	0x2.0000000000003p+44, false, false,
+	0x2.0000000000003p+44, false, false,
+	0x2.0000000000003p+44, false, false,
+	0x2.0000000000003p+44, false, false,
+	true,
+	0x2.0000000000003p+44, false, false,
+	0x2.0000000000003p+44, false, false,
+	0x2.0000000000003p+44, false, false,
+	0x2.0000000000003p+44, false, false,
+	true,
+	0x2.0000000000003p+44, false, false,
+	0x2.0000000000003p+44, false, false,
+	0x2.0000000000003p+44, false, false,
+	0x2.0000000000003p+44, false, false),
   TEST ("1.00000005960464477550",
 	false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	0x1.0000010000001p+0, false,
-	false,
-	0x1.0000010000000002p+0, false,
-	0x1.0000010000000002p+0, false,
-	0x1.0000010000000002p+0, false,
-	0x1.0000010000000004p+0, false,
-	false,
-	0x1.0000010000000002p+0, false,
-	0x1.0000010000000002p+0, false,
-	0x1.0000010000000002p+0, false,
-	0x1.0000010000000004p+0, false,
-	false,
-	0x1.0000010000000002048242f2ffp+0, false,
-	0x1.0000010000000002048242f2ff8p+0, false,
-	0x1.0000010000000002048242f2ffp+0, false,
-	0x1.0000010000000002048242f2ff8p+0, false,
-	false,
-	0x1.0000010000000002048242f2ff66p+0, false,
-	0x1.0000010000000002048242f2ff67p+0, false,
-	0x1.0000010000000002048242f2ff66p+0, false,
-	0x1.0000010000000002048242f2ff67p+0, false),
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.0000010000001p+0, false, false,
+	false,
+	0x1.0000010000000002p+0, false, false,
+	0x1.0000010000000002p+0, false, false,
+	0x1.0000010000000002p+0, false, false,
+	0x1.0000010000000004p+0, false, false,
+	false,
+	0x1.0000010000000002p+0, false, false,
+	0x1.0000010000000002p+0, false, false,
+	0x1.0000010000000002p+0, false, false,
+	0x1.0000010000000004p+0, false, false,
+	false,
+	0x1.0000010000000002048242f2ffp+0, false, false,
+	0x1.0000010000000002048242f2ff8p+0, false, false,
+	0x1.0000010000000002048242f2ffp+0, false, false,
+	0x1.0000010000000002048242f2ff8p+0, false, false,
+	false,
+	0x1.0000010000000002048242f2ff66p+0, false, false,
+	0x1.0000010000000002048242f2ff67p+0, false, false,
+	0x1.0000010000000002048242f2ff66p+0, false, false,
+	0x1.0000010000000002048242f2ff67p+0, false, false),
   TEST ("1.0000000596046447755",
 	false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	0x1.0000010000001p+0, false,
-	false,
-	0x1.0000010000000002p+0, false,
-	0x1.0000010000000002p+0, false,
-	0x1.0000010000000002p+0, false,
-	0x1.0000010000000004p+0, false,
-	false,
-	0x1.0000010000000002p+0, false,
-	0x1.0000010000000002p+0, false,
-	0x1.0000010000000002p+0, false,
-	0x1.0000010000000004p+0, false,
-	false,
-	0x1.0000010000000002048242f2ffp+0, false,
-	0x1.0000010000000002048242f2ff8p+0, false,
-	0x1.0000010000000002048242f2ffp+0, false,
-	0x1.0000010000000002048242f2ff8p+0, false,
-	false,
-	0x1.0000010000000002048242f2ff66p+0, false,
-	0x1.0000010000000002048242f2ff67p+0, false,
-	0x1.0000010000000002048242f2ff66p+0, false,
-	0x1.0000010000000002048242f2ff67p+0, false),
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.0000010000001p+0, false, false,
+	false,
+	0x1.0000010000000002p+0, false, false,
+	0x1.0000010000000002p+0, false, false,
+	0x1.0000010000000002p+0, false, false,
+	0x1.0000010000000004p+0, false, false,
+	false,
+	0x1.0000010000000002p+0, false, false,
+	0x1.0000010000000002p+0, false, false,
+	0x1.0000010000000002p+0, false, false,
+	0x1.0000010000000004p+0, false, false,
+	false,
+	0x1.0000010000000002048242f2ffp+0, false, false,
+	0x1.0000010000000002048242f2ff8p+0, false, false,
+	0x1.0000010000000002048242f2ffp+0, false, false,
+	0x1.0000010000000002048242f2ff8p+0, false, false,
+	false,
+	0x1.0000010000000002048242f2ff66p+0, false, false,
+	0x1.0000010000000002048242f2ff67p+0, false, false,
+	0x1.0000010000000002048242f2ff66p+0, false, false,
+	0x1.0000010000000002048242f2ff67p+0, false, false),
   TEST ("1.000000059604644776",
 	false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	0x1.0000010000001p+0, false,
-	false,
-	0x1.000001000000000ap+0, false,
-	0x1.000001000000000cp+0, false,
-	0x1.000001000000000ap+0, false,
-	0x1.000001000000000cp+0, false,
-	false,
-	0x1.000001000000000ap+0, false,
-	0x1.000001000000000cp+0, false,
-	0x1.000001000000000ap+0, false,
-	0x1.000001000000000cp+0, false,
-	false,
-	0x1.000001000000000b3db12bdc21p+0, false,
-	0x1.000001000000000b3db12bdc21p+0, false,
-	0x1.000001000000000b3db12bdc21p+0, false,
-	0x1.000001000000000b3db12bdc218p+0, false,
-	false,
-	0x1.000001000000000b3db12bdc213cp+0, false,
-	0x1.000001000000000b3db12bdc213dp+0, false,
-	0x1.000001000000000b3db12bdc213cp+0, false,
-	0x1.000001000000000b3db12bdc213dp+0, false),
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.0000010000001p+0, false, false,
+	false,
+	0x1.000001000000000ap+0, false, false,
+	0x1.000001000000000cp+0, false, false,
+	0x1.000001000000000ap+0, false, false,
+	0x1.000001000000000cp+0, false, false,
+	false,
+	0x1.000001000000000ap+0, false, false,
+	0x1.000001000000000cp+0, false, false,
+	0x1.000001000000000ap+0, false, false,
+	0x1.000001000000000cp+0, false, false,
+	false,
+	0x1.000001000000000b3db12bdc21p+0, false, false,
+	0x1.000001000000000b3db12bdc21p+0, false, false,
+	0x1.000001000000000b3db12bdc21p+0, false, false,
+	0x1.000001000000000b3db12bdc218p+0, false, false,
+	false,
+	0x1.000001000000000b3db12bdc213cp+0, false, false,
+	0x1.000001000000000b3db12bdc213dp+0, false, false,
+	0x1.000001000000000b3db12bdc213cp+0, false, false,
+	0x1.000001000000000b3db12bdc213dp+0, false, false),
   TEST ("1.000000059604644775",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1.000000fffffffp+0, false,
-	0x1.000001p+0, false,
-	0x1.000000fffffffp+0, false,
-	0x1.000001p+0, false,
-	false,
-	0x1.000000fffffffff8p+0, false,
-	0x1.000000fffffffff8p+0, false,
-	0x1.000000fffffffff8p+0, false,
-	0x1.000000fffffffffap+0, false,
-	false,
-	0x1.000000fffffffff8p+0, false,
-	0x1.000000fffffffff8p+0, false,
-	0x1.000000fffffffff8p+0, false,
-	0x1.000000fffffffffap+0, false,
-	false,
-	0x1.000000fffffffff8cb535a09dd8p+0, false,
-	0x1.000000fffffffff8cb535a09dd8p+0, false,
-	0x1.000000fffffffff8cb535a09dd8p+0, false,
-	0x1.000000fffffffff8cb535a09dep+0, false,
-	false,
-	0x1.000000fffffffff8cb535a09dd9p+0, false,
-	0x1.000000fffffffff8cb535a09dd91p+0, false,
-	0x1.000000fffffffff8cb535a09dd9p+0, false,
-	0x1.000000fffffffff8cb535a09dd91p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1.000000fffffffp+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.000000fffffffp+0, false, false,
+	0x1.000001p+0, false, false,
+	false,
+	0x1.000000fffffffff8p+0, false, false,
+	0x1.000000fffffffff8p+0, false, false,
+	0x1.000000fffffffff8p+0, false, false,
+	0x1.000000fffffffffap+0, false, false,
+	false,
+	0x1.000000fffffffff8p+0, false, false,
+	0x1.000000fffffffff8p+0, false, false,
+	0x1.000000fffffffff8p+0, false, false,
+	0x1.000000fffffffffap+0, false, false,
+	false,
+	0x1.000000fffffffff8cb535a09dd8p+0, false, false,
+	0x1.000000fffffffff8cb535a09dd8p+0, false, false,
+	0x1.000000fffffffff8cb535a09dd8p+0, false, false,
+	0x1.000000fffffffff8cb535a09dep+0, false, false,
+	false,
+	0x1.000000fffffffff8cb535a09dd9p+0, false, false,
+	0x1.000000fffffffff8cb535a09dd91p+0, false, false,
+	0x1.000000fffffffff8cb535a09dd9p+0, false, false,
+	0x1.000000fffffffff8cb535a09dd91p+0, false, false),
   TEST ("1.00000005960464478",
 	false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	0x1.0000010000001p+0, false,
-	false,
-	0x1.0000010000000054p+0, false,
-	0x1.0000010000000056p+0, false,
-	0x1.0000010000000054p+0, false,
-	0x1.0000010000000056p+0, false,
-	false,
-	0x1.0000010000000054p+0, false,
-	0x1.0000010000000056p+0, false,
-	0x1.0000010000000054p+0, false,
-	0x1.0000010000000056p+0, false,
-	false,
-	0x1.0000010000000055072873252f8p+0, false,
-	0x1.0000010000000055072873253p+0, false,
-	0x1.0000010000000055072873252f8p+0, false,
-	0x1.0000010000000055072873253p+0, false,
-	false,
-	0x1.0000010000000055072873252febp+0, false,
-	0x1.0000010000000055072873252febp+0, false,
-	0x1.0000010000000055072873252febp+0, false,
-	0x1.0000010000000055072873252fecp+0, false),
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.0000010000001p+0, false, false,
+	false,
+	0x1.0000010000000054p+0, false, false,
+	0x1.0000010000000056p+0, false, false,
+	0x1.0000010000000054p+0, false, false,
+	0x1.0000010000000056p+0, false, false,
+	false,
+	0x1.0000010000000054p+0, false, false,
+	0x1.0000010000000056p+0, false, false,
+	0x1.0000010000000054p+0, false, false,
+	0x1.0000010000000056p+0, false, false,
+	false,
+	0x1.0000010000000055072873252f8p+0, false, false,
+	0x1.0000010000000055072873253p+0, false, false,
+	0x1.0000010000000055072873252f8p+0, false, false,
+	0x1.0000010000000055072873253p+0, false, false,
+	false,
+	0x1.0000010000000055072873252febp+0, false, false,
+	0x1.0000010000000055072873252febp+0, false, false,
+	0x1.0000010000000055072873252febp+0, false, false,
+	0x1.0000010000000055072873252fecp+0, false, false),
   TEST ("1.0000000596046448",
 	false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	0x1.0000010000001p+0, false,
-	false,
-	0x1.00000100000001c4p+0, false,
-	0x1.00000100000001c6p+0, false,
-	0x1.00000100000001c4p+0, false,
-	0x1.00000100000001c6p+0, false,
-	false,
-	0x1.00000100000001c4p+0, false,
-	0x1.00000100000001c6p+0, false,
-	0x1.00000100000001c4p+0, false,
-	0x1.00000100000001c6p+0, false,
-	false,
-	0x1.00000100000001c5f67cd79279p+0, false,
-	0x1.00000100000001c5f67cd792798p+0, false,
-	0x1.00000100000001c5f67cd79279p+0, false,
-	0x1.00000100000001c5f67cd792798p+0, false,
-	false,
-	0x1.00000100000001c5f67cd7927953p+0, false,
-	0x1.00000100000001c5f67cd7927954p+0, false,
-	0x1.00000100000001c5f67cd7927953p+0, false,
-	0x1.00000100000001c5f67cd7927954p+0, false),
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.0000010000001p+0, false, false,
+	false,
+	0x1.00000100000001c4p+0, false, false,
+	0x1.00000100000001c6p+0, false, false,
+	0x1.00000100000001c4p+0, false, false,
+	0x1.00000100000001c6p+0, false, false,
+	false,
+	0x1.00000100000001c4p+0, false, false,
+	0x1.00000100000001c6p+0, false, false,
+	0x1.00000100000001c4p+0, false, false,
+	0x1.00000100000001c6p+0, false, false,
+	false,
+	0x1.00000100000001c5f67cd79279p+0, false, false,
+	0x1.00000100000001c5f67cd792798p+0, false, false,
+	0x1.00000100000001c5f67cd79279p+0, false, false,
+	0x1.00000100000001c5f67cd792798p+0, false, false,
+	false,
+	0x1.00000100000001c5f67cd7927953p+0, false, false,
+	0x1.00000100000001c5f67cd7927954p+0, false, false,
+	0x1.00000100000001c5f67cd7927953p+0, false, false,
+	0x1.00000100000001c5f67cd7927954p+0, false, false),
   TEST ("1.000000059604645",
 	false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1.0000010000001p+0, false,
-	0x1.0000010000001p+0, false,
-	0x1.0000010000001p+0, false,
-	0x1.0000010000002p+0, false,
-	false,
-	0x1.000001000000102ep+0, false,
-	0x1.000001000000103p+0, false,
-	0x1.000001000000102ep+0, false,
-	0x1.000001000000103p+0, false,
-	false,
-	0x1.000001000000102ep+0, false,
-	0x1.000001000000103p+0, false,
-	0x1.000001000000102ep+0, false,
-	0x1.000001000000103p+0, false,
-	false,
-	0x1.000001000000102f4fc8c3d757p+0, false,
-	0x1.000001000000102f4fc8c3d7578p+0, false,
-	0x1.000001000000102f4fc8c3d757p+0, false,
-	0x1.000001000000102f4fc8c3d7578p+0, false,
-	false,
-	0x1.000001000000102f4fc8c3d75769p+0, false,
-	0x1.000001000000102f4fc8c3d75769p+0, false,
-	0x1.000001000000102f4fc8c3d75769p+0, false,
-	0x1.000001000000102f4fc8c3d7576ap+0, false),
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1.0000010000001p+0, false, false,
+	0x1.0000010000001p+0, false, false,
+	0x1.0000010000001p+0, false, false,
+	0x1.0000010000002p+0, false, false,
+	false,
+	0x1.000001000000102ep+0, false, false,
+	0x1.000001000000103p+0, false, false,
+	0x1.000001000000102ep+0, false, false,
+	0x1.000001000000103p+0, false, false,
+	false,
+	0x1.000001000000102ep+0, false, false,
+	0x1.000001000000103p+0, false, false,
+	0x1.000001000000102ep+0, false, false,
+	0x1.000001000000103p+0, false, false,
+	false,
+	0x1.000001000000102f4fc8c3d757p+0, false, false,
+	0x1.000001000000102f4fc8c3d7578p+0, false, false,
+	0x1.000001000000102f4fc8c3d757p+0, false, false,
+	0x1.000001000000102f4fc8c3d7578p+0, false, false,
+	false,
+	0x1.000001000000102f4fc8c3d75769p+0, false, false,
+	0x1.000001000000102f4fc8c3d75769p+0, false, false,
+	0x1.000001000000102f4fc8c3d75769p+0, false, false,
+	0x1.000001000000102f4fc8c3d7576ap+0, false, false),
   TEST ("1.00000005960464",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1.000000fffffeap+0, false,
-	0x1.000000fffffeap+0, false,
-	0x1.000000fffffeap+0, false,
-	0x1.000000fffffebp+0, false,
-	false,
-	0x1.000000fffffea7e4p+0, false,
-	0x1.000000fffffea7e6p+0, false,
-	0x1.000000fffffea7e4p+0, false,
-	0x1.000000fffffea7e6p+0, false,
-	false,
-	0x1.000000fffffea7e4p+0, false,
-	0x1.000000fffffea7e6p+0, false,
-	0x1.000000fffffea7e4p+0, false,
-	0x1.000000fffffea7e6p+0, false,
-	false,
-	0x1.000000fffffea7e5975eb11da7p+0, false,
-	0x1.000000fffffea7e5975eb11da78p+0, false,
-	0x1.000000fffffea7e5975eb11da7p+0, false,
-	0x1.000000fffffea7e5975eb11da78p+0, false,
-	false,
-	0x1.000000fffffea7e5975eb11da74ap+0, false,
-	0x1.000000fffffea7e5975eb11da74bp+0, false,
-	0x1.000000fffffea7e5975eb11da74ap+0, false,
-	0x1.000000fffffea7e5975eb11da74bp+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1.000000fffffeap+0, false, false,
+	0x1.000000fffffeap+0, false, false,
+	0x1.000000fffffeap+0, false, false,
+	0x1.000000fffffebp+0, false, false,
+	false,
+	0x1.000000fffffea7e4p+0, false, false,
+	0x1.000000fffffea7e6p+0, false, false,
+	0x1.000000fffffea7e4p+0, false, false,
+	0x1.000000fffffea7e6p+0, false, false,
+	false,
+	0x1.000000fffffea7e4p+0, false, false,
+	0x1.000000fffffea7e6p+0, false, false,
+	0x1.000000fffffea7e4p+0, false, false,
+	0x1.000000fffffea7e6p+0, false, false,
+	false,
+	0x1.000000fffffea7e5975eb11da7p+0, false, false,
+	0x1.000000fffffea7e5975eb11da78p+0, false, false,
+	0x1.000000fffffea7e5975eb11da7p+0, false, false,
+	0x1.000000fffffea7e5975eb11da78p+0, false, false,
+	false,
+	0x1.000000fffffea7e5975eb11da74ap+0, false, false,
+	0x1.000000fffffea7e5975eb11da74bp+0, false, false,
+	0x1.000000fffffea7e5975eb11da74ap+0, false, false,
+	0x1.000000fffffea7e5975eb11da74bp+0, false, false),
   TEST ("1.0000000596046",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1.000000fffff36p+0, false,
-	0x1.000000fffff36p+0, false,
-	0x1.000000fffff36p+0, false,
-	0x1.000000fffff37p+0, false,
-	false,
-	0x1.000000fffff36596p+0, false,
-	0x1.000000fffff36598p+0, false,
-	0x1.000000fffff36596p+0, false,
-	0x1.000000fffff36598p+0, false,
-	false,
-	0x1.000000fffff36596p+0, false,
-	0x1.000000fffff36598p+0, false,
-	0x1.000000fffff36596p+0, false,
-	0x1.000000fffff36598p+0, false,
-	false,
-	0x1.000000fffff36597d40e1b5026p+0, false,
-	0x1.000000fffff36597d40e1b50268p+0, false,
-	0x1.000000fffff36597d40e1b5026p+0, false,
-	0x1.000000fffff36597d40e1b50268p+0, false,
-	false,
-	0x1.000000fffff36597d40e1b502655p+0, false,
-	0x1.000000fffff36597d40e1b502656p+0, false,
-	0x1.000000fffff36597d40e1b502655p+0, false,
-	0x1.000000fffff36597d40e1b502656p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1.000000fffff36p+0, false, false,
+	0x1.000000fffff36p+0, false, false,
+	0x1.000000fffff36p+0, false, false,
+	0x1.000000fffff37p+0, false, false,
+	false,
+	0x1.000000fffff36596p+0, false, false,
+	0x1.000000fffff36598p+0, false, false,
+	0x1.000000fffff36596p+0, false, false,
+	0x1.000000fffff36598p+0, false, false,
+	false,
+	0x1.000000fffff36596p+0, false, false,
+	0x1.000000fffff36598p+0, false, false,
+	0x1.000000fffff36596p+0, false, false,
+	0x1.000000fffff36598p+0, false, false,
+	false,
+	0x1.000000fffff36597d40e1b5026p+0, false, false,
+	0x1.000000fffff36597d40e1b50268p+0, false, false,
+	0x1.000000fffff36597d40e1b5026p+0, false, false,
+	0x1.000000fffff36597d40e1b50268p+0, false, false,
+	false,
+	0x1.000000fffff36597d40e1b502655p+0, false, false,
+	0x1.000000fffff36597d40e1b502656p+0, false, false,
+	0x1.000000fffff36597d40e1b502655p+0, false, false,
+	0x1.000000fffff36597d40e1b502656p+0, false, false),
   TEST ("1.000000059605",
 	false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1.000001000063fp+0, false,
-	0x1.000001000064p+0, false,
-	0x1.000001000063fp+0, false,
-	0x1.000001000064p+0, false,
-	false,
-	0x1.000001000063fcap+0, false,
-	0x1.000001000063fca2p+0, false,
-	0x1.000001000063fcap+0, false,
-	0x1.000001000063fca2p+0, false,
-	false,
-	0x1.000001000063fcap+0, false,
-	0x1.000001000063fca2p+0, false,
-	0x1.000001000063fcap+0, false,
-	0x1.000001000063fca2p+0, false,
-	false,
-	0x1.000001000063fca17533f5572f8p+0, false,
-	0x1.000001000063fca17533f5573p+0, false,
-	0x1.000001000063fca17533f5572f8p+0, false,
-	0x1.000001000063fca17533f5573p+0, false,
-	false,
-	0x1.000001000063fca17533f5572fe9p+0, false,
-	0x1.000001000063fca17533f5572feap+0, false,
-	0x1.000001000063fca17533f5572fe9p+0, false,
-	0x1.000001000063fca17533f5572feap+0, false),
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1.000001000063fp+0, false, false,
+	0x1.000001000064p+0, false, false,
+	0x1.000001000063fp+0, false, false,
+	0x1.000001000064p+0, false, false,
+	false,
+	0x1.000001000063fcap+0, false, false,
+	0x1.000001000063fca2p+0, false, false,
+	0x1.000001000063fcap+0, false, false,
+	0x1.000001000063fca2p+0, false, false,
+	false,
+	0x1.000001000063fcap+0, false, false,
+	0x1.000001000063fca2p+0, false, false,
+	0x1.000001000063fcap+0, false, false,
+	0x1.000001000063fca2p+0, false, false,
+	false,
+	0x1.000001000063fca17533f5572f8p+0, false, false,
+	0x1.000001000063fca17533f5573p+0, false, false,
+	0x1.000001000063fca17533f5572f8p+0, false, false,
+	0x1.000001000063fca17533f5573p+0, false, false,
+	false,
+	0x1.000001000063fca17533f5572fe9p+0, false, false,
+	0x1.000001000063fca17533f5572feap+0, false, false,
+	0x1.000001000063fca17533f5572fe9p+0, false, false,
+	0x1.000001000063fca17533f5572feap+0, false, false),
   TEST ("1.00000005960",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1.000000fffae49p+0, false,
-	0x1.000000fffae4ap+0, false,
-	0x1.000000fffae49p+0, false,
-	0x1.000000fffae4ap+0, false,
-	false,
-	0x1.000000fffae49ca8p+0, false,
-	0x1.000000fffae49caap+0, false,
-	0x1.000000fffae49ca8p+0, false,
-	0x1.000000fffae49caap+0, false,
-	false,
-	0x1.000000fffae49ca8p+0, false,
-	0x1.000000fffae49caap+0, false,
-	0x1.000000fffae49ca8p+0, false,
-	0x1.000000fffae49caap+0, false,
-	false,
-	0x1.000000fffae49ca916dacfff38p+0, false,
-	0x1.000000fffae49ca916dacfff38p+0, false,
-	0x1.000000fffae49ca916dacfff38p+0, false,
-	0x1.000000fffae49ca916dacfff388p+0, false,
-	false,
-	0x1.000000fffae49ca916dacfff382dp+0, false,
-	0x1.000000fffae49ca916dacfff382dp+0, false,
-	0x1.000000fffae49ca916dacfff382dp+0, false,
-	0x1.000000fffae49ca916dacfff382ep+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1.000000fffae49p+0, false, false,
+	0x1.000000fffae4ap+0, false, false,
+	0x1.000000fffae49p+0, false, false,
+	0x1.000000fffae4ap+0, false, false,
+	false,
+	0x1.000000fffae49ca8p+0, false, false,
+	0x1.000000fffae49caap+0, false, false,
+	0x1.000000fffae49ca8p+0, false, false,
+	0x1.000000fffae49caap+0, false, false,
+	false,
+	0x1.000000fffae49ca8p+0, false, false,
+	0x1.000000fffae49caap+0, false, false,
+	0x1.000000fffae49ca8p+0, false, false,
+	0x1.000000fffae49caap+0, false, false,
+	false,
+	0x1.000000fffae49ca916dacfff38p+0, false, false,
+	0x1.000000fffae49ca916dacfff38p+0, false, false,
+	0x1.000000fffae49ca916dacfff38p+0, false, false,
+	0x1.000000fffae49ca916dacfff388p+0, false, false,
+	false,
+	0x1.000000fffae49ca916dacfff382dp+0, false, false,
+	0x1.000000fffae49ca916dacfff382dp+0, false, false,
+	0x1.000000fffae49ca916dacfff382dp+0, false, false,
+	0x1.000000fffae49ca916dacfff382ep+0, false, false),
   TEST ("1.0000000596",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1.000000fffae49p+0, false,
-	0x1.000000fffae4ap+0, false,
-	0x1.000000fffae49p+0, false,
-	0x1.000000fffae4ap+0, false,
-	false,
-	0x1.000000fffae49ca8p+0, false,
-	0x1.000000fffae49caap+0, false,
-	0x1.000000fffae49ca8p+0, false,
-	0x1.000000fffae49caap+0, false,
-	false,
-	0x1.000000fffae49ca8p+0, false,
-	0x1.000000fffae49caap+0, false,
-	0x1.000000fffae49ca8p+0, false,
-	0x1.000000fffae49caap+0, false,
-	false,
-	0x1.000000fffae49ca916dacfff38p+0, false,
-	0x1.000000fffae49ca916dacfff38p+0, false,
-	0x1.000000fffae49ca916dacfff38p+0, false,
-	0x1.000000fffae49ca916dacfff388p+0, false,
-	false,
-	0x1.000000fffae49ca916dacfff382dp+0, false,
-	0x1.000000fffae49ca916dacfff382dp+0, false,
-	0x1.000000fffae49ca916dacfff382dp+0, false,
-	0x1.000000fffae49ca916dacfff382ep+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1.000000fffae49p+0, false, false,
+	0x1.000000fffae4ap+0, false, false,
+	0x1.000000fffae49p+0, false, false,
+	0x1.000000fffae4ap+0, false, false,
+	false,
+	0x1.000000fffae49ca8p+0, false, false,
+	0x1.000000fffae49caap+0, false, false,
+	0x1.000000fffae49ca8p+0, false, false,
+	0x1.000000fffae49caap+0, false, false,
+	false,
+	0x1.000000fffae49ca8p+0, false, false,
+	0x1.000000fffae49caap+0, false, false,
+	0x1.000000fffae49ca8p+0, false, false,
+	0x1.000000fffae49caap+0, false, false,
+	false,
+	0x1.000000fffae49ca916dacfff38p+0, false, false,
+	0x1.000000fffae49ca916dacfff38p+0, false, false,
+	0x1.000000fffae49ca916dacfff38p+0, false, false,
+	0x1.000000fffae49ca916dacfff388p+0, false, false,
+	false,
+	0x1.000000fffae49ca916dacfff382dp+0, false, false,
+	0x1.000000fffae49ca916dacfff382dp+0, false, false,
+	0x1.000000fffae49ca916dacfff382dp+0, false, false,
+	0x1.000000fffae49ca916dacfff382ep+0, false, false),
   TEST ("1.000000060",
 	false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1.00000101b2b29p+0, false,
-	0x1.00000101b2b2ap+0, false,
-	0x1.00000101b2b29p+0, false,
-	0x1.00000101b2b2ap+0, false,
-	false,
-	0x1.00000101b2b29a46p+0, false,
-	0x1.00000101b2b29a46p+0, false,
-	0x1.00000101b2b29a46p+0, false,
-	0x1.00000101b2b29a48p+0, false,
-	false,
-	0x1.00000101b2b29a46p+0, false,
-	0x1.00000101b2b29a46p+0, false,
-	0x1.00000101b2b29a46p+0, false,
-	0x1.00000101b2b29a48p+0, false,
-	false,
-	0x1.00000101b2b29a4692b67b7ca3p+0, false,
-	0x1.00000101b2b29a4692b67b7ca3p+0, false,
-	0x1.00000101b2b29a4692b67b7ca3p+0, false,
-	0x1.00000101b2b29a4692b67b7ca38p+0, false,
-	false,
-	0x1.00000101b2b29a4692b67b7ca313p+0, false,
-	0x1.00000101b2b29a4692b67b7ca314p+0, false,
-	0x1.00000101b2b29a4692b67b7ca313p+0, false,
-	0x1.00000101b2b29a4692b67b7ca314p+0, false),
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1.00000101b2b29p+0, false, false,
+	0x1.00000101b2b2ap+0, false, false,
+	0x1.00000101b2b29p+0, false, false,
+	0x1.00000101b2b2ap+0, false, false,
+	false,
+	0x1.00000101b2b29a46p+0, false, false,
+	0x1.00000101b2b29a46p+0, false, false,
+	0x1.00000101b2b29a46p+0, false, false,
+	0x1.00000101b2b29a48p+0, false, false,
+	false,
+	0x1.00000101b2b29a46p+0, false, false,
+	0x1.00000101b2b29a46p+0, false, false,
+	0x1.00000101b2b29a46p+0, false, false,
+	0x1.00000101b2b29a48p+0, false, false,
+	false,
+	0x1.00000101b2b29a4692b67b7ca3p+0, false, false,
+	0x1.00000101b2b29a4692b67b7ca3p+0, false, false,
+	0x1.00000101b2b29a4692b67b7ca3p+0, false, false,
+	0x1.00000101b2b29a4692b67b7ca38p+0, false, false,
+	false,
+	0x1.00000101b2b29a4692b67b7ca313p+0, false, false,
+	0x1.00000101b2b29a4692b67b7ca314p+0, false, false,
+	0x1.00000101b2b29a4692b67b7ca313p+0, false, false,
+	0x1.00000101b2b29a4692b67b7ca314p+0, false, false),
   TEST ("1.00000006",
 	false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1.00000101b2b29p+0, false,
-	0x1.00000101b2b2ap+0, false,
-	0x1.00000101b2b29p+0, false,
-	0x1.00000101b2b2ap+0, false,
-	false,
-	0x1.00000101b2b29a46p+0, false,
-	0x1.00000101b2b29a46p+0, false,
-	0x1.00000101b2b29a46p+0, false,
-	0x1.00000101b2b29a48p+0, false,
-	false,
-	0x1.00000101b2b29a46p+0, false,
-	0x1.00000101b2b29a46p+0, false,
-	0x1.00000101b2b29a46p+0, false,
-	0x1.00000101b2b29a48p+0, false,
-	false,
-	0x1.00000101b2b29a4692b67b7ca3p+0, false,
-	0x1.00000101b2b29a4692b67b7ca3p+0, false,
-	0x1.00000101b2b29a4692b67b7ca3p+0, false,
-	0x1.00000101b2b29a4692b67b7ca38p+0, false,
-	false,
-	0x1.00000101b2b29a4692b67b7ca313p+0, false,
-	0x1.00000101b2b29a4692b67b7ca314p+0, false,
-	0x1.00000101b2b29a4692b67b7ca313p+0, false,
-	0x1.00000101b2b29a4692b67b7ca314p+0, false),
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1.00000101b2b29p+0, false, false,
+	0x1.00000101b2b2ap+0, false, false,
+	0x1.00000101b2b29p+0, false, false,
+	0x1.00000101b2b2ap+0, false, false,
+	false,
+	0x1.00000101b2b29a46p+0, false, false,
+	0x1.00000101b2b29a46p+0, false, false,
+	0x1.00000101b2b29a46p+0, false, false,
+	0x1.00000101b2b29a48p+0, false, false,
+	false,
+	0x1.00000101b2b29a46p+0, false, false,
+	0x1.00000101b2b29a46p+0, false, false,
+	0x1.00000101b2b29a46p+0, false, false,
+	0x1.00000101b2b29a48p+0, false, false,
+	false,
+	0x1.00000101b2b29a4692b67b7ca3p+0, false, false,
+	0x1.00000101b2b29a4692b67b7ca3p+0, false, false,
+	0x1.00000101b2b29a4692b67b7ca3p+0, false, false,
+	0x1.00000101b2b29a4692b67b7ca38p+0, false, false,
+	false,
+	0x1.00000101b2b29a4692b67b7ca313p+0, false, false,
+	0x1.00000101b2b29a4692b67b7ca314p+0, false, false,
+	0x1.00000101b2b29a4692b67b7ca313p+0, false, false,
+	0x1.00000101b2b29a4692b67b7ca314p+0, false, false),
   TEST ("1.0000001",
 	false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1.000001ad7f29ap+0, false,
-	0x1.000001ad7f29bp+0, false,
-	0x1.000001ad7f29ap+0, false,
-	0x1.000001ad7f29bp+0, false,
-	false,
-	0x1.000001ad7f29abcap+0, false,
-	0x1.000001ad7f29abcap+0, false,
-	0x1.000001ad7f29abcap+0, false,
-	0x1.000001ad7f29abccp+0, false,
-	false,
-	0x1.000001ad7f29abcap+0, false,
-	0x1.000001ad7f29abcap+0, false,
-	0x1.000001ad7f29abcap+0, false,
-	0x1.000001ad7f29abccp+0, false,
-	false,
-	0x1.000001ad7f29abcaf485787a65p+0, false,
-	0x1.000001ad7f29abcaf485787a65p+0, false,
-	0x1.000001ad7f29abcaf485787a65p+0, false,
-	0x1.000001ad7f29abcaf485787a658p+0, false,
-	false,
-	0x1.000001ad7f29abcaf485787a652p+0, false,
-	0x1.000001ad7f29abcaf485787a6521p+0, false,
-	0x1.000001ad7f29abcaf485787a652p+0, false,
-	0x1.000001ad7f29abcaf485787a6521p+0, false),
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1.000001ad7f29ap+0, false, false,
+	0x1.000001ad7f29bp+0, false, false,
+	0x1.000001ad7f29ap+0, false, false,
+	0x1.000001ad7f29bp+0, false, false,
+	false,
+	0x1.000001ad7f29abcap+0, false, false,
+	0x1.000001ad7f29abcap+0, false, false,
+	0x1.000001ad7f29abcap+0, false, false,
+	0x1.000001ad7f29abccp+0, false, false,
+	false,
+	0x1.000001ad7f29abcap+0, false, false,
+	0x1.000001ad7f29abcap+0, false, false,
+	0x1.000001ad7f29abcap+0, false, false,
+	0x1.000001ad7f29abccp+0, false, false,
+	false,
+	0x1.000001ad7f29abcaf485787a65p+0, false, false,
+	0x1.000001ad7f29abcaf485787a65p+0, false, false,
+	0x1.000001ad7f29abcaf485787a65p+0, false, false,
+	0x1.000001ad7f29abcaf485787a658p+0, false, false,
+	false,
+	0x1.000001ad7f29abcaf485787a652p+0, false, false,
+	0x1.000001ad7f29abcaf485787a6521p+0, false, false,
+	0x1.000001ad7f29abcaf485787a652p+0, false, false,
+	0x1.000001ad7f29abcaf485787a6521p+0, false, false),
   TEST ("1.000000",
 	true,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	true,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	true,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	true,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	true,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	true,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	true,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	true,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	true,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	true,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	true,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false),
   TEST ("1.00000000000000011113",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1.00000000000008p+0, false,
-	0x1.0000000000000802p+0, false,
-	0x1.00000000000008p+0, false,
-	0x1.0000000000000802p+0, false,
-	false,
-	0x1.00000000000008p+0, false,
-	0x1.0000000000000802p+0, false,
-	0x1.00000000000008p+0, false,
-	0x1.0000000000000802p+0, false,
-	false,
-	0x1.0000000000000801fc96557232p+0, false,
-	0x1.0000000000000801fc96557232p+0, false,
-	0x1.0000000000000801fc96557232p+0, false,
-	0x1.0000000000000801fc965572328p+0, false,
-	false,
-	0x1.0000000000000801fc9655723222p+0, false,
-	0x1.0000000000000801fc9655723222p+0, false,
-	0x1.0000000000000801fc9655723222p+0, false,
-	0x1.0000000000000801fc9655723223p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1.00000000000008p+0, false, false,
+	0x1.0000000000000802p+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	0x1.0000000000000802p+0, false, false,
+	false,
+	0x1.00000000000008p+0, false, false,
+	0x1.0000000000000802p+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	0x1.0000000000000802p+0, false, false,
+	false,
+	0x1.0000000000000801fc96557232p+0, false, false,
+	0x1.0000000000000801fc96557232p+0, false, false,
+	0x1.0000000000000801fc96557232p+0, false, false,
+	0x1.0000000000000801fc965572328p+0, false, false,
+	false,
+	0x1.0000000000000801fc9655723222p+0, false, false,
+	0x1.0000000000000801fc9655723222p+0, false, false,
+	0x1.0000000000000801fc9655723222p+0, false, false,
+	0x1.0000000000000801fc9655723223p+0, false, false),
   TEST ("1.00000000000000011103",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1.00000000000008p+0, false,
-	0x1.00000000000008p+0, false,
-	0x1.00000000000008p+0, false,
-	0x1.0000000000000802p+0, false,
-	false,
-	0x1.00000000000008p+0, false,
-	0x1.00000000000008p+0, false,
-	0x1.00000000000008p+0, false,
-	0x1.0000000000000802p+0, false,
-	false,
-	0x1.00000000000008002459c076c48p+0, false,
-	0x1.00000000000008002459c076c5p+0, false,
-	0x1.00000000000008002459c076c48p+0, false,
-	0x1.00000000000008002459c076c5p+0, false,
-	false,
-	0x1.00000000000008002459c076c4f7p+0, false,
-	0x1.00000000000008002459c076c4f8p+0, false,
-	0x1.00000000000008002459c076c4f7p+0, false,
-	0x1.00000000000008002459c076c4f8p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1.00000000000008p+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	0x1.0000000000000802p+0, false, false,
+	false,
+	0x1.00000000000008p+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	0x1.0000000000000802p+0, false, false,
+	false,
+	0x1.00000000000008002459c076c48p+0, false, false,
+	0x1.00000000000008002459c076c5p+0, false, false,
+	0x1.00000000000008002459c076c48p+0, false, false,
+	0x1.00000000000008002459c076c5p+0, false, false,
+	false,
+	0x1.00000000000008002459c076c4f7p+0, false, false,
+	0x1.00000000000008002459c076c4f8p+0, false, false,
+	0x1.00000000000008002459c076c4f7p+0, false, false,
+	0x1.00000000000008002459c076c4f8p+0, false, false),
   TEST ("1.00000000000000011102",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1.00000000000007fep+0, false,
-	0x1.00000000000008p+0, false,
-	0x1.00000000000007fep+0, false,
-	0x1.00000000000008p+0, false,
-	false,
-	0x1.00000000000007fep+0, false,
-	0x1.00000000000008p+0, false,
-	0x1.00000000000007fep+0, false,
-	0x1.00000000000008p+0, false,
-	false,
-	0x1.00000000000007fff5207e5dap+0, false,
-	0x1.00000000000007fff5207e5da08p+0, false,
-	0x1.00000000000007fff5207e5dap+0, false,
-	0x1.00000000000007fff5207e5da08p+0, false,
-	false,
-	0x1.00000000000007fff5207e5da073p+0, false,
-	0x1.00000000000007fff5207e5da073p+0, false,
-	0x1.00000000000007fff5207e5da073p+0, false,
-	0x1.00000000000007fff5207e5da074p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1.00000000000007fep+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	0x1.00000000000007fep+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	false,
+	0x1.00000000000007fep+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	0x1.00000000000007fep+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	false,
+	0x1.00000000000007fff5207e5dap+0, false, false,
+	0x1.00000000000007fff5207e5da08p+0, false, false,
+	0x1.00000000000007fff5207e5dap+0, false, false,
+	0x1.00000000000007fff5207e5da08p+0, false, false,
+	false,
+	0x1.00000000000007fff5207e5da073p+0, false, false,
+	0x1.00000000000007fff5207e5da073p+0, false, false,
+	0x1.00000000000007fff5207e5da073p+0, false, false,
+	0x1.00000000000007fff5207e5da074p+0, false, false),
   TEST ("1.00000000000000011101",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1.00000000000007fep+0, false,
-	0x1.00000000000008p+0, false,
-	0x1.00000000000007fep+0, false,
-	0x1.00000000000008p+0, false,
-	false,
-	0x1.00000000000007fep+0, false,
-	0x1.00000000000008p+0, false,
-	0x1.00000000000007fep+0, false,
-	0x1.00000000000008p+0, false,
-	false,
-	0x1.00000000000007ffc5e73c447b8p+0, false,
-	0x1.00000000000007ffc5e73c447cp+0, false,
-	0x1.00000000000007ffc5e73c447b8p+0, false,
-	0x1.00000000000007ffc5e73c447cp+0, false,
-	false,
-	0x1.00000000000007ffc5e73c447befp+0, false,
-	0x1.00000000000007ffc5e73c447befp+0, false,
-	0x1.00000000000007ffc5e73c447befp+0, false,
-	0x1.00000000000007ffc5e73c447bfp+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1.00000000000007fep+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	0x1.00000000000007fep+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	false,
+	0x1.00000000000007fep+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	0x1.00000000000007fep+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	false,
+	0x1.00000000000007ffc5e73c447b8p+0, false, false,
+	0x1.00000000000007ffc5e73c447cp+0, false, false,
+	0x1.00000000000007ffc5e73c447b8p+0, false, false,
+	0x1.00000000000007ffc5e73c447cp+0, false, false,
+	false,
+	0x1.00000000000007ffc5e73c447befp+0, false, false,
+	0x1.00000000000007ffc5e73c447befp+0, false, false,
+	0x1.00000000000007ffc5e73c447befp+0, false, false,
+	0x1.00000000000007ffc5e73c447bfp+0, false, false),
   TEST ("1.0000000000000001111",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1.00000000000008p+0, false,
-	0x1.0000000000000802p+0, false,
-	0x1.00000000000008p+0, false,
-	0x1.0000000000000802p+0, false,
-	false,
-	0x1.00000000000008p+0, false,
-	0x1.0000000000000802p+0, false,
-	0x1.00000000000008p+0, false,
-	0x1.0000000000000802p+0, false,
-	false,
-	0x1.00000000000008016eea8f26c48p+0, false,
-	0x1.00000000000008016eea8f26c48p+0, false,
-	0x1.00000000000008016eea8f26c48p+0, false,
-	0x1.00000000000008016eea8f26c5p+0, false,
-	false,
-	0x1.00000000000008016eea8f26c495p+0, false,
-	0x1.00000000000008016eea8f26c496p+0, false,
-	0x1.00000000000008016eea8f26c495p+0, false,
-	0x1.00000000000008016eea8f26c496p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1.00000000000008p+0, false, false,
+	0x1.0000000000000802p+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	0x1.0000000000000802p+0, false, false,
+	false,
+	0x1.00000000000008p+0, false, false,
+	0x1.0000000000000802p+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	0x1.0000000000000802p+0, false, false,
+	false,
+	0x1.00000000000008016eea8f26c48p+0, false, false,
+	0x1.00000000000008016eea8f26c48p+0, false, false,
+	0x1.00000000000008016eea8f26c48p+0, false, false,
+	0x1.00000000000008016eea8f26c5p+0, false, false,
+	false,
+	0x1.00000000000008016eea8f26c495p+0, false, false,
+	0x1.00000000000008016eea8f26c496p+0, false, false,
+	0x1.00000000000008016eea8f26c495p+0, false, false,
+	0x1.00000000000008016eea8f26c496p+0, false, false),
   TEST ("1.000000000000000111",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1.00000000000007fep+0, false,
-	0x1.00000000000008p+0, false,
-	0x1.00000000000007fep+0, false,
-	0x1.00000000000008p+0, false,
-	false,
-	0x1.00000000000007fep+0, false,
-	0x1.00000000000008p+0, false,
-	0x1.00000000000007fep+0, false,
-	0x1.00000000000008p+0, false,
-	false,
-	0x1.00000000000007ff96adfa2b57p+0, false,
-	0x1.00000000000007ff96adfa2b578p+0, false,
-	0x1.00000000000007ff96adfa2b57p+0, false,
-	0x1.00000000000007ff96adfa2b578p+0, false,
-	false,
-	0x1.00000000000007ff96adfa2b576ap+0, false,
-	0x1.00000000000007ff96adfa2b576bp+0, false,
-	0x1.00000000000007ff96adfa2b576ap+0, false,
-	0x1.00000000000007ff96adfa2b576bp+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1.00000000000007fep+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	0x1.00000000000007fep+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	false,
+	0x1.00000000000007fep+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	0x1.00000000000007fep+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	false,
+	0x1.00000000000007ff96adfa2b57p+0, false, false,
+	0x1.00000000000007ff96adfa2b578p+0, false, false,
+	0x1.00000000000007ff96adfa2b57p+0, false, false,
+	0x1.00000000000007ff96adfa2b578p+0, false, false,
+	false,
+	0x1.00000000000007ff96adfa2b576ap+0, false, false,
+	0x1.00000000000007ff96adfa2b576bp+0, false, false,
+	0x1.00000000000007ff96adfa2b576ap+0, false, false,
+	0x1.00000000000007ff96adfa2b576bp+0, false, false),
   TEST ("1.00000000000000011",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1.00000000000007ecp+0, false,
-	0x1.00000000000007eep+0, false,
-	0x1.00000000000007ecp+0, false,
-	0x1.00000000000007eep+0, false,
-	false,
-	0x1.00000000000007ecp+0, false,
-	0x1.00000000000007eep+0, false,
-	0x1.00000000000007ecp+0, false,
-	0x1.00000000000007eep+0, false,
-	false,
-	0x1.00000000000007ed24502859138p+0, false,
-	0x1.00000000000007ed24502859138p+0, false,
-	0x1.00000000000007ed24502859138p+0, false,
-	0x1.00000000000007ed2450285914p+0, false,
-	false,
-	0x1.00000000000007ed2450285913bfp+0, false,
-	0x1.00000000000007ed2450285913bfp+0, false,
-	0x1.00000000000007ed2450285913bfp+0, false,
-	0x1.00000000000007ed2450285913cp+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1.00000000000007ecp+0, false, false,
+	0x1.00000000000007eep+0, false, false,
+	0x1.00000000000007ecp+0, false, false,
+	0x1.00000000000007eep+0, false, false,
+	false,
+	0x1.00000000000007ecp+0, false, false,
+	0x1.00000000000007eep+0, false, false,
+	0x1.00000000000007ecp+0, false, false,
+	0x1.00000000000007eep+0, false, false,
+	false,
+	0x1.00000000000007ed24502859138p+0, false, false,
+	0x1.00000000000007ed24502859138p+0, false, false,
+	0x1.00000000000007ed24502859138p+0, false, false,
+	0x1.00000000000007ed2450285914p+0, false, false,
+	false,
+	0x1.00000000000007ed2450285913bfp+0, false, false,
+	0x1.00000000000007ed2450285913bfp+0, false, false,
+	0x1.00000000000007ed2450285913bfp+0, false, false,
+	0x1.00000000000007ed2450285913cp+0, false, false),
   TEST ("1.0000000000000001",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1.0000000000000734p+0, false,
-	0x1.0000000000000734p+0, false,
-	0x1.0000000000000734p+0, false,
-	0x1.0000000000000736p+0, false,
-	false,
-	0x1.0000000000000734p+0, false,
-	0x1.0000000000000734p+0, false,
-	0x1.0000000000000734p+0, false,
-	0x1.0000000000000736p+0, false,
-	false,
-	0x1.0000000000000734aca5f6226fp+0, false,
-	0x1.0000000000000734aca5f6226fp+0, false,
-	0x1.0000000000000734aca5f6226fp+0, false,
-	0x1.0000000000000734aca5f6226f8p+0, false,
-	false,
-	0x1.0000000000000734aca5f6226f0ap+0, false,
-	0x1.0000000000000734aca5f6226f0bp+0, false,
-	0x1.0000000000000734aca5f6226f0ap+0, false,
-	0x1.0000000000000734aca5f6226f0bp+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1.0000000000000734p+0, false, false,
+	0x1.0000000000000734p+0, false, false,
+	0x1.0000000000000734p+0, false, false,
+	0x1.0000000000000736p+0, false, false,
+	false,
+	0x1.0000000000000734p+0, false, false,
+	0x1.0000000000000734p+0, false, false,
+	0x1.0000000000000734p+0, false, false,
+	0x1.0000000000000736p+0, false, false,
+	false,
+	0x1.0000000000000734aca5f6226fp+0, false, false,
+	0x1.0000000000000734aca5f6226fp+0, false, false,
+	0x1.0000000000000734aca5f6226fp+0, false, false,
+	0x1.0000000000000734aca5f6226f8p+0, false, false,
+	false,
+	0x1.0000000000000734aca5f6226f0ap+0, false, false,
+	0x1.0000000000000734aca5f6226f0bp+0, false, false,
+	0x1.0000000000000734aca5f6226f0ap+0, false, false,
+	0x1.0000000000000734aca5f6226f0bp+0, false, false),
   TEST ("3929201589819414e-25",
 	false,
-	0x1.b0053p-32, false,
-	0x1.b00532p-32, false,
-	0x1.b0053p-32, false,
-	0x1.b00532p-32, false,
-	false,
-	0x1.b005314e2421ep-32, false,
-	0x1.b005314e2421ep-32, false,
-	0x1.b005314e2421ep-32, false,
-	0x1.b005314e2421fp-32, false,
-	false,
-	0x1.b005314e2421e7fep-32, false,
-	0x1.b005314e2421e8p-32, false,
-	0x1.b005314e2421e7fep-32, false,
-	0x1.b005314e2421e8p-32, false,
-	false,
-	0x1.b005314e2421e7fep-32, false,
-	0x1.b005314e2421e8p-32, false,
-	0x1.b005314e2421e7fep-32, false,
-	0x1.b005314e2421e8p-32, false,
-	false,
-	0x1.b005314e2421e7ffb472840c5ap-32, false,
-	0x1.b005314e2421e7ffb472840c5a8p-32, false,
-	0x1.b005314e2421e7ffb472840c5ap-32, false,
-	0x1.b005314e2421e7ffb472840c5a8p-32, false,
-	false,
-	0x1.b005314e2421e7ffb472840c5a6ep-32, false,
-	0x1.b005314e2421e7ffb472840c5a6fp-32, false,
-	0x1.b005314e2421e7ffb472840c5a6ep-32, false,
-	0x1.b005314e2421e7ffb472840c5a6fp-32, false),
+	0x1.b0053p-32, false, false,
+	0x1.b00532p-32, false, false,
+	0x1.b0053p-32, false, false,
+	0x1.b00532p-32, false, false,
+	false,
+	0x1.b005314e2421ep-32, false, false,
+	0x1.b005314e2421ep-32, false, false,
+	0x1.b005314e2421ep-32, false, false,
+	0x1.b005314e2421fp-32, false, false,
+	false,
+	0x1.b005314e2421e7fep-32, false, false,
+	0x1.b005314e2421e8p-32, false, false,
+	0x1.b005314e2421e7fep-32, false, false,
+	0x1.b005314e2421e8p-32, false, false,
+	false,
+	0x1.b005314e2421e7fep-32, false, false,
+	0x1.b005314e2421e8p-32, false, false,
+	0x1.b005314e2421e7fep-32, false, false,
+	0x1.b005314e2421e8p-32, false, false,
+	false,
+	0x1.b005314e2421e7ffb472840c5ap-32, false, false,
+	0x1.b005314e2421e7ffb472840c5a8p-32, false, false,
+	0x1.b005314e2421e7ffb472840c5ap-32, false, false,
+	0x1.b005314e2421e7ffb472840c5a8p-32, false, false,
+	false,
+	0x1.b005314e2421e7ffb472840c5a6ep-32, false, false,
+	0x1.b005314e2421e7ffb472840c5a6fp-32, false, false,
+	0x1.b005314e2421e7ffb472840c5a6ep-32, false, false,
+	0x1.b005314e2421e7ffb472840c5a6fp-32, false, false),
   TEST ("0.0000000000000000000000000000000000000000000021019476964872"
 	"256063855943749348741969203929128147736576356024258346866240"
 	"28790902229957282543182373046875",
 	false,
-	0x8p-152, false,
-	0x1p-148, false,
-	0x8p-152, false,
-	0x1p-148, false,
-	true,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xcp-152, false,
-	true,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xcp-152, false,
-	true,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xcp-152, false,
-	true,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xcp-152, false,
-	true,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xcp-152, false),
+	0x8p-152, false, true,
+	0x1p-148, false, true,
+	0x8p-152, false, true,
+	0x1p-148, false, true,
+	true,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	true,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	true,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	true,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	true,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xcp-152, false, false),
   TEST ("1.00000005960464477539062499",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1.000000fffffffp+0, false,
-	0x1.000001p+0, false,
-	0x1.000000fffffffp+0, false,
-	0x1.000001p+0, false,
-	false,
-	0x1.000000fffffffffep+0, false,
-	0x1.000001p+0, false,
-	0x1.000000fffffffffep+0, false,
-	0x1.000001p+0, false,
-	false,
-	0x1.000000fffffffffep+0, false,
-	0x1.000001p+0, false,
-	0x1.000000fffffffffep+0, false,
-	0x1.000001p+0, false,
-	false,
-	0x1.000000fffffffffffffffce7b78p+0, false,
-	0x1.000000fffffffffffffffce7b8p+0, false,
-	0x1.000000fffffffffffffffce7b78p+0, false,
-	0x1.000000fffffffffffffffce7b8p+0, false,
-	false,
-	0x1.000000fffffffffffffffce7b7e7p+0, false,
-	0x1.000000fffffffffffffffce7b7e7p+0, false,
-	0x1.000000fffffffffffffffce7b7e7p+0, false,
-	0x1.000000fffffffffffffffce7b7e8p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1.000000fffffffp+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.000000fffffffp+0, false, false,
+	0x1.000001p+0, false, false,
+	false,
+	0x1.000000fffffffffep+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.000000fffffffffep+0, false, false,
+	0x1.000001p+0, false, false,
+	false,
+	0x1.000000fffffffffep+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.000000fffffffffep+0, false, false,
+	0x1.000001p+0, false, false,
+	false,
+	0x1.000000fffffffffffffffce7b78p+0, false, false,
+	0x1.000000fffffffffffffffce7b8p+0, false, false,
+	0x1.000000fffffffffffffffce7b78p+0, false, false,
+	0x1.000000fffffffffffffffce7b8p+0, false, false,
+	false,
+	0x1.000000fffffffffffffffce7b7e7p+0, false, false,
+	0x1.000000fffffffffffffffce7b7e7p+0, false, false,
+	0x1.000000fffffffffffffffce7b7e7p+0, false, false,
+	0x1.000000fffffffffffffffce7b7e8p+0, false, false),
   TEST ("1.000000059604644775390625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	true,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	true,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	true,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	true,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	true,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	true,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	true,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	true,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false),
   TEST ("1.00000005960464477539062501",
 	false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	0x1.0000010000001p+0, false,
-	false,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	0x1.0000010000000002p+0, false,
-	false,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	0x1.000001p+0, false,
-	0x1.0000010000000002p+0, false,
-	false,
-	0x1.00000100000000000000031848p+0, false,
-	0x1.00000100000000000000031848p+0, false,
-	0x1.00000100000000000000031848p+0, false,
-	0x1.000001000000000000000318488p+0, false,
-	false,
-	0x1.0000010000000000000003184818p+0, false,
-	0x1.0000010000000000000003184819p+0, false,
-	0x1.0000010000000000000003184818p+0, false,
-	0x1.0000010000000000000003184819p+0, false),
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.0000010000001p+0, false, false,
+	false,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.0000010000000002p+0, false, false,
+	false,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.000001p+0, false, false,
+	0x1.0000010000000002p+0, false, false,
+	false,
+	0x1.00000100000000000000031848p+0, false, false,
+	0x1.00000100000000000000031848p+0, false, false,
+	0x1.00000100000000000000031848p+0, false, false,
+	0x1.000001000000000000000318488p+0, false, false,
+	false,
+	0x1.0000010000000000000003184818p+0, false, false,
+	0x1.0000010000000000000003184819p+0, false, false,
+	0x1.0000010000000000000003184818p+0, false, false,
+	0x1.0000010000000000000003184819p+0, false, false),
   TEST ("1.00000011920928955078125",
 	true,
-	0x1.000002p+0, false,
-	0x1.000002p+0, false,
-	0x1.000002p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.000002p+0, false,
-	0x1.000002p+0, false,
-	0x1.000002p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.000002p+0, false,
-	0x1.000002p+0, false,
-	0x1.000002p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.000002p+0, false,
-	0x1.000002p+0, false,
-	0x1.000002p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.000002p+0, false,
-	0x1.000002p+0, false,
-	0x1.000002p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.000002p+0, false,
-	0x1.000002p+0, false,
-	0x1.000002p+0, false,
-	0x1.000002p+0, false),
+	0x1.000002p+0, false, false,
+	0x1.000002p+0, false, false,
+	0x1.000002p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.000002p+0, false, false,
+	0x1.000002p+0, false, false,
+	0x1.000002p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.000002p+0, false, false,
+	0x1.000002p+0, false, false,
+	0x1.000002p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.000002p+0, false, false,
+	0x1.000002p+0, false, false,
+	0x1.000002p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.000002p+0, false, false,
+	0x1.000002p+0, false, false,
+	0x1.000002p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.000002p+0, false, false,
+	0x1.000002p+0, false, false,
+	0x1.000002p+0, false, false,
+	0x1.000002p+0, false, false),
   TEST ("1.00000017881393432617187499",
 	false,
-	0x1.000002p+0, false,
-	0x1.000002p+0, false,
-	0x1.000002p+0, false,
-	0x1.000004p+0, false,
-	false,
-	0x1.000002fffffffp+0, false,
-	0x1.000003p+0, false,
-	0x1.000002fffffffp+0, false,
-	0x1.000003p+0, false,
-	false,
-	0x1.000002fffffffffep+0, false,
-	0x1.000003p+0, false,
-	0x1.000002fffffffffep+0, false,
-	0x1.000003p+0, false,
-	false,
-	0x1.000002fffffffffep+0, false,
-	0x1.000003p+0, false,
-	0x1.000002fffffffffep+0, false,
-	0x1.000003p+0, false,
-	false,
-	0x1.000002fffffffffffffffce7b78p+0, false,
-	0x1.000002fffffffffffffffce7b8p+0, false,
-	0x1.000002fffffffffffffffce7b78p+0, false,
-	0x1.000002fffffffffffffffce7b8p+0, false,
-	false,
-	0x1.000002fffffffffffffffce7b7e7p+0, false,
-	0x1.000002fffffffffffffffce7b7e7p+0, false,
-	0x1.000002fffffffffffffffce7b7e7p+0, false,
-	0x1.000002fffffffffffffffce7b7e8p+0, false),
+	0x1.000002p+0, false, false,
+	0x1.000002p+0, false, false,
+	0x1.000002p+0, false, false,
+	0x1.000004p+0, false, false,
+	false,
+	0x1.000002fffffffp+0, false, false,
+	0x1.000003p+0, false, false,
+	0x1.000002fffffffp+0, false, false,
+	0x1.000003p+0, false, false,
+	false,
+	0x1.000002fffffffffep+0, false, false,
+	0x1.000003p+0, false, false,
+	0x1.000002fffffffffep+0, false, false,
+	0x1.000003p+0, false, false,
+	false,
+	0x1.000002fffffffffep+0, false, false,
+	0x1.000003p+0, false, false,
+	0x1.000002fffffffffep+0, false, false,
+	0x1.000003p+0, false, false,
+	false,
+	0x1.000002fffffffffffffffce7b78p+0, false, false,
+	0x1.000002fffffffffffffffce7b8p+0, false, false,
+	0x1.000002fffffffffffffffce7b78p+0, false, false,
+	0x1.000002fffffffffffffffce7b8p+0, false, false,
+	false,
+	0x1.000002fffffffffffffffce7b7e7p+0, false, false,
+	0x1.000002fffffffffffffffce7b7e7p+0, false, false,
+	0x1.000002fffffffffffffffce7b7e7p+0, false, false,
+	0x1.000002fffffffffffffffce7b7e8p+0, false, false),
   TEST ("1.000000178813934326171875",
 	false,
-	0x1.000002p+0, false,
-	0x1.000004p+0, false,
-	0x1.000002p+0, false,
-	0x1.000004p+0, false,
-	true,
-	0x1.000003p+0, false,
-	0x1.000003p+0, false,
-	0x1.000003p+0, false,
-	0x1.000003p+0, false,
-	true,
-	0x1.000003p+0, false,
-	0x1.000003p+0, false,
-	0x1.000003p+0, false,
-	0x1.000003p+0, false,
-	true,
-	0x1.000003p+0, false,
-	0x1.000003p+0, false,
-	0x1.000003p+0, false,
-	0x1.000003p+0, false,
-	true,
-	0x1.000003p+0, false,
-	0x1.000003p+0, false,
-	0x1.000003p+0, false,
-	0x1.000003p+0, false,
-	true,
-	0x1.000003p+0, false,
-	0x1.000003p+0, false,
-	0x1.000003p+0, false,
-	0x1.000003p+0, false),
+	0x1.000002p+0, false, false,
+	0x1.000004p+0, false, false,
+	0x1.000002p+0, false, false,
+	0x1.000004p+0, false, false,
+	true,
+	0x1.000003p+0, false, false,
+	0x1.000003p+0, false, false,
+	0x1.000003p+0, false, false,
+	0x1.000003p+0, false, false,
+	true,
+	0x1.000003p+0, false, false,
+	0x1.000003p+0, false, false,
+	0x1.000003p+0, false, false,
+	0x1.000003p+0, false, false,
+	true,
+	0x1.000003p+0, false, false,
+	0x1.000003p+0, false, false,
+	0x1.000003p+0, false, false,
+	0x1.000003p+0, false, false,
+	true,
+	0x1.000003p+0, false, false,
+	0x1.000003p+0, false, false,
+	0x1.000003p+0, false, false,
+	0x1.000003p+0, false, false,
+	true,
+	0x1.000003p+0, false, false,
+	0x1.000003p+0, false, false,
+	0x1.000003p+0, false, false,
+	0x1.000003p+0, false, false),
   TEST ("1.00000017881393432617187501",
 	false,
-	0x1.000002p+0, false,
-	0x1.000004p+0, false,
-	0x1.000002p+0, false,
-	0x1.000004p+0, false,
-	false,
-	0x1.000003p+0, false,
-	0x1.000003p+0, false,
-	0x1.000003p+0, false,
-	0x1.0000030000001p+0, false,
-	false,
-	0x1.000003p+0, false,
-	0x1.000003p+0, false,
-	0x1.000003p+0, false,
-	0x1.0000030000000002p+0, false,
-	false,
-	0x1.000003p+0, false,
-	0x1.000003p+0, false,
-	0x1.000003p+0, false,
-	0x1.0000030000000002p+0, false,
-	false,
-	0x1.00000300000000000000031848p+0, false,
-	0x1.00000300000000000000031848p+0, false,
-	0x1.00000300000000000000031848p+0, false,
-	0x1.000003000000000000000318488p+0, false,
-	false,
-	0x1.0000030000000000000003184818p+0, false,
-	0x1.0000030000000000000003184819p+0, false,
-	0x1.0000030000000000000003184818p+0, false,
-	0x1.0000030000000000000003184819p+0, false),
+	0x1.000002p+0, false, false,
+	0x1.000004p+0, false, false,
+	0x1.000002p+0, false, false,
+	0x1.000004p+0, false, false,
+	false,
+	0x1.000003p+0, false, false,
+	0x1.000003p+0, false, false,
+	0x1.000003p+0, false, false,
+	0x1.0000030000001p+0, false, false,
+	false,
+	0x1.000003p+0, false, false,
+	0x1.000003p+0, false, false,
+	0x1.000003p+0, false, false,
+	0x1.0000030000000002p+0, false, false,
+	false,
+	0x1.000003p+0, false, false,
+	0x1.000003p+0, false, false,
+	0x1.000003p+0, false, false,
+	0x1.0000030000000002p+0, false, false,
+	false,
+	0x1.00000300000000000000031848p+0, false, false,
+	0x1.00000300000000000000031848p+0, false, false,
+	0x1.00000300000000000000031848p+0, false, false,
+	0x1.000003000000000000000318488p+0, false, false,
+	false,
+	0x1.0000030000000000000003184818p+0, false, false,
+	0x1.0000030000000000000003184819p+0, false, false,
+	0x1.0000030000000000000003184818p+0, false, false,
+	0x1.0000030000000000000003184819p+0, false, false),
   TEST ("1.0000002384185791015625",
 	true,
-	0x1.000004p+0, false,
-	0x1.000004p+0, false,
-	0x1.000004p+0, false,
-	0x1.000004p+0, false,
-	true,
-	0x1.000004p+0, false,
-	0x1.000004p+0, false,
-	0x1.000004p+0, false,
-	0x1.000004p+0, false,
-	true,
-	0x1.000004p+0, false,
-	0x1.000004p+0, false,
-	0x1.000004p+0, false,
-	0x1.000004p+0, false,
-	true,
-	0x1.000004p+0, false,
-	0x1.000004p+0, false,
-	0x1.000004p+0, false,
-	0x1.000004p+0, false,
-	true,
-	0x1.000004p+0, false,
-	0x1.000004p+0, false,
-	0x1.000004p+0, false,
-	0x1.000004p+0, false,
-	true,
-	0x1.000004p+0, false,
-	0x1.000004p+0, false,
-	0x1.000004p+0, false,
-	0x1.000004p+0, false),
+	0x1.000004p+0, false, false,
+	0x1.000004p+0, false, false,
+	0x1.000004p+0, false, false,
+	0x1.000004p+0, false, false,
+	true,
+	0x1.000004p+0, false, false,
+	0x1.000004p+0, false, false,
+	0x1.000004p+0, false, false,
+	0x1.000004p+0, false, false,
+	true,
+	0x1.000004p+0, false, false,
+	0x1.000004p+0, false, false,
+	0x1.000004p+0, false, false,
+	0x1.000004p+0, false, false,
+	true,
+	0x1.000004p+0, false, false,
+	0x1.000004p+0, false, false,
+	0x1.000004p+0, false, false,
+	0x1.000004p+0, false, false,
+	true,
+	0x1.000004p+0, false, false,
+	0x1.000004p+0, false, false,
+	0x1.000004p+0, false, false,
+	0x1.000004p+0, false, false,
+	true,
+	0x1.000004p+0, false, false,
+	0x1.000004p+0, false, false,
+	0x1.000004p+0, false, false,
+	0x1.000004p+0, false, false),
   TEST ("1.08420217248550443400745280086994171142578125e-19",
 	true,
-	0x2p-64, false,
-	0x2p-64, false,
-	0x2p-64, false,
-	0x2p-64, false,
-	true,
-	0x2p-64, false,
-	0x2p-64, false,
-	0x2p-64, false,
-	0x2p-64, false,
-	true,
-	0x2p-64, false,
-	0x2p-64, false,
-	0x2p-64, false,
-	0x2p-64, false,
-	true,
-	0x2p-64, false,
-	0x2p-64, false,
-	0x2p-64, false,
-	0x2p-64, false,
-	true,
-	0x2p-64, false,
-	0x2p-64, false,
-	0x2p-64, false,
-	0x2p-64, false,
-	true,
-	0x2p-64, false,
-	0x2p-64, false,
-	0x2p-64, false,
-	0x2p-64, false),
+	0x2p-64, false, false,
+	0x2p-64, false, false,
+	0x2p-64, false, false,
+	0x2p-64, false, false,
+	true,
+	0x2p-64, false, false,
+	0x2p-64, false, false,
+	0x2p-64, false, false,
+	0x2p-64, false, false,
+	true,
+	0x2p-64, false, false,
+	0x2p-64, false, false,
+	0x2p-64, false, false,
+	0x2p-64, false, false,
+	true,
+	0x2p-64, false, false,
+	0x2p-64, false, false,
+	0x2p-64, false, false,
+	0x2p-64, false, false,
+	true,
+	0x2p-64, false, false,
+	0x2p-64, false, false,
+	0x2p-64, false, false,
+	0x2p-64, false, false,
+	true,
+	0x2p-64, false, false,
+	0x2p-64, false, false,
+	0x2p-64, false, false,
+	0x2p-64, false, false),
   TEST ("1.0842022371089897897127399001987457793916291848290711641311"
 	"645507812499e-19",
 	false,
-	0x2p-64, false,
-	0x2p-64, false,
-	0x2p-64, false,
-	0x2.000004p-64, false,
-	false,
-	0x2.000001ffffffep-64, false,
-	0x2.000002p-64, false,
-	0x2.000001ffffffep-64, false,
-	0x2.000002p-64, false,
-	false,
-	0x2.000001fffffffffcp-64, false,
-	0x2.000002p-64, false,
-	0x2.000001fffffffffcp-64, false,
-	0x2.000002p-64, false,
-	false,
-	0x2.000001fffffffffcp-64, false,
-	0x2.000002p-64, false,
-	0x2.000001fffffffffcp-64, false,
-	0x2.000002p-64, false,
-	false,
-	0x2.000001ffffffffffffffffffffp-64, false,
-	0x2.000002p-64, false,
-	0x2.000001ffffffffffffffffffffp-64, false,
-	0x2.000002p-64, false,
-	false,
-	0x2.000001fffffffffffffffffffffep-64, false,
-	0x2.000002p-64, false,
-	0x2.000001fffffffffffffffffffffep-64, false,
-	0x2.000002p-64, false),
+	0x2p-64, false, false,
+	0x2p-64, false, false,
+	0x2p-64, false, false,
+	0x2.000004p-64, false, false,
+	false,
+	0x2.000001ffffffep-64, false, false,
+	0x2.000002p-64, false, false,
+	0x2.000001ffffffep-64, false, false,
+	0x2.000002p-64, false, false,
+	false,
+	0x2.000001fffffffffcp-64, false, false,
+	0x2.000002p-64, false, false,
+	0x2.000001fffffffffcp-64, false, false,
+	0x2.000002p-64, false, false,
+	false,
+	0x2.000001fffffffffcp-64, false, false,
+	0x2.000002p-64, false, false,
+	0x2.000001fffffffffcp-64, false, false,
+	0x2.000002p-64, false, false,
+	false,
+	0x2.000001ffffffffffffffffffffp-64, false, false,
+	0x2.000002p-64, false, false,
+	0x2.000001ffffffffffffffffffffp-64, false, false,
+	0x2.000002p-64, false, false,
+	false,
+	0x2.000001fffffffffffffffffffffep-64, false, false,
+	0x2.000002p-64, false, false,
+	0x2.000001fffffffffffffffffffffep-64, false, false,
+	0x2.000002p-64, false, false),
   TEST ("1.0842022371089897897127399001987457793916291848290711641311"
 	"6455078125e-19",
 	false,
-	0x2p-64, false,
-	0x2p-64, false,
-	0x2p-64, false,
-	0x2.000004p-64, false,
-	true,
-	0x2.000002p-64, false,
-	0x2.000002p-64, false,
-	0x2.000002p-64, false,
-	0x2.000002p-64, false,
-	true,
-	0x2.000002p-64, false,
-	0x2.000002p-64, false,
-	0x2.000002p-64, false,
-	0x2.000002p-64, false,
-	true,
-	0x2.000002p-64, false,
-	0x2.000002p-64, false,
-	0x2.000002p-64, false,
-	0x2.000002p-64, false,
-	true,
-	0x2.000002p-64, false,
-	0x2.000002p-64, false,
-	0x2.000002p-64, false,
-	0x2.000002p-64, false,
-	true,
-	0x2.000002p-64, false,
-	0x2.000002p-64, false,
-	0x2.000002p-64, false,
-	0x2.000002p-64, false),
+	0x2p-64, false, false,
+	0x2p-64, false, false,
+	0x2p-64, false, false,
+	0x2.000004p-64, false, false,
+	true,
+	0x2.000002p-64, false, false,
+	0x2.000002p-64, false, false,
+	0x2.000002p-64, false, false,
+	0x2.000002p-64, false, false,
+	true,
+	0x2.000002p-64, false, false,
+	0x2.000002p-64, false, false,
+	0x2.000002p-64, false, false,
+	0x2.000002p-64, false, false,
+	true,
+	0x2.000002p-64, false, false,
+	0x2.000002p-64, false, false,
+	0x2.000002p-64, false, false,
+	0x2.000002p-64, false, false,
+	true,
+	0x2.000002p-64, false, false,
+	0x2.000002p-64, false, false,
+	0x2.000002p-64, false, false,
+	0x2.000002p-64, false, false,
+	true,
+	0x2.000002p-64, false, false,
+	0x2.000002p-64, false, false,
+	0x2.000002p-64, false, false,
+	0x2.000002p-64, false, false),
   TEST ("1.0842022371089897897127399001987457793916291848290711641311"
 	"645507812501e-19",
 	false,
-	0x2p-64, false,
-	0x2.000004p-64, false,
-	0x2p-64, false,
-	0x2.000004p-64, false,
-	false,
-	0x2.000002p-64, false,
-	0x2.000002p-64, false,
-	0x2.000002p-64, false,
-	0x2.0000020000002p-64, false,
-	false,
-	0x2.000002p-64, false,
-	0x2.000002p-64, false,
-	0x2.000002p-64, false,
-	0x2.0000020000000004p-64, false,
-	false,
-	0x2.000002p-64, false,
-	0x2.000002p-64, false,
-	0x2.000002p-64, false,
-	0x2.0000020000000004p-64, false,
-	false,
-	0x2.000002p-64, false,
-	0x2.000002p-64, false,
-	0x2.000002p-64, false,
-	0x2.00000200000000000000000001p-64, false,
-	false,
-	0x2.000002p-64, false,
-	0x2.000002p-64, false,
-	0x2.000002p-64, false,
-	0x2.0000020000000000000000000002p-64, false),
+	0x2p-64, false, false,
+	0x2.000004p-64, false, false,
+	0x2p-64, false, false,
+	0x2.000004p-64, false, false,
+	false,
+	0x2.000002p-64, false, false,
+	0x2.000002p-64, false, false,
+	0x2.000002p-64, false, false,
+	0x2.0000020000002p-64, false, false,
+	false,
+	0x2.000002p-64, false, false,
+	0x2.000002p-64, false, false,
+	0x2.000002p-64, false, false,
+	0x2.0000020000000004p-64, false, false,
+	false,
+	0x2.000002p-64, false, false,
+	0x2.000002p-64, false, false,
+	0x2.000002p-64, false, false,
+	0x2.0000020000000004p-64, false, false,
+	false,
+	0x2.000002p-64, false, false,
+	0x2.000002p-64, false, false,
+	0x2.000002p-64, false, false,
+	0x2.00000200000000000000000001p-64, false, false,
+	false,
+	0x2.000002p-64, false, false,
+	0x2.000002p-64, false, false,
+	0x2.000002p-64, false, false,
+	0x2.0000020000000000000000000002p-64, false, false),
   TEST ("1.0842023017324751454180269995275498473574771196581423282623"
 	"291015625e-19",
 	true,
-	0x2.000004p-64, false,
-	0x2.000004p-64, false,
-	0x2.000004p-64, false,
-	0x2.000004p-64, false,
-	true,
-	0x2.000004p-64, false,
-	0x2.000004p-64, false,
-	0x2.000004p-64, false,
-	0x2.000004p-64, false,
-	true,
-	0x2.000004p-64, false,
-	0x2.000004p-64, false,
-	0x2.000004p-64, false,
-	0x2.000004p-64, false,
-	true,
-	0x2.000004p-64, false,
-	0x2.000004p-64, false,
-	0x2.000004p-64, false,
-	0x2.000004p-64, false,
-	true,
-	0x2.000004p-64, false,
-	0x2.000004p-64, false,
-	0x2.000004p-64, false,
-	0x2.000004p-64, false,
-	true,
-	0x2.000004p-64, false,
-	0x2.000004p-64, false,
-	0x2.000004p-64, false,
-	0x2.000004p-64, false),
+	0x2.000004p-64, false, false,
+	0x2.000004p-64, false, false,
+	0x2.000004p-64, false, false,
+	0x2.000004p-64, false, false,
+	true,
+	0x2.000004p-64, false, false,
+	0x2.000004p-64, false, false,
+	0x2.000004p-64, false, false,
+	0x2.000004p-64, false, false,
+	true,
+	0x2.000004p-64, false, false,
+	0x2.000004p-64, false, false,
+	0x2.000004p-64, false, false,
+	0x2.000004p-64, false, false,
+	true,
+	0x2.000004p-64, false, false,
+	0x2.000004p-64, false, false,
+	0x2.000004p-64, false, false,
+	0x2.000004p-64, false, false,
+	true,
+	0x2.000004p-64, false, false,
+	0x2.000004p-64, false, false,
+	0x2.000004p-64, false, false,
+	0x2.000004p-64, false, false,
+	true,
+	0x2.000004p-64, false, false,
+	0x2.000004p-64, false, false,
+	0x2.000004p-64, false, false,
+	0x2.000004p-64, false, false),
   TEST ("1.0842023663559605011233140988563539153233250544872134923934"
 	"936523437499e-19",
 	false,
-	0x2.000004p-64, false,
-	0x2.000004p-64, false,
-	0x2.000004p-64, false,
-	0x2.000008p-64, false,
-	false,
-	0x2.000005ffffffep-64, false,
-	0x2.000006p-64, false,
-	0x2.000005ffffffep-64, false,
-	0x2.000006p-64, false,
-	false,
-	0x2.000005fffffffffcp-64, false,
-	0x2.000006p-64, false,
-	0x2.000005fffffffffcp-64, false,
-	0x2.000006p-64, false,
-	false,
-	0x2.000005fffffffffcp-64, false,
-	0x2.000006p-64, false,
-	0x2.000005fffffffffcp-64, false,
-	0x2.000006p-64, false,
-	false,
-	0x2.000005ffffffffffffffffffffp-64, false,
-	0x2.000006p-64, false,
-	0x2.000005ffffffffffffffffffffp-64, false,
-	0x2.000006p-64, false,
-	false,
-	0x2.000005fffffffffffffffffffffep-64, false,
-	0x2.000006p-64, false,
-	0x2.000005fffffffffffffffffffffep-64, false,
-	0x2.000006p-64, false),
+	0x2.000004p-64, false, false,
+	0x2.000004p-64, false, false,
+	0x2.000004p-64, false, false,
+	0x2.000008p-64, false, false,
+	false,
+	0x2.000005ffffffep-64, false, false,
+	0x2.000006p-64, false, false,
+	0x2.000005ffffffep-64, false, false,
+	0x2.000006p-64, false, false,
+	false,
+	0x2.000005fffffffffcp-64, false, false,
+	0x2.000006p-64, false, false,
+	0x2.000005fffffffffcp-64, false, false,
+	0x2.000006p-64, false, false,
+	false,
+	0x2.000005fffffffffcp-64, false, false,
+	0x2.000006p-64, false, false,
+	0x2.000005fffffffffcp-64, false, false,
+	0x2.000006p-64, false, false,
+	false,
+	0x2.000005ffffffffffffffffffffp-64, false, false,
+	0x2.000006p-64, false, false,
+	0x2.000005ffffffffffffffffffffp-64, false, false,
+	0x2.000006p-64, false, false,
+	false,
+	0x2.000005fffffffffffffffffffffep-64, false, false,
+	0x2.000006p-64, false, false,
+	0x2.000005fffffffffffffffffffffep-64, false, false,
+	0x2.000006p-64, false, false),
   TEST ("1.0842023663559605011233140988563539153233250544872134923934"
 	"9365234375e-19",
 	false,
-	0x2.000004p-64, false,
-	0x2.000008p-64, false,
-	0x2.000004p-64, false,
-	0x2.000008p-64, false,
-	true,
-	0x2.000006p-64, false,
-	0x2.000006p-64, false,
-	0x2.000006p-64, false,
-	0x2.000006p-64, false,
-	true,
-	0x2.000006p-64, false,
-	0x2.000006p-64, false,
-	0x2.000006p-64, false,
-	0x2.000006p-64, false,
-	true,
-	0x2.000006p-64, false,
-	0x2.000006p-64, false,
-	0x2.000006p-64, false,
-	0x2.000006p-64, false,
-	true,
-	0x2.000006p-64, false,
-	0x2.000006p-64, false,
-	0x2.000006p-64, false,
-	0x2.000006p-64, false,
-	true,
-	0x2.000006p-64, false,
-	0x2.000006p-64, false,
-	0x2.000006p-64, false,
-	0x2.000006p-64, false),
+	0x2.000004p-64, false, false,
+	0x2.000008p-64, false, false,
+	0x2.000004p-64, false, false,
+	0x2.000008p-64, false, false,
+	true,
+	0x2.000006p-64, false, false,
+	0x2.000006p-64, false, false,
+	0x2.000006p-64, false, false,
+	0x2.000006p-64, false, false,
+	true,
+	0x2.000006p-64, false, false,
+	0x2.000006p-64, false, false,
+	0x2.000006p-64, false, false,
+	0x2.000006p-64, false, false,
+	true,
+	0x2.000006p-64, false, false,
+	0x2.000006p-64, false, false,
+	0x2.000006p-64, false, false,
+	0x2.000006p-64, false, false,
+	true,
+	0x2.000006p-64, false, false,
+	0x2.000006p-64, false, false,
+	0x2.000006p-64, false, false,
+	0x2.000006p-64, false, false,
+	true,
+	0x2.000006p-64, false, false,
+	0x2.000006p-64, false, false,
+	0x2.000006p-64, false, false,
+	0x2.000006p-64, false, false),
   TEST ("1.0842023663559605011233140988563539153233250544872134923934"
 	"936523437501e-19",
 	false,
-	0x2.000004p-64, false,
-	0x2.000008p-64, false,
-	0x2.000004p-64, false,
-	0x2.000008p-64, false,
-	false,
-	0x2.000006p-64, false,
-	0x2.000006p-64, false,
-	0x2.000006p-64, false,
-	0x2.0000060000002p-64, false,
-	false,
-	0x2.000006p-64, false,
-	0x2.000006p-64, false,
-	0x2.000006p-64, false,
-	0x2.0000060000000004p-64, false,
-	false,
-	0x2.000006p-64, false,
-	0x2.000006p-64, false,
-	0x2.000006p-64, false,
-	0x2.0000060000000004p-64, false,
-	false,
-	0x2.000006p-64, false,
-	0x2.000006p-64, false,
-	0x2.000006p-64, false,
-	0x2.00000600000000000000000001p-64, false,
-	false,
-	0x2.000006p-64, false,
-	0x2.000006p-64, false,
-	0x2.000006p-64, false,
-	0x2.0000060000000000000000000002p-64, false),
+	0x2.000004p-64, false, false,
+	0x2.000008p-64, false, false,
+	0x2.000004p-64, false, false,
+	0x2.000008p-64, false, false,
+	false,
+	0x2.000006p-64, false, false,
+	0x2.000006p-64, false, false,
+	0x2.000006p-64, false, false,
+	0x2.0000060000002p-64, false, false,
+	false,
+	0x2.000006p-64, false, false,
+	0x2.000006p-64, false, false,
+	0x2.000006p-64, false, false,
+	0x2.0000060000000004p-64, false, false,
+	false,
+	0x2.000006p-64, false, false,
+	0x2.000006p-64, false, false,
+	0x2.000006p-64, false, false,
+	0x2.0000060000000004p-64, false, false,
+	false,
+	0x2.000006p-64, false, false,
+	0x2.000006p-64, false, false,
+	0x2.000006p-64, false, false,
+	0x2.00000600000000000000000001p-64, false, false,
+	false,
+	0x2.000006p-64, false, false,
+	0x2.000006p-64, false, false,
+	0x2.000006p-64, false, false,
+	0x2.0000060000000000000000000002p-64, false, false),
   TEST ("1.0842024309794458568286011981851579832891729893162846565246"
 	"58203125e-19",
 	true,
-	0x2.000008p-64, false,
-	0x2.000008p-64, false,
-	0x2.000008p-64, false,
-	0x2.000008p-64, false,
-	true,
-	0x2.000008p-64, false,
-	0x2.000008p-64, false,
-	0x2.000008p-64, false,
-	0x2.000008p-64, false,
-	true,
-	0x2.000008p-64, false,
-	0x2.000008p-64, false,
-	0x2.000008p-64, false,
-	0x2.000008p-64, false,
-	true,
-	0x2.000008p-64, false,
-	0x2.000008p-64, false,
-	0x2.000008p-64, false,
-	0x2.000008p-64, false,
-	true,
-	0x2.000008p-64, false,
-	0x2.000008p-64, false,
-	0x2.000008p-64, false,
-	0x2.000008p-64, false,
-	true,
-	0x2.000008p-64, false,
-	0x2.000008p-64, false,
-	0x2.000008p-64, false,
-	0x2.000008p-64, false),
+	0x2.000008p-64, false, false,
+	0x2.000008p-64, false, false,
+	0x2.000008p-64, false, false,
+	0x2.000008p-64, false, false,
+	true,
+	0x2.000008p-64, false, false,
+	0x2.000008p-64, false, false,
+	0x2.000008p-64, false, false,
+	0x2.000008p-64, false, false,
+	true,
+	0x2.000008p-64, false, false,
+	0x2.000008p-64, false, false,
+	0x2.000008p-64, false, false,
+	0x2.000008p-64, false, false,
+	true,
+	0x2.000008p-64, false, false,
+	0x2.000008p-64, false, false,
+	0x2.000008p-64, false, false,
+	0x2.000008p-64, false, false,
+	true,
+	0x2.000008p-64, false, false,
+	0x2.000008p-64, false, false,
+	0x2.000008p-64, false, false,
+	0x2.000008p-64, false, false,
+	true,
+	0x2.000008p-64, false, false,
+	0x2.000008p-64, false, false,
+	0x2.000008p-64, false, false,
+	0x2.000008p-64, false, false),
   TEST ("7.5231638452626400509999138382223723380394595633413601376560"
 	"1092018187046051025390625e-37",
 	true,
-	0x1p-120, false,
-	0x1p-120, false,
-	0x1p-120, false,
-	0x1p-120, false,
-	true,
-	0x1p-120, false,
-	0x1p-120, false,
-	0x1p-120, false,
-	0x1p-120, false,
-	true,
-	0x1p-120, false,
-	0x1p-120, false,
-	0x1p-120, false,
-	0x1p-120, false,
-	true,
-	0x1p-120, false,
-	0x1p-120, false,
-	0x1p-120, false,
-	0x1p-120, false,
-	true,
-	0x1p-120, false,
-	0x1p-120, false,
-	0x1p-120, false,
-	0x1p-120, false,
-	true,
-	0x1p-120, false,
-	0x1p-120, false,
-	0x1p-120, false,
-	0x1p-120, false),
+	0x1p-120, false, false,
+	0x1p-120, false, false,
+	0x1p-120, false, false,
+	0x1p-120, false, false,
+	true,
+	0x1p-120, false, false,
+	0x1p-120, false, false,
+	0x1p-120, false, false,
+	0x1p-120, false, false,
+	true,
+	0x1p-120, false, false,
+	0x1p-120, false, false,
+	0x1p-120, false, false,
+	0x1p-120, false, false,
+	true,
+	0x1p-120, false, false,
+	0x1p-120, false, false,
+	0x1p-120, false, false,
+	0x1p-120, false, false,
+	true,
+	0x1p-120, false, false,
+	0x1p-120, false, false,
+	0x1p-120, false, false,
+	0x1p-120, false, false,
+	true,
+	0x1p-120, false, false,
+	0x1p-120, false, false,
+	0x1p-120, false, false,
+	0x1p-120, false, false),
   TEST ("7.5231642936781486349413765338158389908126215730251815381410"
 	"578824437213052434003657253924757242202758789062499e-37",
 	false,
-	0x1p-120, false,
-	0x1p-120, false,
-	0x1p-120, false,
-	0x1.000002p-120, false,
-	false,
-	0x1.000000fffffffp-120, false,
-	0x1.000001p-120, false,
-	0x1.000000fffffffp-120, false,
-	0x1.000001p-120, false,
-	false,
-	0x1.000000fffffffffep-120, false,
-	0x1.000001p-120, false,
-	0x1.000000fffffffffep-120, false,
-	0x1.000001p-120, false,
-	false,
-	0x1.000000fffffffffep-120, false,
-	0x1.000001p-120, false,
-	0x1.000000fffffffffep-120, false,
-	0x1.000001p-120, false,
-	false,
-	0x1.000000ffffffffffffffffffff8p-120, false,
-	0x1.000001p-120, false,
-	0x1.000000ffffffffffffffffffff8p-120, false,
-	0x1.000001p-120, false,
-	false,
-	0x1.000000ffffffffffffffffffffffp-120, false,
-	0x1.000001p-120, false,
-	0x1.000000ffffffffffffffffffffffp-120, false,
-	0x1.000001p-120, false),
+	0x1p-120, false, false,
+	0x1p-120, false, false,
+	0x1p-120, false, false,
+	0x1.000002p-120, false, false,
+	false,
+	0x1.000000fffffffp-120, false, false,
+	0x1.000001p-120, false, false,
+	0x1.000000fffffffp-120, false, false,
+	0x1.000001p-120, false, false,
+	false,
+	0x1.000000fffffffffep-120, false, false,
+	0x1.000001p-120, false, false,
+	0x1.000000fffffffffep-120, false, false,
+	0x1.000001p-120, false, false,
+	false,
+	0x1.000000fffffffffep-120, false, false,
+	0x1.000001p-120, false, false,
+	0x1.000000fffffffffep-120, false, false,
+	0x1.000001p-120, false, false,
+	false,
+	0x1.000000ffffffffffffffffffff8p-120, false, false,
+	0x1.000001p-120, false, false,
+	0x1.000000ffffffffffffffffffff8p-120, false, false,
+	0x1.000001p-120, false, false,
+	false,
+	0x1.000000ffffffffffffffffffffffp-120, false, false,
+	0x1.000001p-120, false, false,
+	0x1.000000ffffffffffffffffffffffp-120, false, false,
+	0x1.000001p-120, false, false),
   TEST ("7.5231642936781486349413765338158389908126215730251815381410"
 	"5788244372130524340036572539247572422027587890625e-37",
 	false,
-	0x1p-120, false,
-	0x1p-120, false,
-	0x1p-120, false,
-	0x1.000002p-120, false,
-	true,
-	0x1.000001p-120, false,
-	0x1.000001p-120, false,
-	0x1.000001p-120, false,
-	0x1.000001p-120, false,
-	true,
-	0x1.000001p-120, false,
-	0x1.000001p-120, false,
-	0x1.000001p-120, false,
-	0x1.000001p-120, false,
-	true,
-	0x1.000001p-120, false,
-	0x1.000001p-120, false,
-	0x1.000001p-120, false,
-	0x1.000001p-120, false,
-	true,
-	0x1.000001p-120, false,
-	0x1.000001p-120, false,
-	0x1.000001p-120, false,
-	0x1.000001p-120, false,
-	true,
-	0x1.000001p-120, false,
-	0x1.000001p-120, false,
-	0x1.000001p-120, false,
-	0x1.000001p-120, false),
+	0x1p-120, false, false,
+	0x1p-120, false, false,
+	0x1p-120, false, false,
+	0x1.000002p-120, false, false,
+	true,
+	0x1.000001p-120, false, false,
+	0x1.000001p-120, false, false,
+	0x1.000001p-120, false, false,
+	0x1.000001p-120, false, false,
+	true,
+	0x1.000001p-120, false, false,
+	0x1.000001p-120, false, false,
+	0x1.000001p-120, false, false,
+	0x1.000001p-120, false, false,
+	true,
+	0x1.000001p-120, false, false,
+	0x1.000001p-120, false, false,
+	0x1.000001p-120, false, false,
+	0x1.000001p-120, false, false,
+	true,
+	0x1.000001p-120, false, false,
+	0x1.000001p-120, false, false,
+	0x1.000001p-120, false, false,
+	0x1.000001p-120, false, false,
+	true,
+	0x1.000001p-120, false, false,
+	0x1.000001p-120, false, false,
+	0x1.000001p-120, false, false,
+	0x1.000001p-120, false, false),
   TEST ("7.5231642936781486349413765338158389908126215730251815381410"
 	"578824437213052434003657253924757242202758789062501e-37",
 	false,
-	0x1p-120, false,
-	0x1.000002p-120, false,
-	0x1p-120, false,
-	0x1.000002p-120, false,
-	false,
-	0x1.000001p-120, false,
-	0x1.000001p-120, false,
-	0x1.000001p-120, false,
-	0x1.0000010000001p-120, false,
-	false,
-	0x1.000001p-120, false,
-	0x1.000001p-120, false,
-	0x1.000001p-120, false,
-	0x1.0000010000000002p-120, false,
-	false,
-	0x1.000001p-120, false,
-	0x1.000001p-120, false,
-	0x1.000001p-120, false,
-	0x1.0000010000000002p-120, false,
-	false,
-	0x1.000001p-120, false,
-	0x1.000001p-120, false,
-	0x1.000001p-120, false,
-	0x1.000001000000000000000000008p-120, false,
-	false,
-	0x1.000001p-120, false,
-	0x1.000001p-120, false,
-	0x1.000001p-120, false,
-	0x1.0000010000000000000000000001p-120, false),
+	0x1p-120, false, false,
+	0x1.000002p-120, false, false,
+	0x1p-120, false, false,
+	0x1.000002p-120, false, false,
+	false,
+	0x1.000001p-120, false, false,
+	0x1.000001p-120, false, false,
+	0x1.000001p-120, false, false,
+	0x1.0000010000001p-120, false, false,
+	false,
+	0x1.000001p-120, false, false,
+	0x1.000001p-120, false, false,
+	0x1.000001p-120, false, false,
+	0x1.0000010000000002p-120, false, false,
+	false,
+	0x1.000001p-120, false, false,
+	0x1.000001p-120, false, false,
+	0x1.000001p-120, false, false,
+	0x1.0000010000000002p-120, false, false,
+	false,
+	0x1.000001p-120, false, false,
+	0x1.000001p-120, false, false,
+	0x1.000001p-120, false, false,
+	0x1.000001000000000000000000008p-120, false, false,
+	false,
+	0x1.000001p-120, false, false,
+	0x1.000001p-120, false, false,
+	0x1.000001p-120, false, false,
+	0x1.0000010000000000000000000001p-120, false, false),
   TEST ("7.5231647420936572188828392294093056435857835827090029386261"
 	"048447055721499765468252007849514484405517578125e-37",
 	true,
-	0x1.000002p-120, false,
-	0x1.000002p-120, false,
-	0x1.000002p-120, false,
-	0x1.000002p-120, false,
-	true,
-	0x1.000002p-120, false,
-	0x1.000002p-120, false,
-	0x1.000002p-120, false,
-	0x1.000002p-120, false,
-	true,
-	0x1.000002p-120, false,
-	0x1.000002p-120, false,
-	0x1.000002p-120, false,
-	0x1.000002p-120, false,
-	true,
-	0x1.000002p-120, false,
-	0x1.000002p-120, false,
-	0x1.000002p-120, false,
-	0x1.000002p-120, false,
-	true,
-	0x1.000002p-120, false,
-	0x1.000002p-120, false,
-	0x1.000002p-120, false,
-	0x1.000002p-120, false,
-	true,
-	0x1.000002p-120, false,
-	0x1.000002p-120, false,
-	0x1.000002p-120, false,
-	0x1.000002p-120, false),
+	0x1.000002p-120, false, false,
+	0x1.000002p-120, false, false,
+	0x1.000002p-120, false, false,
+	0x1.000002p-120, false, false,
+	true,
+	0x1.000002p-120, false, false,
+	0x1.000002p-120, false, false,
+	0x1.000002p-120, false, false,
+	0x1.000002p-120, false, false,
+	true,
+	0x1.000002p-120, false, false,
+	0x1.000002p-120, false, false,
+	0x1.000002p-120, false, false,
+	0x1.000002p-120, false, false,
+	true,
+	0x1.000002p-120, false, false,
+	0x1.000002p-120, false, false,
+	0x1.000002p-120, false, false,
+	0x1.000002p-120, false, false,
+	true,
+	0x1.000002p-120, false, false,
+	0x1.000002p-120, false, false,
+	0x1.000002p-120, false, false,
+	0x1.000002p-120, false, false,
+	true,
+	0x1.000002p-120, false, false,
+	0x1.000002p-120, false, false,
+	0x1.000002p-120, false, false,
+	0x1.000002p-120, false, false),
   TEST ("7.5231651905091658028243019250027722963589455923928243391111"
 	"518069674229947096932846761774271726608276367187499e-37",
 	false,
-	0x1.000002p-120, false,
-	0x1.000002p-120, false,
-	0x1.000002p-120, false,
-	0x1.000004p-120, false,
-	false,
-	0x1.000002fffffffp-120, false,
-	0x1.000003p-120, false,
-	0x1.000002fffffffp-120, false,
-	0x1.000003p-120, false,
-	false,
-	0x1.000002fffffffffep-120, false,
-	0x1.000003p-120, false,
-	0x1.000002fffffffffep-120, false,
-	0x1.000003p-120, false,
-	false,
-	0x1.000002fffffffffep-120, false,
-	0x1.000003p-120, false,
-	0x1.000002fffffffffep-120, false,
-	0x1.000003p-120, false,
-	false,
-	0x1.000002ffffffffffffffffffff8p-120, false,
-	0x1.000003p-120, false,
-	0x1.000002ffffffffffffffffffff8p-120, false,
-	0x1.000003p-120, false,
-	false,
-	0x1.000002ffffffffffffffffffffffp-120, false,
-	0x1.000003p-120, false,
-	0x1.000002ffffffffffffffffffffffp-120, false,
-	0x1.000003p-120, false),
+	0x1.000002p-120, false, false,
+	0x1.000002p-120, false, false,
+	0x1.000002p-120, false, false,
+	0x1.000004p-120, false, false,
+	false,
+	0x1.000002fffffffp-120, false, false,
+	0x1.000003p-120, false, false,
+	0x1.000002fffffffp-120, false, false,
+	0x1.000003p-120, false, false,
+	false,
+	0x1.000002fffffffffep-120, false, false,
+	0x1.000003p-120, false, false,
+	0x1.000002fffffffffep-120, false, false,
+	0x1.000003p-120, false, false,
+	false,
+	0x1.000002fffffffffep-120, false, false,
+	0x1.000003p-120, false, false,
+	0x1.000002fffffffffep-120, false, false,
+	0x1.000003p-120, false, false,
+	false,
+	0x1.000002ffffffffffffffffffff8p-120, false, false,
+	0x1.000003p-120, false, false,
+	0x1.000002ffffffffffffffffffff8p-120, false, false,
+	0x1.000003p-120, false, false,
+	false,
+	0x1.000002ffffffffffffffffffffffp-120, false, false,
+	0x1.000003p-120, false, false,
+	0x1.000002ffffffffffffffffffffffp-120, false, false,
+	0x1.000003p-120, false, false),
   TEST ("7.5231651905091658028243019250027722963589455923928243391111"
 	"5180696742299470969328467617742717266082763671875e-37",
 	false,
-	0x1.000002p-120, false,
-	0x1.000004p-120, false,
-	0x1.000002p-120, false,
-	0x1.000004p-120, false,
-	true,
-	0x1.000003p-120, false,
-	0x1.000003p-120, false,
-	0x1.000003p-120, false,
-	0x1.000003p-120, false,
-	true,
-	0x1.000003p-120, false,
-	0x1.000003p-120, false,
-	0x1.000003p-120, false,
-	0x1.000003p-120, false,
-	true,
-	0x1.000003p-120, false,
-	0x1.000003p-120, false,
-	0x1.000003p-120, false,
-	0x1.000003p-120, false,
-	true,
-	0x1.000003p-120, false,
-	0x1.000003p-120, false,
-	0x1.000003p-120, false,
-	0x1.000003p-120, false,
-	true,
-	0x1.000003p-120, false,
-	0x1.000003p-120, false,
-	0x1.000003p-120, false,
-	0x1.000003p-120, false),
+	0x1.000002p-120, false, false,
+	0x1.000004p-120, false, false,
+	0x1.000002p-120, false, false,
+	0x1.000004p-120, false, false,
+	true,
+	0x1.000003p-120, false, false,
+	0x1.000003p-120, false, false,
+	0x1.000003p-120, false, false,
+	0x1.000003p-120, false, false,
+	true,
+	0x1.000003p-120, false, false,
+	0x1.000003p-120, false, false,
+	0x1.000003p-120, false, false,
+	0x1.000003p-120, false, false,
+	true,
+	0x1.000003p-120, false, false,
+	0x1.000003p-120, false, false,
+	0x1.000003p-120, false, false,
+	0x1.000003p-120, false, false,
+	true,
+	0x1.000003p-120, false, false,
+	0x1.000003p-120, false, false,
+	0x1.000003p-120, false, false,
+	0x1.000003p-120, false, false,
+	true,
+	0x1.000003p-120, false, false,
+	0x1.000003p-120, false, false,
+	0x1.000003p-120, false, false,
+	0x1.000003p-120, false, false),
   TEST ("7.5231651905091658028243019250027722963589455923928243391111"
 	"518069674229947096932846761774271726608276367187501e-37",
 	false,
-	0x1.000002p-120, false,
-	0x1.000004p-120, false,
-	0x1.000002p-120, false,
-	0x1.000004p-120, false,
-	false,
-	0x1.000003p-120, false,
-	0x1.000003p-120, false,
-	0x1.000003p-120, false,
-	0x1.0000030000001p-120, false,
-	false,
-	0x1.000003p-120, false,
-	0x1.000003p-120, false,
-	0x1.000003p-120, false,
-	0x1.0000030000000002p-120, false,
-	false,
-	0x1.000003p-120, false,
-	0x1.000003p-120, false,
-	0x1.000003p-120, false,
-	0x1.0000030000000002p-120, false,
-	false,
-	0x1.000003p-120, false,
-	0x1.000003p-120, false,
-	0x1.000003p-120, false,
-	0x1.000003000000000000000000008p-120, false,
-	false,
-	0x1.000003p-120, false,
-	0x1.000003p-120, false,
-	0x1.000003p-120, false,
-	0x1.0000030000000000000000000001p-120, false),
+	0x1.000002p-120, false, false,
+	0x1.000004p-120, false, false,
+	0x1.000002p-120, false, false,
+	0x1.000004p-120, false, false,
+	false,
+	0x1.000003p-120, false, false,
+	0x1.000003p-120, false, false,
+	0x1.000003p-120, false, false,
+	0x1.0000030000001p-120, false, false,
+	false,
+	0x1.000003p-120, false, false,
+	0x1.000003p-120, false, false,
+	0x1.000003p-120, false, false,
+	0x1.0000030000000002p-120, false, false,
+	false,
+	0x1.000003p-120, false, false,
+	0x1.000003p-120, false, false,
+	0x1.000003p-120, false, false,
+	0x1.0000030000000002p-120, false, false,
+	false,
+	0x1.000003p-120, false, false,
+	0x1.000003p-120, false, false,
+	0x1.000003p-120, false, false,
+	0x1.000003000000000000000000008p-120, false, false,
+	false,
+	0x1.000003p-120, false, false,
+	0x1.000003p-120, false, false,
+	0x1.000003p-120, false, false,
+	0x1.0000030000000000000000000001p-120, false, false),
   TEST ("7.5231656389246743867657646205962389491321076020766457395961"
 	"98769229273839442839744151569902896881103515625e-37",
 	true,
-	0x1.000004p-120, false,
-	0x1.000004p-120, false,
-	0x1.000004p-120, false,
-	0x1.000004p-120, false,
-	true,
-	0x1.000004p-120, false,
-	0x1.000004p-120, false,
-	0x1.000004p-120, false,
-	0x1.000004p-120, false,
-	true,
-	0x1.000004p-120, false,
-	0x1.000004p-120, false,
-	0x1.000004p-120, false,
-	0x1.000004p-120, false,
-	true,
-	0x1.000004p-120, false,
-	0x1.000004p-120, false,
-	0x1.000004p-120, false,
-	0x1.000004p-120, false,
-	true,
-	0x1.000004p-120, false,
-	0x1.000004p-120, false,
-	0x1.000004p-120, false,
-	0x1.000004p-120, false,
-	true,
-	0x1.000004p-120, false,
-	0x1.000004p-120, false,
-	0x1.000004p-120, false,
-	0x1.000004p-120, false),
+	0x1.000004p-120, false, false,
+	0x1.000004p-120, false, false,
+	0x1.000004p-120, false, false,
+	0x1.000004p-120, false, false,
+	true,
+	0x1.000004p-120, false, false,
+	0x1.000004p-120, false, false,
+	0x1.000004p-120, false, false,
+	0x1.000004p-120, false, false,
+	true,
+	0x1.000004p-120, false, false,
+	0x1.000004p-120, false, false,
+	0x1.000004p-120, false, false,
+	0x1.000004p-120, false, false,
+	true,
+	0x1.000004p-120, false, false,
+	0x1.000004p-120, false, false,
+	0x1.000004p-120, false, false,
+	0x1.000004p-120, false, false,
+	true,
+	0x1.000004p-120, false, false,
+	0x1.000004p-120, false, false,
+	0x1.000004p-120, false, false,
+	0x1.000004p-120, false, false,
+	true,
+	0x1.000004p-120, false, false,
+	0x1.000004p-120, false, false,
+	0x1.000004p-120, false, false,
+	0x1.000004p-120, false, false),
   TEST ("340282356779733661637539395458142568447.999",
 	false,
-	0xf.fffffp+124, false,
-	0xf.fffffp+124, false,
-	0xf.fffffp+124, false,
-	INF, true,
-	false,
-	0xf.fffff7ffffff8p+124, false,
-	0xf.fffff8p+124, false,
-	0xf.fffff7ffffff8p+124, false,
-	0xf.fffff8p+124, false,
-	false,
-	0xf.fffff7fffffffffp+124, false,
-	0xf.fffff8p+124, false,
-	0xf.fffff7fffffffffp+124, false,
-	0xf.fffff8p+124, false,
-	false,
-	0xf.fffff7fffffffffp+124, false,
-	0xf.fffff8p+124, false,
-	0xf.fffff7fffffffffp+124, false,
-	0xf.fffff8p+124, false,
-	false,
-	0xf.fffff7fffffffffffffffffffcp+124, false,
-	0xf.fffff8p+124, false,
-	0xf.fffff7fffffffffffffffffffcp+124, false,
-	0xf.fffff8p+124, false,
-	false,
-	0xf.fffff7fffffffffffffffffffff8p+124, false,
-	0xf.fffff8p+124, false,
-	0xf.fffff7fffffffffffffffffffff8p+124, false,
-	0xf.fffff8p+124, false),
+	0xf.fffffp+124, false, false,
+	0xf.fffffp+124, false, false,
+	0xf.fffffp+124, false, false,
+	INF, true, false,
+	false,
+	0xf.fffff7ffffff8p+124, false, false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff7ffffff8p+124, false, false,
+	0xf.fffff8p+124, false, false,
+	false,
+	0xf.fffff7fffffffffp+124, false, false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff7fffffffffp+124, false, false,
+	0xf.fffff8p+124, false, false,
+	false,
+	0xf.fffff7fffffffffp+124, false, false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff7fffffffffp+124, false, false,
+	0xf.fffff8p+124, false, false,
+	false,
+	0xf.fffff7fffffffffffffffffffcp+124, false, false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff7fffffffffffffffffffcp+124, false, false,
+	0xf.fffff8p+124, false, false,
+	false,
+	0xf.fffff7fffffffffffffffffffff8p+124, false, false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff7fffffffffffffffffffff8p+124, false, false,
+	0xf.fffff8p+124, false, false),
   TEST ("340282356779733661637539395458142568448",
 	false,
-	0xf.fffffp+124, false,
-	INF, true,
-	0xf.fffffp+124, false,
-	INF, true,
-	true,
-	0xf.fffff8p+124, false,
-	0xf.fffff8p+124, false,
-	0xf.fffff8p+124, false,
-	0xf.fffff8p+124, false,
-	true,
-	0xf.fffff8p+124, false,
-	0xf.fffff8p+124, false,
-	0xf.fffff8p+124, false,
-	0xf.fffff8p+124, false,
-	true,
-	0xf.fffff8p+124, false,
-	0xf.fffff8p+124, false,
-	0xf.fffff8p+124, false,
-	0xf.fffff8p+124, false,
-	true,
-	0xf.fffff8p+124, false,
-	0xf.fffff8p+124, false,
-	0xf.fffff8p+124, false,
-	0xf.fffff8p+124, false,
-	true,
-	0xf.fffff8p+124, false,
-	0xf.fffff8p+124, false,
-	0xf.fffff8p+124, false,
-	0xf.fffff8p+124, false),
+	0xf.fffffp+124, false, false,
+	INF, true, false,
+	0xf.fffffp+124, false, false,
+	INF, true, false,
+	true,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff8p+124, false, false,
+	true,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff8p+124, false, false,
+	true,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff8p+124, false, false,
+	true,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff8p+124, false, false,
+	true,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff8p+124, false, false),
   TEST ("340282356779733661637539395458142568448.001",
 	false,
-	0xf.fffffp+124, false,
-	INF, true,
-	0xf.fffffp+124, false,
-	INF, true,
-	false,
-	0xf.fffff8p+124, false,
-	0xf.fffff8p+124, false,
-	0xf.fffff8p+124, false,
-	0xf.fffff80000008p+124, false,
-	false,
-	0xf.fffff8p+124, false,
-	0xf.fffff8p+124, false,
-	0xf.fffff8p+124, false,
-	0xf.fffff8000000001p+124, false,
-	false,
-	0xf.fffff8p+124, false,
-	0xf.fffff8p+124, false,
-	0xf.fffff8p+124, false,
-	0xf.fffff8000000001p+124, false,
-	false,
-	0xf.fffff8p+124, false,
-	0xf.fffff8p+124, false,
-	0xf.fffff8p+124, false,
-	0xf.fffff800000000000000000004p+124, false,
-	false,
-	0xf.fffff8p+124, false,
-	0xf.fffff8p+124, false,
-	0xf.fffff8p+124, false,
-	0xf.fffff80000000000000000000008p+124, false),
+	0xf.fffffp+124, false, false,
+	INF, true, false,
+	0xf.fffffp+124, false, false,
+	INF, true, false,
+	false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff80000008p+124, false, false,
+	false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff8000000001p+124, false, false,
+	false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff8000000001p+124, false, false,
+	false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff800000000000000000004p+124, false, false,
+	false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff8p+124, false, false,
+	0xf.fffff80000000000000000000008p+124, false, false),
   TEST ("-340282356779733661637539395458142568447.999",
 	false,
-	-INF, true,
-	-0xf.fffffp+124, false,
-	-0xf.fffffp+124, false,
-	-0xf.fffffp+124, false,
-	false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff7ffffff8p+124, false,
-	-0xf.fffff7ffffff8p+124, false,
-	false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff7fffffffffp+124, false,
-	-0xf.fffff7fffffffffp+124, false,
-	false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff7fffffffffp+124, false,
-	-0xf.fffff7fffffffffp+124, false,
-	false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff7fffffffffffffffffffcp+124, false,
-	-0xf.fffff7fffffffffffffffffffcp+124, false,
-	false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff7fffffffffffffffffffff8p+124, false,
-	-0xf.fffff7fffffffffffffffffffff8p+124, false),
+	-INF, true, false,
+	-0xf.fffffp+124, false, false,
+	-0xf.fffffp+124, false, false,
+	-0xf.fffffp+124, false, false,
+	false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff7ffffff8p+124, false, false,
+	-0xf.fffff7ffffff8p+124, false, false,
+	false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff7fffffffffp+124, false, false,
+	-0xf.fffff7fffffffffp+124, false, false,
+	false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff7fffffffffp+124, false, false,
+	-0xf.fffff7fffffffffp+124, false, false,
+	false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff7fffffffffffffffffffcp+124, false, false,
+	-0xf.fffff7fffffffffffffffffffcp+124, false, false,
+	false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff7fffffffffffffffffffff8p+124, false, false,
+	-0xf.fffff7fffffffffffffffffffff8p+124, false, false),
   TEST ("-340282356779733661637539395458142568448",
 	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffp+124, false,
-	-0xf.fffffp+124, false,
-	true,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false,
-	true,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false,
-	true,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false,
-	true,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false,
-	true,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false),
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffp+124, false, false,
+	-0xf.fffffp+124, false, false,
+	true,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	true,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	true,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	true,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	true,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false),
   TEST ("-340282356779733661637539395458142568448.001",
 	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffp+124, false,
-	-0xf.fffffp+124, false,
-	false,
-	-0xf.fffff80000008p+124, false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false,
-	false,
-	-0xf.fffff8000000001p+124, false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false,
-	false,
-	-0xf.fffff8000000001p+124, false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false,
-	false,
-	-0xf.fffff800000000000000000004p+124, false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false,
-	false,
-	-0xf.fffff80000000000000000000008p+124, false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false,
-	-0xf.fffff8p+124, false),
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffp+124, false, false,
+	-0xf.fffffp+124, false, false,
+	false,
+	-0xf.fffff80000008p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	false,
+	-0xf.fffff8000000001p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	false,
+	-0xf.fffff8000000001p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	false,
+	-0xf.fffff800000000000000000004p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	false,
+	-0xf.fffff80000000000000000000008p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false,
+	-0xf.fffff8p+124, false, false),
   TEST ("179769313486231580793728971405303415079934132710037826936173"
 	"778980444968292764750946649017977587207096330286416692887910"
 	"946555547851940402630657488671505820681908902000708383676273"
@@ -1855,35 +1855,35 @@ static const struct test tests[] = {
 	"936475292719074168444365510704342711559699508093042880177904"
 	"174497791.999",
 	false,
-	0xf.fffffp+124, true,
-	INF, true,
-	0xf.fffffp+124, true,
-	INF, true,
-	false,
-	0xf.ffffffffffff8p+1020, false,
-	0xf.ffffffffffff8p+1020, false,
-	0xf.ffffffffffff8p+1020, false,
-	INF, true,
-	false,
-	0xf.ffffffffffffbffp+1020, false,
-	0xf.ffffffffffffcp+1020, false,
-	0xf.ffffffffffffbffp+1020, false,
-	0xf.ffffffffffffcp+1020, false,
-	false,
-	0xf.ffffffffffffbffp+1020, false,
-	0xf.ffffffffffffcp+1020, false,
-	0xf.ffffffffffffbffp+1020, false,
-	0xf.ffffffffffffcp+1020, false,
-	false,
-	0xf.ffffffffffffbffffffffffffcp+1020, false,
-	0xf.ffffffffffffcp+1020, true,
-	0xf.ffffffffffffbffffffffffffcp+1020, false,
-	0xf.ffffffffffffcp+1020, true,
-	false,
-	0xf.ffffffffffffbffffffffffffff8p+1020, false,
-	0xf.ffffffffffffcp+1020, false,
-	0xf.ffffffffffffbffffffffffffff8p+1020, false,
-	0xf.ffffffffffffcp+1020, false),
+	0xf.fffffp+124, true, false,
+	INF, true, false,
+	0xf.fffffp+124, true, false,
+	INF, true, false,
+	false,
+	0xf.ffffffffffff8p+1020, false, false,
+	0xf.ffffffffffff8p+1020, false, false,
+	0xf.ffffffffffff8p+1020, false, false,
+	INF, true, false,
+	false,
+	0xf.ffffffffffffbffp+1020, false, false,
+	0xf.ffffffffffffcp+1020, false, false,
+	0xf.ffffffffffffbffp+1020, false, false,
+	0xf.ffffffffffffcp+1020, false, false,
+	false,
+	0xf.ffffffffffffbffp+1020, false, false,
+	0xf.ffffffffffffcp+1020, false, false,
+	0xf.ffffffffffffbffp+1020, false, false,
+	0xf.ffffffffffffcp+1020, false, false,
+	false,
+	0xf.ffffffffffffbffffffffffffcp+1020, false, false,
+	0xf.ffffffffffffcp+1020, true, false,
+	0xf.ffffffffffffbffffffffffffcp+1020, false, false,
+	0xf.ffffffffffffcp+1020, true, false,
+	false,
+	0xf.ffffffffffffbffffffffffffff8p+1020, false, false,
+	0xf.ffffffffffffcp+1020, false, false,
+	0xf.ffffffffffffbffffffffffffff8p+1020, false, false,
+	0xf.ffffffffffffcp+1020, false, false),
   TEST ("179769313486231580793728971405303415079934132710037826936173"
 	"778980444968292764750946649017977587207096330286416692887910"
 	"946555547851940402630657488671505820681908902000708383676273"
@@ -1891,35 +1891,35 @@ static const struct test tests[] = {
 	"936475292719074168444365510704342711559699508093042880177904"
 	"174497792",
 	false,
-	0xf.fffffp+124, true,
-	INF, true,
-	0xf.fffffp+124, true,
-	INF, true,
-	false,
-	0xf.ffffffffffff8p+1020, false,
-	INF, true,
-	0xf.ffffffffffff8p+1020, false,
-	INF, true,
-	true,
-	0xf.ffffffffffffcp+1020, false,
-	0xf.ffffffffffffcp+1020, false,
-	0xf.ffffffffffffcp+1020, false,
-	0xf.ffffffffffffcp+1020, false,
-	true,
-	0xf.ffffffffffffcp+1020, false,
-	0xf.ffffffffffffcp+1020, false,
-	0xf.ffffffffffffcp+1020, false,
-	0xf.ffffffffffffcp+1020, false,
-	false,
-	0xf.ffffffffffffcp+1020, true,
-	0xf.ffffffffffffcp+1020, true,
-	0xf.ffffffffffffcp+1020, true,
-	0xf.ffffffffffffcp+1020, true,
-	true,
-	0xf.ffffffffffffcp+1020, false,
-	0xf.ffffffffffffcp+1020, false,
-	0xf.ffffffffffffcp+1020, false,
-	0xf.ffffffffffffcp+1020, false),
+	0xf.fffffp+124, true, false,
+	INF, true, false,
+	0xf.fffffp+124, true, false,
+	INF, true, false,
+	false,
+	0xf.ffffffffffff8p+1020, false, false,
+	INF, true, false,
+	0xf.ffffffffffff8p+1020, false, false,
+	INF, true, false,
+	true,
+	0xf.ffffffffffffcp+1020, false, false,
+	0xf.ffffffffffffcp+1020, false, false,
+	0xf.ffffffffffffcp+1020, false, false,
+	0xf.ffffffffffffcp+1020, false, false,
+	true,
+	0xf.ffffffffffffcp+1020, false, false,
+	0xf.ffffffffffffcp+1020, false, false,
+	0xf.ffffffffffffcp+1020, false, false,
+	0xf.ffffffffffffcp+1020, false, false,
+	false,
+	0xf.ffffffffffffcp+1020, true, false,
+	0xf.ffffffffffffcp+1020, true, false,
+	0xf.ffffffffffffcp+1020, true, false,
+	0xf.ffffffffffffcp+1020, true, false,
+	true,
+	0xf.ffffffffffffcp+1020, false, false,
+	0xf.ffffffffffffcp+1020, false, false,
+	0xf.ffffffffffffcp+1020, false, false,
+	0xf.ffffffffffffcp+1020, false, false),
   TEST ("179769313486231580793728971405303415079934132710037826936173"
 	"778980444968292764750946649017977587207096330286416692887910"
 	"946555547851940402630657488671505820681908902000708383676273"
@@ -1927,35 +1927,35 @@ static const struct test tests[] = {
 	"936475292719074168444365510704342711559699508093042880177904"
 	"174497792.001",
 	false,
-	0xf.fffffp+124, true,
-	INF, true,
-	0xf.fffffp+124, true,
-	INF, true,
-	false,
-	0xf.ffffffffffff8p+1020, false,
-	INF, true,
-	0xf.ffffffffffff8p+1020, false,
-	INF, true,
-	false,
-	0xf.ffffffffffffcp+1020, false,
-	0xf.ffffffffffffcp+1020, false,
-	0xf.ffffffffffffcp+1020, false,
-	0xf.ffffffffffffc01p+1020, false,
-	false,
-	0xf.ffffffffffffcp+1020, false,
-	0xf.ffffffffffffcp+1020, false,
-	0xf.ffffffffffffcp+1020, false,
-	0xf.ffffffffffffc01p+1020, false,
-	false,
-	0xf.ffffffffffffcp+1020, true,
-	0xf.ffffffffffffcp+1020, true,
-	0xf.ffffffffffffcp+1020, true,
-	0xf.ffffffffffffc0000000000004p+1020, true,
-	false,
-	0xf.ffffffffffffcp+1020, false,
-	0xf.ffffffffffffcp+1020, false,
-	0xf.ffffffffffffcp+1020, false,
-	0xf.ffffffffffffc000000000000008p+1020, false),
+	0xf.fffffp+124, true, false,
+	INF, true, false,
+	0xf.fffffp+124, true, false,
+	INF, true, false,
+	false,
+	0xf.ffffffffffff8p+1020, false, false,
+	INF, true, false,
+	0xf.ffffffffffff8p+1020, false, false,
+	INF, true, false,
+	false,
+	0xf.ffffffffffffcp+1020, false, false,
+	0xf.ffffffffffffcp+1020, false, false,
+	0xf.ffffffffffffcp+1020, false, false,
+	0xf.ffffffffffffc01p+1020, false, false,
+	false,
+	0xf.ffffffffffffcp+1020, false, false,
+	0xf.ffffffffffffcp+1020, false, false,
+	0xf.ffffffffffffcp+1020, false, false,
+	0xf.ffffffffffffc01p+1020, false, false,
+	false,
+	0xf.ffffffffffffcp+1020, true, false,
+	0xf.ffffffffffffcp+1020, true, false,
+	0xf.ffffffffffffcp+1020, true, false,
+	0xf.ffffffffffffc0000000000004p+1020, true, false,
+	false,
+	0xf.ffffffffffffcp+1020, false, false,
+	0xf.ffffffffffffcp+1020, false, false,
+	0xf.ffffffffffffcp+1020, false, false,
+	0xf.ffffffffffffc000000000000008p+1020, false, false),
   TEST ("-17976931348623158079372897140530341507993413271003782693617"
 	"377898044496829276475094664901797758720709633028641669288791"
 	"094655554785194040263065748867150582068190890200070838367627"
@@ -1963,35 +1963,35 @@ static const struct test tests[] = {
 	"493647529271907416844436551070434271155969950809304288017790"
 	"4174497791.999",
 	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffp+124, true,
-	-0xf.fffffp+124, true,
-	false,
-	-INF, true,
-	-0xf.ffffffffffff8p+1020, false,
-	-0xf.ffffffffffff8p+1020, false,
-	-0xf.ffffffffffff8p+1020, false,
-	false,
-	-0xf.ffffffffffffcp+1020, false,
-	-0xf.ffffffffffffcp+1020, false,
-	-0xf.ffffffffffffbffp+1020, false,
-	-0xf.ffffffffffffbffp+1020, false,
-	false,
-	-0xf.ffffffffffffcp+1020, false,
-	-0xf.ffffffffffffcp+1020, false,
-	-0xf.ffffffffffffbffp+1020, false,
-	-0xf.ffffffffffffbffp+1020, false,
-	false,
-	-0xf.ffffffffffffcp+1020, true,
-	-0xf.ffffffffffffcp+1020, true,
-	-0xf.ffffffffffffbffffffffffffcp+1020, false,
-	-0xf.ffffffffffffbffffffffffffcp+1020, false,
-	false,
-	-0xf.ffffffffffffcp+1020, false,
-	-0xf.ffffffffffffcp+1020, false,
-	-0xf.ffffffffffffbffffffffffffff8p+1020, false,
-	-0xf.ffffffffffffbffffffffffffff8p+1020, false),
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffp+124, true, false,
+	-0xf.fffffp+124, true, false,
+	false,
+	-INF, true, false,
+	-0xf.ffffffffffff8p+1020, false, false,
+	-0xf.ffffffffffff8p+1020, false, false,
+	-0xf.ffffffffffff8p+1020, false, false,
+	false,
+	-0xf.ffffffffffffcp+1020, false, false,
+	-0xf.ffffffffffffcp+1020, false, false,
+	-0xf.ffffffffffffbffp+1020, false, false,
+	-0xf.ffffffffffffbffp+1020, false, false,
+	false,
+	-0xf.ffffffffffffcp+1020, false, false,
+	-0xf.ffffffffffffcp+1020, false, false,
+	-0xf.ffffffffffffbffp+1020, false, false,
+	-0xf.ffffffffffffbffp+1020, false, false,
+	false,
+	-0xf.ffffffffffffcp+1020, true, false,
+	-0xf.ffffffffffffcp+1020, true, false,
+	-0xf.ffffffffffffbffffffffffffcp+1020, false, false,
+	-0xf.ffffffffffffbffffffffffffcp+1020, false, false,
+	false,
+	-0xf.ffffffffffffcp+1020, false, false,
+	-0xf.ffffffffffffcp+1020, false, false,
+	-0xf.ffffffffffffbffffffffffffff8p+1020, false, false,
+	-0xf.ffffffffffffbffffffffffffff8p+1020, false, false),
   TEST ("-17976931348623158079372897140530341507993413271003782693617"
 	"377898044496829276475094664901797758720709633028641669288791"
 	"094655554785194040263065748867150582068190890200070838367627"
@@ -1999,35 +1999,35 @@ static const struct test tests[] = {
 	"493647529271907416844436551070434271155969950809304288017790"
 	"4174497792",
 	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffp+124, true,
-	-0xf.fffffp+124, true,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.ffffffffffff8p+1020, false,
-	-0xf.ffffffffffff8p+1020, false,
-	true,
-	-0xf.ffffffffffffcp+1020, false,
-	-0xf.ffffffffffffcp+1020, false,
-	-0xf.ffffffffffffcp+1020, false,
-	-0xf.ffffffffffffcp+1020, false,
-	true,
-	-0xf.ffffffffffffcp+1020, false,
-	-0xf.ffffffffffffcp+1020, false,
-	-0xf.ffffffffffffcp+1020, false,
-	-0xf.ffffffffffffcp+1020, false,
-	false,
-	-0xf.ffffffffffffcp+1020, true,
-	-0xf.ffffffffffffcp+1020, true,
-	-0xf.ffffffffffffcp+1020, true,
-	-0xf.ffffffffffffcp+1020, true,
-	true,
-	-0xf.ffffffffffffcp+1020, false,
-	-0xf.ffffffffffffcp+1020, false,
-	-0xf.ffffffffffffcp+1020, false,
-	-0xf.ffffffffffffcp+1020, false),
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffp+124, true, false,
+	-0xf.fffffp+124, true, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.ffffffffffff8p+1020, false, false,
+	-0xf.ffffffffffff8p+1020, false, false,
+	true,
+	-0xf.ffffffffffffcp+1020, false, false,
+	-0xf.ffffffffffffcp+1020, false, false,
+	-0xf.ffffffffffffcp+1020, false, false,
+	-0xf.ffffffffffffcp+1020, false, false,
+	true,
+	-0xf.ffffffffffffcp+1020, false, false,
+	-0xf.ffffffffffffcp+1020, false, false,
+	-0xf.ffffffffffffcp+1020, false, false,
+	-0xf.ffffffffffffcp+1020, false, false,
+	false,
+	-0xf.ffffffffffffcp+1020, true, false,
+	-0xf.ffffffffffffcp+1020, true, false,
+	-0xf.ffffffffffffcp+1020, true, false,
+	-0xf.ffffffffffffcp+1020, true, false,
+	true,
+	-0xf.ffffffffffffcp+1020, false, false,
+	-0xf.ffffffffffffcp+1020, false, false,
+	-0xf.ffffffffffffcp+1020, false, false,
+	-0xf.ffffffffffffcp+1020, false, false),
   TEST ("-17976931348623158079372897140530341507993413271003782693617"
 	"377898044496829276475094664901797758720709633028641669288791"
 	"094655554785194040263065748867150582068190890200070838367627"
@@ -2035,35 +2035,35 @@ static const struct test tests[] = {
 	"493647529271907416844436551070434271155969950809304288017790"
 	"4174497792.001",
 	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffp+124, true,
-	-0xf.fffffp+124, true,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.ffffffffffff8p+1020, false,
-	-0xf.ffffffffffff8p+1020, false,
-	false,
-	-0xf.ffffffffffffc01p+1020, false,
-	-0xf.ffffffffffffcp+1020, false,
-	-0xf.ffffffffffffcp+1020, false,
-	-0xf.ffffffffffffcp+1020, false,
-	false,
-	-0xf.ffffffffffffc01p+1020, false,
-	-0xf.ffffffffffffcp+1020, false,
-	-0xf.ffffffffffffcp+1020, false,
-	-0xf.ffffffffffffcp+1020, false,
-	false,
-	-0xf.ffffffffffffc0000000000004p+1020, true,
-	-0xf.ffffffffffffcp+1020, true,
-	-0xf.ffffffffffffcp+1020, true,
-	-0xf.ffffffffffffcp+1020, true,
-	false,
-	-0xf.ffffffffffffc000000000000008p+1020, false,
-	-0xf.ffffffffffffcp+1020, false,
-	-0xf.ffffffffffffcp+1020, false,
-	-0xf.ffffffffffffcp+1020, false),
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffp+124, true, false,
+	-0xf.fffffp+124, true, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.ffffffffffff8p+1020, false, false,
+	-0xf.ffffffffffff8p+1020, false, false,
+	false,
+	-0xf.ffffffffffffc01p+1020, false, false,
+	-0xf.ffffffffffffcp+1020, false, false,
+	-0xf.ffffffffffffcp+1020, false, false,
+	-0xf.ffffffffffffcp+1020, false, false,
+	false,
+	-0xf.ffffffffffffc01p+1020, false, false,
+	-0xf.ffffffffffffcp+1020, false, false,
+	-0xf.ffffffffffffcp+1020, false, false,
+	-0xf.ffffffffffffcp+1020, false, false,
+	false,
+	-0xf.ffffffffffffc0000000000004p+1020, true, false,
+	-0xf.ffffffffffffcp+1020, true, false,
+	-0xf.ffffffffffffcp+1020, true, false,
+	-0xf.ffffffffffffcp+1020, true, false,
+	false,
+	-0xf.ffffffffffffc000000000000008p+1020, false, false,
+	-0xf.ffffffffffffcp+1020, false, false,
+	-0xf.ffffffffffffcp+1020, false, false,
+	-0xf.ffffffffffffcp+1020, false, false),
   TEST ("118973149535723176505351158982948866796625400469556721895649"
 	"927756249918185172720476044944290457046138433056764616744328"
 	"666255526748948793023632513609765434237723241753648908036202"
@@ -2148,35 +2148,35 @@ static const struct test tests[] = {
 	"578031503869424406179027994752890226443351619365453243328968"
 	"8740976918527.999",
 	false,
-	0xf.fffffp+124, true,
-	INF, true,
-	0xf.fffffp+124, true,
-	INF, true,
-	false,
-	0xf.ffffffffffff8p+1020, true,
-	INF, true,
-	0xf.ffffffffffff8p+1020, true,
-	INF, true,
-	false,
-	0xf.fffffffffffffffp+16380, false,
-	0xf.fffffffffffffffp+16380, false,
-	0xf.fffffffffffffffp+16380, false,
-	INF, true,
-	false,
-	0xf.fffffffffffffffp+16380, false,
-	0xf.fffffffffffffffp+16380, false,
-	0xf.fffffffffffffffp+16380, false,
-	INF, true,
-	false,
-	0xf.fffffffffffffffffffffffffcp+1020, true,
-	INF, true,
-	0xf.fffffffffffffffffffffffffcp+1020, true,
-	INF, true,
-	false,
-	0xf.fffffffffffffff7fffffffffff8p+16380, false,
-	0xf.fffffffffffffff8p+16380, false,
-	0xf.fffffffffffffff7fffffffffff8p+16380, false,
-	0xf.fffffffffffffff8p+16380, false),
+	0xf.fffffp+124, true, false,
+	INF, true, false,
+	0xf.fffffp+124, true, false,
+	INF, true, false,
+	false,
+	0xf.ffffffffffff8p+1020, true, false,
+	INF, true, false,
+	0xf.ffffffffffff8p+1020, true, false,
+	INF, true, false,
+	false,
+	0xf.fffffffffffffffp+16380, false, false,
+	0xf.fffffffffffffffp+16380, false, false,
+	0xf.fffffffffffffffp+16380, false, false,
+	INF, true, false,
+	false,
+	0xf.fffffffffffffffp+16380, false, false,
+	0xf.fffffffffffffffp+16380, false, false,
+	0xf.fffffffffffffffp+16380, false, false,
+	INF, true, false,
+	false,
+	0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	INF, true, false,
+	0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	INF, true, false,
+	false,
+	0xf.fffffffffffffff7fffffffffff8p+16380, false, false,
+	0xf.fffffffffffffff8p+16380, false, false,
+	0xf.fffffffffffffff7fffffffffff8p+16380, false, false,
+	0xf.fffffffffffffff8p+16380, false, false),
   TEST ("118973149535723176505351158982948866796625400469556721895649"
 	"927756249918185172720476044944290457046138433056764616744328"
 	"666255526748948793023632513609765434237723241753648908036202"
@@ -2261,35 +2261,35 @@ static const struct test tests[] = {
 	"578031503869424406179027994752890226443351619365453243328968"
 	"8740976918528",
 	false,
-	0xf.fffffp+124, true,
-	INF, true,
-	0xf.fffffp+124, true,
-	INF, true,
-	false,
-	0xf.ffffffffffff8p+1020, true,
-	INF, true,
-	0xf.ffffffffffff8p+1020, true,
-	INF, true,
-	false,
-	0xf.fffffffffffffffp+16380, false,
-	INF, true,
-	0xf.fffffffffffffffp+16380, false,
-	INF, true,
-	false,
-	0xf.fffffffffffffffp+16380, false,
-	INF, true,
-	0xf.fffffffffffffffp+16380, false,
-	INF, true,
-	false,
-	0xf.fffffffffffffffffffffffffcp+1020, true,
-	INF, true,
-	0xf.fffffffffffffffffffffffffcp+1020, true,
-	INF, true,
-	true,
-	0xf.fffffffffffffff8p+16380, false,
-	0xf.fffffffffffffff8p+16380, false,
-	0xf.fffffffffffffff8p+16380, false,
-	0xf.fffffffffffffff8p+16380, false),
+	0xf.fffffp+124, true, false,
+	INF, true, false,
+	0xf.fffffp+124, true, false,
+	INF, true, false,
+	false,
+	0xf.ffffffffffff8p+1020, true, false,
+	INF, true, false,
+	0xf.ffffffffffff8p+1020, true, false,
+	INF, true, false,
+	false,
+	0xf.fffffffffffffffp+16380, false, false,
+	INF, true, false,
+	0xf.fffffffffffffffp+16380, false, false,
+	INF, true, false,
+	false,
+	0xf.fffffffffffffffp+16380, false, false,
+	INF, true, false,
+	0xf.fffffffffffffffp+16380, false, false,
+	INF, true, false,
+	false,
+	0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	INF, true, false,
+	0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	INF, true, false,
+	true,
+	0xf.fffffffffffffff8p+16380, false, false,
+	0xf.fffffffffffffff8p+16380, false, false,
+	0xf.fffffffffffffff8p+16380, false, false,
+	0xf.fffffffffffffff8p+16380, false, false),
   TEST ("118973149535723176505351158982948866796625400469556721895649"
 	"927756249918185172720476044944290457046138433056764616744328"
 	"666255526748948793023632513609765434237723241753648908036202"
@@ -2374,35 +2374,35 @@ static const struct test tests[] = {
 	"578031503869424406179027994752890226443351619365453243328968"
 	"8740976918528.001",
 	false,
-	0xf.fffffp+124, true,
-	INF, true,
-	0xf.fffffp+124, true,
-	INF, true,
-	false,
-	0xf.ffffffffffff8p+1020, true,
-	INF, true,
-	0xf.ffffffffffff8p+1020, true,
-	INF, true,
-	false,
-	0xf.fffffffffffffffp+16380, false,
-	INF, true,
-	0xf.fffffffffffffffp+16380, false,
-	INF, true,
-	false,
-	0xf.fffffffffffffffp+16380, false,
-	INF, true,
-	0xf.fffffffffffffffp+16380, false,
-	INF, true,
-	false,
-	0xf.fffffffffffffffffffffffffcp+1020, true,
-	INF, true,
-	0xf.fffffffffffffffffffffffffcp+1020, true,
-	INF, true,
-	false,
-	0xf.fffffffffffffff8p+16380, false,
-	0xf.fffffffffffffff8p+16380, false,
-	0xf.fffffffffffffff8p+16380, false,
-	0xf.fffffffffffffff8000000000008p+16380, false),
+	0xf.fffffp+124, true, false,
+	INF, true, false,
+	0xf.fffffp+124, true, false,
+	INF, true, false,
+	false,
+	0xf.ffffffffffff8p+1020, true, false,
+	INF, true, false,
+	0xf.ffffffffffff8p+1020, true, false,
+	INF, true, false,
+	false,
+	0xf.fffffffffffffffp+16380, false, false,
+	INF, true, false,
+	0xf.fffffffffffffffp+16380, false, false,
+	INF, true, false,
+	false,
+	0xf.fffffffffffffffp+16380, false, false,
+	INF, true, false,
+	0xf.fffffffffffffffp+16380, false, false,
+	INF, true, false,
+	false,
+	0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	INF, true, false,
+	0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	INF, true, false,
+	false,
+	0xf.fffffffffffffff8p+16380, false, false,
+	0xf.fffffffffffffff8p+16380, false, false,
+	0xf.fffffffffffffff8p+16380, false, false,
+	0xf.fffffffffffffff8000000000008p+16380, false, false),
   TEST ("-11897314953572317650535115898294886679662540046955672189564"
 	"992775624991818517272047604494429045704613843305676461674432"
 	"866625552674894879302363251360976543423772324175364890803620"
@@ -2487,35 +2487,35 @@ static const struct test tests[] = {
 	"557803150386942440617902799475289022644335161936545324332896"
 	"88740976918527.999",
 	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffp+124, true,
-	-0xf.fffffp+124, true,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.ffffffffffff8p+1020, true,
-	-0xf.ffffffffffff8p+1020, true,
-	false,
-	-INF, true,
-	-0xf.fffffffffffffffp+16380, false,
-	-0xf.fffffffffffffffp+16380, false,
-	-0xf.fffffffffffffffp+16380, false,
-	false,
-	-INF, true,
-	-0xf.fffffffffffffffp+16380, false,
-	-0xf.fffffffffffffffp+16380, false,
-	-0xf.fffffffffffffffp+16380, false,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffffffffffffffffffffffcp+1020, true,
-	-0xf.fffffffffffffffffffffffffcp+1020, true,
-	false,
-	-0xf.fffffffffffffff8p+16380, false,
-	-0xf.fffffffffffffff8p+16380, false,
-	-0xf.fffffffffffffff7fffffffffff8p+16380, false,
-	-0xf.fffffffffffffff7fffffffffff8p+16380, false),
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffp+124, true, false,
+	-0xf.fffffp+124, true, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.ffffffffffff8p+1020, true, false,
+	-0xf.ffffffffffff8p+1020, true, false,
+	false,
+	-INF, true, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	false,
+	-INF, true, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	-0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	false,
+	-0xf.fffffffffffffff8p+16380, false, false,
+	-0xf.fffffffffffffff8p+16380, false, false,
+	-0xf.fffffffffffffff7fffffffffff8p+16380, false, false,
+	-0xf.fffffffffffffff7fffffffffff8p+16380, false, false),
   TEST ("-11897314953572317650535115898294886679662540046955672189564"
 	"992775624991818517272047604494429045704613843305676461674432"
 	"866625552674894879302363251360976543423772324175364890803620"
@@ -2600,35 +2600,35 @@ static const struct test tests[] = {
 	"557803150386942440617902799475289022644335161936545324332896"
 	"88740976918528",
 	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffp+124, true,
-	-0xf.fffffp+124, true,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.ffffffffffff8p+1020, true,
-	-0xf.ffffffffffff8p+1020, true,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffffffffffffp+16380, false,
-	-0xf.fffffffffffffffp+16380, false,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffffffffffffp+16380, false,
-	-0xf.fffffffffffffffp+16380, false,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffffffffffffffffffffffcp+1020, true,
-	-0xf.fffffffffffffffffffffffffcp+1020, true,
-	true,
-	-0xf.fffffffffffffff8p+16380, false,
-	-0xf.fffffffffffffff8p+16380, false,
-	-0xf.fffffffffffffff8p+16380, false,
-	-0xf.fffffffffffffff8p+16380, false),
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffp+124, true, false,
+	-0xf.fffffp+124, true, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.ffffffffffff8p+1020, true, false,
+	-0xf.ffffffffffff8p+1020, true, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	-0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	true,
+	-0xf.fffffffffffffff8p+16380, false, false,
+	-0xf.fffffffffffffff8p+16380, false, false,
+	-0xf.fffffffffffffff8p+16380, false, false,
+	-0xf.fffffffffffffff8p+16380, false, false),
   TEST ("-11897314953572317650535115898294886679662540046955672189564"
 	"992775624991818517272047604494429045704613843305676461674432"
 	"866625552674894879302363251360976543423772324175364890803620"
@@ -2713,35 +2713,35 @@ static const struct test tests[] = {
 	"557803150386942440617902799475289022644335161936545324332896"
 	"88740976918528.001",
 	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffp+124, true,
-	-0xf.fffffp+124, true,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.ffffffffffff8p+1020, true,
-	-0xf.ffffffffffff8p+1020, true,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffffffffffffp+16380, false,
-	-0xf.fffffffffffffffp+16380, false,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffffffffffffp+16380, false,
-	-0xf.fffffffffffffffp+16380, false,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffffffffffffffffffffffcp+1020, true,
-	-0xf.fffffffffffffffffffffffffcp+1020, true,
-	false,
-	-0xf.fffffffffffffff8000000000008p+16380, false,
-	-0xf.fffffffffffffff8p+16380, false,
-	-0xf.fffffffffffffff8p+16380, false,
-	-0xf.fffffffffffffff8p+16380, false),
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffp+124, true, false,
+	-0xf.fffffp+124, true, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.ffffffffffff8p+1020, true, false,
+	-0xf.ffffffffffff8p+1020, true, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	-0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	false,
+	-0xf.fffffffffffffff8000000000008p+16380, false, false,
+	-0xf.fffffffffffffff8p+16380, false, false,
+	-0xf.fffffffffffffff8p+16380, false, false,
+	-0xf.fffffffffffffff8p+16380, false, false),
   TEST ("118973149535723176508575932662800707347995686986910214150118"
 	"685272271246896789803961473130416053705672050873552479421805"
 	"932646640744124594447361172514341324846716679654551308018400"
@@ -2826,35 +2826,35 @@ static const struct test tests[] = {
 	"972233447491583165728635513802591543441145939539353470970452"
 	"5536550715391.999",
 	false,
-	0xf.fffffp+124, true,
-	INF, true,
-	0xf.fffffp+124, true,
-	INF, true,
-	false,
-	0xf.ffffffffffff8p+1020, true,
-	INF, true,
-	0xf.ffffffffffff8p+1020, true,
-	INF, true,
-	false,
-	0xf.fffffffffffffffp+16380, false,
-	INF, true,
-	0xf.fffffffffffffffp+16380, false,
-	INF, true,
-	false,
-	0xf.fffffffffffffffp+16380, false,
-	INF, true,
-	0xf.fffffffffffffffp+16380, false,
-	INF, true,
-	false,
-	0xf.fffffffffffffffffffffffffcp+1020, true,
-	INF, true,
-	0xf.fffffffffffffffffffffffffcp+1020, true,
-	INF, true,
-	false,
-	0xf.fffffffffffffffffffffffffff8p+16380, false,
-	0xf.fffffffffffffffffffffffffff8p+16380, false,
-	0xf.fffffffffffffffffffffffffff8p+16380, false,
-	INF, true),
+	0xf.fffffp+124, true, false,
+	INF, true, false,
+	0xf.fffffp+124, true, false,
+	INF, true, false,
+	false,
+	0xf.ffffffffffff8p+1020, true, false,
+	INF, true, false,
+	0xf.ffffffffffff8p+1020, true, false,
+	INF, true, false,
+	false,
+	0xf.fffffffffffffffp+16380, false, false,
+	INF, true, false,
+	0xf.fffffffffffffffp+16380, false, false,
+	INF, true, false,
+	false,
+	0xf.fffffffffffffffp+16380, false, false,
+	INF, true, false,
+	0xf.fffffffffffffffp+16380, false, false,
+	INF, true, false,
+	false,
+	0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	INF, true, false,
+	0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	INF, true, false,
+	false,
+	0xf.fffffffffffffffffffffffffff8p+16380, false, false,
+	0xf.fffffffffffffffffffffffffff8p+16380, false, false,
+	0xf.fffffffffffffffffffffffffff8p+16380, false, false,
+	INF, true, false),
   TEST ("118973149535723176508575932662800707347995686986910214150118"
 	"685272271246896789803961473130416053705672050873552479421805"
 	"932646640744124594447361172514341324846716679654551308018400"
@@ -2939,35 +2939,35 @@ static const struct test tests[] = {
 	"972233447491583165728635513802591543441145939539353470970452"
 	"5536550715392",
 	false,
-	0xf.fffffp+124, true,
-	INF, true,
-	0xf.fffffp+124, true,
-	INF, true,
-	false,
-	0xf.ffffffffffff8p+1020, true,
-	INF, true,
-	0xf.ffffffffffff8p+1020, true,
-	INF, true,
-	false,
-	0xf.fffffffffffffffp+16380, false,
-	INF, true,
-	0xf.fffffffffffffffp+16380, false,
-	INF, true,
-	false,
-	0xf.fffffffffffffffp+16380, false,
-	INF, true,
-	0xf.fffffffffffffffp+16380, false,
-	INF, true,
-	false,
-	0xf.fffffffffffffffffffffffffcp+1020, true,
-	INF, true,
-	0xf.fffffffffffffffffffffffffcp+1020, true,
-	INF, true,
-	false,
-	0xf.fffffffffffffffffffffffffff8p+16380, false,
-	INF, true,
-	0xf.fffffffffffffffffffffffffff8p+16380, false,
-	INF, true),
+	0xf.fffffp+124, true, false,
+	INF, true, false,
+	0xf.fffffp+124, true, false,
+	INF, true, false,
+	false,
+	0xf.ffffffffffff8p+1020, true, false,
+	INF, true, false,
+	0xf.ffffffffffff8p+1020, true, false,
+	INF, true, false,
+	false,
+	0xf.fffffffffffffffp+16380, false, false,
+	INF, true, false,
+	0xf.fffffffffffffffp+16380, false, false,
+	INF, true, false,
+	false,
+	0xf.fffffffffffffffp+16380, false, false,
+	INF, true, false,
+	0xf.fffffffffffffffp+16380, false, false,
+	INF, true, false,
+	false,
+	0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	INF, true, false,
+	0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	INF, true, false,
+	false,
+	0xf.fffffffffffffffffffffffffff8p+16380, false, false,
+	INF, true, false,
+	0xf.fffffffffffffffffffffffffff8p+16380, false, false,
+	INF, true, false),
   TEST ("118973149535723176508575932662800707347995686986910214150118"
 	"685272271246896789803961473130416053705672050873552479421805"
 	"932646640744124594447361172514341324846716679654551308018400"
@@ -3052,35 +3052,35 @@ static const struct test tests[] = {
 	"972233447491583165728635513802591543441145939539353470970452"
 	"5536550715392.001",
 	false,
-	0xf.fffffp+124, true,
-	INF, true,
-	0xf.fffffp+124, true,
-	INF, true,
-	false,
-	0xf.ffffffffffff8p+1020, true,
-	INF, true,
-	0xf.ffffffffffff8p+1020, true,
-	INF, true,
-	false,
-	0xf.fffffffffffffffp+16380, false,
-	INF, true,
-	0xf.fffffffffffffffp+16380, false,
-	INF, true,
-	false,
-	0xf.fffffffffffffffp+16380, false,
-	INF, true,
-	0xf.fffffffffffffffp+16380, false,
-	INF, true,
-	false,
-	0xf.fffffffffffffffffffffffffcp+1020, true,
-	INF, true,
-	0xf.fffffffffffffffffffffffffcp+1020, true,
-	INF, true,
-	false,
-	0xf.fffffffffffffffffffffffffff8p+16380, false,
-	INF, true,
-	0xf.fffffffffffffffffffffffffff8p+16380, false,
-	INF, true),
+	0xf.fffffp+124, true, false,
+	INF, true, false,
+	0xf.fffffp+124, true, false,
+	INF, true, false,
+	false,
+	0xf.ffffffffffff8p+1020, true, false,
+	INF, true, false,
+	0xf.ffffffffffff8p+1020, true, false,
+	INF, true, false,
+	false,
+	0xf.fffffffffffffffp+16380, false, false,
+	INF, true, false,
+	0xf.fffffffffffffffp+16380, false, false,
+	INF, true, false,
+	false,
+	0xf.fffffffffffffffp+16380, false, false,
+	INF, true, false,
+	0xf.fffffffffffffffp+16380, false, false,
+	INF, true, false,
+	false,
+	0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	INF, true, false,
+	0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	INF, true, false,
+	false,
+	0xf.fffffffffffffffffffffffffff8p+16380, false, false,
+	INF, true, false,
+	0xf.fffffffffffffffffffffffffff8p+16380, false, false,
+	INF, true, false),
   TEST ("-11897314953572317650857593266280070734799568698691021415011"
 	"868527227124689678980396147313041605370567205087355247942180"
 	"593264664074412459444736117251434132484671667965455130801840"
@@ -3165,35 +3165,35 @@ static const struct test tests[] = {
 	"097223344749158316572863551380259154344114593953935347097045"
 	"25536550715391.999",
 	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffp+124, true,
-	-0xf.fffffp+124, true,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.ffffffffffff8p+1020, true,
-	-0xf.ffffffffffff8p+1020, true,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffffffffffffp+16380, false,
-	-0xf.fffffffffffffffp+16380, false,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffffffffffffp+16380, false,
-	-0xf.fffffffffffffffp+16380, false,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffffffffffffffffffffffcp+1020, true,
-	-0xf.fffffffffffffffffffffffffcp+1020, true,
-	false,
-	-INF, true,
-	-0xf.fffffffffffffffffffffffffff8p+16380, false,
-	-0xf.fffffffffffffffffffffffffff8p+16380, false,
-	-0xf.fffffffffffffffffffffffffff8p+16380, false),
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffp+124, true, false,
+	-0xf.fffffp+124, true, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.ffffffffffff8p+1020, true, false,
+	-0xf.ffffffffffff8p+1020, true, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	-0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	false,
+	-INF, true, false,
+	-0xf.fffffffffffffffffffffffffff8p+16380, false, false,
+	-0xf.fffffffffffffffffffffffffff8p+16380, false, false,
+	-0xf.fffffffffffffffffffffffffff8p+16380, false, false),
   TEST ("-11897314953572317650857593266280070734799568698691021415011"
 	"868527227124689678980396147313041605370567205087355247942180"
 	"593264664074412459444736117251434132484671667965455130801840"
@@ -3278,35 +3278,35 @@ static const struct test tests[] = {
 	"097223344749158316572863551380259154344114593953935347097045"
 	"25536550715392",
 	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffp+124, true,
-	-0xf.fffffp+124, true,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.ffffffffffff8p+1020, true,
-	-0xf.ffffffffffff8p+1020, true,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffffffffffffp+16380, false,
-	-0xf.fffffffffffffffp+16380, false,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffffffffffffp+16380, false,
-	-0xf.fffffffffffffffp+16380, false,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffffffffffffffffffffffcp+1020, true,
-	-0xf.fffffffffffffffffffffffffcp+1020, true,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffffffffffffffffffffffff8p+16380, false,
-	-0xf.fffffffffffffffffffffffffff8p+16380, false),
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffp+124, true, false,
+	-0xf.fffffp+124, true, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.ffffffffffff8p+1020, true, false,
+	-0xf.ffffffffffff8p+1020, true, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	-0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffffffffffffffffffffffff8p+16380, false, false,
+	-0xf.fffffffffffffffffffffffffff8p+16380, false, false),
   TEST ("-11897314953572317650857593266280070734799568698691021415011"
 	"868527227124689678980396147313041605370567205087355247942180"
 	"593264664074412459444736117251434132484671667965455130801840"
@@ -3391,419 +3391,419 @@ static const struct test tests[] = {
 	"097223344749158316572863551380259154344114593953935347097045"
 	"25536550715392.001",
 	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffp+124, true,
-	-0xf.fffffp+124, true,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.ffffffffffff8p+1020, true,
-	-0xf.ffffffffffff8p+1020, true,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffffffffffffp+16380, false,
-	-0xf.fffffffffffffffp+16380, false,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffffffffffffp+16380, false,
-	-0xf.fffffffffffffffp+16380, false,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffffffffffffffffffffffcp+1020, true,
-	-0xf.fffffffffffffffffffffffffcp+1020, true,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffffffffffffffffffffffff8p+16380, false,
-	-0xf.fffffffffffffffffffffffffff8p+16380, false),
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffp+124, true, false,
+	-0xf.fffffp+124, true, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.ffffffffffff8p+1020, true, false,
+	-0xf.ffffffffffff8p+1020, true, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	-0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffffffffffffffffffffffff8p+16380, false, false,
+	-0xf.fffffffffffffffffffffffffff8p+16380, false, false),
   TEST ("2.1019476964872256063855943749348741969203929128147736576356"
 	"0242583468662402879090222995728254318237304687499e-45",
 	false,
-	0x8p-152, false,
-	0x8p-152, false,
-	0x8p-152, false,
-	0x1p-148, false,
-	false,
-	0xb.ffffffffffff8p-152, false,
-	0xcp-152, false,
-	0xb.ffffffffffff8p-152, false,
-	0xcp-152, false,
-	false,
-	0xb.fffffffffffffffp-152, false,
-	0xcp-152, false,
-	0xb.fffffffffffffffp-152, false,
-	0xcp-152, false,
-	false,
-	0xb.fffffffffffffffp-152, false,
-	0xcp-152, false,
-	0xb.fffffffffffffffp-152, false,
-	0xcp-152, false,
-	false,
-	0xb.fffffffffffffffffffffffffcp-152, false,
-	0xcp-152, false,
-	0xb.fffffffffffffffffffffffffcp-152, false,
-	0xcp-152, false,
-	false,
-	0xb.fffffffffffffffffffffffffff8p-152, false,
-	0xcp-152, false,
-	0xb.fffffffffffffffffffffffffff8p-152, false,
-	0xcp-152, false),
+	0x8p-152, false, true,
+	0x8p-152, false, true,
+	0x8p-152, false, true,
+	0x1p-148, false, true,
+	false,
+	0xb.ffffffffffff8p-152, false, false,
+	0xcp-152, false, false,
+	0xb.ffffffffffff8p-152, false, false,
+	0xcp-152, false, false,
+	false,
+	0xb.fffffffffffffffp-152, false, false,
+	0xcp-152, false, false,
+	0xb.fffffffffffffffp-152, false, false,
+	0xcp-152, false, false,
+	false,
+	0xb.fffffffffffffffp-152, false, false,
+	0xcp-152, false, false,
+	0xb.fffffffffffffffp-152, false, false,
+	0xcp-152, false, false,
+	false,
+	0xb.fffffffffffffffffffffffffcp-152, false, false,
+	0xcp-152, false, false,
+	0xb.fffffffffffffffffffffffffcp-152, false, false,
+	0xcp-152, false, false,
+	false,
+	0xb.fffffffffffffffffffffffffff8p-152, false, false,
+	0xcp-152, false, false,
+	0xb.fffffffffffffffffffffffffff8p-152, false, false,
+	0xcp-152, false, false),
   TEST ("2.1019476964872256063855943749348741969203929128147736576356"
 	"02425834686624028790902229957282543182373046875e-45",
 	false,
-	0x8p-152, false,
-	0x1p-148, false,
-	0x8p-152, false,
-	0x1p-148, false,
-	true,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xcp-152, false,
-	true,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xcp-152, false,
-	true,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xcp-152, false,
-	true,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xcp-152, false,
-	true,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xcp-152, false),
+	0x8p-152, false, true,
+	0x1p-148, false, true,
+	0x8p-152, false, true,
+	0x1p-148, false, true,
+	true,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	true,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	true,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	true,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	true,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xcp-152, false, false),
   TEST ("2.1019476964872256063855943749348741969203929128147736576356"
 	"0242583468662402879090222995728254318237304687501e-45",
 	false,
-	0x8p-152, false,
-	0x1p-148, false,
-	0x8p-152, false,
-	0x1p-148, false,
-	false,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xc.0000000000008p-152, false,
-	false,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xc.000000000000001p-152, false,
-	false,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xc.000000000000001p-152, false,
-	false,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xc.00000000000000000000000004p-152, false,
-	false,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xcp-152, false,
-	0xc.0000000000000000000000000008p-152, false),
+	0x8p-152, false, true,
+	0x1p-148, false, true,
+	0x8p-152, false, true,
+	0x1p-148, false, true,
+	false,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xc.0000000000008p-152, false, false,
+	false,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xc.000000000000001p-152, false, false,
+	false,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xc.000000000000001p-152, false, false,
+	false,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xc.00000000000000000000000004p-152, false, false,
+	false,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xcp-152, false, false,
+	0xc.0000000000000000000000000008p-152, false, false),
   TEST ("-2.101947696487225606385594374934874196920392912814773657635"
 	"60242583468662402879090222995728254318237304687499e-45",
 	false,
-	-0x1p-148, false,
-	-0x8p-152, false,
-	-0x8p-152, false,
-	-0x8p-152, false,
-	false,
-	-0xcp-152, false,
-	-0xcp-152, false,
-	-0xb.ffffffffffff8p-152, false,
-	-0xb.ffffffffffff8p-152, false,
-	false,
-	-0xcp-152, false,
-	-0xcp-152, false,
-	-0xb.fffffffffffffffp-152, false,
-	-0xb.fffffffffffffffp-152, false,
-	false,
-	-0xcp-152, false,
-	-0xcp-152, false,
-	-0xb.fffffffffffffffp-152, false,
-	-0xb.fffffffffffffffp-152, false,
-	false,
-	-0xcp-152, false,
-	-0xcp-152, false,
-	-0xb.fffffffffffffffffffffffffcp-152, false,
-	-0xb.fffffffffffffffffffffffffcp-152, false,
-	false,
-	-0xcp-152, false,
-	-0xcp-152, false,
-	-0xb.fffffffffffffffffffffffffff8p-152, false,
-	-0xb.fffffffffffffffffffffffffff8p-152, false),
+	-0x1p-148, false, true,
+	-0x8p-152, false, true,
+	-0x8p-152, false, true,
+	-0x8p-152, false, true,
+	false,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false,
+	-0xb.ffffffffffff8p-152, false, false,
+	-0xb.ffffffffffff8p-152, false, false,
+	false,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false,
+	-0xb.fffffffffffffffp-152, false, false,
+	-0xb.fffffffffffffffp-152, false, false,
+	false,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false,
+	-0xb.fffffffffffffffp-152, false, false,
+	-0xb.fffffffffffffffp-152, false, false,
+	false,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false,
+	-0xb.fffffffffffffffffffffffffcp-152, false, false,
+	-0xb.fffffffffffffffffffffffffcp-152, false, false,
+	false,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false,
+	-0xb.fffffffffffffffffffffffffff8p-152, false, false,
+	-0xb.fffffffffffffffffffffffffff8p-152, false, false),
   TEST ("-2.101947696487225606385594374934874196920392912814773657635"
 	"602425834686624028790902229957282543182373046875e-45",
 	false,
-	-0x1p-148, false,
-	-0x1p-148, false,
-	-0x8p-152, false,
-	-0x8p-152, false,
-	true,
-	-0xcp-152, false,
-	-0xcp-152, false,
-	-0xcp-152, false,
-	-0xcp-152, false,
-	true,
-	-0xcp-152, false,
-	-0xcp-152, false,
-	-0xcp-152, false,
-	-0xcp-152, false,
-	true,
-	-0xcp-152, false,
-	-0xcp-152, false,
-	-0xcp-152, false,
-	-0xcp-152, false,
-	true,
-	-0xcp-152, false,
-	-0xcp-152, false,
-	-0xcp-152, false,
-	-0xcp-152, false,
-	true,
-	-0xcp-152, false,
-	-0xcp-152, false,
-	-0xcp-152, false,
-	-0xcp-152, false),
+	-0x1p-148, false, true,
+	-0x1p-148, false, true,
+	-0x8p-152, false, true,
+	-0x8p-152, false, true,
+	true,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false,
+	true,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false,
+	true,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false,
+	true,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false,
+	true,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false),
   TEST ("-2.101947696487225606385594374934874196920392912814773657635"
 	"60242583468662402879090222995728254318237304687501e-45",
 	false,
-	-0x1p-148, false,
-	-0x1p-148, false,
-	-0x8p-152, false,
-	-0x8p-152, false,
-	false,
-	-0xc.0000000000008p-152, false,
-	-0xcp-152, false,
-	-0xcp-152, false,
-	-0xcp-152, false,
-	false,
-	-0xc.000000000000001p-152, false,
-	-0xcp-152, false,
-	-0xcp-152, false,
-	-0xcp-152, false,
-	false,
-	-0xc.000000000000001p-152, false,
-	-0xcp-152, false,
-	-0xcp-152, false,
-	-0xcp-152, false,
-	false,
-	-0xc.00000000000000000000000004p-152, false,
-	-0xcp-152, false,
-	-0xcp-152, false,
-	-0xcp-152, false,
-	false,
-	-0xc.0000000000000000000000000008p-152, false,
-	-0xcp-152, false,
-	-0xcp-152, false,
-	-0xcp-152, false),
+	-0x1p-148, false, true,
+	-0x1p-148, false, true,
+	-0x8p-152, false, true,
+	-0x8p-152, false, true,
+	false,
+	-0xc.0000000000008p-152, false, false,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false,
+	false,
+	-0xc.000000000000001p-152, false, false,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false,
+	false,
+	-0xc.000000000000001p-152, false, false,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false,
+	false,
+	-0xc.00000000000000000000000004p-152, false, false,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false,
+	false,
+	-0xc.0000000000000000000000000008p-152, false, false,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false,
+	-0xcp-152, false, false),
   TEST ("3.5032461608120426773093239582247903282006548546912894293926"
 	"7070972447770671465150371659547090530395507812499e-45",
 	false,
-	0x1p-148, false,
-	0x1p-148, false,
-	0x1p-148, false,
-	0x1.8p-148, false,
-	false,
-	0x1.3ffffffffffffp-148, false,
-	0x1.4p-148, false,
-	0x1.3ffffffffffffp-148, false,
-	0x1.4p-148, false,
-	false,
-	0x1.3ffffffffffffffep-148, false,
-	0x1.4p-148, false,
-	0x1.3ffffffffffffffep-148, false,
-	0x1.4p-148, false,
-	false,
-	0x1.3ffffffffffffffep-148, false,
-	0x1.4p-148, false,
-	0x1.3ffffffffffffffep-148, false,
-	0x1.4p-148, false,
-	false,
-	0x1.3fffffffffffffffffffffffff8p-148, false,
-	0x1.4p-148, false,
-	0x1.3fffffffffffffffffffffffff8p-148, false,
-	0x1.4p-148, false,
-	false,
-	0x1.3fffffffffffffffffffffffffffp-148, false,
-	0x1.4p-148, false,
-	0x1.3fffffffffffffffffffffffffffp-148, false,
-	0x1.4p-148, false),
+	0x1p-148, false, true,
+	0x1p-148, false, true,
+	0x1p-148, false, true,
+	0x1.8p-148, false, true,
+	false,
+	0x1.3ffffffffffffp-148, false, false,
+	0x1.4p-148, false, false,
+	0x1.3ffffffffffffp-148, false, false,
+	0x1.4p-148, false, false,
+	false,
+	0x1.3ffffffffffffffep-148, false, false,
+	0x1.4p-148, false, false,
+	0x1.3ffffffffffffffep-148, false, false,
+	0x1.4p-148, false, false,
+	false,
+	0x1.3ffffffffffffffep-148, false, false,
+	0x1.4p-148, false, false,
+	0x1.3ffffffffffffffep-148, false, false,
+	0x1.4p-148, false, false,
+	false,
+	0x1.3fffffffffffffffffffffffff8p-148, false, false,
+	0x1.4p-148, false, false,
+	0x1.3fffffffffffffffffffffffff8p-148, false, false,
+	0x1.4p-148, false, false,
+	false,
+	0x1.3fffffffffffffffffffffffffffp-148, false, false,
+	0x1.4p-148, false, false,
+	0x1.3fffffffffffffffffffffffffffp-148, false, false,
+	0x1.4p-148, false, false),
   TEST ("3.5032461608120426773093239582247903282006548546912894293926"
 	"70709724477706714651503716595470905303955078125e-45",
 	false,
-	0x1p-148, false,
-	0x1p-148, false,
-	0x1p-148, false,
-	0x1.8p-148, false,
-	true,
-	0x1.4p-148, false,
-	0x1.4p-148, false,
-	0x1.4p-148, false,
-	0x1.4p-148, false,
-	true,
-	0x1.4p-148, false,
-	0x1.4p-148, false,
-	0x1.4p-148, false,
-	0x1.4p-148, false,
-	true,
-	0x1.4p-148, false,
-	0x1.4p-148, false,
-	0x1.4p-148, false,
-	0x1.4p-148, false,
-	true,
-	0x1.4p-148, false,
-	0x1.4p-148, false,
-	0x1.4p-148, false,
-	0x1.4p-148, false,
-	true,
-	0x1.4p-148, false,
-	0x1.4p-148, false,
-	0x1.4p-148, false,
-	0x1.4p-148, false),
+	0x1p-148, false, true,
+	0x1p-148, false, true,
+	0x1p-148, false, true,
+	0x1.8p-148, false, true,
+	true,
+	0x1.4p-148, false, false,
+	0x1.4p-148, false, false,
+	0x1.4p-148, false, false,
+	0x1.4p-148, false, false,
+	true,
+	0x1.4p-148, false, false,
+	0x1.4p-148, false, false,
+	0x1.4p-148, false, false,
+	0x1.4p-148, false, false,
+	true,
+	0x1.4p-148, false, false,
+	0x1.4p-148, false, false,
+	0x1.4p-148, false, false,
+	0x1.4p-148, false, false,
+	true,
+	0x1.4p-148, false, false,
+	0x1.4p-148, false, false,
+	0x1.4p-148, false, false,
+	0x1.4p-148, false, false,
+	true,
+	0x1.4p-148, false, false,
+	0x1.4p-148, false, false,
+	0x1.4p-148, false, false,
+	0x1.4p-148, false, false),
   TEST ("3.5032461608120426773093239582247903282006548546912894293926"
 	"7070972447770671465150371659547090530395507812501e-45",
 	false,
-	0x1p-148, false,
-	0x1.8p-148, false,
-	0x1p-148, false,
-	0x1.8p-148, false,
-	false,
-	0x1.4p-148, false,
-	0x1.4p-148, false,
-	0x1.4p-148, false,
-	0x1.4000000000001p-148, false,
-	false,
-	0x1.4p-148, false,
-	0x1.4p-148, false,
-	0x1.4p-148, false,
-	0x1.4000000000000002p-148, false,
-	false,
-	0x1.4p-148, false,
-	0x1.4p-148, false,
-	0x1.4p-148, false,
-	0x1.4000000000000002p-148, false,
-	false,
-	0x1.4p-148, false,
-	0x1.4p-148, false,
-	0x1.4p-148, false,
-	0x1.400000000000000000000000008p-148, false,
-	false,
-	0x1.4p-148, false,
-	0x1.4p-148, false,
-	0x1.4p-148, false,
-	0x1.4000000000000000000000000001p-148, false),
+	0x1p-148, false, true,
+	0x1.8p-148, false, true,
+	0x1p-148, false, true,
+	0x1.8p-148, false, true,
+	false,
+	0x1.4p-148, false, false,
+	0x1.4p-148, false, false,
+	0x1.4p-148, false, false,
+	0x1.4000000000001p-148, false, false,
+	false,
+	0x1.4p-148, false, false,
+	0x1.4p-148, false, false,
+	0x1.4p-148, false, false,
+	0x1.4000000000000002p-148, false, false,
+	false,
+	0x1.4p-148, false, false,
+	0x1.4p-148, false, false,
+	0x1.4p-148, false, false,
+	0x1.4000000000000002p-148, false, false,
+	false,
+	0x1.4p-148, false, false,
+	0x1.4p-148, false, false,
+	0x1.4p-148, false, false,
+	0x1.400000000000000000000000008p-148, false, false,
+	false,
+	0x1.4p-148, false, false,
+	0x1.4p-148, false, false,
+	0x1.4p-148, false, false,
+	0x1.4000000000000000000000000001p-148, false, false),
   TEST ("-3.503246160812042677309323958224790328200654854691289429392"
 	"67070972447770671465150371659547090530395507812499e-45",
 	false,
-	-0x1.8p-148, false,
-	-0x1p-148, false,
-	-0x1p-148, false,
-	-0x1p-148, false,
-	false,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false,
-	-0x1.3ffffffffffffp-148, false,
-	-0x1.3ffffffffffffp-148, false,
-	false,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false,
-	-0x1.3ffffffffffffffep-148, false,
-	-0x1.3ffffffffffffffep-148, false,
-	false,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false,
-	-0x1.3ffffffffffffffep-148, false,
-	-0x1.3ffffffffffffffep-148, false,
-	false,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false,
-	-0x1.3fffffffffffffffffffffffff8p-148, false,
-	-0x1.3fffffffffffffffffffffffff8p-148, false,
-	false,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false,
-	-0x1.3fffffffffffffffffffffffffffp-148, false,
-	-0x1.3fffffffffffffffffffffffffffp-148, false),
+	-0x1.8p-148, false, true,
+	-0x1p-148, false, true,
+	-0x1p-148, false, true,
+	-0x1p-148, false, true,
+	false,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false,
+	-0x1.3ffffffffffffp-148, false, false,
+	-0x1.3ffffffffffffp-148, false, false,
+	false,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false,
+	-0x1.3ffffffffffffffep-148, false, false,
+	-0x1.3ffffffffffffffep-148, false, false,
+	false,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false,
+	-0x1.3ffffffffffffffep-148, false, false,
+	-0x1.3ffffffffffffffep-148, false, false,
+	false,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false,
+	-0x1.3fffffffffffffffffffffffff8p-148, false, false,
+	-0x1.3fffffffffffffffffffffffff8p-148, false, false,
+	false,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false,
+	-0x1.3fffffffffffffffffffffffffffp-148, false, false,
+	-0x1.3fffffffffffffffffffffffffffp-148, false, false),
   TEST ("-3.503246160812042677309323958224790328200654854691289429392"
 	"670709724477706714651503716595470905303955078125e-45",
 	false,
-	-0x1.8p-148, false,
-	-0x1p-148, false,
-	-0x1p-148, false,
-	-0x1p-148, false,
-	true,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false,
-	true,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false,
-	true,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false,
-	true,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false,
-	true,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false),
+	-0x1.8p-148, false, true,
+	-0x1p-148, false, true,
+	-0x1p-148, false, true,
+	-0x1p-148, false, true,
+	true,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false,
+	true,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false,
+	true,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false,
+	true,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false,
+	true,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false),
   TEST ("-3.503246160812042677309323958224790328200654854691289429392"
 	"67070972447770671465150371659547090530395507812501e-45",
 	false,
-	-0x1.8p-148, false,
-	-0x1.8p-148, false,
-	-0x1p-148, false,
-	-0x1p-148, false,
-	false,
-	-0x1.4000000000001p-148, false,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false,
-	false,
-	-0x1.4000000000000002p-148, false,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false,
-	false,
-	-0x1.4000000000000002p-148, false,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false,
-	false,
-	-0x1.400000000000000000000000008p-148, false,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false,
-	false,
-	-0x1.4000000000000000000000000001p-148, false,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false,
-	-0x1.4p-148, false),
+	-0x1.8p-148, false, true,
+	-0x1.8p-148, false, true,
+	-0x1p-148, false, true,
+	-0x1p-148, false, true,
+	false,
+	-0x1.4000000000001p-148, false, false,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false,
+	false,
+	-0x1.4000000000000002p-148, false, false,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false,
+	false,
+	-0x1.4000000000000002p-148, false, false,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false,
+	false,
+	-0x1.400000000000000000000000008p-148, false, false,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false,
+	false,
+	-0x1.4000000000000000000000000001p-148, false, false,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false,
+	-0x1.4p-148, false, false),
   TEST ("7.4109846876186981626485318930233205854758970392148714663837"
 	"852375101326090531312779794975454245398856969484704316857659"
 	"638998506553390969459816219401617281718945106978546710679176"
@@ -3818,35 +3818,35 @@ static const struct test tests[] = {
 	"337560846003984904972149117463085539556354188641513168478436"
 	"31308023759629577398300170898437499e-324",
 	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-152, false,
-	false,
-	0x4p-1076, false,
-	0x4p-1076, false,
-	0x4p-1076, false,
-	0x8p-1076, false,
-	false,
-	0x5.fffffffffffffff8p-1076, false,
-	0x6p-1076, false,
-	0x5.fffffffffffffff8p-1076, false,
-	0x6p-1076, false,
-	false,
-	0x5.fffffffffffffff8p-1076, false,
-	0x6p-1076, false,
-	0x5.fffffffffffffff8p-1076, false,
-	0x6p-1076, false,
-	false,
-	0x4p-1076, false,
-	0x4p-1076, false,
-	0x4p-1076, false,
-	0x8p-1076, false,
-	false,
-	0x5.fffffffffffffffffffffffffffcp-1076, false,
-	0x6p-1076, false,
-	0x5.fffffffffffffffffffffffffffcp-1076, false,
-	0x6p-1076, false),
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x4p-1076, false, true,
+	0x4p-1076, false, true,
+	0x4p-1076, false, true,
+	0x8p-1076, false, true,
+	false,
+	0x5.fffffffffffffff8p-1076, false, false,
+	0x6p-1076, false, false,
+	0x5.fffffffffffffff8p-1076, false, false,
+	0x6p-1076, false, false,
+	false,
+	0x5.fffffffffffffff8p-1076, false, false,
+	0x6p-1076, false, false,
+	0x5.fffffffffffffff8p-1076, false, false,
+	0x6p-1076, false, false,
+	false,
+	0x4p-1076, false, true,
+	0x4p-1076, false, true,
+	0x4p-1076, false, true,
+	0x8p-1076, false, true,
+	false,
+	0x5.fffffffffffffffffffffffffffcp-1076, false, false,
+	0x6p-1076, false, false,
+	0x5.fffffffffffffffffffffffffffcp-1076, false, false,
+	0x6p-1076, false, false),
   TEST ("7.4109846876186981626485318930233205854758970392148714663837"
 	"852375101326090531312779794975454245398856969484704316857659"
 	"638998506553390969459816219401617281718945106978546710679176"
@@ -3861,35 +3861,35 @@ static const struct test tests[] = {
 	"337560846003984904972149117463085539556354188641513168478436"
 	"313080237596295773983001708984375e-324",
 	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-152, false,
-	false,
-	0x4p-1076, false,
-	0x8p-1076, false,
-	0x4p-1076, false,
-	0x8p-1076, false,
-	true,
-	0x6p-1076, false,
-	0x6p-1076, false,
-	0x6p-1076, false,
-	0x6p-1076, false,
-	true,
-	0x6p-1076, false,
-	0x6p-1076, false,
-	0x6p-1076, false,
-	0x6p-1076, false,
-	false,
-	0x4p-1076, false,
-	0x8p-1076, false,
-	0x4p-1076, false,
-	0x8p-1076, false,
-	true,
-	0x6p-1076, false,
-	0x6p-1076, false,
-	0x6p-1076, false,
-	0x6p-1076, false),
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x4p-1076, false, true,
+	0x8p-1076, false, true,
+	0x4p-1076, false, true,
+	0x8p-1076, false, true,
+	true,
+	0x6p-1076, false, false,
+	0x6p-1076, false, false,
+	0x6p-1076, false, false,
+	0x6p-1076, false, false,
+	true,
+	0x6p-1076, false, false,
+	0x6p-1076, false, false,
+	0x6p-1076, false, false,
+	0x6p-1076, false, false,
+	false,
+	0x4p-1076, false, true,
+	0x8p-1076, false, true,
+	0x4p-1076, false, true,
+	0x8p-1076, false, true,
+	true,
+	0x6p-1076, false, false,
+	0x6p-1076, false, false,
+	0x6p-1076, false, false,
+	0x6p-1076, false, false),
   TEST ("7.4109846876186981626485318930233205854758970392148714663837"
 	"852375101326090531312779794975454245398856969484704316857659"
 	"638998506553390969459816219401617281718945106978546710679176"
@@ -3904,35 +3904,35 @@ static const struct test tests[] = {
 	"337560846003984904972149117463085539556354188641513168478436"
 	"31308023759629577398300170898437501e-324",
 	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-152, false,
-	false,
-	0x4p-1076, false,
-	0x8p-1076, false,
-	0x4p-1076, false,
-	0x8p-1076, false,
-	false,
-	0x6p-1076, false,
-	0x6p-1076, false,
-	0x6p-1076, false,
-	0x6.0000000000000008p-1076, false,
-	false,
-	0x6p-1076, false,
-	0x6p-1076, false,
-	0x6p-1076, false,
-	0x6.0000000000000008p-1076, false,
-	false,
-	0x4p-1076, false,
-	0x8p-1076, false,
-	0x4p-1076, false,
-	0x8p-1076, false,
-	false,
-	0x6p-1076, false,
-	0x6p-1076, false,
-	0x6p-1076, false,
-	0x6.0000000000000000000000000004p-1076, false),
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x4p-1076, false, true,
+	0x8p-1076, false, true,
+	0x4p-1076, false, true,
+	0x8p-1076, false, true,
+	false,
+	0x6p-1076, false, false,
+	0x6p-1076, false, false,
+	0x6p-1076, false, false,
+	0x6.0000000000000008p-1076, false, false,
+	false,
+	0x6p-1076, false, false,
+	0x6p-1076, false, false,
+	0x6p-1076, false, false,
+	0x6.0000000000000008p-1076, false, false,
+	false,
+	0x4p-1076, false, true,
+	0x8p-1076, false, true,
+	0x4p-1076, false, true,
+	0x8p-1076, false, true,
+	false,
+	0x6p-1076, false, false,
+	0x6p-1076, false, false,
+	0x6p-1076, false, false,
+	0x6.0000000000000000000000000004p-1076, false, false),
   TEST ("-7.410984687618698162648531893023320585475897039214871466383"
 	"785237510132609053131277979497545424539885696948470431685765"
 	"963899850655339096945981621940161728171894510697854671067917"
@@ -3947,35 +3947,35 @@ static const struct test tests[] = {
 	"433756084600398490497214911746308553955635418864151316847843"
 	"631308023759629577398300170898437499e-324",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x8p-1076, false,
-	-0x4p-1076, false,
-	-0x4p-1076, false,
-	-0x4p-1076, false,
-	false,
-	-0x6p-1076, false,
-	-0x6p-1076, false,
-	-0x5.fffffffffffffff8p-1076, false,
-	-0x5.fffffffffffffff8p-1076, false,
-	false,
-	-0x6p-1076, false,
-	-0x6p-1076, false,
-	-0x5.fffffffffffffff8p-1076, false,
-	-0x5.fffffffffffffff8p-1076, false,
-	false,
-	-0x8p-1076, false,
-	-0x4p-1076, false,
-	-0x4p-1076, false,
-	-0x4p-1076, false,
-	false,
-	-0x6p-1076, false,
-	-0x6p-1076, false,
-	-0x5.fffffffffffffffffffffffffffcp-1076, false,
-	-0x5.fffffffffffffffffffffffffffcp-1076, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x8p-1076, false, true,
+	-0x4p-1076, false, true,
+	-0x4p-1076, false, true,
+	-0x4p-1076, false, true,
+	false,
+	-0x6p-1076, false, false,
+	-0x6p-1076, false, false,
+	-0x5.fffffffffffffff8p-1076, false, false,
+	-0x5.fffffffffffffff8p-1076, false, false,
+	false,
+	-0x6p-1076, false, false,
+	-0x6p-1076, false, false,
+	-0x5.fffffffffffffff8p-1076, false, false,
+	-0x5.fffffffffffffff8p-1076, false, false,
+	false,
+	-0x8p-1076, false, true,
+	-0x4p-1076, false, true,
+	-0x4p-1076, false, true,
+	-0x4p-1076, false, true,
+	false,
+	-0x6p-1076, false, false,
+	-0x6p-1076, false, false,
+	-0x5.fffffffffffffffffffffffffffcp-1076, false, false,
+	-0x5.fffffffffffffffffffffffffffcp-1076, false, false),
   TEST ("-7.410984687618698162648531893023320585475897039214871466383"
 	"785237510132609053131277979497545424539885696948470431685765"
 	"963899850655339096945981621940161728171894510697854671067917"
@@ -3990,35 +3990,35 @@ static const struct test tests[] = {
 	"433756084600398490497214911746308553955635418864151316847843"
 	"6313080237596295773983001708984375e-324",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x8p-1076, false,
-	-0x8p-1076, false,
-	-0x4p-1076, false,
-	-0x4p-1076, false,
-	true,
-	-0x6p-1076, false,
-	-0x6p-1076, false,
-	-0x6p-1076, false,
-	-0x6p-1076, false,
-	true,
-	-0x6p-1076, false,
-	-0x6p-1076, false,
-	-0x6p-1076, false,
-	-0x6p-1076, false,
-	false,
-	-0x8p-1076, false,
-	-0x8p-1076, false,
-	-0x4p-1076, false,
-	-0x4p-1076, false,
-	true,
-	-0x6p-1076, false,
-	-0x6p-1076, false,
-	-0x6p-1076, false,
-	-0x6p-1076, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x8p-1076, false, true,
+	-0x8p-1076, false, true,
+	-0x4p-1076, false, true,
+	-0x4p-1076, false, true,
+	true,
+	-0x6p-1076, false, false,
+	-0x6p-1076, false, false,
+	-0x6p-1076, false, false,
+	-0x6p-1076, false, false,
+	true,
+	-0x6p-1076, false, false,
+	-0x6p-1076, false, false,
+	-0x6p-1076, false, false,
+	-0x6p-1076, false, false,
+	false,
+	-0x8p-1076, false, true,
+	-0x8p-1076, false, true,
+	-0x4p-1076, false, true,
+	-0x4p-1076, false, true,
+	true,
+	-0x6p-1076, false, false,
+	-0x6p-1076, false, false,
+	-0x6p-1076, false, false,
+	-0x6p-1076, false, false),
   TEST ("-7.410984687618698162648531893023320585475897039214871466383"
 	"785237510132609053131277979497545424539885696948470431685765"
 	"963899850655339096945981621940161728171894510697854671067917"
@@ -4033,35 +4033,35 @@ static const struct test tests[] = {
 	"433756084600398490497214911746308553955635418864151316847843"
 	"631308023759629577398300170898437501e-324",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x8p-1076, false,
-	-0x8p-1076, false,
-	-0x4p-1076, false,
-	-0x4p-1076, false,
-	false,
-	-0x6.0000000000000008p-1076, false,
-	-0x6p-1076, false,
-	-0x6p-1076, false,
-	-0x6p-1076, false,
-	false,
-	-0x6.0000000000000008p-1076, false,
-	-0x6p-1076, false,
-	-0x6p-1076, false,
-	-0x6p-1076, false,
-	false,
-	-0x8p-1076, false,
-	-0x8p-1076, false,
-	-0x4p-1076, false,
-	-0x4p-1076, false,
-	false,
-	-0x6.0000000000000000000000000004p-1076, false,
-	-0x6p-1076, false,
-	-0x6p-1076, false,
-	-0x6p-1076, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x8p-1076, false, true,
+	-0x8p-1076, false, true,
+	-0x4p-1076, false, true,
+	-0x4p-1076, false, true,
+	false,
+	-0x6.0000000000000008p-1076, false, false,
+	-0x6p-1076, false, false,
+	-0x6p-1076, false, false,
+	-0x6p-1076, false, false,
+	false,
+	-0x6.0000000000000008p-1076, false, false,
+	-0x6p-1076, false, false,
+	-0x6p-1076, false, false,
+	-0x6p-1076, false, false,
+	false,
+	-0x8p-1076, false, true,
+	-0x8p-1076, false, true,
+	-0x4p-1076, false, true,
+	-0x4p-1076, false, true,
+	false,
+	-0x6.0000000000000000000000000004p-1076, false, false,
+	-0x6p-1076, false, false,
+	-0x6p-1076, false, false,
+	-0x6p-1076, false, false),
   TEST ("5.4677992978237119037926089004291297245985762235403450155814"
 	"707305425575329500966052143410629387408077958710210208052966"
 	"529504784489330482549602621133847135082257338717668975178538"
@@ -4255,35 +4255,35 @@ static const struct test tests[] = {
 	"866268925981702690270202829595794350800918257913991744455922"
 	"683343374046671669930219650268554687499e-4951",
 	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-152, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0x8p-16448, false,
-	0x8p-16448, false,
-	0x8p-16448, false,
-	0x1p-16444, false,
-	false,
-	0x8p-16448, false,
-	0xcp-16448, false,
-	0x8p-16448, false,
-	0xcp-16448, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0xb.fffffffffffcp-16448, false,
-	0xcp-16448, false,
-	0xb.fffffffffffcp-16448, false,
-	0xcp-16448, false),
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x8p-16448, false, true,
+	0x8p-16448, false, true,
+	0x8p-16448, false, true,
+	0x1p-16444, false, true,
+	false,
+	0x8p-16448, false, true,
+	0xcp-16448, false, true,
+	0x8p-16448, false, true,
+	0xcp-16448, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0xb.fffffffffffcp-16448, false, true,
+	0xcp-16448, false, true,
+	0xb.fffffffffffcp-16448, false, true,
+	0xcp-16448, false, true),
   TEST ("5.4677992978237119037926089004291297245985762235403450155814"
 	"707305425575329500966052143410629387408077958710210208052966"
 	"529504784489330482549602621133847135082257338717668975178538"
@@ -4477,35 +4477,35 @@ static const struct test tests[] = {
 	"866268925981702690270202829595794350800918257913991744455922"
 	"6833433740466716699302196502685546875e-4951",
 	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-152, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0x8p-16448, false,
-	0x1p-16444, false,
-	0x8p-16448, false,
-	0x1p-16444, false,
-	true,
-	0xcp-16448, false,
-	0xcp-16448, false,
-	0xcp-16448, false,
-	0xcp-16448, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	true,
-	0xcp-16448, false,
-	0xcp-16448, false,
-	0xcp-16448, false,
-	0xcp-16448, false),
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x8p-16448, false, true,
+	0x1p-16444, false, true,
+	0x8p-16448, false, true,
+	0x1p-16444, false, true,
+	true,
+	0xcp-16448, false, false,
+	0xcp-16448, false, false,
+	0xcp-16448, false, false,
+	0xcp-16448, false, false,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	true,
+	0xcp-16448, false, false,
+	0xcp-16448, false, false,
+	0xcp-16448, false, false,
+	0xcp-16448, false, false),
   TEST ("5.4677992978237119037926089004291297245985762235403450155814"
 	"707305425575329500966052143410629387408077958710210208052966"
 	"529504784489330482549602621133847135082257338717668975178538"
@@ -4699,35 +4699,35 @@ static const struct test tests[] = {
 	"866268925981702690270202829595794350800918257913991744455922"
 	"683343374046671669930219650268554687501e-4951",
 	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-152, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0x8p-16448, false,
-	0x1p-16444, false,
-	0x8p-16448, false,
-	0x1p-16444, false,
-	false,
-	0xcp-16448, false,
-	0xcp-16448, false,
-	0xcp-16448, false,
-	0x1p-16444, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0xcp-16448, false,
-	0xcp-16448, false,
-	0xcp-16448, false,
-	0xc.000000000004p-16448, false),
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x8p-16448, false, true,
+	0x1p-16444, false, true,
+	0x8p-16448, false, true,
+	0x1p-16444, false, true,
+	false,
+	0xcp-16448, false, true,
+	0xcp-16448, false, true,
+	0xcp-16448, false, true,
+	0x1p-16444, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0xcp-16448, false, true,
+	0xcp-16448, false, true,
+	0xcp-16448, false, true,
+	0xc.000000000004p-16448, false, true),
   TEST ("-5.467799297823711903792608900429129724598576223540345015581"
 	"470730542557532950096605214341062938740807795871021020805296"
 	"652950478448933048254960262113384713508225733871766897517853"
@@ -4921,35 +4921,35 @@ static const struct test tests[] = {
 	"386626892598170269027020282959579435080091825791399174445592"
 	"2683343374046671669930219650268554687499e-4951",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x1p-16444, false,
-	-0x8p-16448, false,
-	-0x8p-16448, false,
-	-0x8p-16448, false,
-	false,
-	-0xcp-16448, false,
-	-0xcp-16448, false,
-	-0x8p-16448, false,
-	-0x8p-16448, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0xcp-16448, false,
-	-0xcp-16448, false,
-	-0xb.fffffffffffcp-16448, false,
-	-0xb.fffffffffffcp-16448, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x1p-16444, false, true,
+	-0x8p-16448, false, true,
+	-0x8p-16448, false, true,
+	-0x8p-16448, false, true,
+	false,
+	-0xcp-16448, false, true,
+	-0xcp-16448, false, true,
+	-0x8p-16448, false, true,
+	-0x8p-16448, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0xcp-16448, false, true,
+	-0xcp-16448, false, true,
+	-0xb.fffffffffffcp-16448, false, true,
+	-0xb.fffffffffffcp-16448, false, true),
   TEST ("-5.467799297823711903792608900429129724598576223540345015581"
 	"470730542557532950096605214341062938740807795871021020805296"
 	"652950478448933048254960262113384713508225733871766897517853"
@@ -5143,35 +5143,35 @@ static const struct test tests[] = {
 	"386626892598170269027020282959579435080091825791399174445592"
 	"26833433740466716699302196502685546875e-4951",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x1p-16444, false,
-	-0x1p-16444, false,
-	-0x8p-16448, false,
-	-0x8p-16448, false,
-	true,
-	-0xcp-16448, false,
-	-0xcp-16448, false,
-	-0xcp-16448, false,
-	-0xcp-16448, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	true,
-	-0xcp-16448, false,
-	-0xcp-16448, false,
-	-0xcp-16448, false,
-	-0xcp-16448, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x1p-16444, false, true,
+	-0x1p-16444, false, true,
+	-0x8p-16448, false, true,
+	-0x8p-16448, false, true,
+	true,
+	-0xcp-16448, false, false,
+	-0xcp-16448, false, false,
+	-0xcp-16448, false, false,
+	-0xcp-16448, false, false,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	true,
+	-0xcp-16448, false, false,
+	-0xcp-16448, false, false,
+	-0xcp-16448, false, false,
+	-0xcp-16448, false, false),
   TEST ("-5.467799297823711903792608900429129724598576223540345015581"
 	"470730542557532950096605214341062938740807795871021020805296"
 	"652950478448933048254960262113384713508225733871766897517853"
@@ -5365,35 +5365,35 @@ static const struct test tests[] = {
 	"386626892598170269027020282959579435080091825791399174445592"
 	"2683343374046671669930219650268554687501e-4951",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x1p-16444, false,
-	-0x1p-16444, false,
-	-0x8p-16448, false,
-	-0x8p-16448, false,
-	false,
-	-0x1p-16444, false,
-	-0xcp-16448, false,
-	-0xcp-16448, false,
-	-0xcp-16448, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0xc.000000000004p-16448, false,
-	-0xcp-16448, false,
-	-0xcp-16448, false,
-	-0xcp-16448, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x1p-16444, false, true,
+	-0x1p-16444, false, true,
+	-0x8p-16448, false, true,
+	-0x8p-16448, false, true,
+	false,
+	-0x1p-16444, false, true,
+	-0xcp-16448, false, true,
+	-0xcp-16448, false, true,
+	-0xcp-16448, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0xc.000000000004p-16448, false, true,
+	-0xcp-16448, false, true,
+	-0xcp-16448, false, true,
+	-0xcp-16448, false, true),
   TEST ("5.4677992978237119037926089004291297245985762235403450155814"
 	"707305425575329500966052143410629387408077958710210208052966"
 	"529504784489330482549602621133847135082257338717668975178538"
@@ -5587,35 +5587,35 @@ static const struct test tests[] = {
 	"866268925981702690270202829595794350800918257913991744455922"
 	"683343374046671669930219650268554687499e-4951",
 	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-152, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0x8p-16448, false,
-	0x8p-16448, false,
-	0x8p-16448, false,
-	0x1p-16444, false,
-	false,
-	0x8p-16448, false,
-	0xcp-16448, false,
-	0x8p-16448, false,
-	0xcp-16448, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0xb.fffffffffffcp-16448, false,
-	0xcp-16448, false,
-	0xb.fffffffffffcp-16448, false,
-	0xcp-16448, false),
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x8p-16448, false, true,
+	0x8p-16448, false, true,
+	0x8p-16448, false, true,
+	0x1p-16444, false, true,
+	false,
+	0x8p-16448, false, true,
+	0xcp-16448, false, true,
+	0x8p-16448, false, true,
+	0xcp-16448, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0xb.fffffffffffcp-16448, false, true,
+	0xcp-16448, false, true,
+	0xb.fffffffffffcp-16448, false, true,
+	0xcp-16448, false, true),
   TEST ("5.4677992978237119037926089004291297245985762235403450155814"
 	"707305425575329500966052143410629387408077958710210208052966"
 	"529504784489330482549602621133847135082257338717668975178538"
@@ -5809,35 +5809,35 @@ static const struct test tests[] = {
 	"866268925981702690270202829595794350800918257913991744455922"
 	"6833433740466716699302196502685546875e-4951",
 	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-152, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0x8p-16448, false,
-	0x1p-16444, false,
-	0x8p-16448, false,
-	0x1p-16444, false,
-	true,
-	0xcp-16448, false,
-	0xcp-16448, false,
-	0xcp-16448, false,
-	0xcp-16448, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	true,
-	0xcp-16448, false,
-	0xcp-16448, false,
-	0xcp-16448, false,
-	0xcp-16448, false),
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x8p-16448, false, true,
+	0x1p-16444, false, true,
+	0x8p-16448, false, true,
+	0x1p-16444, false, true,
+	true,
+	0xcp-16448, false, false,
+	0xcp-16448, false, false,
+	0xcp-16448, false, false,
+	0xcp-16448, false, false,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	true,
+	0xcp-16448, false, false,
+	0xcp-16448, false, false,
+	0xcp-16448, false, false,
+	0xcp-16448, false, false),
   TEST ("5.4677992978237119037926089004291297245985762235403450155814"
 	"707305425575329500966052143410629387408077958710210208052966"
 	"529504784489330482549602621133847135082257338717668975178538"
@@ -6031,35 +6031,35 @@ static const struct test tests[] = {
 	"866268925981702690270202829595794350800918257913991744455922"
 	"683343374046671669930219650268554687501e-4951",
 	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-152, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0x8p-16448, false,
-	0x1p-16444, false,
-	0x8p-16448, false,
-	0x1p-16444, false,
-	false,
-	0xcp-16448, false,
-	0xcp-16448, false,
-	0xcp-16448, false,
-	0x1p-16444, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0xcp-16448, false,
-	0xcp-16448, false,
-	0xcp-16448, false,
-	0xc.000000000004p-16448, false),
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x8p-16448, false, true,
+	0x1p-16444, false, true,
+	0x8p-16448, false, true,
+	0x1p-16444, false, true,
+	false,
+	0xcp-16448, false, true,
+	0xcp-16448, false, true,
+	0xcp-16448, false, true,
+	0x1p-16444, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0xcp-16448, false, true,
+	0xcp-16448, false, true,
+	0xcp-16448, false, true,
+	0xc.000000000004p-16448, false, true),
   TEST ("-5.467799297823711903792608900429129724598576223540345015581"
 	"470730542557532950096605214341062938740807795871021020805296"
 	"652950478448933048254960262113384713508225733871766897517853"
@@ -6253,35 +6253,35 @@ static const struct test tests[] = {
 	"386626892598170269027020282959579435080091825791399174445592"
 	"2683343374046671669930219650268554687499e-4951",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x1p-16444, false,
-	-0x8p-16448, false,
-	-0x8p-16448, false,
-	-0x8p-16448, false,
-	false,
-	-0xcp-16448, false,
-	-0xcp-16448, false,
-	-0x8p-16448, false,
-	-0x8p-16448, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0xcp-16448, false,
-	-0xcp-16448, false,
-	-0xb.fffffffffffcp-16448, false,
-	-0xb.fffffffffffcp-16448, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x1p-16444, false, true,
+	-0x8p-16448, false, true,
+	-0x8p-16448, false, true,
+	-0x8p-16448, false, true,
+	false,
+	-0xcp-16448, false, true,
+	-0xcp-16448, false, true,
+	-0x8p-16448, false, true,
+	-0x8p-16448, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0xcp-16448, false, true,
+	-0xcp-16448, false, true,
+	-0xb.fffffffffffcp-16448, false, true,
+	-0xb.fffffffffffcp-16448, false, true),
   TEST ("-5.467799297823711903792608900429129724598576223540345015581"
 	"470730542557532950096605214341062938740807795871021020805296"
 	"652950478448933048254960262113384713508225733871766897517853"
@@ -6475,35 +6475,35 @@ static const struct test tests[] = {
 	"386626892598170269027020282959579435080091825791399174445592"
 	"26833433740466716699302196502685546875e-4951",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x1p-16444, false,
-	-0x1p-16444, false,
-	-0x8p-16448, false,
-	-0x8p-16448, false,
-	true,
-	-0xcp-16448, false,
-	-0xcp-16448, false,
-	-0xcp-16448, false,
-	-0xcp-16448, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	true,
-	-0xcp-16448, false,
-	-0xcp-16448, false,
-	-0xcp-16448, false,
-	-0xcp-16448, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x1p-16444, false, true,
+	-0x1p-16444, false, true,
+	-0x8p-16448, false, true,
+	-0x8p-16448, false, true,
+	true,
+	-0xcp-16448, false, false,
+	-0xcp-16448, false, false,
+	-0xcp-16448, false, false,
+	-0xcp-16448, false, false,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	true,
+	-0xcp-16448, false, false,
+	-0xcp-16448, false, false,
+	-0xcp-16448, false, false,
+	-0xcp-16448, false, false),
   TEST ("-5.467799297823711903792608900429129724598576223540345015581"
 	"470730542557532950096605214341062938740807795871021020805296"
 	"652950478448933048254960262113384713508225733871766897517853"
@@ -6697,630 +6697,630 @@ static const struct test tests[] = {
 	"386626892598170269027020282959579435080091825791399174445592"
 	"2683343374046671669930219650268554687501e-4951",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x1p-16444, false,
-	-0x1p-16444, false,
-	-0x8p-16448, false,
-	-0x8p-16448, false,
-	false,
-	-0x1p-16444, false,
-	-0xcp-16448, false,
-	-0xcp-16448, false,
-	-0xcp-16448, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0xc.000000000004p-16448, false,
-	-0xcp-16448, false,
-	-0xcp-16448, false,
-	-0xcp-16448, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x1p-16444, false, true,
+	-0x1p-16444, false, true,
+	-0x8p-16448, false, true,
+	-0x8p-16448, false, true,
+	false,
+	-0x1p-16444, false, true,
+	-0xcp-16448, false, true,
+	-0xcp-16448, false, true,
+	-0xcp-16448, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0xc.000000000004p-16448, false, true,
+	-0xcp-16448, false, true,
+	-0xcp-16448, false, true,
+	-0xcp-16448, false, true),
   TEST ("-0x0.7p-149",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	true,
-	-0x3.8p-152, false,
-	-0x3.8p-152, false,
-	-0x3.8p-152, false,
-	-0x3.8p-152, false,
-	true,
-	-0x3.8p-152, false,
-	-0x3.8p-152, false,
-	-0x3.8p-152, false,
-	-0x3.8p-152, false,
-	true,
-	-0x3.8p-152, false,
-	-0x3.8p-152, false,
-	-0x3.8p-152, false,
-	-0x3.8p-152, false,
-	true,
-	-0x3.8p-152, false,
-	-0x3.8p-152, false,
-	-0x3.8p-152, false,
-	-0x3.8p-152, false,
-	true,
-	-0x3.8p-152, false,
-	-0x3.8p-152, false,
-	-0x3.8p-152, false,
-	-0x3.8p-152, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	true,
+	-0x3.8p-152, false, false,
+	-0x3.8p-152, false, false,
+	-0x3.8p-152, false, false,
+	-0x3.8p-152, false, false,
+	true,
+	-0x3.8p-152, false, false,
+	-0x3.8p-152, false, false,
+	-0x3.8p-152, false, false,
+	-0x3.8p-152, false, false,
+	true,
+	-0x3.8p-152, false, false,
+	-0x3.8p-152, false, false,
+	-0x3.8p-152, false, false,
+	-0x3.8p-152, false, false,
+	true,
+	-0x3.8p-152, false, false,
+	-0x3.8p-152, false, false,
+	-0x3.8p-152, false, false,
+	-0x3.8p-152, false, false,
+	true,
+	-0x3.8p-152, false, false,
+	-0x3.8p-152, false, false,
+	-0x3.8p-152, false, false,
+	-0x3.8p-152, false, false),
   TEST ("-0x0.7p-1074",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	true,
-	-0x1.cp-1076, false,
-	-0x1.cp-1076, false,
-	-0x1.cp-1076, false,
-	-0x1.cp-1076, false,
-	true,
-	-0x1.cp-1076, false,
-	-0x1.cp-1076, false,
-	-0x1.cp-1076, false,
-	-0x1.cp-1076, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	true,
-	-0x1.cp-1076, false,
-	-0x1.cp-1076, false,
-	-0x1.cp-1076, false,
-	-0x1.cp-1076, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	true,
+	-0x1.cp-1076, false, false,
+	-0x1.cp-1076, false, false,
+	-0x1.cp-1076, false, false,
+	-0x1.cp-1076, false, false,
+	true,
+	-0x1.cp-1076, false, false,
+	-0x1.cp-1076, false, false,
+	-0x1.cp-1076, false, false,
+	-0x1.cp-1076, false, false,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	true,
+	-0x1.cp-1076, false, false,
+	-0x1.cp-1076, false, false,
+	-0x1.cp-1076, false, false,
+	-0x1.cp-1076, false, false),
   TEST ("-0x0.7p-16445",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x8p-16448, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-16448, false,
-	-0x4p-16448, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	true,
-	-0x3.8p-16448, false,
-	-0x3.8p-16448, false,
-	-0x3.8p-16448, false,
-	-0x3.8p-16448, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x8p-16448, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-16448, false, true,
+	-0x4p-16448, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	true,
+	-0x3.8p-16448, false, false,
+	-0x3.8p-16448, false, false,
+	-0x3.8p-16448, false, false,
+	-0x3.8p-16448, false, false),
   TEST ("-0x0.7p-16494",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x8p-16448, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-16448, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-16496, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x8p-16448, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-16448, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-16496, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true),
   TEST ("0x1p-150",
 	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-152, false,
-	true,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false,
-	true,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false,
-	true,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false,
-	true,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false,
-	true,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false),
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	true,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	true,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	true,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	true,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	true,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false),
   TEST ("0x1p-1075",
 	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-152, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	true,
-	0x2p-1076, false,
-	0x2p-1076, false,
-	0x2p-1076, false,
-	0x2p-1076, false,
-	true,
-	0x2p-1076, false,
-	0x2p-1076, false,
-	0x2p-1076, false,
-	0x2p-1076, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	true,
-	0x2p-1076, false,
-	0x2p-1076, false,
-	0x2p-1076, false,
-	0x2p-1076, false),
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	true,
+	0x2p-1076, false, false,
+	0x2p-1076, false, false,
+	0x2p-1076, false, false,
+	0x2p-1076, false, false,
+	true,
+	0x2p-1076, false, false,
+	0x2p-1076, false, false,
+	0x2p-1076, false, false,
+	0x2p-1076, false, false,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	true,
+	0x2p-1076, false, false,
+	0x2p-1076, false, false,
+	0x2p-1076, false, false,
+	0x2p-1076, false, false),
   TEST ("0x1p-16446",
 	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-152, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-16448, false,
-	true,
-	0x4p-16448, false,
-	0x4p-16448, false,
-	0x4p-16448, false,
-	0x4p-16448, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	true,
-	0x4p-16448, false,
-	0x4p-16448, false,
-	0x4p-16448, false,
-	0x4p-16448, false),
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-16448, false, true,
+	true,
+	0x4p-16448, false, false,
+	0x4p-16448, false, false,
+	0x4p-16448, false, false,
+	0x4p-16448, false, false,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	true,
+	0x4p-16448, false, false,
+	0x4p-16448, false, false,
+	0x4p-16448, false, false,
+	0x4p-16448, false, false),
   TEST ("0x1p-16495",
 	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-152, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-16448, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-16448, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-16496, false),
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-16448, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-16448, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-16496, false, true),
   TEST ("-0x1p-150",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	true,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	true,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	true,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	true,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	true,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	true,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	true,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	true,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	true,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	true,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false),
   TEST ("-0x1p-1075",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	true,
-	-0x2p-1076, false,
-	-0x2p-1076, false,
-	-0x2p-1076, false,
-	-0x2p-1076, false,
-	true,
-	-0x2p-1076, false,
-	-0x2p-1076, false,
-	-0x2p-1076, false,
-	-0x2p-1076, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	true,
-	-0x2p-1076, false,
-	-0x2p-1076, false,
-	-0x2p-1076, false,
-	-0x2p-1076, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	true,
+	-0x2p-1076, false, false,
+	-0x2p-1076, false, false,
+	-0x2p-1076, false, false,
+	-0x2p-1076, false, false,
+	true,
+	-0x2p-1076, false, false,
+	-0x2p-1076, false, false,
+	-0x2p-1076, false, false,
+	-0x2p-1076, false, false,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	true,
+	-0x2p-1076, false, false,
+	-0x2p-1076, false, false,
+	-0x2p-1076, false, false,
+	-0x2p-1076, false, false),
   TEST ("-0x1p-16446",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x8p-16448, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	true,
-	-0x4p-16448, false,
-	-0x4p-16448, false,
-	-0x4p-16448, false,
-	-0x4p-16448, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	true,
-	-0x4p-16448, false,
-	-0x4p-16448, false,
-	-0x4p-16448, false,
-	-0x4p-16448, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x8p-16448, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	true,
+	-0x4p-16448, false, false,
+	-0x4p-16448, false, false,
+	-0x4p-16448, false, false,
+	-0x4p-16448, false, false,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	true,
+	-0x4p-16448, false, false,
+	-0x4p-16448, false, false,
+	-0x4p-16448, false, false,
+	-0x4p-16448, false, false),
   TEST ("-0x1p-16495",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x8p-16448, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-16448, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-16496, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x8p-16448, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-16448, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-16496, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true),
   TEST (".70064923216240853546186479164495807e-45",
 	false,
-	0x0p+0, false,
-	0x8p-152, false,
-	0x0p+0, false,
-	0x8p-152, false,
-	false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4.0000000000004p-152, false,
-	false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4.0000000000000008p-152, false,
-	false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4.0000000000000008p-152, false,
-	false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4.00000000000000000000000002p-152, false,
-	false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4.0000000000000000000000000004p-152, false),
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4.0000000000004p-152, false, false,
+	false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4.0000000000000008p-152, false, false,
+	false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4.0000000000000008p-152, false, false,
+	false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4.00000000000000000000000002p-152, false, false,
+	false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4.0000000000000000000000000004p-152, false, false),
   TEST ("7.0064923216240853546186479164495806564013097093825788587853"
 	"4141944895541342930300743319094181060791015624e-46",
 	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-152, false,
-	false,
-	0x3.ffffffffffffep-152, false,
-	0x4p-152, false,
-	0x3.ffffffffffffep-152, false,
-	0x4p-152, false,
-	false,
-	0x3.fffffffffffffffcp-152, false,
-	0x4p-152, false,
-	0x3.fffffffffffffffcp-152, false,
-	0x4p-152, false,
-	false,
-	0x3.fffffffffffffffcp-152, false,
-	0x4p-152, false,
-	0x3.fffffffffffffffcp-152, false,
-	0x4p-152, false,
-	false,
-	0x3.ffffffffffffffffffffffffffp-152, false,
-	0x4p-152, false,
-	0x3.ffffffffffffffffffffffffffp-152, false,
-	0x4p-152, false,
-	false,
-	0x3.fffffffffffffffffffffffffffep-152, false,
-	0x4p-152, false,
-	0x3.fffffffffffffffffffffffffffep-152, false,
-	0x4p-152, false),
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x3.ffffffffffffep-152, false, false,
+	0x4p-152, false, false,
+	0x3.ffffffffffffep-152, false, false,
+	0x4p-152, false, false,
+	false,
+	0x3.fffffffffffffffcp-152, false, false,
+	0x4p-152, false, false,
+	0x3.fffffffffffffffcp-152, false, false,
+	0x4p-152, false, false,
+	false,
+	0x3.fffffffffffffffcp-152, false, false,
+	0x4p-152, false, false,
+	0x3.fffffffffffffffcp-152, false, false,
+	0x4p-152, false, false,
+	false,
+	0x3.ffffffffffffffffffffffffffp-152, false, false,
+	0x4p-152, false, false,
+	0x3.ffffffffffffffffffffffffffp-152, false, false,
+	0x4p-152, false, false,
+	false,
+	0x3.fffffffffffffffffffffffffffep-152, false, false,
+	0x4p-152, false, false,
+	0x3.fffffffffffffffffffffffffffep-152, false, false,
+	0x4p-152, false, false),
   TEST ("7.0064923216240853546186479164495806564013097093825788587853"
 	"4141944895541342930300743319094181060791015625e-46",
 	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-152, false,
-	true,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false,
-	true,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false,
-	true,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false,
-	true,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false,
-	true,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false),
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	true,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	true,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	true,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	true,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	true,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false),
   TEST ("7.0064923216240853546186479164495806564013097093825788587853"
 	"4141944895541342930300743319094181060791015626e-46",
 	false,
-	0x0p+0, false,
-	0x8p-152, false,
-	0x0p+0, false,
-	0x8p-152, false,
-	false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4.0000000000004p-152, false,
-	false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4.0000000000000008p-152, false,
-	false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4.0000000000000008p-152, false,
-	false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4.00000000000000000000000002p-152, false,
-	false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4p-152, false,
-	0x4.0000000000000000000000000004p-152, false),
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4.0000000000004p-152, false, false,
+	false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4.0000000000000008p-152, false, false,
+	false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4.0000000000000008p-152, false, false,
+	false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4.00000000000000000000000002p-152, false, false,
+	false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4p-152, false, false,
+	0x4.0000000000000000000000000004p-152, false, false),
   TEST ("-7.006492321624085354618647916449580656401309709382578858785"
 	"34141944895541342930300743319094181060791015624e-46",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x3.ffffffffffffep-152, false,
-	-0x3.ffffffffffffep-152, false,
-	false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x3.fffffffffffffffcp-152, false,
-	-0x3.fffffffffffffffcp-152, false,
-	false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x3.fffffffffffffffcp-152, false,
-	-0x3.fffffffffffffffcp-152, false,
-	false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x3.ffffffffffffffffffffffffffp-152, false,
-	-0x3.ffffffffffffffffffffffffffp-152, false,
-	false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x3.fffffffffffffffffffffffffffep-152, false,
-	-0x3.fffffffffffffffffffffffffffep-152, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x3.ffffffffffffep-152, false, false,
+	-0x3.ffffffffffffep-152, false, false,
+	false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x3.fffffffffffffffcp-152, false, false,
+	-0x3.fffffffffffffffcp-152, false, false,
+	false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x3.fffffffffffffffcp-152, false, false,
+	-0x3.fffffffffffffffcp-152, false, false,
+	false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x3.ffffffffffffffffffffffffffp-152, false, false,
+	-0x3.ffffffffffffffffffffffffffp-152, false, false,
+	false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x3.fffffffffffffffffffffffffffep-152, false, false,
+	-0x3.fffffffffffffffffffffffffffep-152, false, false),
   TEST ("-7.006492321624085354618647916449580656401309709382578858785"
 	"34141944895541342930300743319094181060791015625e-46",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	true,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	true,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	true,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	true,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	true,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	true,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	true,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	true,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	true,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	true,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false),
   TEST ("-7.006492321624085354618647916449580656401309709382578858785"
 	"34141944895541342930300743319094181060791015626e-46",
 	false,
-	-0x8p-152, false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4.0000000000004p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	false,
-	-0x4.0000000000000008p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	false,
-	-0x4.0000000000000008p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	false,
-	-0x4.00000000000000000000000002p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	false,
-	-0x4.0000000000000000000000000004p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false,
-	-0x4p-152, false),
+	-0x8p-152, false, true,
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4.0000000000004p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	false,
+	-0x4.0000000000000008p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	false,
+	-0x4.0000000000000008p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	false,
+	-0x4.00000000000000000000000002p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	false,
+	-0x4.0000000000000000000000000004p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false,
+	-0x4p-152, false, false),
   TEST ("2.4703282292062327208828439643411068618252990130716238221279"
 	"284125033775363510437593264991818081799618989828234772285886"
 	"546332835517796989819938739800539093906315035659515570226392"
@@ -7335,35 +7335,35 @@ static const struct test tests[] = {
 	"779186948667994968324049705821028513185451396213837722826145"
 	"437693412532098591327667236328124e-324",
 	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-152, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0x1.fffffffffffffffep-1076, false,
-	0x2p-1076, false,
-	0x1.fffffffffffffffep-1076, false,
-	0x2p-1076, false,
-	false,
-	0x1.fffffffffffffffep-1076, false,
-	0x2p-1076, false,
-	0x1.fffffffffffffffep-1076, false,
-	0x2p-1076, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0x1.ffffffffffffffffffffffffffffp-1076, false,
-	0x2p-1076, false,
-	0x1.ffffffffffffffffffffffffffffp-1076, false,
-	0x2p-1076, false),
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x1.fffffffffffffffep-1076, false, false,
+	0x2p-1076, false, false,
+	0x1.fffffffffffffffep-1076, false, false,
+	0x2p-1076, false, false,
+	false,
+	0x1.fffffffffffffffep-1076, false, false,
+	0x2p-1076, false, false,
+	0x1.fffffffffffffffep-1076, false, false,
+	0x2p-1076, false, false,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x1.ffffffffffffffffffffffffffffp-1076, false, false,
+	0x2p-1076, false, false,
+	0x1.ffffffffffffffffffffffffffffp-1076, false, false,
+	0x2p-1076, false, false),
   TEST ("2.4703282292062327208828439643411068618252990130716238221279"
 	"284125033775363510437593264991818081799618989828234772285886"
 	"546332835517796989819938739800539093906315035659515570226392"
@@ -7378,35 +7378,35 @@ static const struct test tests[] = {
 	"779186948667994968324049705821028513185451396213837722826145"
 	"437693412532098591327667236328125e-324",
 	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-152, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	true,
-	0x2p-1076, false,
-	0x2p-1076, false,
-	0x2p-1076, false,
-	0x2p-1076, false,
-	true,
-	0x2p-1076, false,
-	0x2p-1076, false,
-	0x2p-1076, false,
-	0x2p-1076, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	true,
-	0x2p-1076, false,
-	0x2p-1076, false,
-	0x2p-1076, false,
-	0x2p-1076, false),
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	true,
+	0x2p-1076, false, false,
+	0x2p-1076, false, false,
+	0x2p-1076, false, false,
+	0x2p-1076, false, false,
+	true,
+	0x2p-1076, false, false,
+	0x2p-1076, false, false,
+	0x2p-1076, false, false,
+	0x2p-1076, false, false,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	true,
+	0x2p-1076, false, false,
+	0x2p-1076, false, false,
+	0x2p-1076, false, false,
+	0x2p-1076, false, false),
   TEST ("2.4703282292062327208828439643411068618252990130716238221279"
 	"284125033775363510437593264991818081799618989828234772285886"
 	"546332835517796989819938739800539093906315035659515570226392"
@@ -7421,35 +7421,35 @@ static const struct test tests[] = {
 	"779186948667994968324049705821028513185451396213837722826145"
 	"437693412532098591327667236328126e-324",
 	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-152, false,
-	false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0x2p-1076, false,
-	0x2p-1076, false,
-	0x2p-1076, false,
-	0x2.0000000000000004p-1076, false,
-	false,
-	0x2p-1076, false,
-	0x2p-1076, false,
-	0x2p-1076, false,
-	0x2.0000000000000004p-1076, false,
-	false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0x2p-1076, false,
-	0x2p-1076, false,
-	0x2p-1076, false,
-	0x2.0000000000000000000000000002p-1076, false),
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x2p-1076, false, false,
+	0x2p-1076, false, false,
+	0x2p-1076, false, false,
+	0x2.0000000000000004p-1076, false, false,
+	false,
+	0x2p-1076, false, false,
+	0x2p-1076, false, false,
+	0x2p-1076, false, false,
+	0x2.0000000000000004p-1076, false, false,
+	false,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x2p-1076, false, false,
+	0x2p-1076, false, false,
+	0x2p-1076, false, false,
+	0x2.0000000000000000000000000002p-1076, false, false),
   TEST ("-2.470328229206232720882843964341106861825299013071623822127"
 	"928412503377536351043759326499181808179961898982823477228588"
 	"654633283551779698981993873980053909390631503565951557022639"
@@ -7464,35 +7464,35 @@ static const struct test tests[] = {
 	"477918694866799496832404970582102851318545139621383772282614"
 	"5437693412532098591327667236328124e-324",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x2p-1076, false,
-	-0x2p-1076, false,
-	-0x1.fffffffffffffffep-1076, false,
-	-0x1.fffffffffffffffep-1076, false,
-	false,
-	-0x2p-1076, false,
-	-0x2p-1076, false,
-	-0x1.fffffffffffffffep-1076, false,
-	-0x1.fffffffffffffffep-1076, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x2p-1076, false,
-	-0x2p-1076, false,
-	-0x1.ffffffffffffffffffffffffffffp-1076, false,
-	-0x1.ffffffffffffffffffffffffffffp-1076, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x2p-1076, false, false,
+	-0x2p-1076, false, false,
+	-0x1.fffffffffffffffep-1076, false, false,
+	-0x1.fffffffffffffffep-1076, false, false,
+	false,
+	-0x2p-1076, false, false,
+	-0x2p-1076, false, false,
+	-0x1.fffffffffffffffep-1076, false, false,
+	-0x1.fffffffffffffffep-1076, false, false,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x2p-1076, false, false,
+	-0x2p-1076, false, false,
+	-0x1.ffffffffffffffffffffffffffffp-1076, false, false,
+	-0x1.ffffffffffffffffffffffffffffp-1076, false, false),
   TEST ("-2.470328229206232720882843964341106861825299013071623822127"
 	"928412503377536351043759326499181808179961898982823477228588"
 	"654633283551779698981993873980053909390631503565951557022639"
@@ -7507,35 +7507,35 @@ static const struct test tests[] = {
 	"477918694866799496832404970582102851318545139621383772282614"
 	"5437693412532098591327667236328125e-324",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	true,
-	-0x2p-1076, false,
-	-0x2p-1076, false,
-	-0x2p-1076, false,
-	-0x2p-1076, false,
-	true,
-	-0x2p-1076, false,
-	-0x2p-1076, false,
-	-0x2p-1076, false,
-	-0x2p-1076, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	true,
-	-0x2p-1076, false,
-	-0x2p-1076, false,
-	-0x2p-1076, false,
-	-0x2p-1076, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	true,
+	-0x2p-1076, false, false,
+	-0x2p-1076, false, false,
+	-0x2p-1076, false, false,
+	-0x2p-1076, false, false,
+	true,
+	-0x2p-1076, false, false,
+	-0x2p-1076, false, false,
+	-0x2p-1076, false, false,
+	-0x2p-1076, false, false,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	true,
+	-0x2p-1076, false, false,
+	-0x2p-1076, false, false,
+	-0x2p-1076, false, false,
+	-0x2p-1076, false, false),
   TEST ("-2.470328229206232720882843964341106861825299013071623822127"
 	"928412503377536351043759326499181808179961898982823477228588"
 	"654633283551779698981993873980053909390631503565951557022639"
@@ -7550,35 +7550,35 @@ static const struct test tests[] = {
 	"477918694866799496832404970582102851318545139621383772282614"
 	"5437693412532098591327667236328126e-324",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x2.0000000000000004p-1076, false,
-	-0x2p-1076, false,
-	-0x2p-1076, false,
-	-0x2p-1076, false,
-	false,
-	-0x2.0000000000000004p-1076, false,
-	-0x2p-1076, false,
-	-0x2p-1076, false,
-	-0x2p-1076, false,
-	false,
-	-0x4p-1076, false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x2.0000000000000000000000000002p-1076, false,
-	-0x2p-1076, false,
-	-0x2p-1076, false,
-	-0x2p-1076, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x2.0000000000000004p-1076, false, false,
+	-0x2p-1076, false, false,
+	-0x2p-1076, false, false,
+	-0x2p-1076, false, false,
+	false,
+	-0x2.0000000000000004p-1076, false, false,
+	-0x2p-1076, false, false,
+	-0x2p-1076, false, false,
+	-0x2p-1076, false, false,
+	false,
+	-0x4p-1076, false, true,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x2.0000000000000000000000000002p-1076, false, false,
+	-0x2p-1076, false, false,
+	-0x2p-1076, false, false,
+	-0x2p-1076, false, false),
   TEST ("1.8225997659412373012642029668097099081995254078467816718604"
 	"902435141858443166988684047803543129136025986236736736017655"
 	"509834928163110160849867540377949045027419112905889658392846"
@@ -7772,35 +7772,35 @@ static const struct test tests[] = {
 	"622089641993900896756734276531931450266972752637997248151974"
 	"2277811246822238899767398834228515624e-4951",
 	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-152, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-16448, false,
-	false,
-	0x0p+0, false,
-	0x4p-16448, false,
-	0x0p+0, false,
-	0x4p-16448, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0x3.fffffffffffcp-16448, false,
-	0x4p-16448, false,
-	0x3.fffffffffffcp-16448, false,
-	0x4p-16448, false),
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-16448, false, true,
+	false,
+	0x0p+0, false, true,
+	0x4p-16448, false, true,
+	0x0p+0, false, true,
+	0x4p-16448, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x3.fffffffffffcp-16448, false, true,
+	0x4p-16448, false, true,
+	0x3.fffffffffffcp-16448, false, true,
+	0x4p-16448, false, true),
   TEST ("1.8225997659412373012642029668097099081995254078467816718604"
 	"902435141858443166988684047803543129136025986236736736017655"
 	"509834928163110160849867540377949045027419112905889658392846"
@@ -7994,35 +7994,35 @@ static const struct test tests[] = {
 	"622089641993900896756734276531931450266972752637997248151974"
 	"2277811246822238899767398834228515625e-4951",
 	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-152, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-16448, false,
-	true,
-	0x4p-16448, false,
-	0x4p-16448, false,
-	0x4p-16448, false,
-	0x4p-16448, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	true,
-	0x4p-16448, false,
-	0x4p-16448, false,
-	0x4p-16448, false,
-	0x4p-16448, false),
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-16448, false, true,
+	true,
+	0x4p-16448, false, false,
+	0x4p-16448, false, false,
+	0x4p-16448, false, false,
+	0x4p-16448, false, false,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	true,
+	0x4p-16448, false, false,
+	0x4p-16448, false, false,
+	0x4p-16448, false, false,
+	0x4p-16448, false, false),
   TEST ("1.8225997659412373012642029668097099081995254078467816718604"
 	"902435141858443166988684047803543129136025986236736736017655"
 	"509834928163110160849867540377949045027419112905889658392846"
@@ -8216,35 +8216,35 @@ static const struct test tests[] = {
 	"622089641993900896756734276531931450266972752637997248151974"
 	"2277811246822238899767398834228515626e-4951",
 	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-152, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0x0p+0, false,
-	0x8p-16448, false,
-	0x0p+0, false,
-	0x8p-16448, false,
-	false,
-	0x4p-16448, false,
-	0x4p-16448, false,
-	0x4p-16448, false,
-	0x8p-16448, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0x4p-16448, false,
-	0x4p-16448, false,
-	0x4p-16448, false,
-	0x4.000000000004p-16448, false),
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x0p+0, false, true,
+	0x8p-16448, false, true,
+	0x0p+0, false, true,
+	0x8p-16448, false, true,
+	false,
+	0x4p-16448, false, true,
+	0x4p-16448, false, true,
+	0x4p-16448, false, true,
+	0x8p-16448, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x4p-16448, false, true,
+	0x4p-16448, false, true,
+	0x4p-16448, false, true,
+	0x4.000000000004p-16448, false, true),
   TEST ("-1.822599765941237301264202966809709908199525407846781671860"
 	"490243514185844316698868404780354312913602598623673673601765"
 	"550983492816311016084986754037794904502741911290588965839284"
@@ -8438,35 +8438,35 @@ static const struct test tests[] = {
 	"462208964199390089675673427653193145026697275263799724815197"
 	"42277811246822238899767398834228515624e-4951",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x8p-16448, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-16448, false,
-	-0x4p-16448, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-16448, false,
-	-0x4p-16448, false,
-	-0x3.fffffffffffcp-16448, false,
-	-0x3.fffffffffffcp-16448, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x8p-16448, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-16448, false, true,
+	-0x4p-16448, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-16448, false, true,
+	-0x4p-16448, false, true,
+	-0x3.fffffffffffcp-16448, false, true,
+	-0x3.fffffffffffcp-16448, false, true),
   TEST ("-1.822599765941237301264202966809709908199525407846781671860"
 	"490243514185844316698868404780354312913602598623673673601765"
 	"550983492816311016084986754037794904502741911290588965839284"
@@ -8660,35 +8660,35 @@ static const struct test tests[] = {
 	"462208964199390089675673427653193145026697275263799724815197"
 	"42277811246822238899767398834228515625e-4951",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x8p-16448, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	true,
-	-0x4p-16448, false,
-	-0x4p-16448, false,
-	-0x4p-16448, false,
-	-0x4p-16448, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	true,
-	-0x4p-16448, false,
-	-0x4p-16448, false,
-	-0x4p-16448, false,
-	-0x4p-16448, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x8p-16448, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	true,
+	-0x4p-16448, false, false,
+	-0x4p-16448, false, false,
+	-0x4p-16448, false, false,
+	-0x4p-16448, false, false,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	true,
+	-0x4p-16448, false, false,
+	-0x4p-16448, false, false,
+	-0x4p-16448, false, false,
+	-0x4p-16448, false, false),
   TEST ("-1.822599765941237301264202966809709908199525407846781671860"
 	"490243514185844316698868404780354312913602598623673673601765"
 	"550983492816311016084986754037794904502741911290588965839284"
@@ -8882,35 +8882,35 @@ static const struct test tests[] = {
 	"462208964199390089675673427653193145026697275263799724815197"
 	"42277811246822238899767398834228515626e-4951",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x8p-16448, false,
-	-0x8p-16448, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x8p-16448, false,
-	-0x4p-16448, false,
-	-0x4p-16448, false,
-	-0x4p-16448, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4.000000000004p-16448, false,
-	-0x4p-16448, false,
-	-0x4p-16448, false,
-	-0x4p-16448, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x8p-16448, false, true,
+	-0x8p-16448, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x8p-16448, false, true,
+	-0x4p-16448, false, true,
+	-0x4p-16448, false, true,
+	-0x4p-16448, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4.000000000004p-16448, false, true,
+	-0x4p-16448, false, true,
+	-0x4p-16448, false, true,
+	-0x4p-16448, false, true),
   TEST ("9.1129988297061865063210148340485495409976270392339083593024"
 	"512175709292215834943420239017715645680129931183683680088277"
 	"549174640815550804249337701889745225137095564529448291964230"
@@ -9104,35 +9104,35 @@ static const struct test tests[] = {
 	"110448209969504483783671382659657251334863763189986240759871"
 	"1389056234111194498836994171142578124e-4952",
 	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-152, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-16448, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-16448, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0x1.fffffffffffcp-16448, false,
-	0x2p-16448, false,
-	0x1.fffffffffffcp-16448, false,
-	0x2p-16448, false),
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-16448, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-16448, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x1.fffffffffffcp-16448, false, true,
+	0x2p-16448, false, true,
+	0x1.fffffffffffcp-16448, false, true,
+	0x2p-16448, false, true),
   TEST ("9.1129988297061865063210148340485495409976270392339083593024"
 	"512175709292215834943420239017715645680129931183683680088277"
 	"549174640815550804249337701889745225137095564529448291964230"
@@ -9326,35 +9326,35 @@ static const struct test tests[] = {
 	"110448209969504483783671382659657251334863763189986240759871"
 	"1389056234111194498836994171142578125e-4952",
 	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-152, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-16448, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-16448, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	true,
-	0x2p-16448, false,
-	0x2p-16448, false,
-	0x2p-16448, false,
-	0x2p-16448, false),
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-16448, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-16448, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	true,
+	0x2p-16448, false, false,
+	0x2p-16448, false, false,
+	0x2p-16448, false, false,
+	0x2p-16448, false, false),
   TEST ("9.1129988297061865063210148340485495409976270392339083593024"
 	"512175709292215834943420239017715645680129931183683680088277"
 	"549174640815550804249337701889745225137095564529448291964230"
@@ -9548,35 +9548,35 @@ static const struct test tests[] = {
 	"110448209969504483783671382659657251334863763189986240759871"
 	"1389056234111194498836994171142578126e-4952",
 	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-152, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-16448, false,
-	false,
-	0x0p+0, false,
-	0x4p-16448, false,
-	0x0p+0, false,
-	0x4p-16448, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0x2p-16448, false,
-	0x2p-16448, false,
-	0x2p-16448, false,
-	0x2.000000000004p-16448, false),
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-16448, false, true,
+	false,
+	0x0p+0, false, true,
+	0x4p-16448, false, true,
+	0x0p+0, false, true,
+	0x4p-16448, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x2p-16448, false, true,
+	0x2p-16448, false, true,
+	0x2p-16448, false, true,
+	0x2.000000000004p-16448, false, true),
   TEST ("-9.112998829706186506321014834048549540997627039233908359302"
 	"451217570929221583494342023901771564568012993118368368008827"
 	"754917464081555080424933770188974522513709556452944829196423"
@@ -9770,35 +9770,35 @@ static const struct test tests[] = {
 	"311044820996950448378367138265965725133486376318998624075987"
 	"11389056234111194498836994171142578124e-4952",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x8p-16448, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-16448, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x2p-16448, false,
-	-0x2p-16448, false,
-	-0x1.fffffffffffcp-16448, false,
-	-0x1.fffffffffffcp-16448, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x8p-16448, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-16448, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x2p-16448, false, true,
+	-0x2p-16448, false, true,
+	-0x1.fffffffffffcp-16448, false, true,
+	-0x1.fffffffffffcp-16448, false, true),
   TEST ("-9.112998829706186506321014834048549540997627039233908359302"
 	"451217570929221583494342023901771564568012993118368368008827"
 	"754917464081555080424933770188974522513709556452944829196423"
@@ -9992,35 +9992,35 @@ static const struct test tests[] = {
 	"311044820996950448378367138265965725133486376318998624075987"
 	"11389056234111194498836994171142578125e-4952",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x8p-16448, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-16448, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	true,
-	-0x2p-16448, false,
-	-0x2p-16448, false,
-	-0x2p-16448, false,
-	-0x2p-16448, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x8p-16448, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-16448, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	true,
+	-0x2p-16448, false, false,
+	-0x2p-16448, false, false,
+	-0x2p-16448, false, false,
+	-0x2p-16448, false, false),
   TEST ("-9.112998829706186506321014834048549540997627039233908359302"
 	"451217570929221583494342023901771564568012993118368368008827"
 	"754917464081555080424933770188974522513709556452944829196423"
@@ -10214,35 +10214,35 @@ static const struct test tests[] = {
 	"311044820996950448378367138265965725133486376318998624075987"
 	"11389056234111194498836994171142578126e-4952",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x8p-16448, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-16448, false,
-	-0x4p-16448, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x2.000000000004p-16448, false,
-	-0x2p-16448, false,
-	-0x2p-16448, false,
-	-0x2p-16448, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x8p-16448, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-16448, false, true,
+	-0x4p-16448, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x2.000000000004p-16448, false, true,
+	-0x2p-16448, false, true,
+	-0x2p-16448, false, true,
+	-0x2p-16448, false, true),
   TEST ("3.2375875597190125554622194791138232762497846690173405048449"
 	"421945985197700620596855088357456383249701279390707384240598"
 	"382936099431912710233425550359863089915213963553756674672083"
@@ -10437,35 +10437,35 @@ static const struct test tests[] = {
 	"182358152808745703724362178773168996492870519432472065091133"
 	"11767578124e-4966",
 	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-152, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-16448, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-16448, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-16496, false),
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-16448, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-16448, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-16496, false, true),
   TEST ("3.2375875597190125554622194791138232762497846690173405048449"
 	"421945985197700620596855088357456383249701279390707384240598"
 	"382936099431912710233425550359863089915213963553756674672083"
@@ -10660,35 +10660,35 @@ static const struct test tests[] = {
 	"182358152808745703724362178773168996492870519432472065091133"
 	"11767578125e-4966",
 	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-152, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-16448, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-16448, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-16496, false),
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-16448, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-16448, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-16496, false, true),
   TEST ("3.2375875597190125554622194791138232762497846690173405048449"
 	"421945985197700620596855088357456383249701279390707384240598"
 	"382936099431912710233425550359863089915213963553756674672083"
@@ -10883,35 +10883,35 @@ static const struct test tests[] = {
 	"182358152808745703724362178773168996492870519432472065091133"
 	"11767578126e-4966",
 	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-152, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x8p-16448, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-16448, false,
-	false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x0p+0, false,
-	0x4p-1076, false,
-	false,
-	0x0p+0, false,
-	0x4p-16496, false,
-	0x0p+0, false,
-	0x4p-16496, false),
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-16448, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-16448, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x0p+0, false, true,
+	0x4p-16496, false, true,
+	0x0p+0, false, true,
+	0x4p-16496, false, true),
   TEST ("-3.237587559719012555462219479113823276249784669017340504844"
 	"942194598519770062059685508835745638324970127939070738424059"
 	"838293609943191271023342555035986308991521396355375667467208"
@@ -11106,35 +11106,35 @@ static const struct test tests[] = {
 	"218235815280874570372436217877316899649287051943247206509113"
 	"311767578124e-4966",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x8p-16448, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-16448, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-16496, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x8p-16448, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-16448, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-16496, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true),
   TEST ("-3.237587559719012555462219479113823276249784669017340504844"
 	"942194598519770062059685508835745638324970127939070738424059"
 	"838293609943191271023342555035986308991521396355375667467208"
@@ -11329,35 +11329,35 @@ static const struct test tests[] = {
 	"218235815280874570372436217877316899649287051943247206509113"
 	"311767578125e-4966",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x8p-16448, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-16448, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-16496, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x8p-16448, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-16448, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-16496, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true),
   TEST ("-3.237587559719012555462219479113823276249784669017340504844"
 	"942194598519770062059685508835745638324970127939070738424059"
 	"838293609943191271023342555035986308991521396355375667467208"
@@ -11552,66 +11552,66 @@ static const struct test tests[] = {
 	"218235815280874570372436217877316899649287051943247206509113"
 	"311767578126e-4966",
 	false,
-	-0x8p-152, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x8p-16448, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-16448, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-1076, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	-0x0p+0, false,
-	false,
-	-0x4p-16496, false,
-	-0x4p-16496, false,
-	-0x0p+0, false,
-	-0x0p+0, false),
+	-0x8p-152, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x8p-16448, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-16448, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-1076, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true,
+	false,
+	-0x4p-16496, false, true,
+	-0x4p-16496, false, true,
+	-0x0p+0, false, true,
+	-0x0p+0, false, true),
   TEST ("340282366920938463463374607431768211455",
 	false,
-	0xf.fffffp+124, false,
-	INF, true,
-	0xf.fffffp+124, false,
-	INF, true,
-	false,
-	0xf.ffffffffffff8p+124, false,
-	0x1p+128, false,
-	0xf.ffffffffffff8p+124, false,
-	0x1p+128, false,
-	false,
-	0xf.fffffffffffffffp+124, false,
-	0x1p+128, false,
-	0xf.fffffffffffffffp+124, false,
-	0x1p+128, false,
-	false,
-	0xf.fffffffffffffffp+124, false,
-	0x1p+128, false,
-	0xf.fffffffffffffffp+124, false,
-	0x1p+128, false,
-	false,
-	0xf.fffffffffffffffffffffffffcp+124, false,
-	0x1p+128, false,
-	0xf.fffffffffffffffffffffffffcp+124, false,
-	0x1p+128, false,
-	false,
-	0xf.fffffffffffffffffffffffffff8p+124, false,
-	0x1p+128, false,
-	0xf.fffffffffffffffffffffffffff8p+124, false,
-	0x1p+128, false),
+	0xf.fffffp+124, false, false,
+	INF, true, false,
+	0xf.fffffp+124, false, false,
+	INF, true, false,
+	false,
+	0xf.ffffffffffff8p+124, false, false,
+	0x1p+128, false, false,
+	0xf.ffffffffffff8p+124, false, false,
+	0x1p+128, false, false,
+	false,
+	0xf.fffffffffffffffp+124, false, false,
+	0x1p+128, false, false,
+	0xf.fffffffffffffffp+124, false, false,
+	0x1p+128, false, false,
+	false,
+	0xf.fffffffffffffffp+124, false, false,
+	0x1p+128, false, false,
+	0xf.fffffffffffffffp+124, false, false,
+	0x1p+128, false, false,
+	false,
+	0xf.fffffffffffffffffffffffffcp+124, false, false,
+	0x1p+128, false, false,
+	0xf.fffffffffffffffffffffffffcp+124, false, false,
+	0x1p+128, false, false,
+	false,
+	0xf.fffffffffffffffffffffffffff8p+124, false, false,
+	0x1p+128, false, false,
+	0xf.fffffffffffffffffffffffffff8p+124, false, false,
+	0x1p+128, false, false),
   TEST ("179769313486231590772930519078902473361797697894230657273430"
 	"081157732675805500963132708477322407536021120113879871393357"
 	"658789768814416622492847430639474124377767893424865485276302"
@@ -11619,35 +11619,35 @@ static const struct test tests[] = {
 	"540827237163350510684586298239947245938479716304835356329624"
 	"224137215",
 	false,
-	0xf.fffffp+124, true,
-	INF, true,
-	0xf.fffffp+124, true,
-	INF, true,
-	false,
-	0xf.ffffffffffff8p+1020, false,
-	INF, true,
-	0xf.ffffffffffff8p+1020, false,
-	INF, true,
-	false,
-	0xf.fffffffffffffffp+1020, false,
-	0x1p+1024, false,
-	0xf.fffffffffffffffp+1020, false,
-	0x1p+1024, false,
-	false,
-	0xf.fffffffffffffffp+1020, false,
-	0x1p+1024, false,
-	0xf.fffffffffffffffp+1020, false,
-	0x1p+1024, false,
-	false,
-	0xf.fffffffffffffffffffffffffcp+1020, true,
-	INF, true,
-	0xf.fffffffffffffffffffffffffcp+1020, true,
-	INF, true,
-	false,
-	0xf.fffffffffffffffffffffffffff8p+1020, false,
-	0x1p+1024, false,
-	0xf.fffffffffffffffffffffffffff8p+1020, false,
-	0x1p+1024, false),
+	0xf.fffffp+124, true, false,
+	INF, true, false,
+	0xf.fffffp+124, true, false,
+	INF, true, false,
+	false,
+	0xf.ffffffffffff8p+1020, false, false,
+	INF, true, false,
+	0xf.ffffffffffff8p+1020, false, false,
+	INF, true, false,
+	false,
+	0xf.fffffffffffffffp+1020, false, false,
+	0x1p+1024, false, false,
+	0xf.fffffffffffffffp+1020, false, false,
+	0x1p+1024, false, false,
+	false,
+	0xf.fffffffffffffffp+1020, false, false,
+	0x1p+1024, false, false,
+	0xf.fffffffffffffffp+1020, false, false,
+	0x1p+1024, false, false,
+	false,
+	0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	INF, true, false,
+	0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	INF, true, false,
+	false,
+	0xf.fffffffffffffffffffffffffff8p+1020, false, false,
+	0x1p+1024, false, false,
+	0xf.fffffffffffffffffffffffffff8p+1020, false, false,
+	0x1p+1024, false, false),
   TEST ("118973149535723176508575932662800713076344468709651023747267"
 	"482123326135818048368690448859547261203991511543748483930925"
 	"889766738130868742627452469834156500608087163436600489752214"
@@ -11732,66 +11732,66 @@ static const struct test tests[] = {
 	"047398248889922809181821393428829567971736994315246044702729"
 	"0669964066815",
 	false,
-	0xf.fffffp+124, true,
-	INF, true,
-	0xf.fffffp+124, true,
-	INF, true,
-	false,
-	0xf.ffffffffffff8p+1020, true,
-	INF, true,
-	0xf.ffffffffffff8p+1020, true,
-	INF, true,
-	false,
-	0xf.fffffffffffffffp+16380, false,
-	INF, true,
-	0xf.fffffffffffffffp+16380, false,
-	INF, true,
-	false,
-	0xf.fffffffffffffffp+16380, false,
-	INF, true,
-	0xf.fffffffffffffffp+16380, false,
-	INF, true,
-	false,
-	0xf.fffffffffffffffffffffffffcp+1020, true,
-	INF, true,
-	0xf.fffffffffffffffffffffffffcp+1020, true,
-	INF, true,
-	false,
-	0xf.fffffffffffffffffffffffffff8p+16380, false,
-	INF, true,
-	0xf.fffffffffffffffffffffffffff8p+16380, false,
-	INF, true),
+	0xf.fffffp+124, true, false,
+	INF, true, false,
+	0xf.fffffp+124, true, false,
+	INF, true, false,
+	false,
+	0xf.ffffffffffff8p+1020, true, false,
+	INF, true, false,
+	0xf.ffffffffffff8p+1020, true, false,
+	INF, true, false,
+	false,
+	0xf.fffffffffffffffp+16380, false, false,
+	INF, true, false,
+	0xf.fffffffffffffffp+16380, false, false,
+	INF, true, false,
+	false,
+	0xf.fffffffffffffffp+16380, false, false,
+	INF, true, false,
+	0xf.fffffffffffffffp+16380, false, false,
+	INF, true, false,
+	false,
+	0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	INF, true, false,
+	0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	INF, true, false,
+	false,
+	0xf.fffffffffffffffffffffffffff8p+16380, false, false,
+	INF, true, false,
+	0xf.fffffffffffffffffffffffffff8p+16380, false, false,
+	INF, true, false),
   TEST ("-340282366920938463463374607431768211455",
 	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffp+124, false,
-	-0xf.fffffp+124, false,
-	false,
-	-0x1p+128, false,
-	-0x1p+128, false,
-	-0xf.ffffffffffff8p+124, false,
-	-0xf.ffffffffffff8p+124, false,
-	false,
-	-0x1p+128, false,
-	-0x1p+128, false,
-	-0xf.fffffffffffffffp+124, false,
-	-0xf.fffffffffffffffp+124, false,
-	false,
-	-0x1p+128, false,
-	-0x1p+128, false,
-	-0xf.fffffffffffffffp+124, false,
-	-0xf.fffffffffffffffp+124, false,
-	false,
-	-0x1p+128, false,
-	-0x1p+128, false,
-	-0xf.fffffffffffffffffffffffffcp+124, false,
-	-0xf.fffffffffffffffffffffffffcp+124, false,
-	false,
-	-0x1p+128, false,
-	-0x1p+128, false,
-	-0xf.fffffffffffffffffffffffffff8p+124, false,
-	-0xf.fffffffffffffffffffffffffff8p+124, false),
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffp+124, false, false,
+	-0xf.fffffp+124, false, false,
+	false,
+	-0x1p+128, false, false,
+	-0x1p+128, false, false,
+	-0xf.ffffffffffff8p+124, false, false,
+	-0xf.ffffffffffff8p+124, false, false,
+	false,
+	-0x1p+128, false, false,
+	-0x1p+128, false, false,
+	-0xf.fffffffffffffffp+124, false, false,
+	-0xf.fffffffffffffffp+124, false, false,
+	false,
+	-0x1p+128, false, false,
+	-0x1p+128, false, false,
+	-0xf.fffffffffffffffp+124, false, false,
+	-0xf.fffffffffffffffp+124, false, false,
+	false,
+	-0x1p+128, false, false,
+	-0x1p+128, false, false,
+	-0xf.fffffffffffffffffffffffffcp+124, false, false,
+	-0xf.fffffffffffffffffffffffffcp+124, false, false,
+	false,
+	-0x1p+128, false, false,
+	-0x1p+128, false, false,
+	-0xf.fffffffffffffffffffffffffff8p+124, false, false,
+	-0xf.fffffffffffffffffffffffffff8p+124, false, false),
   TEST ("-17976931348623159077293051907890247336179769789423065727343"
 	"008115773267580550096313270847732240753602112011387987139335"
 	"765878976881441662249284743063947412437776789342486548527630"
@@ -11799,35 +11799,35 @@ static const struct test tests[] = {
 	"054082723716335051068458629823994724593847971630483535632962"
 	"4224137215",
 	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffp+124, true,
-	-0xf.fffffp+124, true,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.ffffffffffff8p+1020, false,
-	-0xf.ffffffffffff8p+1020, false,
-	false,
-	-0x1p+1024, false,
-	-0x1p+1024, false,
-	-0xf.fffffffffffffffp+1020, false,
-	-0xf.fffffffffffffffp+1020, false,
-	false,
-	-0x1p+1024, false,
-	-0x1p+1024, false,
-	-0xf.fffffffffffffffp+1020, false,
-	-0xf.fffffffffffffffp+1020, false,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffffffffffffffffffffffcp+1020, true,
-	-0xf.fffffffffffffffffffffffffcp+1020, true,
-	false,
-	-0x1p+1024, false,
-	-0x1p+1024, false,
-	-0xf.fffffffffffffffffffffffffff8p+1020, false,
-	-0xf.fffffffffffffffffffffffffff8p+1020, false),
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffp+124, true, false,
+	-0xf.fffffp+124, true, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.ffffffffffff8p+1020, false, false,
+	-0xf.ffffffffffff8p+1020, false, false,
+	false,
+	-0x1p+1024, false, false,
+	-0x1p+1024, false, false,
+	-0xf.fffffffffffffffp+1020, false, false,
+	-0xf.fffffffffffffffp+1020, false, false,
+	false,
+	-0x1p+1024, false, false,
+	-0x1p+1024, false, false,
+	-0xf.fffffffffffffffp+1020, false, false,
+	-0xf.fffffffffffffffp+1020, false, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	-0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	false,
+	-0x1p+1024, false, false,
+	-0x1p+1024, false, false,
+	-0xf.fffffffffffffffffffffffffff8p+1020, false, false,
+	-0xf.fffffffffffffffffffffffffff8p+1020, false, false),
   TEST ("-11897314953572317650857593266280071307634446870965102374726"
 	"748212332613581804836869044885954726120399151154374848393092"
 	"588976673813086874262745246983415650060808716343660048975221"
@@ -11912,3529 +11912,3901 @@ static const struct test tests[] = {
 	"904739824888992280918182139342882956797173699431524604470272"
 	"90669964066815",
 	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffp+124, true,
-	-0xf.fffffp+124, true,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.ffffffffffff8p+1020, true,
-	-0xf.ffffffffffff8p+1020, true,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffffffffffffp+16380, false,
-	-0xf.fffffffffffffffp+16380, false,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffffffffffffp+16380, false,
-	-0xf.fffffffffffffffp+16380, false,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffffffffffffffffffffffcp+1020, true,
-	-0xf.fffffffffffffffffffffffffcp+1020, true,
-	false,
-	-INF, true,
-	-INF, true,
-	-0xf.fffffffffffffffffffffffffff8p+16380, false,
-	-0xf.fffffffffffffffffffffffffff8p+16380, false),
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffp+124, true, false,
+	-0xf.fffffp+124, true, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.ffffffffffff8p+1020, true, false,
+	-0xf.ffffffffffff8p+1020, true, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	-0xf.fffffffffffffffp+16380, false, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	-0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	false,
+	-INF, true, false,
+	-INF, true, false,
+	-0xf.fffffffffffffffffffffffffff8p+16380, false, false,
+	-0xf.fffffffffffffffffffffffffff8p+16380, false, false),
   TEST ("+0x.80000000000000000000000000000001p1025",
 	false,
-	0xf.fffffp+124, true,
-	INF, true,
-	0xf.fffffp+124, true,
-	INF, true,
-	false,
-	0xf.ffffffffffff8p+1020, true,
-	INF, true,
-	0xf.ffffffffffff8p+1020, true,
-	INF, true,
-	false,
-	0x1p+1024, false,
-	0x1p+1024, false,
-	0x1p+1024, false,
-	0x1.0000000000000002p+1024, false,
-	false,
-	0x1p+1024, false,
-	0x1p+1024, false,
-	0x1p+1024, false,
-	0x1.0000000000000002p+1024, false,
-	false,
-	0xf.fffffffffffffffffffffffffcp+1020, true,
-	INF, true,
-	0xf.fffffffffffffffffffffffffcp+1020, true,
-	INF, true,
-	false,
-	0x1p+1024, false,
-	0x1p+1024, false,
-	0x1p+1024, false,
-	0x1.0000000000000000000000000001p+1024, false),
+	0xf.fffffp+124, true, false,
+	INF, true, false,
+	0xf.fffffp+124, true, false,
+	INF, true, false,
+	false,
+	0xf.ffffffffffff8p+1020, true, false,
+	INF, true, false,
+	0xf.ffffffffffff8p+1020, true, false,
+	INF, true, false,
+	false,
+	0x1p+1024, false, false,
+	0x1p+1024, false, false,
+	0x1p+1024, false, false,
+	0x1.0000000000000002p+1024, false, false,
+	false,
+	0x1p+1024, false, false,
+	0x1p+1024, false, false,
+	0x1p+1024, false, false,
+	0x1.0000000000000002p+1024, false, false,
+	false,
+	0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	INF, true, false,
+	0xf.fffffffffffffffffffffffffcp+1020, true, false,
+	INF, true, false,
+	false,
+	0x1p+1024, false, false,
+	0x1p+1024, false, false,
+	0x1p+1024, false, false,
+	0x1.0000000000000000000000000001p+1024, false, false),
   TEST ("1.5",
 	true,
-	0x1.8p+0, false,
-	0x1.8p+0, false,
-	0x1.8p+0, false,
-	0x1.8p+0, false,
-	true,
-	0x1.8p+0, false,
-	0x1.8p+0, false,
-	0x1.8p+0, false,
-	0x1.8p+0, false,
-	true,
-	0x1.8p+0, false,
-	0x1.8p+0, false,
-	0x1.8p+0, false,
-	0x1.8p+0, false,
-	true,
-	0x1.8p+0, false,
-	0x1.8p+0, false,
-	0x1.8p+0, false,
-	0x1.8p+0, false,
-	true,
-	0x1.8p+0, false,
-	0x1.8p+0, false,
-	0x1.8p+0, false,
-	0x1.8p+0, false,
-	true,
-	0x1.8p+0, false,
-	0x1.8p+0, false,
-	0x1.8p+0, false,
-	0x1.8p+0, false),
+	0x1.8p+0, false, false,
+	0x1.8p+0, false, false,
+	0x1.8p+0, false, false,
+	0x1.8p+0, false, false,
+	true,
+	0x1.8p+0, false, false,
+	0x1.8p+0, false, false,
+	0x1.8p+0, false, false,
+	0x1.8p+0, false, false,
+	true,
+	0x1.8p+0, false, false,
+	0x1.8p+0, false, false,
+	0x1.8p+0, false, false,
+	0x1.8p+0, false, false,
+	true,
+	0x1.8p+0, false, false,
+	0x1.8p+0, false, false,
+	0x1.8p+0, false, false,
+	0x1.8p+0, false, false,
+	true,
+	0x1.8p+0, false, false,
+	0x1.8p+0, false, false,
+	0x1.8p+0, false, false,
+	0x1.8p+0, false, false,
+	true,
+	0x1.8p+0, false, false,
+	0x1.8p+0, false, false,
+	0x1.8p+0, false, false,
+	0x1.8p+0, false, false),
   TEST ("1.25",
 	true,
-	0x1.4p+0, false,
-	0x1.4p+0, false,
-	0x1.4p+0, false,
-	0x1.4p+0, false,
-	true,
-	0x1.4p+0, false,
-	0x1.4p+0, false,
-	0x1.4p+0, false,
-	0x1.4p+0, false,
-	true,
-	0x1.4p+0, false,
-	0x1.4p+0, false,
-	0x1.4p+0, false,
-	0x1.4p+0, false,
-	true,
-	0x1.4p+0, false,
-	0x1.4p+0, false,
-	0x1.4p+0, false,
-	0x1.4p+0, false,
-	true,
-	0x1.4p+0, false,
-	0x1.4p+0, false,
-	0x1.4p+0, false,
-	0x1.4p+0, false,
-	true,
-	0x1.4p+0, false,
-	0x1.4p+0, false,
-	0x1.4p+0, false,
-	0x1.4p+0, false),
+	0x1.4p+0, false, false,
+	0x1.4p+0, false, false,
+	0x1.4p+0, false, false,
+	0x1.4p+0, false, false,
+	true,
+	0x1.4p+0, false, false,
+	0x1.4p+0, false, false,
+	0x1.4p+0, false, false,
+	0x1.4p+0, false, false,
+	true,
+	0x1.4p+0, false, false,
+	0x1.4p+0, false, false,
+	0x1.4p+0, false, false,
+	0x1.4p+0, false, false,
+	true,
+	0x1.4p+0, false, false,
+	0x1.4p+0, false, false,
+	0x1.4p+0, false, false,
+	0x1.4p+0, false, false,
+	true,
+	0x1.4p+0, false, false,
+	0x1.4p+0, false, false,
+	0x1.4p+0, false, false,
+	0x1.4p+0, false, false,
+	true,
+	0x1.4p+0, false, false,
+	0x1.4p+0, false, false,
+	0x1.4p+0, false, false,
+	0x1.4p+0, false, false),
   TEST ("1.125",
 	true,
-	0x1.2p+0, false,
-	0x1.2p+0, false,
-	0x1.2p+0, false,
-	0x1.2p+0, false,
-	true,
-	0x1.2p+0, false,
-	0x1.2p+0, false,
-	0x1.2p+0, false,
-	0x1.2p+0, false,
-	true,
-	0x1.2p+0, false,
-	0x1.2p+0, false,
-	0x1.2p+0, false,
-	0x1.2p+0, false,
-	true,
-	0x1.2p+0, false,
-	0x1.2p+0, false,
-	0x1.2p+0, false,
-	0x1.2p+0, false,
-	true,
-	0x1.2p+0, false,
-	0x1.2p+0, false,
-	0x1.2p+0, false,
-	0x1.2p+0, false,
-	true,
-	0x1.2p+0, false,
-	0x1.2p+0, false,
-	0x1.2p+0, false,
-	0x1.2p+0, false),
+	0x1.2p+0, false, false,
+	0x1.2p+0, false, false,
+	0x1.2p+0, false, false,
+	0x1.2p+0, false, false,
+	true,
+	0x1.2p+0, false, false,
+	0x1.2p+0, false, false,
+	0x1.2p+0, false, false,
+	0x1.2p+0, false, false,
+	true,
+	0x1.2p+0, false, false,
+	0x1.2p+0, false, false,
+	0x1.2p+0, false, false,
+	0x1.2p+0, false, false,
+	true,
+	0x1.2p+0, false, false,
+	0x1.2p+0, false, false,
+	0x1.2p+0, false, false,
+	0x1.2p+0, false, false,
+	true,
+	0x1.2p+0, false, false,
+	0x1.2p+0, false, false,
+	0x1.2p+0, false, false,
+	0x1.2p+0, false, false,
+	true,
+	0x1.2p+0, false, false,
+	0x1.2p+0, false, false,
+	0x1.2p+0, false, false,
+	0x1.2p+0, false, false),
   TEST ("1.0625",
 	true,
-	0x1.1p+0, false,
-	0x1.1p+0, false,
-	0x1.1p+0, false,
-	0x1.1p+0, false,
-	true,
-	0x1.1p+0, false,
-	0x1.1p+0, false,
-	0x1.1p+0, false,
-	0x1.1p+0, false,
-	true,
-	0x1.1p+0, false,
-	0x1.1p+0, false,
-	0x1.1p+0, false,
-	0x1.1p+0, false,
-	true,
-	0x1.1p+0, false,
-	0x1.1p+0, false,
-	0x1.1p+0, false,
-	0x1.1p+0, false,
-	true,
-	0x1.1p+0, false,
-	0x1.1p+0, false,
-	0x1.1p+0, false,
-	0x1.1p+0, false,
-	true,
-	0x1.1p+0, false,
-	0x1.1p+0, false,
-	0x1.1p+0, false,
-	0x1.1p+0, false),
+	0x1.1p+0, false, false,
+	0x1.1p+0, false, false,
+	0x1.1p+0, false, false,
+	0x1.1p+0, false, false,
+	true,
+	0x1.1p+0, false, false,
+	0x1.1p+0, false, false,
+	0x1.1p+0, false, false,
+	0x1.1p+0, false, false,
+	true,
+	0x1.1p+0, false, false,
+	0x1.1p+0, false, false,
+	0x1.1p+0, false, false,
+	0x1.1p+0, false, false,
+	true,
+	0x1.1p+0, false, false,
+	0x1.1p+0, false, false,
+	0x1.1p+0, false, false,
+	0x1.1p+0, false, false,
+	true,
+	0x1.1p+0, false, false,
+	0x1.1p+0, false, false,
+	0x1.1p+0, false, false,
+	0x1.1p+0, false, false,
+	true,
+	0x1.1p+0, false, false,
+	0x1.1p+0, false, false,
+	0x1.1p+0, false, false,
+	0x1.1p+0, false, false),
   TEST ("1.03125",
 	true,
-	0x1.08p+0, false,
-	0x1.08p+0, false,
-	0x1.08p+0, false,
-	0x1.08p+0, false,
-	true,
-	0x1.08p+0, false,
-	0x1.08p+0, false,
-	0x1.08p+0, false,
-	0x1.08p+0, false,
-	true,
-	0x1.08p+0, false,
-	0x1.08p+0, false,
-	0x1.08p+0, false,
-	0x1.08p+0, false,
-	true,
-	0x1.08p+0, false,
-	0x1.08p+0, false,
-	0x1.08p+0, false,
-	0x1.08p+0, false,
-	true,
-	0x1.08p+0, false,
-	0x1.08p+0, false,
-	0x1.08p+0, false,
-	0x1.08p+0, false,
-	true,
-	0x1.08p+0, false,
-	0x1.08p+0, false,
-	0x1.08p+0, false,
-	0x1.08p+0, false),
+	0x1.08p+0, false, false,
+	0x1.08p+0, false, false,
+	0x1.08p+0, false, false,
+	0x1.08p+0, false, false,
+	true,
+	0x1.08p+0, false, false,
+	0x1.08p+0, false, false,
+	0x1.08p+0, false, false,
+	0x1.08p+0, false, false,
+	true,
+	0x1.08p+0, false, false,
+	0x1.08p+0, false, false,
+	0x1.08p+0, false, false,
+	0x1.08p+0, false, false,
+	true,
+	0x1.08p+0, false, false,
+	0x1.08p+0, false, false,
+	0x1.08p+0, false, false,
+	0x1.08p+0, false, false,
+	true,
+	0x1.08p+0, false, false,
+	0x1.08p+0, false, false,
+	0x1.08p+0, false, false,
+	0x1.08p+0, false, false,
+	true,
+	0x1.08p+0, false, false,
+	0x1.08p+0, false, false,
+	0x1.08p+0, false, false,
+	0x1.08p+0, false, false),
   TEST ("1.015625",
 	true,
-	0x1.04p+0, false,
-	0x1.04p+0, false,
-	0x1.04p+0, false,
-	0x1.04p+0, false,
-	true,
-	0x1.04p+0, false,
-	0x1.04p+0, false,
-	0x1.04p+0, false,
-	0x1.04p+0, false,
-	true,
-	0x1.04p+0, false,
-	0x1.04p+0, false,
-	0x1.04p+0, false,
-	0x1.04p+0, false,
-	true,
-	0x1.04p+0, false,
-	0x1.04p+0, false,
-	0x1.04p+0, false,
-	0x1.04p+0, false,
-	true,
-	0x1.04p+0, false,
-	0x1.04p+0, false,
-	0x1.04p+0, false,
-	0x1.04p+0, false,
-	true,
-	0x1.04p+0, false,
-	0x1.04p+0, false,
-	0x1.04p+0, false,
-	0x1.04p+0, false),
+	0x1.04p+0, false, false,
+	0x1.04p+0, false, false,
+	0x1.04p+0, false, false,
+	0x1.04p+0, false, false,
+	true,
+	0x1.04p+0, false, false,
+	0x1.04p+0, false, false,
+	0x1.04p+0, false, false,
+	0x1.04p+0, false, false,
+	true,
+	0x1.04p+0, false, false,
+	0x1.04p+0, false, false,
+	0x1.04p+0, false, false,
+	0x1.04p+0, false, false,
+	true,
+	0x1.04p+0, false, false,
+	0x1.04p+0, false, false,
+	0x1.04p+0, false, false,
+	0x1.04p+0, false, false,
+	true,
+	0x1.04p+0, false, false,
+	0x1.04p+0, false, false,
+	0x1.04p+0, false, false,
+	0x1.04p+0, false, false,
+	true,
+	0x1.04p+0, false, false,
+	0x1.04p+0, false, false,
+	0x1.04p+0, false, false,
+	0x1.04p+0, false, false),
   TEST ("1.0078125",
 	true,
-	0x1.02p+0, false,
-	0x1.02p+0, false,
-	0x1.02p+0, false,
-	0x1.02p+0, false,
-	true,
-	0x1.02p+0, false,
-	0x1.02p+0, false,
-	0x1.02p+0, false,
-	0x1.02p+0, false,
-	true,
-	0x1.02p+0, false,
-	0x1.02p+0, false,
-	0x1.02p+0, false,
-	0x1.02p+0, false,
-	true,
-	0x1.02p+0, false,
-	0x1.02p+0, false,
-	0x1.02p+0, false,
-	0x1.02p+0, false,
-	true,
-	0x1.02p+0, false,
-	0x1.02p+0, false,
-	0x1.02p+0, false,
-	0x1.02p+0, false,
-	true,
-	0x1.02p+0, false,
-	0x1.02p+0, false,
-	0x1.02p+0, false,
-	0x1.02p+0, false),
+	0x1.02p+0, false, false,
+	0x1.02p+0, false, false,
+	0x1.02p+0, false, false,
+	0x1.02p+0, false, false,
+	true,
+	0x1.02p+0, false, false,
+	0x1.02p+0, false, false,
+	0x1.02p+0, false, false,
+	0x1.02p+0, false, false,
+	true,
+	0x1.02p+0, false, false,
+	0x1.02p+0, false, false,
+	0x1.02p+0, false, false,
+	0x1.02p+0, false, false,
+	true,
+	0x1.02p+0, false, false,
+	0x1.02p+0, false, false,
+	0x1.02p+0, false, false,
+	0x1.02p+0, false, false,
+	true,
+	0x1.02p+0, false, false,
+	0x1.02p+0, false, false,
+	0x1.02p+0, false, false,
+	0x1.02p+0, false, false,
+	true,
+	0x1.02p+0, false, false,
+	0x1.02p+0, false, false,
+	0x1.02p+0, false, false,
+	0x1.02p+0, false, false),
   TEST ("1.00390625",
 	true,
-	0x1.01p+0, false,
-	0x1.01p+0, false,
-	0x1.01p+0, false,
-	0x1.01p+0, false,
-	true,
-	0x1.01p+0, false,
-	0x1.01p+0, false,
-	0x1.01p+0, false,
-	0x1.01p+0, false,
-	true,
-	0x1.01p+0, false,
-	0x1.01p+0, false,
-	0x1.01p+0, false,
-	0x1.01p+0, false,
-	true,
-	0x1.01p+0, false,
-	0x1.01p+0, false,
-	0x1.01p+0, false,
-	0x1.01p+0, false,
-	true,
-	0x1.01p+0, false,
-	0x1.01p+0, false,
-	0x1.01p+0, false,
-	0x1.01p+0, false,
-	true,
-	0x1.01p+0, false,
-	0x1.01p+0, false,
-	0x1.01p+0, false,
-	0x1.01p+0, false),
+	0x1.01p+0, false, false,
+	0x1.01p+0, false, false,
+	0x1.01p+0, false, false,
+	0x1.01p+0, false, false,
+	true,
+	0x1.01p+0, false, false,
+	0x1.01p+0, false, false,
+	0x1.01p+0, false, false,
+	0x1.01p+0, false, false,
+	true,
+	0x1.01p+0, false, false,
+	0x1.01p+0, false, false,
+	0x1.01p+0, false, false,
+	0x1.01p+0, false, false,
+	true,
+	0x1.01p+0, false, false,
+	0x1.01p+0, false, false,
+	0x1.01p+0, false, false,
+	0x1.01p+0, false, false,
+	true,
+	0x1.01p+0, false, false,
+	0x1.01p+0, false, false,
+	0x1.01p+0, false, false,
+	0x1.01p+0, false, false,
+	true,
+	0x1.01p+0, false, false,
+	0x1.01p+0, false, false,
+	0x1.01p+0, false, false,
+	0x1.01p+0, false, false),
   TEST ("1.001953125",
 	true,
-	0x1.008p+0, false,
-	0x1.008p+0, false,
-	0x1.008p+0, false,
-	0x1.008p+0, false,
-	true,
-	0x1.008p+0, false,
-	0x1.008p+0, false,
-	0x1.008p+0, false,
-	0x1.008p+0, false,
-	true,
-	0x1.008p+0, false,
-	0x1.008p+0, false,
-	0x1.008p+0, false,
-	0x1.008p+0, false,
-	true,
-	0x1.008p+0, false,
-	0x1.008p+0, false,
-	0x1.008p+0, false,
-	0x1.008p+0, false,
-	true,
-	0x1.008p+0, false,
-	0x1.008p+0, false,
-	0x1.008p+0, false,
-	0x1.008p+0, false,
-	true,
-	0x1.008p+0, false,
-	0x1.008p+0, false,
-	0x1.008p+0, false,
-	0x1.008p+0, false),
+	0x1.008p+0, false, false,
+	0x1.008p+0, false, false,
+	0x1.008p+0, false, false,
+	0x1.008p+0, false, false,
+	true,
+	0x1.008p+0, false, false,
+	0x1.008p+0, false, false,
+	0x1.008p+0, false, false,
+	0x1.008p+0, false, false,
+	true,
+	0x1.008p+0, false, false,
+	0x1.008p+0, false, false,
+	0x1.008p+0, false, false,
+	0x1.008p+0, false, false,
+	true,
+	0x1.008p+0, false, false,
+	0x1.008p+0, false, false,
+	0x1.008p+0, false, false,
+	0x1.008p+0, false, false,
+	true,
+	0x1.008p+0, false, false,
+	0x1.008p+0, false, false,
+	0x1.008p+0, false, false,
+	0x1.008p+0, false, false,
+	true,
+	0x1.008p+0, false, false,
+	0x1.008p+0, false, false,
+	0x1.008p+0, false, false,
+	0x1.008p+0, false, false),
   TEST ("1.0009765625",
 	true,
-	0x1.004p+0, false,
-	0x1.004p+0, false,
-	0x1.004p+0, false,
-	0x1.004p+0, false,
-	true,
-	0x1.004p+0, false,
-	0x1.004p+0, false,
-	0x1.004p+0, false,
-	0x1.004p+0, false,
-	true,
-	0x1.004p+0, false,
-	0x1.004p+0, false,
-	0x1.004p+0, false,
-	0x1.004p+0, false,
-	true,
-	0x1.004p+0, false,
-	0x1.004p+0, false,
-	0x1.004p+0, false,
-	0x1.004p+0, false,
-	true,
-	0x1.004p+0, false,
-	0x1.004p+0, false,
-	0x1.004p+0, false,
-	0x1.004p+0, false,
-	true,
-	0x1.004p+0, false,
-	0x1.004p+0, false,
-	0x1.004p+0, false,
-	0x1.004p+0, false),
+	0x1.004p+0, false, false,
+	0x1.004p+0, false, false,
+	0x1.004p+0, false, false,
+	0x1.004p+0, false, false,
+	true,
+	0x1.004p+0, false, false,
+	0x1.004p+0, false, false,
+	0x1.004p+0, false, false,
+	0x1.004p+0, false, false,
+	true,
+	0x1.004p+0, false, false,
+	0x1.004p+0, false, false,
+	0x1.004p+0, false, false,
+	0x1.004p+0, false, false,
+	true,
+	0x1.004p+0, false, false,
+	0x1.004p+0, false, false,
+	0x1.004p+0, false, false,
+	0x1.004p+0, false, false,
+	true,
+	0x1.004p+0, false, false,
+	0x1.004p+0, false, false,
+	0x1.004p+0, false, false,
+	0x1.004p+0, false, false,
+	true,
+	0x1.004p+0, false, false,
+	0x1.004p+0, false, false,
+	0x1.004p+0, false, false,
+	0x1.004p+0, false, false),
   TEST ("1.00048828125",
 	true,
-	0x1.002p+0, false,
-	0x1.002p+0, false,
-	0x1.002p+0, false,
-	0x1.002p+0, false,
-	true,
-	0x1.002p+0, false,
-	0x1.002p+0, false,
-	0x1.002p+0, false,
-	0x1.002p+0, false,
-	true,
-	0x1.002p+0, false,
-	0x1.002p+0, false,
-	0x1.002p+0, false,
-	0x1.002p+0, false,
-	true,
-	0x1.002p+0, false,
-	0x1.002p+0, false,
-	0x1.002p+0, false,
-	0x1.002p+0, false,
-	true,
-	0x1.002p+0, false,
-	0x1.002p+0, false,
-	0x1.002p+0, false,
-	0x1.002p+0, false,
-	true,
-	0x1.002p+0, false,
-	0x1.002p+0, false,
-	0x1.002p+0, false,
-	0x1.002p+0, false),
+	0x1.002p+0, false, false,
+	0x1.002p+0, false, false,
+	0x1.002p+0, false, false,
+	0x1.002p+0, false, false,
+	true,
+	0x1.002p+0, false, false,
+	0x1.002p+0, false, false,
+	0x1.002p+0, false, false,
+	0x1.002p+0, false, false,
+	true,
+	0x1.002p+0, false, false,
+	0x1.002p+0, false, false,
+	0x1.002p+0, false, false,
+	0x1.002p+0, false, false,
+	true,
+	0x1.002p+0, false, false,
+	0x1.002p+0, false, false,
+	0x1.002p+0, false, false,
+	0x1.002p+0, false, false,
+	true,
+	0x1.002p+0, false, false,
+	0x1.002p+0, false, false,
+	0x1.002p+0, false, false,
+	0x1.002p+0, false, false,
+	true,
+	0x1.002p+0, false, false,
+	0x1.002p+0, false, false,
+	0x1.002p+0, false, false,
+	0x1.002p+0, false, false),
   TEST ("1.000244140625",
 	true,
-	0x1.001p+0, false,
-	0x1.001p+0, false,
-	0x1.001p+0, false,
-	0x1.001p+0, false,
-	true,
-	0x1.001p+0, false,
-	0x1.001p+0, false,
-	0x1.001p+0, false,
-	0x1.001p+0, false,
-	true,
-	0x1.001p+0, false,
-	0x1.001p+0, false,
-	0x1.001p+0, false,
-	0x1.001p+0, false,
-	true,
-	0x1.001p+0, false,
-	0x1.001p+0, false,
-	0x1.001p+0, false,
-	0x1.001p+0, false,
-	true,
-	0x1.001p+0, false,
-	0x1.001p+0, false,
-	0x1.001p+0, false,
-	0x1.001p+0, false,
-	true,
-	0x1.001p+0, false,
-	0x1.001p+0, false,
-	0x1.001p+0, false,
-	0x1.001p+0, false),
+	0x1.001p+0, false, false,
+	0x1.001p+0, false, false,
+	0x1.001p+0, false, false,
+	0x1.001p+0, false, false,
+	true,
+	0x1.001p+0, false, false,
+	0x1.001p+0, false, false,
+	0x1.001p+0, false, false,
+	0x1.001p+0, false, false,
+	true,
+	0x1.001p+0, false, false,
+	0x1.001p+0, false, false,
+	0x1.001p+0, false, false,
+	0x1.001p+0, false, false,
+	true,
+	0x1.001p+0, false, false,
+	0x1.001p+0, false, false,
+	0x1.001p+0, false, false,
+	0x1.001p+0, false, false,
+	true,
+	0x1.001p+0, false, false,
+	0x1.001p+0, false, false,
+	0x1.001p+0, false, false,
+	0x1.001p+0, false, false,
+	true,
+	0x1.001p+0, false, false,
+	0x1.001p+0, false, false,
+	0x1.001p+0, false, false,
+	0x1.001p+0, false, false),
   TEST ("1.0001220703125",
 	true,
-	0x1.0008p+0, false,
-	0x1.0008p+0, false,
-	0x1.0008p+0, false,
-	0x1.0008p+0, false,
-	true,
-	0x1.0008p+0, false,
-	0x1.0008p+0, false,
-	0x1.0008p+0, false,
-	0x1.0008p+0, false,
-	true,
-	0x1.0008p+0, false,
-	0x1.0008p+0, false,
-	0x1.0008p+0, false,
-	0x1.0008p+0, false,
-	true,
-	0x1.0008p+0, false,
-	0x1.0008p+0, false,
-	0x1.0008p+0, false,
-	0x1.0008p+0, false,
-	true,
-	0x1.0008p+0, false,
-	0x1.0008p+0, false,
-	0x1.0008p+0, false,
-	0x1.0008p+0, false,
-	true,
-	0x1.0008p+0, false,
-	0x1.0008p+0, false,
-	0x1.0008p+0, false,
-	0x1.0008p+0, false),
+	0x1.0008p+0, false, false,
+	0x1.0008p+0, false, false,
+	0x1.0008p+0, false, false,
+	0x1.0008p+0, false, false,
+	true,
+	0x1.0008p+0, false, false,
+	0x1.0008p+0, false, false,
+	0x1.0008p+0, false, false,
+	0x1.0008p+0, false, false,
+	true,
+	0x1.0008p+0, false, false,
+	0x1.0008p+0, false, false,
+	0x1.0008p+0, false, false,
+	0x1.0008p+0, false, false,
+	true,
+	0x1.0008p+0, false, false,
+	0x1.0008p+0, false, false,
+	0x1.0008p+0, false, false,
+	0x1.0008p+0, false, false,
+	true,
+	0x1.0008p+0, false, false,
+	0x1.0008p+0, false, false,
+	0x1.0008p+0, false, false,
+	0x1.0008p+0, false, false,
+	true,
+	0x1.0008p+0, false, false,
+	0x1.0008p+0, false, false,
+	0x1.0008p+0, false, false,
+	0x1.0008p+0, false, false),
   TEST ("1.00006103515625",
 	true,
-	0x1.0004p+0, false,
-	0x1.0004p+0, false,
-	0x1.0004p+0, false,
-	0x1.0004p+0, false,
-	true,
-	0x1.0004p+0, false,
-	0x1.0004p+0, false,
-	0x1.0004p+0, false,
-	0x1.0004p+0, false,
-	true,
-	0x1.0004p+0, false,
-	0x1.0004p+0, false,
-	0x1.0004p+0, false,
-	0x1.0004p+0, false,
-	true,
-	0x1.0004p+0, false,
-	0x1.0004p+0, false,
-	0x1.0004p+0, false,
-	0x1.0004p+0, false,
-	true,
-	0x1.0004p+0, false,
-	0x1.0004p+0, false,
-	0x1.0004p+0, false,
-	0x1.0004p+0, false,
-	true,
-	0x1.0004p+0, false,
-	0x1.0004p+0, false,
-	0x1.0004p+0, false,
-	0x1.0004p+0, false),
+	0x1.0004p+0, false, false,
+	0x1.0004p+0, false, false,
+	0x1.0004p+0, false, false,
+	0x1.0004p+0, false, false,
+	true,
+	0x1.0004p+0, false, false,
+	0x1.0004p+0, false, false,
+	0x1.0004p+0, false, false,
+	0x1.0004p+0, false, false,
+	true,
+	0x1.0004p+0, false, false,
+	0x1.0004p+0, false, false,
+	0x1.0004p+0, false, false,
+	0x1.0004p+0, false, false,
+	true,
+	0x1.0004p+0, false, false,
+	0x1.0004p+0, false, false,
+	0x1.0004p+0, false, false,
+	0x1.0004p+0, false, false,
+	true,
+	0x1.0004p+0, false, false,
+	0x1.0004p+0, false, false,
+	0x1.0004p+0, false, false,
+	0x1.0004p+0, false, false,
+	true,
+	0x1.0004p+0, false, false,
+	0x1.0004p+0, false, false,
+	0x1.0004p+0, false, false,
+	0x1.0004p+0, false, false),
   TEST ("1.000030517578125",
 	true,
-	0x1.0002p+0, false,
-	0x1.0002p+0, false,
-	0x1.0002p+0, false,
-	0x1.0002p+0, false,
-	true,
-	0x1.0002p+0, false,
-	0x1.0002p+0, false,
-	0x1.0002p+0, false,
-	0x1.0002p+0, false,
-	true,
-	0x1.0002p+0, false,
-	0x1.0002p+0, false,
-	0x1.0002p+0, false,
-	0x1.0002p+0, false,
-	true,
-	0x1.0002p+0, false,
-	0x1.0002p+0, false,
-	0x1.0002p+0, false,
-	0x1.0002p+0, false,
-	true,
-	0x1.0002p+0, false,
-	0x1.0002p+0, false,
-	0x1.0002p+0, false,
-	0x1.0002p+0, false,
-	true,
-	0x1.0002p+0, false,
-	0x1.0002p+0, false,
-	0x1.0002p+0, false,
-	0x1.0002p+0, false),
+	0x1.0002p+0, false, false,
+	0x1.0002p+0, false, false,
+	0x1.0002p+0, false, false,
+	0x1.0002p+0, false, false,
+	true,
+	0x1.0002p+0, false, false,
+	0x1.0002p+0, false, false,
+	0x1.0002p+0, false, false,
+	0x1.0002p+0, false, false,
+	true,
+	0x1.0002p+0, false, false,
+	0x1.0002p+0, false, false,
+	0x1.0002p+0, false, false,
+	0x1.0002p+0, false, false,
+	true,
+	0x1.0002p+0, false, false,
+	0x1.0002p+0, false, false,
+	0x1.0002p+0, false, false,
+	0x1.0002p+0, false, false,
+	true,
+	0x1.0002p+0, false, false,
+	0x1.0002p+0, false, false,
+	0x1.0002p+0, false, false,
+	0x1.0002p+0, false, false,
+	true,
+	0x1.0002p+0, false, false,
+	0x1.0002p+0, false, false,
+	0x1.0002p+0, false, false,
+	0x1.0002p+0, false, false),
   TEST ("1.0000152587890625",
 	true,
-	0x1.0001p+0, false,
-	0x1.0001p+0, false,
-	0x1.0001p+0, false,
-	0x1.0001p+0, false,
-	true,
-	0x1.0001p+0, false,
-	0x1.0001p+0, false,
-	0x1.0001p+0, false,
-	0x1.0001p+0, false,
-	true,
-	0x1.0001p+0, false,
-	0x1.0001p+0, false,
-	0x1.0001p+0, false,
-	0x1.0001p+0, false,
-	true,
-	0x1.0001p+0, false,
-	0x1.0001p+0, false,
-	0x1.0001p+0, false,
-	0x1.0001p+0, false,
-	true,
-	0x1.0001p+0, false,
-	0x1.0001p+0, false,
-	0x1.0001p+0, false,
-	0x1.0001p+0, false,
-	true,
-	0x1.0001p+0, false,
-	0x1.0001p+0, false,
-	0x1.0001p+0, false,
-	0x1.0001p+0, false),
+	0x1.0001p+0, false, false,
+	0x1.0001p+0, false, false,
+	0x1.0001p+0, false, false,
+	0x1.0001p+0, false, false,
+	true,
+	0x1.0001p+0, false, false,
+	0x1.0001p+0, false, false,
+	0x1.0001p+0, false, false,
+	0x1.0001p+0, false, false,
+	true,
+	0x1.0001p+0, false, false,
+	0x1.0001p+0, false, false,
+	0x1.0001p+0, false, false,
+	0x1.0001p+0, false, false,
+	true,
+	0x1.0001p+0, false, false,
+	0x1.0001p+0, false, false,
+	0x1.0001p+0, false, false,
+	0x1.0001p+0, false, false,
+	true,
+	0x1.0001p+0, false, false,
+	0x1.0001p+0, false, false,
+	0x1.0001p+0, false, false,
+	0x1.0001p+0, false, false,
+	true,
+	0x1.0001p+0, false, false,
+	0x1.0001p+0, false, false,
+	0x1.0001p+0, false, false,
+	0x1.0001p+0, false, false),
   TEST ("1.00000762939453125",
 	true,
-	0x1.00008p+0, false,
-	0x1.00008p+0, false,
-	0x1.00008p+0, false,
-	0x1.00008p+0, false,
-	true,
-	0x1.00008p+0, false,
-	0x1.00008p+0, false,
-	0x1.00008p+0, false,
-	0x1.00008p+0, false,
-	true,
-	0x1.00008p+0, false,
-	0x1.00008p+0, false,
-	0x1.00008p+0, false,
-	0x1.00008p+0, false,
-	true,
-	0x1.00008p+0, false,
-	0x1.00008p+0, false,
-	0x1.00008p+0, false,
-	0x1.00008p+0, false,
-	true,
-	0x1.00008p+0, false,
-	0x1.00008p+0, false,
-	0x1.00008p+0, false,
-	0x1.00008p+0, false,
-	true,
-	0x1.00008p+0, false,
-	0x1.00008p+0, false,
-	0x1.00008p+0, false,
-	0x1.00008p+0, false),
+	0x1.00008p+0, false, false,
+	0x1.00008p+0, false, false,
+	0x1.00008p+0, false, false,
+	0x1.00008p+0, false, false,
+	true,
+	0x1.00008p+0, false, false,
+	0x1.00008p+0, false, false,
+	0x1.00008p+0, false, false,
+	0x1.00008p+0, false, false,
+	true,
+	0x1.00008p+0, false, false,
+	0x1.00008p+0, false, false,
+	0x1.00008p+0, false, false,
+	0x1.00008p+0, false, false,
+	true,
+	0x1.00008p+0, false, false,
+	0x1.00008p+0, false, false,
+	0x1.00008p+0, false, false,
+	0x1.00008p+0, false, false,
+	true,
+	0x1.00008p+0, false, false,
+	0x1.00008p+0, false, false,
+	0x1.00008p+0, false, false,
+	0x1.00008p+0, false, false,
+	true,
+	0x1.00008p+0, false, false,
+	0x1.00008p+0, false, false,
+	0x1.00008p+0, false, false,
+	0x1.00008p+0, false, false),
   TEST ("1.000003814697265625",
 	true,
-	0x1.00004p+0, false,
-	0x1.00004p+0, false,
-	0x1.00004p+0, false,
-	0x1.00004p+0, false,
-	true,
-	0x1.00004p+0, false,
-	0x1.00004p+0, false,
-	0x1.00004p+0, false,
-	0x1.00004p+0, false,
-	true,
-	0x1.00004p+0, false,
-	0x1.00004p+0, false,
-	0x1.00004p+0, false,
-	0x1.00004p+0, false,
-	true,
-	0x1.00004p+0, false,
-	0x1.00004p+0, false,
-	0x1.00004p+0, false,
-	0x1.00004p+0, false,
-	true,
-	0x1.00004p+0, false,
-	0x1.00004p+0, false,
-	0x1.00004p+0, false,
-	0x1.00004p+0, false,
-	true,
-	0x1.00004p+0, false,
-	0x1.00004p+0, false,
-	0x1.00004p+0, false,
-	0x1.00004p+0, false),
+	0x1.00004p+0, false, false,
+	0x1.00004p+0, false, false,
+	0x1.00004p+0, false, false,
+	0x1.00004p+0, false, false,
+	true,
+	0x1.00004p+0, false, false,
+	0x1.00004p+0, false, false,
+	0x1.00004p+0, false, false,
+	0x1.00004p+0, false, false,
+	true,
+	0x1.00004p+0, false, false,
+	0x1.00004p+0, false, false,
+	0x1.00004p+0, false, false,
+	0x1.00004p+0, false, false,
+	true,
+	0x1.00004p+0, false, false,
+	0x1.00004p+0, false, false,
+	0x1.00004p+0, false, false,
+	0x1.00004p+0, false, false,
+	true,
+	0x1.00004p+0, false, false,
+	0x1.00004p+0, false, false,
+	0x1.00004p+0, false, false,
+	0x1.00004p+0, false, false,
+	true,
+	0x1.00004p+0, false, false,
+	0x1.00004p+0, false, false,
+	0x1.00004p+0, false, false,
+	0x1.00004p+0, false, false),
   TEST ("1.0000019073486328125",
 	true,
-	0x1.00002p+0, false,
-	0x1.00002p+0, false,
-	0x1.00002p+0, false,
-	0x1.00002p+0, false,
-	true,
-	0x1.00002p+0, false,
-	0x1.00002p+0, false,
-	0x1.00002p+0, false,
-	0x1.00002p+0, false,
-	true,
-	0x1.00002p+0, false,
-	0x1.00002p+0, false,
-	0x1.00002p+0, false,
-	0x1.00002p+0, false,
-	true,
-	0x1.00002p+0, false,
-	0x1.00002p+0, false,
-	0x1.00002p+0, false,
-	0x1.00002p+0, false,
-	true,
-	0x1.00002p+0, false,
-	0x1.00002p+0, false,
-	0x1.00002p+0, false,
-	0x1.00002p+0, false,
-	true,
-	0x1.00002p+0, false,
-	0x1.00002p+0, false,
-	0x1.00002p+0, false,
-	0x1.00002p+0, false),
+	0x1.00002p+0, false, false,
+	0x1.00002p+0, false, false,
+	0x1.00002p+0, false, false,
+	0x1.00002p+0, false, false,
+	true,
+	0x1.00002p+0, false, false,
+	0x1.00002p+0, false, false,
+	0x1.00002p+0, false, false,
+	0x1.00002p+0, false, false,
+	true,
+	0x1.00002p+0, false, false,
+	0x1.00002p+0, false, false,
+	0x1.00002p+0, false, false,
+	0x1.00002p+0, false, false,
+	true,
+	0x1.00002p+0, false, false,
+	0x1.00002p+0, false, false,
+	0x1.00002p+0, false, false,
+	0x1.00002p+0, false, false,
+	true,
+	0x1.00002p+0, false, false,
+	0x1.00002p+0, false, false,
+	0x1.00002p+0, false, false,
+	0x1.00002p+0, false, false,
+	true,
+	0x1.00002p+0, false, false,
+	0x1.00002p+0, false, false,
+	0x1.00002p+0, false, false,
+	0x1.00002p+0, false, false),
   TEST ("1.00000095367431640625",
 	true,
-	0x1.00001p+0, false,
-	0x1.00001p+0, false,
-	0x1.00001p+0, false,
-	0x1.00001p+0, false,
-	true,
-	0x1.00001p+0, false,
-	0x1.00001p+0, false,
-	0x1.00001p+0, false,
-	0x1.00001p+0, false,
-	true,
-	0x1.00001p+0, false,
-	0x1.00001p+0, false,
-	0x1.00001p+0, false,
-	0x1.00001p+0, false,
-	true,
-	0x1.00001p+0, false,
-	0x1.00001p+0, false,
-	0x1.00001p+0, false,
-	0x1.00001p+0, false,
-	true,
-	0x1.00001p+0, false,
-	0x1.00001p+0, false,
-	0x1.00001p+0, false,
-	0x1.00001p+0, false,
-	true,
-	0x1.00001p+0, false,
-	0x1.00001p+0, false,
-	0x1.00001p+0, false,
-	0x1.00001p+0, false),
+	0x1.00001p+0, false, false,
+	0x1.00001p+0, false, false,
+	0x1.00001p+0, false, false,
+	0x1.00001p+0, false, false,
+	true,
+	0x1.00001p+0, false, false,
+	0x1.00001p+0, false, false,
+	0x1.00001p+0, false, false,
+	0x1.00001p+0, false, false,
+	true,
+	0x1.00001p+0, false, false,
+	0x1.00001p+0, false, false,
+	0x1.00001p+0, false, false,
+	0x1.00001p+0, false, false,
+	true,
+	0x1.00001p+0, false, false,
+	0x1.00001p+0, false, false,
+	0x1.00001p+0, false, false,
+	0x1.00001p+0, false, false,
+	true,
+	0x1.00001p+0, false, false,
+	0x1.00001p+0, false, false,
+	0x1.00001p+0, false, false,
+	0x1.00001p+0, false, false,
+	true,
+	0x1.00001p+0, false, false,
+	0x1.00001p+0, false, false,
+	0x1.00001p+0, false, false,
+	0x1.00001p+0, false, false),
   TEST ("1.000000476837158203125",
 	true,
-	0x1.000008p+0, false,
-	0x1.000008p+0, false,
-	0x1.000008p+0, false,
-	0x1.000008p+0, false,
-	true,
-	0x1.000008p+0, false,
-	0x1.000008p+0, false,
-	0x1.000008p+0, false,
-	0x1.000008p+0, false,
-	true,
-	0x1.000008p+0, false,
-	0x1.000008p+0, false,
-	0x1.000008p+0, false,
-	0x1.000008p+0, false,
-	true,
-	0x1.000008p+0, false,
-	0x1.000008p+0, false,
-	0x1.000008p+0, false,
-	0x1.000008p+0, false,
-	true,
-	0x1.000008p+0, false,
-	0x1.000008p+0, false,
-	0x1.000008p+0, false,
-	0x1.000008p+0, false,
-	true,
-	0x1.000008p+0, false,
-	0x1.000008p+0, false,
-	0x1.000008p+0, false,
-	0x1.000008p+0, false),
+	0x1.000008p+0, false, false,
+	0x1.000008p+0, false, false,
+	0x1.000008p+0, false, false,
+	0x1.000008p+0, false, false,
+	true,
+	0x1.000008p+0, false, false,
+	0x1.000008p+0, false, false,
+	0x1.000008p+0, false, false,
+	0x1.000008p+0, false, false,
+	true,
+	0x1.000008p+0, false, false,
+	0x1.000008p+0, false, false,
+	0x1.000008p+0, false, false,
+	0x1.000008p+0, false, false,
+	true,
+	0x1.000008p+0, false, false,
+	0x1.000008p+0, false, false,
+	0x1.000008p+0, false, false,
+	0x1.000008p+0, false, false,
+	true,
+	0x1.000008p+0, false, false,
+	0x1.000008p+0, false, false,
+	0x1.000008p+0, false, false,
+	0x1.000008p+0, false, false,
+	true,
+	0x1.000008p+0, false, false,
+	0x1.000008p+0, false, false,
+	0x1.000008p+0, false, false,
+	0x1.000008p+0, false, false),
   TEST ("1.0000000298023223876953125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.0000008p+0, false,
-	0x1.0000008p+0, false,
-	0x1.0000008p+0, false,
-	0x1.0000008p+0, false,
-	true,
-	0x1.0000008p+0, false,
-	0x1.0000008p+0, false,
-	0x1.0000008p+0, false,
-	0x1.0000008p+0, false,
-	true,
-	0x1.0000008p+0, false,
-	0x1.0000008p+0, false,
-	0x1.0000008p+0, false,
-	0x1.0000008p+0, false,
-	true,
-	0x1.0000008p+0, false,
-	0x1.0000008p+0, false,
-	0x1.0000008p+0, false,
-	0x1.0000008p+0, false,
-	true,
-	0x1.0000008p+0, false,
-	0x1.0000008p+0, false,
-	0x1.0000008p+0, false,
-	0x1.0000008p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.0000008p+0, false, false,
+	0x1.0000008p+0, false, false,
+	0x1.0000008p+0, false, false,
+	0x1.0000008p+0, false, false,
+	true,
+	0x1.0000008p+0, false, false,
+	0x1.0000008p+0, false, false,
+	0x1.0000008p+0, false, false,
+	0x1.0000008p+0, false, false,
+	true,
+	0x1.0000008p+0, false, false,
+	0x1.0000008p+0, false, false,
+	0x1.0000008p+0, false, false,
+	0x1.0000008p+0, false, false,
+	true,
+	0x1.0000008p+0, false, false,
+	0x1.0000008p+0, false, false,
+	0x1.0000008p+0, false, false,
+	0x1.0000008p+0, false, false,
+	true,
+	0x1.0000008p+0, false, false,
+	0x1.0000008p+0, false, false,
+	0x1.0000008p+0, false, false,
+	0x1.0000008p+0, false, false),
   TEST ("1.00000001490116119384765625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.0000004p+0, false,
-	0x1.0000004p+0, false,
-	0x1.0000004p+0, false,
-	0x1.0000004p+0, false,
-	true,
-	0x1.0000004p+0, false,
-	0x1.0000004p+0, false,
-	0x1.0000004p+0, false,
-	0x1.0000004p+0, false,
-	true,
-	0x1.0000004p+0, false,
-	0x1.0000004p+0, false,
-	0x1.0000004p+0, false,
-	0x1.0000004p+0, false,
-	true,
-	0x1.0000004p+0, false,
-	0x1.0000004p+0, false,
-	0x1.0000004p+0, false,
-	0x1.0000004p+0, false,
-	true,
-	0x1.0000004p+0, false,
-	0x1.0000004p+0, false,
-	0x1.0000004p+0, false,
-	0x1.0000004p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.0000004p+0, false, false,
+	0x1.0000004p+0, false, false,
+	0x1.0000004p+0, false, false,
+	0x1.0000004p+0, false, false,
+	true,
+	0x1.0000004p+0, false, false,
+	0x1.0000004p+0, false, false,
+	0x1.0000004p+0, false, false,
+	0x1.0000004p+0, false, false,
+	true,
+	0x1.0000004p+0, false, false,
+	0x1.0000004p+0, false, false,
+	0x1.0000004p+0, false, false,
+	0x1.0000004p+0, false, false,
+	true,
+	0x1.0000004p+0, false, false,
+	0x1.0000004p+0, false, false,
+	0x1.0000004p+0, false, false,
+	0x1.0000004p+0, false, false,
+	true,
+	0x1.0000004p+0, false, false,
+	0x1.0000004p+0, false, false,
+	0x1.0000004p+0, false, false,
+	0x1.0000004p+0, false, false),
   TEST ("1.000000007450580596923828125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.0000002p+0, false,
-	0x1.0000002p+0, false,
-	0x1.0000002p+0, false,
-	0x1.0000002p+0, false,
-	true,
-	0x1.0000002p+0, false,
-	0x1.0000002p+0, false,
-	0x1.0000002p+0, false,
-	0x1.0000002p+0, false,
-	true,
-	0x1.0000002p+0, false,
-	0x1.0000002p+0, false,
-	0x1.0000002p+0, false,
-	0x1.0000002p+0, false,
-	true,
-	0x1.0000002p+0, false,
-	0x1.0000002p+0, false,
-	0x1.0000002p+0, false,
-	0x1.0000002p+0, false,
-	true,
-	0x1.0000002p+0, false,
-	0x1.0000002p+0, false,
-	0x1.0000002p+0, false,
-	0x1.0000002p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.0000002p+0, false, false,
+	0x1.0000002p+0, false, false,
+	0x1.0000002p+0, false, false,
+	0x1.0000002p+0, false, false,
+	true,
+	0x1.0000002p+0, false, false,
+	0x1.0000002p+0, false, false,
+	0x1.0000002p+0, false, false,
+	0x1.0000002p+0, false, false,
+	true,
+	0x1.0000002p+0, false, false,
+	0x1.0000002p+0, false, false,
+	0x1.0000002p+0, false, false,
+	0x1.0000002p+0, false, false,
+	true,
+	0x1.0000002p+0, false, false,
+	0x1.0000002p+0, false, false,
+	0x1.0000002p+0, false, false,
+	0x1.0000002p+0, false, false,
+	true,
+	0x1.0000002p+0, false, false,
+	0x1.0000002p+0, false, false,
+	0x1.0000002p+0, false, false,
+	0x1.0000002p+0, false, false),
   TEST ("1.0000000037252902984619140625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.0000001p+0, false,
-	0x1.0000001p+0, false,
-	0x1.0000001p+0, false,
-	0x1.0000001p+0, false,
-	true,
-	0x1.0000001p+0, false,
-	0x1.0000001p+0, false,
-	0x1.0000001p+0, false,
-	0x1.0000001p+0, false,
-	true,
-	0x1.0000001p+0, false,
-	0x1.0000001p+0, false,
-	0x1.0000001p+0, false,
-	0x1.0000001p+0, false,
-	true,
-	0x1.0000001p+0, false,
-	0x1.0000001p+0, false,
-	0x1.0000001p+0, false,
-	0x1.0000001p+0, false,
-	true,
-	0x1.0000001p+0, false,
-	0x1.0000001p+0, false,
-	0x1.0000001p+0, false,
-	0x1.0000001p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.0000001p+0, false, false,
+	0x1.0000001p+0, false, false,
+	0x1.0000001p+0, false, false,
+	0x1.0000001p+0, false, false,
+	true,
+	0x1.0000001p+0, false, false,
+	0x1.0000001p+0, false, false,
+	0x1.0000001p+0, false, false,
+	0x1.0000001p+0, false, false,
+	true,
+	0x1.0000001p+0, false, false,
+	0x1.0000001p+0, false, false,
+	0x1.0000001p+0, false, false,
+	0x1.0000001p+0, false, false,
+	true,
+	0x1.0000001p+0, false, false,
+	0x1.0000001p+0, false, false,
+	0x1.0000001p+0, false, false,
+	0x1.0000001p+0, false, false,
+	true,
+	0x1.0000001p+0, false, false,
+	0x1.0000001p+0, false, false,
+	0x1.0000001p+0, false, false,
+	0x1.0000001p+0, false, false),
   TEST ("1.00000000186264514923095703125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.00000008p+0, false,
-	0x1.00000008p+0, false,
-	0x1.00000008p+0, false,
-	0x1.00000008p+0, false,
-	true,
-	0x1.00000008p+0, false,
-	0x1.00000008p+0, false,
-	0x1.00000008p+0, false,
-	0x1.00000008p+0, false,
-	true,
-	0x1.00000008p+0, false,
-	0x1.00000008p+0, false,
-	0x1.00000008p+0, false,
-	0x1.00000008p+0, false,
-	true,
-	0x1.00000008p+0, false,
-	0x1.00000008p+0, false,
-	0x1.00000008p+0, false,
-	0x1.00000008p+0, false,
-	true,
-	0x1.00000008p+0, false,
-	0x1.00000008p+0, false,
-	0x1.00000008p+0, false,
-	0x1.00000008p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.00000008p+0, false, false,
+	0x1.00000008p+0, false, false,
+	0x1.00000008p+0, false, false,
+	0x1.00000008p+0, false, false,
+	true,
+	0x1.00000008p+0, false, false,
+	0x1.00000008p+0, false, false,
+	0x1.00000008p+0, false, false,
+	0x1.00000008p+0, false, false,
+	true,
+	0x1.00000008p+0, false, false,
+	0x1.00000008p+0, false, false,
+	0x1.00000008p+0, false, false,
+	0x1.00000008p+0, false, false,
+	true,
+	0x1.00000008p+0, false, false,
+	0x1.00000008p+0, false, false,
+	0x1.00000008p+0, false, false,
+	0x1.00000008p+0, false, false,
+	true,
+	0x1.00000008p+0, false, false,
+	0x1.00000008p+0, false, false,
+	0x1.00000008p+0, false, false,
+	0x1.00000008p+0, false, false),
   TEST ("1.000000000931322574615478515625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.00000004p+0, false,
-	0x1.00000004p+0, false,
-	0x1.00000004p+0, false,
-	0x1.00000004p+0, false,
-	true,
-	0x1.00000004p+0, false,
-	0x1.00000004p+0, false,
-	0x1.00000004p+0, false,
-	0x1.00000004p+0, false,
-	true,
-	0x1.00000004p+0, false,
-	0x1.00000004p+0, false,
-	0x1.00000004p+0, false,
-	0x1.00000004p+0, false,
-	true,
-	0x1.00000004p+0, false,
-	0x1.00000004p+0, false,
-	0x1.00000004p+0, false,
-	0x1.00000004p+0, false,
-	true,
-	0x1.00000004p+0, false,
-	0x1.00000004p+0, false,
-	0x1.00000004p+0, false,
-	0x1.00000004p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.00000004p+0, false, false,
+	0x1.00000004p+0, false, false,
+	0x1.00000004p+0, false, false,
+	0x1.00000004p+0, false, false,
+	true,
+	0x1.00000004p+0, false, false,
+	0x1.00000004p+0, false, false,
+	0x1.00000004p+0, false, false,
+	0x1.00000004p+0, false, false,
+	true,
+	0x1.00000004p+0, false, false,
+	0x1.00000004p+0, false, false,
+	0x1.00000004p+0, false, false,
+	0x1.00000004p+0, false, false,
+	true,
+	0x1.00000004p+0, false, false,
+	0x1.00000004p+0, false, false,
+	0x1.00000004p+0, false, false,
+	0x1.00000004p+0, false, false,
+	true,
+	0x1.00000004p+0, false, false,
+	0x1.00000004p+0, false, false,
+	0x1.00000004p+0, false, false,
+	0x1.00000004p+0, false, false),
   TEST ("1.0000000004656612873077392578125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.00000002p+0, false,
-	0x1.00000002p+0, false,
-	0x1.00000002p+0, false,
-	0x1.00000002p+0, false,
-	true,
-	0x1.00000002p+0, false,
-	0x1.00000002p+0, false,
-	0x1.00000002p+0, false,
-	0x1.00000002p+0, false,
-	true,
-	0x1.00000002p+0, false,
-	0x1.00000002p+0, false,
-	0x1.00000002p+0, false,
-	0x1.00000002p+0, false,
-	true,
-	0x1.00000002p+0, false,
-	0x1.00000002p+0, false,
-	0x1.00000002p+0, false,
-	0x1.00000002p+0, false,
-	true,
-	0x1.00000002p+0, false,
-	0x1.00000002p+0, false,
-	0x1.00000002p+0, false,
-	0x1.00000002p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.00000002p+0, false, false,
+	0x1.00000002p+0, false, false,
+	0x1.00000002p+0, false, false,
+	0x1.00000002p+0, false, false,
+	true,
+	0x1.00000002p+0, false, false,
+	0x1.00000002p+0, false, false,
+	0x1.00000002p+0, false, false,
+	0x1.00000002p+0, false, false,
+	true,
+	0x1.00000002p+0, false, false,
+	0x1.00000002p+0, false, false,
+	0x1.00000002p+0, false, false,
+	0x1.00000002p+0, false, false,
+	true,
+	0x1.00000002p+0, false, false,
+	0x1.00000002p+0, false, false,
+	0x1.00000002p+0, false, false,
+	0x1.00000002p+0, false, false,
+	true,
+	0x1.00000002p+0, false, false,
+	0x1.00000002p+0, false, false,
+	0x1.00000002p+0, false, false,
+	0x1.00000002p+0, false, false),
   TEST ("1.00000000023283064365386962890625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.00000001p+0, false,
-	0x1.00000001p+0, false,
-	0x1.00000001p+0, false,
-	0x1.00000001p+0, false,
-	true,
-	0x1.00000001p+0, false,
-	0x1.00000001p+0, false,
-	0x1.00000001p+0, false,
-	0x1.00000001p+0, false,
-	true,
-	0x1.00000001p+0, false,
-	0x1.00000001p+0, false,
-	0x1.00000001p+0, false,
-	0x1.00000001p+0, false,
-	true,
-	0x1.00000001p+0, false,
-	0x1.00000001p+0, false,
-	0x1.00000001p+0, false,
-	0x1.00000001p+0, false,
-	true,
-	0x1.00000001p+0, false,
-	0x1.00000001p+0, false,
-	0x1.00000001p+0, false,
-	0x1.00000001p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.00000001p+0, false, false,
+	0x1.00000001p+0, false, false,
+	0x1.00000001p+0, false, false,
+	0x1.00000001p+0, false, false,
+	true,
+	0x1.00000001p+0, false, false,
+	0x1.00000001p+0, false, false,
+	0x1.00000001p+0, false, false,
+	0x1.00000001p+0, false, false,
+	true,
+	0x1.00000001p+0, false, false,
+	0x1.00000001p+0, false, false,
+	0x1.00000001p+0, false, false,
+	0x1.00000001p+0, false, false,
+	true,
+	0x1.00000001p+0, false, false,
+	0x1.00000001p+0, false, false,
+	0x1.00000001p+0, false, false,
+	0x1.00000001p+0, false, false,
+	true,
+	0x1.00000001p+0, false, false,
+	0x1.00000001p+0, false, false,
+	0x1.00000001p+0, false, false,
+	0x1.00000001p+0, false, false),
   TEST ("1.000000000116415321826934814453125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.000000008p+0, false,
-	0x1.000000008p+0, false,
-	0x1.000000008p+0, false,
-	0x1.000000008p+0, false,
-	true,
-	0x1.000000008p+0, false,
-	0x1.000000008p+0, false,
-	0x1.000000008p+0, false,
-	0x1.000000008p+0, false,
-	true,
-	0x1.000000008p+0, false,
-	0x1.000000008p+0, false,
-	0x1.000000008p+0, false,
-	0x1.000000008p+0, false,
-	true,
-	0x1.000000008p+0, false,
-	0x1.000000008p+0, false,
-	0x1.000000008p+0, false,
-	0x1.000000008p+0, false,
-	true,
-	0x1.000000008p+0, false,
-	0x1.000000008p+0, false,
-	0x1.000000008p+0, false,
-	0x1.000000008p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.000000008p+0, false, false,
+	0x1.000000008p+0, false, false,
+	0x1.000000008p+0, false, false,
+	0x1.000000008p+0, false, false,
+	true,
+	0x1.000000008p+0, false, false,
+	0x1.000000008p+0, false, false,
+	0x1.000000008p+0, false, false,
+	0x1.000000008p+0, false, false,
+	true,
+	0x1.000000008p+0, false, false,
+	0x1.000000008p+0, false, false,
+	0x1.000000008p+0, false, false,
+	0x1.000000008p+0, false, false,
+	true,
+	0x1.000000008p+0, false, false,
+	0x1.000000008p+0, false, false,
+	0x1.000000008p+0, false, false,
+	0x1.000000008p+0, false, false,
+	true,
+	0x1.000000008p+0, false, false,
+	0x1.000000008p+0, false, false,
+	0x1.000000008p+0, false, false,
+	0x1.000000008p+0, false, false),
   TEST ("1.0000000000582076609134674072265625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.000000004p+0, false,
-	0x1.000000004p+0, false,
-	0x1.000000004p+0, false,
-	0x1.000000004p+0, false,
-	true,
-	0x1.000000004p+0, false,
-	0x1.000000004p+0, false,
-	0x1.000000004p+0, false,
-	0x1.000000004p+0, false,
-	true,
-	0x1.000000004p+0, false,
-	0x1.000000004p+0, false,
-	0x1.000000004p+0, false,
-	0x1.000000004p+0, false,
-	true,
-	0x1.000000004p+0, false,
-	0x1.000000004p+0, false,
-	0x1.000000004p+0, false,
-	0x1.000000004p+0, false,
-	true,
-	0x1.000000004p+0, false,
-	0x1.000000004p+0, false,
-	0x1.000000004p+0, false,
-	0x1.000000004p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.000000004p+0, false, false,
+	0x1.000000004p+0, false, false,
+	0x1.000000004p+0, false, false,
+	0x1.000000004p+0, false, false,
+	true,
+	0x1.000000004p+0, false, false,
+	0x1.000000004p+0, false, false,
+	0x1.000000004p+0, false, false,
+	0x1.000000004p+0, false, false,
+	true,
+	0x1.000000004p+0, false, false,
+	0x1.000000004p+0, false, false,
+	0x1.000000004p+0, false, false,
+	0x1.000000004p+0, false, false,
+	true,
+	0x1.000000004p+0, false, false,
+	0x1.000000004p+0, false, false,
+	0x1.000000004p+0, false, false,
+	0x1.000000004p+0, false, false,
+	true,
+	0x1.000000004p+0, false, false,
+	0x1.000000004p+0, false, false,
+	0x1.000000004p+0, false, false,
+	0x1.000000004p+0, false, false),
   TEST ("1.00000000002910383045673370361328125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.000000002p+0, false,
-	0x1.000000002p+0, false,
-	0x1.000000002p+0, false,
-	0x1.000000002p+0, false,
-	true,
-	0x1.000000002p+0, false,
-	0x1.000000002p+0, false,
-	0x1.000000002p+0, false,
-	0x1.000000002p+0, false,
-	true,
-	0x1.000000002p+0, false,
-	0x1.000000002p+0, false,
-	0x1.000000002p+0, false,
-	0x1.000000002p+0, false,
-	true,
-	0x1.000000002p+0, false,
-	0x1.000000002p+0, false,
-	0x1.000000002p+0, false,
-	0x1.000000002p+0, false,
-	true,
-	0x1.000000002p+0, false,
-	0x1.000000002p+0, false,
-	0x1.000000002p+0, false,
-	0x1.000000002p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.000000002p+0, false, false,
+	0x1.000000002p+0, false, false,
+	0x1.000000002p+0, false, false,
+	0x1.000000002p+0, false, false,
+	true,
+	0x1.000000002p+0, false, false,
+	0x1.000000002p+0, false, false,
+	0x1.000000002p+0, false, false,
+	0x1.000000002p+0, false, false,
+	true,
+	0x1.000000002p+0, false, false,
+	0x1.000000002p+0, false, false,
+	0x1.000000002p+0, false, false,
+	0x1.000000002p+0, false, false,
+	true,
+	0x1.000000002p+0, false, false,
+	0x1.000000002p+0, false, false,
+	0x1.000000002p+0, false, false,
+	0x1.000000002p+0, false, false,
+	true,
+	0x1.000000002p+0, false, false,
+	0x1.000000002p+0, false, false,
+	0x1.000000002p+0, false, false,
+	0x1.000000002p+0, false, false),
   TEST ("1.000000000014551915228366851806640625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.000000001p+0, false,
-	0x1.000000001p+0, false,
-	0x1.000000001p+0, false,
-	0x1.000000001p+0, false,
-	true,
-	0x1.000000001p+0, false,
-	0x1.000000001p+0, false,
-	0x1.000000001p+0, false,
-	0x1.000000001p+0, false,
-	true,
-	0x1.000000001p+0, false,
-	0x1.000000001p+0, false,
-	0x1.000000001p+0, false,
-	0x1.000000001p+0, false,
-	true,
-	0x1.000000001p+0, false,
-	0x1.000000001p+0, false,
-	0x1.000000001p+0, false,
-	0x1.000000001p+0, false,
-	true,
-	0x1.000000001p+0, false,
-	0x1.000000001p+0, false,
-	0x1.000000001p+0, false,
-	0x1.000000001p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.000000001p+0, false, false,
+	0x1.000000001p+0, false, false,
+	0x1.000000001p+0, false, false,
+	0x1.000000001p+0, false, false,
+	true,
+	0x1.000000001p+0, false, false,
+	0x1.000000001p+0, false, false,
+	0x1.000000001p+0, false, false,
+	0x1.000000001p+0, false, false,
+	true,
+	0x1.000000001p+0, false, false,
+	0x1.000000001p+0, false, false,
+	0x1.000000001p+0, false, false,
+	0x1.000000001p+0, false, false,
+	true,
+	0x1.000000001p+0, false, false,
+	0x1.000000001p+0, false, false,
+	0x1.000000001p+0, false, false,
+	0x1.000000001p+0, false, false,
+	true,
+	0x1.000000001p+0, false, false,
+	0x1.000000001p+0, false, false,
+	0x1.000000001p+0, false, false,
+	0x1.000000001p+0, false, false),
   TEST ("1.0000000000072759576141834259033203125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.0000000008p+0, false,
-	0x1.0000000008p+0, false,
-	0x1.0000000008p+0, false,
-	0x1.0000000008p+0, false,
-	true,
-	0x1.0000000008p+0, false,
-	0x1.0000000008p+0, false,
-	0x1.0000000008p+0, false,
-	0x1.0000000008p+0, false,
-	true,
-	0x1.0000000008p+0, false,
-	0x1.0000000008p+0, false,
-	0x1.0000000008p+0, false,
-	0x1.0000000008p+0, false,
-	true,
-	0x1.0000000008p+0, false,
-	0x1.0000000008p+0, false,
-	0x1.0000000008p+0, false,
-	0x1.0000000008p+0, false,
-	true,
-	0x1.0000000008p+0, false,
-	0x1.0000000008p+0, false,
-	0x1.0000000008p+0, false,
-	0x1.0000000008p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.0000000008p+0, false, false,
+	0x1.0000000008p+0, false, false,
+	0x1.0000000008p+0, false, false,
+	0x1.0000000008p+0, false, false,
+	true,
+	0x1.0000000008p+0, false, false,
+	0x1.0000000008p+0, false, false,
+	0x1.0000000008p+0, false, false,
+	0x1.0000000008p+0, false, false,
+	true,
+	0x1.0000000008p+0, false, false,
+	0x1.0000000008p+0, false, false,
+	0x1.0000000008p+0, false, false,
+	0x1.0000000008p+0, false, false,
+	true,
+	0x1.0000000008p+0, false, false,
+	0x1.0000000008p+0, false, false,
+	0x1.0000000008p+0, false, false,
+	0x1.0000000008p+0, false, false,
+	true,
+	0x1.0000000008p+0, false, false,
+	0x1.0000000008p+0, false, false,
+	0x1.0000000008p+0, false, false,
+	0x1.0000000008p+0, false, false),
   TEST ("1.00000000000363797880709171295166015625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.0000000004p+0, false,
-	0x1.0000000004p+0, false,
-	0x1.0000000004p+0, false,
-	0x1.0000000004p+0, false,
-	true,
-	0x1.0000000004p+0, false,
-	0x1.0000000004p+0, false,
-	0x1.0000000004p+0, false,
-	0x1.0000000004p+0, false,
-	true,
-	0x1.0000000004p+0, false,
-	0x1.0000000004p+0, false,
-	0x1.0000000004p+0, false,
-	0x1.0000000004p+0, false,
-	true,
-	0x1.0000000004p+0, false,
-	0x1.0000000004p+0, false,
-	0x1.0000000004p+0, false,
-	0x1.0000000004p+0, false,
-	true,
-	0x1.0000000004p+0, false,
-	0x1.0000000004p+0, false,
-	0x1.0000000004p+0, false,
-	0x1.0000000004p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.0000000004p+0, false, false,
+	0x1.0000000004p+0, false, false,
+	0x1.0000000004p+0, false, false,
+	0x1.0000000004p+0, false, false,
+	true,
+	0x1.0000000004p+0, false, false,
+	0x1.0000000004p+0, false, false,
+	0x1.0000000004p+0, false, false,
+	0x1.0000000004p+0, false, false,
+	true,
+	0x1.0000000004p+0, false, false,
+	0x1.0000000004p+0, false, false,
+	0x1.0000000004p+0, false, false,
+	0x1.0000000004p+0, false, false,
+	true,
+	0x1.0000000004p+0, false, false,
+	0x1.0000000004p+0, false, false,
+	0x1.0000000004p+0, false, false,
+	0x1.0000000004p+0, false, false,
+	true,
+	0x1.0000000004p+0, false, false,
+	0x1.0000000004p+0, false, false,
+	0x1.0000000004p+0, false, false,
+	0x1.0000000004p+0, false, false),
   TEST ("1.000000000001818989403545856475830078125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.0000000002p+0, false,
-	0x1.0000000002p+0, false,
-	0x1.0000000002p+0, false,
-	0x1.0000000002p+0, false,
-	true,
-	0x1.0000000002p+0, false,
-	0x1.0000000002p+0, false,
-	0x1.0000000002p+0, false,
-	0x1.0000000002p+0, false,
-	true,
-	0x1.0000000002p+0, false,
-	0x1.0000000002p+0, false,
-	0x1.0000000002p+0, false,
-	0x1.0000000002p+0, false,
-	true,
-	0x1.0000000002p+0, false,
-	0x1.0000000002p+0, false,
-	0x1.0000000002p+0, false,
-	0x1.0000000002p+0, false,
-	true,
-	0x1.0000000002p+0, false,
-	0x1.0000000002p+0, false,
-	0x1.0000000002p+0, false,
-	0x1.0000000002p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.0000000002p+0, false, false,
+	0x1.0000000002p+0, false, false,
+	0x1.0000000002p+0, false, false,
+	0x1.0000000002p+0, false, false,
+	true,
+	0x1.0000000002p+0, false, false,
+	0x1.0000000002p+0, false, false,
+	0x1.0000000002p+0, false, false,
+	0x1.0000000002p+0, false, false,
+	true,
+	0x1.0000000002p+0, false, false,
+	0x1.0000000002p+0, false, false,
+	0x1.0000000002p+0, false, false,
+	0x1.0000000002p+0, false, false,
+	true,
+	0x1.0000000002p+0, false, false,
+	0x1.0000000002p+0, false, false,
+	0x1.0000000002p+0, false, false,
+	0x1.0000000002p+0, false, false,
+	true,
+	0x1.0000000002p+0, false, false,
+	0x1.0000000002p+0, false, false,
+	0x1.0000000002p+0, false, false,
+	0x1.0000000002p+0, false, false),
   TEST ("1.0000000000009094947017729282379150390625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.0000000001p+0, false,
-	0x1.0000000001p+0, false,
-	0x1.0000000001p+0, false,
-	0x1.0000000001p+0, false,
-	true,
-	0x1.0000000001p+0, false,
-	0x1.0000000001p+0, false,
-	0x1.0000000001p+0, false,
-	0x1.0000000001p+0, false,
-	true,
-	0x1.0000000001p+0, false,
-	0x1.0000000001p+0, false,
-	0x1.0000000001p+0, false,
-	0x1.0000000001p+0, false,
-	true,
-	0x1.0000000001p+0, false,
-	0x1.0000000001p+0, false,
-	0x1.0000000001p+0, false,
-	0x1.0000000001p+0, false,
-	true,
-	0x1.0000000001p+0, false,
-	0x1.0000000001p+0, false,
-	0x1.0000000001p+0, false,
-	0x1.0000000001p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.0000000001p+0, false, false,
+	0x1.0000000001p+0, false, false,
+	0x1.0000000001p+0, false, false,
+	0x1.0000000001p+0, false, false,
+	true,
+	0x1.0000000001p+0, false, false,
+	0x1.0000000001p+0, false, false,
+	0x1.0000000001p+0, false, false,
+	0x1.0000000001p+0, false, false,
+	true,
+	0x1.0000000001p+0, false, false,
+	0x1.0000000001p+0, false, false,
+	0x1.0000000001p+0, false, false,
+	0x1.0000000001p+0, false, false,
+	true,
+	0x1.0000000001p+0, false, false,
+	0x1.0000000001p+0, false, false,
+	0x1.0000000001p+0, false, false,
+	0x1.0000000001p+0, false, false,
+	true,
+	0x1.0000000001p+0, false, false,
+	0x1.0000000001p+0, false, false,
+	0x1.0000000001p+0, false, false,
+	0x1.0000000001p+0, false, false),
   TEST ("1.00000000000045474735088646411895751953125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.00000000008p+0, false,
-	0x1.00000000008p+0, false,
-	0x1.00000000008p+0, false,
-	0x1.00000000008p+0, false,
-	true,
-	0x1.00000000008p+0, false,
-	0x1.00000000008p+0, false,
-	0x1.00000000008p+0, false,
-	0x1.00000000008p+0, false,
-	true,
-	0x1.00000000008p+0, false,
-	0x1.00000000008p+0, false,
-	0x1.00000000008p+0, false,
-	0x1.00000000008p+0, false,
-	true,
-	0x1.00000000008p+0, false,
-	0x1.00000000008p+0, false,
-	0x1.00000000008p+0, false,
-	0x1.00000000008p+0, false,
-	true,
-	0x1.00000000008p+0, false,
-	0x1.00000000008p+0, false,
-	0x1.00000000008p+0, false,
-	0x1.00000000008p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.00000000008p+0, false, false,
+	0x1.00000000008p+0, false, false,
+	0x1.00000000008p+0, false, false,
+	0x1.00000000008p+0, false, false,
+	true,
+	0x1.00000000008p+0, false, false,
+	0x1.00000000008p+0, false, false,
+	0x1.00000000008p+0, false, false,
+	0x1.00000000008p+0, false, false,
+	true,
+	0x1.00000000008p+0, false, false,
+	0x1.00000000008p+0, false, false,
+	0x1.00000000008p+0, false, false,
+	0x1.00000000008p+0, false, false,
+	true,
+	0x1.00000000008p+0, false, false,
+	0x1.00000000008p+0, false, false,
+	0x1.00000000008p+0, false, false,
+	0x1.00000000008p+0, false, false,
+	true,
+	0x1.00000000008p+0, false, false,
+	0x1.00000000008p+0, false, false,
+	0x1.00000000008p+0, false, false,
+	0x1.00000000008p+0, false, false),
   TEST ("1.000000000000227373675443232059478759765625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.00000000004p+0, false,
-	0x1.00000000004p+0, false,
-	0x1.00000000004p+0, false,
-	0x1.00000000004p+0, false,
-	true,
-	0x1.00000000004p+0, false,
-	0x1.00000000004p+0, false,
-	0x1.00000000004p+0, false,
-	0x1.00000000004p+0, false,
-	true,
-	0x1.00000000004p+0, false,
-	0x1.00000000004p+0, false,
-	0x1.00000000004p+0, false,
-	0x1.00000000004p+0, false,
-	true,
-	0x1.00000000004p+0, false,
-	0x1.00000000004p+0, false,
-	0x1.00000000004p+0, false,
-	0x1.00000000004p+0, false,
-	true,
-	0x1.00000000004p+0, false,
-	0x1.00000000004p+0, false,
-	0x1.00000000004p+0, false,
-	0x1.00000000004p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.00000000004p+0, false, false,
+	0x1.00000000004p+0, false, false,
+	0x1.00000000004p+0, false, false,
+	0x1.00000000004p+0, false, false,
+	true,
+	0x1.00000000004p+0, false, false,
+	0x1.00000000004p+0, false, false,
+	0x1.00000000004p+0, false, false,
+	0x1.00000000004p+0, false, false,
+	true,
+	0x1.00000000004p+0, false, false,
+	0x1.00000000004p+0, false, false,
+	0x1.00000000004p+0, false, false,
+	0x1.00000000004p+0, false, false,
+	true,
+	0x1.00000000004p+0, false, false,
+	0x1.00000000004p+0, false, false,
+	0x1.00000000004p+0, false, false,
+	0x1.00000000004p+0, false, false,
+	true,
+	0x1.00000000004p+0, false, false,
+	0x1.00000000004p+0, false, false,
+	0x1.00000000004p+0, false, false,
+	0x1.00000000004p+0, false, false),
   TEST ("1.0000000000001136868377216160297393798828125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.00000000002p+0, false,
-	0x1.00000000002p+0, false,
-	0x1.00000000002p+0, false,
-	0x1.00000000002p+0, false,
-	true,
-	0x1.00000000002p+0, false,
-	0x1.00000000002p+0, false,
-	0x1.00000000002p+0, false,
-	0x1.00000000002p+0, false,
-	true,
-	0x1.00000000002p+0, false,
-	0x1.00000000002p+0, false,
-	0x1.00000000002p+0, false,
-	0x1.00000000002p+0, false,
-	true,
-	0x1.00000000002p+0, false,
-	0x1.00000000002p+0, false,
-	0x1.00000000002p+0, false,
-	0x1.00000000002p+0, false,
-	true,
-	0x1.00000000002p+0, false,
-	0x1.00000000002p+0, false,
-	0x1.00000000002p+0, false,
-	0x1.00000000002p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.00000000002p+0, false, false,
+	0x1.00000000002p+0, false, false,
+	0x1.00000000002p+0, false, false,
+	0x1.00000000002p+0, false, false,
+	true,
+	0x1.00000000002p+0, false, false,
+	0x1.00000000002p+0, false, false,
+	0x1.00000000002p+0, false, false,
+	0x1.00000000002p+0, false, false,
+	true,
+	0x1.00000000002p+0, false, false,
+	0x1.00000000002p+0, false, false,
+	0x1.00000000002p+0, false, false,
+	0x1.00000000002p+0, false, false,
+	true,
+	0x1.00000000002p+0, false, false,
+	0x1.00000000002p+0, false, false,
+	0x1.00000000002p+0, false, false,
+	0x1.00000000002p+0, false, false,
+	true,
+	0x1.00000000002p+0, false, false,
+	0x1.00000000002p+0, false, false,
+	0x1.00000000002p+0, false, false,
+	0x1.00000000002p+0, false, false),
   TEST ("1.00000000000005684341886080801486968994140625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.00000000001p+0, false,
-	0x1.00000000001p+0, false,
-	0x1.00000000001p+0, false,
-	0x1.00000000001p+0, false,
-	true,
-	0x1.00000000001p+0, false,
-	0x1.00000000001p+0, false,
-	0x1.00000000001p+0, false,
-	0x1.00000000001p+0, false,
-	true,
-	0x1.00000000001p+0, false,
-	0x1.00000000001p+0, false,
-	0x1.00000000001p+0, false,
-	0x1.00000000001p+0, false,
-	true,
-	0x1.00000000001p+0, false,
-	0x1.00000000001p+0, false,
-	0x1.00000000001p+0, false,
-	0x1.00000000001p+0, false,
-	true,
-	0x1.00000000001p+0, false,
-	0x1.00000000001p+0, false,
-	0x1.00000000001p+0, false,
-	0x1.00000000001p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.00000000001p+0, false, false,
+	0x1.00000000001p+0, false, false,
+	0x1.00000000001p+0, false, false,
+	0x1.00000000001p+0, false, false,
+	true,
+	0x1.00000000001p+0, false, false,
+	0x1.00000000001p+0, false, false,
+	0x1.00000000001p+0, false, false,
+	0x1.00000000001p+0, false, false,
+	true,
+	0x1.00000000001p+0, false, false,
+	0x1.00000000001p+0, false, false,
+	0x1.00000000001p+0, false, false,
+	0x1.00000000001p+0, false, false,
+	true,
+	0x1.00000000001p+0, false, false,
+	0x1.00000000001p+0, false, false,
+	0x1.00000000001p+0, false, false,
+	0x1.00000000001p+0, false, false,
+	true,
+	0x1.00000000001p+0, false, false,
+	0x1.00000000001p+0, false, false,
+	0x1.00000000001p+0, false, false,
+	0x1.00000000001p+0, false, false),
   TEST ("1.000000000000028421709430404007434844970703125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.000000000008p+0, false,
-	0x1.000000000008p+0, false,
-	0x1.000000000008p+0, false,
-	0x1.000000000008p+0, false,
-	true,
-	0x1.000000000008p+0, false,
-	0x1.000000000008p+0, false,
-	0x1.000000000008p+0, false,
-	0x1.000000000008p+0, false,
-	true,
-	0x1.000000000008p+0, false,
-	0x1.000000000008p+0, false,
-	0x1.000000000008p+0, false,
-	0x1.000000000008p+0, false,
-	true,
-	0x1.000000000008p+0, false,
-	0x1.000000000008p+0, false,
-	0x1.000000000008p+0, false,
-	0x1.000000000008p+0, false,
-	true,
-	0x1.000000000008p+0, false,
-	0x1.000000000008p+0, false,
-	0x1.000000000008p+0, false,
-	0x1.000000000008p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.000000000008p+0, false, false,
+	0x1.000000000008p+0, false, false,
+	0x1.000000000008p+0, false, false,
+	0x1.000000000008p+0, false, false,
+	true,
+	0x1.000000000008p+0, false, false,
+	0x1.000000000008p+0, false, false,
+	0x1.000000000008p+0, false, false,
+	0x1.000000000008p+0, false, false,
+	true,
+	0x1.000000000008p+0, false, false,
+	0x1.000000000008p+0, false, false,
+	0x1.000000000008p+0, false, false,
+	0x1.000000000008p+0, false, false,
+	true,
+	0x1.000000000008p+0, false, false,
+	0x1.000000000008p+0, false, false,
+	0x1.000000000008p+0, false, false,
+	0x1.000000000008p+0, false, false,
+	true,
+	0x1.000000000008p+0, false, false,
+	0x1.000000000008p+0, false, false,
+	0x1.000000000008p+0, false, false,
+	0x1.000000000008p+0, false, false),
   TEST ("1.0000000000000142108547152020037174224853515625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.000000000004p+0, false,
-	0x1.000000000004p+0, false,
-	0x1.000000000004p+0, false,
-	0x1.000000000004p+0, false,
-	true,
-	0x1.000000000004p+0, false,
-	0x1.000000000004p+0, false,
-	0x1.000000000004p+0, false,
-	0x1.000000000004p+0, false,
-	true,
-	0x1.000000000004p+0, false,
-	0x1.000000000004p+0, false,
-	0x1.000000000004p+0, false,
-	0x1.000000000004p+0, false,
-	true,
-	0x1.000000000004p+0, false,
-	0x1.000000000004p+0, false,
-	0x1.000000000004p+0, false,
-	0x1.000000000004p+0, false,
-	true,
-	0x1.000000000004p+0, false,
-	0x1.000000000004p+0, false,
-	0x1.000000000004p+0, false,
-	0x1.000000000004p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.000000000004p+0, false, false,
+	0x1.000000000004p+0, false, false,
+	0x1.000000000004p+0, false, false,
+	0x1.000000000004p+0, false, false,
+	true,
+	0x1.000000000004p+0, false, false,
+	0x1.000000000004p+0, false, false,
+	0x1.000000000004p+0, false, false,
+	0x1.000000000004p+0, false, false,
+	true,
+	0x1.000000000004p+0, false, false,
+	0x1.000000000004p+0, false, false,
+	0x1.000000000004p+0, false, false,
+	0x1.000000000004p+0, false, false,
+	true,
+	0x1.000000000004p+0, false, false,
+	0x1.000000000004p+0, false, false,
+	0x1.000000000004p+0, false, false,
+	0x1.000000000004p+0, false, false,
+	true,
+	0x1.000000000004p+0, false, false,
+	0x1.000000000004p+0, false, false,
+	0x1.000000000004p+0, false, false,
+	0x1.000000000004p+0, false, false),
   TEST ("1.00000000000000710542735760100185871124267578125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.000000000002p+0, false,
-	0x1.000000000002p+0, false,
-	0x1.000000000002p+0, false,
-	0x1.000000000002p+0, false,
-	true,
-	0x1.000000000002p+0, false,
-	0x1.000000000002p+0, false,
-	0x1.000000000002p+0, false,
-	0x1.000000000002p+0, false,
-	true,
-	0x1.000000000002p+0, false,
-	0x1.000000000002p+0, false,
-	0x1.000000000002p+0, false,
-	0x1.000000000002p+0, false,
-	true,
-	0x1.000000000002p+0, false,
-	0x1.000000000002p+0, false,
-	0x1.000000000002p+0, false,
-	0x1.000000000002p+0, false,
-	true,
-	0x1.000000000002p+0, false,
-	0x1.000000000002p+0, false,
-	0x1.000000000002p+0, false,
-	0x1.000000000002p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.000000000002p+0, false, false,
+	0x1.000000000002p+0, false, false,
+	0x1.000000000002p+0, false, false,
+	0x1.000000000002p+0, false, false,
+	true,
+	0x1.000000000002p+0, false, false,
+	0x1.000000000002p+0, false, false,
+	0x1.000000000002p+0, false, false,
+	0x1.000000000002p+0, false, false,
+	true,
+	0x1.000000000002p+0, false, false,
+	0x1.000000000002p+0, false, false,
+	0x1.000000000002p+0, false, false,
+	0x1.000000000002p+0, false, false,
+	true,
+	0x1.000000000002p+0, false, false,
+	0x1.000000000002p+0, false, false,
+	0x1.000000000002p+0, false, false,
+	0x1.000000000002p+0, false, false,
+	true,
+	0x1.000000000002p+0, false, false,
+	0x1.000000000002p+0, false, false,
+	0x1.000000000002p+0, false, false,
+	0x1.000000000002p+0, false, false),
   TEST ("1.000000000000003552713678800500929355621337890625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.000000000001p+0, false,
-	0x1.000000000001p+0, false,
-	0x1.000000000001p+0, false,
-	0x1.000000000001p+0, false,
-	true,
-	0x1.000000000001p+0, false,
-	0x1.000000000001p+0, false,
-	0x1.000000000001p+0, false,
-	0x1.000000000001p+0, false,
-	true,
-	0x1.000000000001p+0, false,
-	0x1.000000000001p+0, false,
-	0x1.000000000001p+0, false,
-	0x1.000000000001p+0, false,
-	true,
-	0x1.000000000001p+0, false,
-	0x1.000000000001p+0, false,
-	0x1.000000000001p+0, false,
-	0x1.000000000001p+0, false,
-	true,
-	0x1.000000000001p+0, false,
-	0x1.000000000001p+0, false,
-	0x1.000000000001p+0, false,
-	0x1.000000000001p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.000000000001p+0, false, false,
+	0x1.000000000001p+0, false, false,
+	0x1.000000000001p+0, false, false,
+	0x1.000000000001p+0, false, false,
+	true,
+	0x1.000000000001p+0, false, false,
+	0x1.000000000001p+0, false, false,
+	0x1.000000000001p+0, false, false,
+	0x1.000000000001p+0, false, false,
+	true,
+	0x1.000000000001p+0, false, false,
+	0x1.000000000001p+0, false, false,
+	0x1.000000000001p+0, false, false,
+	0x1.000000000001p+0, false, false,
+	true,
+	0x1.000000000001p+0, false, false,
+	0x1.000000000001p+0, false, false,
+	0x1.000000000001p+0, false, false,
+	0x1.000000000001p+0, false, false,
+	true,
+	0x1.000000000001p+0, false, false,
+	0x1.000000000001p+0, false, false,
+	0x1.000000000001p+0, false, false,
+	0x1.000000000001p+0, false, false),
   TEST ("1.0000000000000017763568394002504646778106689453125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.0000000000008p+0, false,
-	0x1.0000000000008p+0, false,
-	0x1.0000000000008p+0, false,
-	0x1.0000000000008p+0, false,
-	true,
-	0x1.0000000000008p+0, false,
-	0x1.0000000000008p+0, false,
-	0x1.0000000000008p+0, false,
-	0x1.0000000000008p+0, false,
-	true,
-	0x1.0000000000008p+0, false,
-	0x1.0000000000008p+0, false,
-	0x1.0000000000008p+0, false,
-	0x1.0000000000008p+0, false,
-	true,
-	0x1.0000000000008p+0, false,
-	0x1.0000000000008p+0, false,
-	0x1.0000000000008p+0, false,
-	0x1.0000000000008p+0, false,
-	true,
-	0x1.0000000000008p+0, false,
-	0x1.0000000000008p+0, false,
-	0x1.0000000000008p+0, false,
-	0x1.0000000000008p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.0000000000008p+0, false, false,
+	0x1.0000000000008p+0, false, false,
+	0x1.0000000000008p+0, false, false,
+	0x1.0000000000008p+0, false, false,
+	true,
+	0x1.0000000000008p+0, false, false,
+	0x1.0000000000008p+0, false, false,
+	0x1.0000000000008p+0, false, false,
+	0x1.0000000000008p+0, false, false,
+	true,
+	0x1.0000000000008p+0, false, false,
+	0x1.0000000000008p+0, false, false,
+	0x1.0000000000008p+0, false, false,
+	0x1.0000000000008p+0, false, false,
+	true,
+	0x1.0000000000008p+0, false, false,
+	0x1.0000000000008p+0, false, false,
+	0x1.0000000000008p+0, false, false,
+	0x1.0000000000008p+0, false, false,
+	true,
+	0x1.0000000000008p+0, false, false,
+	0x1.0000000000008p+0, false, false,
+	0x1.0000000000008p+0, false, false,
+	0x1.0000000000008p+0, false, false),
   TEST ("1.00000000000000088817841970012523233890533447265625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.0000000000004p+0, false,
-	0x1.0000000000004p+0, false,
-	0x1.0000000000004p+0, false,
-	0x1.0000000000004p+0, false,
-	true,
-	0x1.0000000000004p+0, false,
-	0x1.0000000000004p+0, false,
-	0x1.0000000000004p+0, false,
-	0x1.0000000000004p+0, false,
-	true,
-	0x1.0000000000004p+0, false,
-	0x1.0000000000004p+0, false,
-	0x1.0000000000004p+0, false,
-	0x1.0000000000004p+0, false,
-	true,
-	0x1.0000000000004p+0, false,
-	0x1.0000000000004p+0, false,
-	0x1.0000000000004p+0, false,
-	0x1.0000000000004p+0, false,
-	true,
-	0x1.0000000000004p+0, false,
-	0x1.0000000000004p+0, false,
-	0x1.0000000000004p+0, false,
-	0x1.0000000000004p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.0000000000004p+0, false, false,
+	0x1.0000000000004p+0, false, false,
+	0x1.0000000000004p+0, false, false,
+	0x1.0000000000004p+0, false, false,
+	true,
+	0x1.0000000000004p+0, false, false,
+	0x1.0000000000004p+0, false, false,
+	0x1.0000000000004p+0, false, false,
+	0x1.0000000000004p+0, false, false,
+	true,
+	0x1.0000000000004p+0, false, false,
+	0x1.0000000000004p+0, false, false,
+	0x1.0000000000004p+0, false, false,
+	0x1.0000000000004p+0, false, false,
+	true,
+	0x1.0000000000004p+0, false, false,
+	0x1.0000000000004p+0, false, false,
+	0x1.0000000000004p+0, false, false,
+	0x1.0000000000004p+0, false, false,
+	true,
+	0x1.0000000000004p+0, false, false,
+	0x1.0000000000004p+0, false, false,
+	0x1.0000000000004p+0, false, false,
+	0x1.0000000000004p+0, false, false),
   TEST ("1.000000000000000444089209850062616169452667236328125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.0000000000002p+0, false,
-	0x1.0000000000002p+0, false,
-	0x1.0000000000002p+0, false,
-	0x1.0000000000002p+0, false,
-	true,
-	0x1.0000000000002p+0, false,
-	0x1.0000000000002p+0, false,
-	0x1.0000000000002p+0, false,
-	0x1.0000000000002p+0, false,
-	true,
-	0x1.0000000000002p+0, false,
-	0x1.0000000000002p+0, false,
-	0x1.0000000000002p+0, false,
-	0x1.0000000000002p+0, false,
-	true,
-	0x1.0000000000002p+0, false,
-	0x1.0000000000002p+0, false,
-	0x1.0000000000002p+0, false,
-	0x1.0000000000002p+0, false,
-	true,
-	0x1.0000000000002p+0, false,
-	0x1.0000000000002p+0, false,
-	0x1.0000000000002p+0, false,
-	0x1.0000000000002p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.0000000000002p+0, false, false,
+	0x1.0000000000002p+0, false, false,
+	0x1.0000000000002p+0, false, false,
+	0x1.0000000000002p+0, false, false,
+	true,
+	0x1.0000000000002p+0, false, false,
+	0x1.0000000000002p+0, false, false,
+	0x1.0000000000002p+0, false, false,
+	0x1.0000000000002p+0, false, false,
+	true,
+	0x1.0000000000002p+0, false, false,
+	0x1.0000000000002p+0, false, false,
+	0x1.0000000000002p+0, false, false,
+	0x1.0000000000002p+0, false, false,
+	true,
+	0x1.0000000000002p+0, false, false,
+	0x1.0000000000002p+0, false, false,
+	0x1.0000000000002p+0, false, false,
+	0x1.0000000000002p+0, false, false,
+	true,
+	0x1.0000000000002p+0, false, false,
+	0x1.0000000000002p+0, false, false,
+	0x1.0000000000002p+0, false, false,
+	0x1.0000000000002p+0, false, false),
   TEST ("1.0000000000000002220446049250313080847263336181640625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	true,
-	0x1.0000000000001p+0, false,
-	0x1.0000000000001p+0, false,
-	0x1.0000000000001p+0, false,
-	0x1.0000000000001p+0, false,
-	true,
-	0x1.0000000000001p+0, false,
-	0x1.0000000000001p+0, false,
-	0x1.0000000000001p+0, false,
-	0x1.0000000000001p+0, false,
-	true,
-	0x1.0000000000001p+0, false,
-	0x1.0000000000001p+0, false,
-	0x1.0000000000001p+0, false,
-	0x1.0000000000001p+0, false,
-	true,
-	0x1.0000000000001p+0, false,
-	0x1.0000000000001p+0, false,
-	0x1.0000000000001p+0, false,
-	0x1.0000000000001p+0, false,
-	true,
-	0x1.0000000000001p+0, false,
-	0x1.0000000000001p+0, false,
-	0x1.0000000000001p+0, false,
-	0x1.0000000000001p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	true,
+	0x1.0000000000001p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	true,
+	0x1.0000000000001p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	true,
+	0x1.0000000000001p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	true,
+	0x1.0000000000001p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	true,
+	0x1.0000000000001p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	0x1.0000000000001p+0, false, false),
   TEST ("1.00000000000000011102230246251565404236316680908203125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	true,
-	0x1.00000000000008p+0, false,
-	0x1.00000000000008p+0, false,
-	0x1.00000000000008p+0, false,
-	0x1.00000000000008p+0, false,
-	true,
-	0x1.00000000000008p+0, false,
-	0x1.00000000000008p+0, false,
-	0x1.00000000000008p+0, false,
-	0x1.00000000000008p+0, false,
-	true,
-	0x1.00000000000008p+0, false,
-	0x1.00000000000008p+0, false,
-	0x1.00000000000008p+0, false,
-	0x1.00000000000008p+0, false,
-	true,
-	0x1.00000000000008p+0, false,
-	0x1.00000000000008p+0, false,
-	0x1.00000000000008p+0, false,
-	0x1.00000000000008p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	true,
+	0x1.00000000000008p+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	true,
+	0x1.00000000000008p+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	true,
+	0x1.00000000000008p+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	true,
+	0x1.00000000000008p+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	0x1.00000000000008p+0, false, false,
+	0x1.00000000000008p+0, false, false),
   TEST ("1.000000000000000055511151231257827021181583404541015625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	true,
-	0x1.00000000000004p+0, false,
-	0x1.00000000000004p+0, false,
-	0x1.00000000000004p+0, false,
-	0x1.00000000000004p+0, false,
-	true,
-	0x1.00000000000004p+0, false,
-	0x1.00000000000004p+0, false,
-	0x1.00000000000004p+0, false,
-	0x1.00000000000004p+0, false,
-	true,
-	0x1.00000000000004p+0, false,
-	0x1.00000000000004p+0, false,
-	0x1.00000000000004p+0, false,
-	0x1.00000000000004p+0, false,
-	true,
-	0x1.00000000000004p+0, false,
-	0x1.00000000000004p+0, false,
-	0x1.00000000000004p+0, false,
-	0x1.00000000000004p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	true,
+	0x1.00000000000004p+0, false, false,
+	0x1.00000000000004p+0, false, false,
+	0x1.00000000000004p+0, false, false,
+	0x1.00000000000004p+0, false, false,
+	true,
+	0x1.00000000000004p+0, false, false,
+	0x1.00000000000004p+0, false, false,
+	0x1.00000000000004p+0, false, false,
+	0x1.00000000000004p+0, false, false,
+	true,
+	0x1.00000000000004p+0, false, false,
+	0x1.00000000000004p+0, false, false,
+	0x1.00000000000004p+0, false, false,
+	0x1.00000000000004p+0, false, false,
+	true,
+	0x1.00000000000004p+0, false, false,
+	0x1.00000000000004p+0, false, false,
+	0x1.00000000000004p+0, false, false,
+	0x1.00000000000004p+0, false, false),
   TEST ("1.0000000000000000277555756156289135105907917022705078125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	true,
-	0x1.00000000000002p+0, false,
-	0x1.00000000000002p+0, false,
-	0x1.00000000000002p+0, false,
-	0x1.00000000000002p+0, false,
-	true,
-	0x1.00000000000002p+0, false,
-	0x1.00000000000002p+0, false,
-	0x1.00000000000002p+0, false,
-	0x1.00000000000002p+0, false,
-	true,
-	0x1.00000000000002p+0, false,
-	0x1.00000000000002p+0, false,
-	0x1.00000000000002p+0, false,
-	0x1.00000000000002p+0, false,
-	true,
-	0x1.00000000000002p+0, false,
-	0x1.00000000000002p+0, false,
-	0x1.00000000000002p+0, false,
-	0x1.00000000000002p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	true,
+	0x1.00000000000002p+0, false, false,
+	0x1.00000000000002p+0, false, false,
+	0x1.00000000000002p+0, false, false,
+	0x1.00000000000002p+0, false, false,
+	true,
+	0x1.00000000000002p+0, false, false,
+	0x1.00000000000002p+0, false, false,
+	0x1.00000000000002p+0, false, false,
+	0x1.00000000000002p+0, false, false,
+	true,
+	0x1.00000000000002p+0, false, false,
+	0x1.00000000000002p+0, false, false,
+	0x1.00000000000002p+0, false, false,
+	0x1.00000000000002p+0, false, false,
+	true,
+	0x1.00000000000002p+0, false, false,
+	0x1.00000000000002p+0, false, false,
+	0x1.00000000000002p+0, false, false,
+	0x1.00000000000002p+0, false, false),
   TEST ("1.00000000000000001387778780781445675529539585113525390625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	true,
-	0x1.00000000000001p+0, false,
-	0x1.00000000000001p+0, false,
-	0x1.00000000000001p+0, false,
-	0x1.00000000000001p+0, false,
-	true,
-	0x1.00000000000001p+0, false,
-	0x1.00000000000001p+0, false,
-	0x1.00000000000001p+0, false,
-	0x1.00000000000001p+0, false,
-	true,
-	0x1.00000000000001p+0, false,
-	0x1.00000000000001p+0, false,
-	0x1.00000000000001p+0, false,
-	0x1.00000000000001p+0, false,
-	true,
-	0x1.00000000000001p+0, false,
-	0x1.00000000000001p+0, false,
-	0x1.00000000000001p+0, false,
-	0x1.00000000000001p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	true,
+	0x1.00000000000001p+0, false, false,
+	0x1.00000000000001p+0, false, false,
+	0x1.00000000000001p+0, false, false,
+	0x1.00000000000001p+0, false, false,
+	true,
+	0x1.00000000000001p+0, false, false,
+	0x1.00000000000001p+0, false, false,
+	0x1.00000000000001p+0, false, false,
+	0x1.00000000000001p+0, false, false,
+	true,
+	0x1.00000000000001p+0, false, false,
+	0x1.00000000000001p+0, false, false,
+	0x1.00000000000001p+0, false, false,
+	0x1.00000000000001p+0, false, false,
+	true,
+	0x1.00000000000001p+0, false, false,
+	0x1.00000000000001p+0, false, false,
+	0x1.00000000000001p+0, false, false,
+	0x1.00000000000001p+0, false, false),
   TEST ("1.000000000000000006938893903907228377647697925567626953125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	true,
-	0x1.000000000000008p+0, false,
-	0x1.000000000000008p+0, false,
-	0x1.000000000000008p+0, false,
-	0x1.000000000000008p+0, false,
-	true,
-	0x1.000000000000008p+0, false,
-	0x1.000000000000008p+0, false,
-	0x1.000000000000008p+0, false,
-	0x1.000000000000008p+0, false,
-	true,
-	0x1.000000000000008p+0, false,
-	0x1.000000000000008p+0, false,
-	0x1.000000000000008p+0, false,
-	0x1.000000000000008p+0, false,
-	true,
-	0x1.000000000000008p+0, false,
-	0x1.000000000000008p+0, false,
-	0x1.000000000000008p+0, false,
-	0x1.000000000000008p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	true,
+	0x1.000000000000008p+0, false, false,
+	0x1.000000000000008p+0, false, false,
+	0x1.000000000000008p+0, false, false,
+	0x1.000000000000008p+0, false, false,
+	true,
+	0x1.000000000000008p+0, false, false,
+	0x1.000000000000008p+0, false, false,
+	0x1.000000000000008p+0, false, false,
+	0x1.000000000000008p+0, false, false,
+	true,
+	0x1.000000000000008p+0, false, false,
+	0x1.000000000000008p+0, false, false,
+	0x1.000000000000008p+0, false, false,
+	0x1.000000000000008p+0, false, false,
+	true,
+	0x1.000000000000008p+0, false, false,
+	0x1.000000000000008p+0, false, false,
+	0x1.000000000000008p+0, false, false,
+	0x1.000000000000008p+0, false, false),
   TEST ("1.0000000000000000034694469519536141888238489627838134765625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	true,
-	0x1.000000000000004p+0, false,
-	0x1.000000000000004p+0, false,
-	0x1.000000000000004p+0, false,
-	0x1.000000000000004p+0, false,
-	true,
-	0x1.000000000000004p+0, false,
-	0x1.000000000000004p+0, false,
-	0x1.000000000000004p+0, false,
-	0x1.000000000000004p+0, false,
-	true,
-	0x1.000000000000004p+0, false,
-	0x1.000000000000004p+0, false,
-	0x1.000000000000004p+0, false,
-	0x1.000000000000004p+0, false,
-	true,
-	0x1.000000000000004p+0, false,
-	0x1.000000000000004p+0, false,
-	0x1.000000000000004p+0, false,
-	0x1.000000000000004p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	true,
+	0x1.000000000000004p+0, false, false,
+	0x1.000000000000004p+0, false, false,
+	0x1.000000000000004p+0, false, false,
+	0x1.000000000000004p+0, false, false,
+	true,
+	0x1.000000000000004p+0, false, false,
+	0x1.000000000000004p+0, false, false,
+	0x1.000000000000004p+0, false, false,
+	0x1.000000000000004p+0, false, false,
+	true,
+	0x1.000000000000004p+0, false, false,
+	0x1.000000000000004p+0, false, false,
+	0x1.000000000000004p+0, false, false,
+	0x1.000000000000004p+0, false, false,
+	true,
+	0x1.000000000000004p+0, false, false,
+	0x1.000000000000004p+0, false, false,
+	0x1.000000000000004p+0, false, false,
+	0x1.000000000000004p+0, false, false),
   TEST ("1.0000000000000000017347234759768070944119244813919067382812"
 	"5",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	true,
-	0x1.000000000000002p+0, false,
-	0x1.000000000000002p+0, false,
-	0x1.000000000000002p+0, false,
-	0x1.000000000000002p+0, false,
-	true,
-	0x1.000000000000002p+0, false,
-	0x1.000000000000002p+0, false,
-	0x1.000000000000002p+0, false,
-	0x1.000000000000002p+0, false,
-	true,
-	0x1.000000000000002p+0, false,
-	0x1.000000000000002p+0, false,
-	0x1.000000000000002p+0, false,
-	0x1.000000000000002p+0, false,
-	true,
-	0x1.000000000000002p+0, false,
-	0x1.000000000000002p+0, false,
-	0x1.000000000000002p+0, false,
-	0x1.000000000000002p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	true,
+	0x1.000000000000002p+0, false, false,
+	0x1.000000000000002p+0, false, false,
+	0x1.000000000000002p+0, false, false,
+	0x1.000000000000002p+0, false, false,
+	true,
+	0x1.000000000000002p+0, false, false,
+	0x1.000000000000002p+0, false, false,
+	0x1.000000000000002p+0, false, false,
+	0x1.000000000000002p+0, false, false,
+	true,
+	0x1.000000000000002p+0, false, false,
+	0x1.000000000000002p+0, false, false,
+	0x1.000000000000002p+0, false, false,
+	0x1.000000000000002p+0, false, false,
+	true,
+	0x1.000000000000002p+0, false, false,
+	0x1.000000000000002p+0, false, false,
+	0x1.000000000000002p+0, false, false,
+	0x1.000000000000002p+0, false, false),
   TEST ("1.0000000000000000008673617379884035472059622406959533691406"
 	"25",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	true,
-	0x1.000000000000001p+0, false,
-	0x1.000000000000001p+0, false,
-	0x1.000000000000001p+0, false,
-	0x1.000000000000001p+0, false,
-	true,
-	0x1.000000000000001p+0, false,
-	0x1.000000000000001p+0, false,
-	0x1.000000000000001p+0, false,
-	0x1.000000000000001p+0, false,
-	true,
-	0x1.000000000000001p+0, false,
-	0x1.000000000000001p+0, false,
-	0x1.000000000000001p+0, false,
-	0x1.000000000000001p+0, false,
-	true,
-	0x1.000000000000001p+0, false,
-	0x1.000000000000001p+0, false,
-	0x1.000000000000001p+0, false,
-	0x1.000000000000001p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	true,
+	0x1.000000000000001p+0, false, false,
+	0x1.000000000000001p+0, false, false,
+	0x1.000000000000001p+0, false, false,
+	0x1.000000000000001p+0, false, false,
+	true,
+	0x1.000000000000001p+0, false, false,
+	0x1.000000000000001p+0, false, false,
+	0x1.000000000000001p+0, false, false,
+	0x1.000000000000001p+0, false, false,
+	true,
+	0x1.000000000000001p+0, false, false,
+	0x1.000000000000001p+0, false, false,
+	0x1.000000000000001p+0, false, false,
+	0x1.000000000000001p+0, false, false,
+	true,
+	0x1.000000000000001p+0, false, false,
+	0x1.000000000000001p+0, false, false,
+	0x1.000000000000001p+0, false, false,
+	0x1.000000000000001p+0, false, false),
   TEST ("1.0000000000000000004336808689942017736029811203479766845703"
 	"125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	true,
-	0x1.0000000000000008p+0, false,
-	0x1.0000000000000008p+0, false,
-	0x1.0000000000000008p+0, false,
-	0x1.0000000000000008p+0, false,
-	true,
-	0x1.0000000000000008p+0, false,
-	0x1.0000000000000008p+0, false,
-	0x1.0000000000000008p+0, false,
-	0x1.0000000000000008p+0, false,
-	true,
-	0x1.0000000000000008p+0, false,
-	0x1.0000000000000008p+0, false,
-	0x1.0000000000000008p+0, false,
-	0x1.0000000000000008p+0, false,
-	true,
-	0x1.0000000000000008p+0, false,
-	0x1.0000000000000008p+0, false,
-	0x1.0000000000000008p+0, false,
-	0x1.0000000000000008p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	true,
+	0x1.0000000000000008p+0, false, false,
+	0x1.0000000000000008p+0, false, false,
+	0x1.0000000000000008p+0, false, false,
+	0x1.0000000000000008p+0, false, false,
+	true,
+	0x1.0000000000000008p+0, false, false,
+	0x1.0000000000000008p+0, false, false,
+	0x1.0000000000000008p+0, false, false,
+	0x1.0000000000000008p+0, false, false,
+	true,
+	0x1.0000000000000008p+0, false, false,
+	0x1.0000000000000008p+0, false, false,
+	0x1.0000000000000008p+0, false, false,
+	0x1.0000000000000008p+0, false, false,
+	true,
+	0x1.0000000000000008p+0, false, false,
+	0x1.0000000000000008p+0, false, false,
+	0x1.0000000000000008p+0, false, false,
+	0x1.0000000000000008p+0, false, false),
   TEST ("1.0000000000000000002168404344971008868014905601739883422851"
 	"5625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	true,
-	0x1.0000000000000004p+0, false,
-	0x1.0000000000000004p+0, false,
-	0x1.0000000000000004p+0, false,
-	0x1.0000000000000004p+0, false,
-	true,
-	0x1.0000000000000004p+0, false,
-	0x1.0000000000000004p+0, false,
-	0x1.0000000000000004p+0, false,
-	0x1.0000000000000004p+0, false,
-	true,
-	0x1.0000000000000004p+0, false,
-	0x1.0000000000000004p+0, false,
-	0x1.0000000000000004p+0, false,
-	0x1.0000000000000004p+0, false,
-	true,
-	0x1.0000000000000004p+0, false,
-	0x1.0000000000000004p+0, false,
-	0x1.0000000000000004p+0, false,
-	0x1.0000000000000004p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	true,
+	0x1.0000000000000004p+0, false, false,
+	0x1.0000000000000004p+0, false, false,
+	0x1.0000000000000004p+0, false, false,
+	0x1.0000000000000004p+0, false, false,
+	true,
+	0x1.0000000000000004p+0, false, false,
+	0x1.0000000000000004p+0, false, false,
+	0x1.0000000000000004p+0, false, false,
+	0x1.0000000000000004p+0, false, false,
+	true,
+	0x1.0000000000000004p+0, false, false,
+	0x1.0000000000000004p+0, false, false,
+	0x1.0000000000000004p+0, false, false,
+	0x1.0000000000000004p+0, false, false,
+	true,
+	0x1.0000000000000004p+0, false, false,
+	0x1.0000000000000004p+0, false, false,
+	0x1.0000000000000004p+0, false, false,
+	0x1.0000000000000004p+0, false, false),
   TEST ("1.0000000000000000001084202172485504434007452800869941711425"
 	"78125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	true,
-	0x1.0000000000000002p+0, false,
-	0x1.0000000000000002p+0, false,
-	0x1.0000000000000002p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.0000000000000002p+0, false,
-	0x1.0000000000000002p+0, false,
-	0x1.0000000000000002p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.0000000000000002p+0, false,
-	0x1.0000000000000002p+0, false,
-	0x1.0000000000000002p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.0000000000000002p+0, false,
-	0x1.0000000000000002p+0, false,
-	0x1.0000000000000002p+0, false,
-	0x1.0000000000000002p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	true,
+	0x1.0000000000000002p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.0000000000000002p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.0000000000000002p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.0000000000000002p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	0x1.0000000000000002p+0, false, false),
   TEST ("1.0000000000000000000542101086242752217003726400434970855712"
 	"890625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.0000000000000001p+0, false,
-	0x1.0000000000000001p+0, false,
-	0x1.0000000000000001p+0, false,
-	0x1.0000000000000001p+0, false,
-	true,
-	0x1.0000000000000001p+0, false,
-	0x1.0000000000000001p+0, false,
-	0x1.0000000000000001p+0, false,
-	0x1.0000000000000001p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.0000000000000001p+0, false, false,
+	0x1.0000000000000001p+0, false, false,
+	0x1.0000000000000001p+0, false, false,
+	0x1.0000000000000001p+0, false, false,
+	true,
+	0x1.0000000000000001p+0, false, false,
+	0x1.0000000000000001p+0, false, false,
+	0x1.0000000000000001p+0, false, false,
+	0x1.0000000000000001p+0, false, false),
   TEST ("1.0000000000000000000271050543121376108501863200217485427856"
 	"4453125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.00000000000000008p+0, false,
-	0x1.00000000000000008p+0, false,
-	0x1.00000000000000008p+0, false,
-	0x1.00000000000000008p+0, false,
-	true,
-	0x1.00000000000000008p+0, false,
-	0x1.00000000000000008p+0, false,
-	0x1.00000000000000008p+0, false,
-	0x1.00000000000000008p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.00000000000000008p+0, false, false,
+	0x1.00000000000000008p+0, false, false,
+	0x1.00000000000000008p+0, false, false,
+	0x1.00000000000000008p+0, false, false,
+	true,
+	0x1.00000000000000008p+0, false, false,
+	0x1.00000000000000008p+0, false, false,
+	0x1.00000000000000008p+0, false, false,
+	0x1.00000000000000008p+0, false, false),
   TEST ("1.0000000000000000000135525271560688054250931600108742713928"
 	"22265625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.00000000000000004p+0, false,
-	0x1.00000000000000004p+0, false,
-	0x1.00000000000000004p+0, false,
-	0x1.00000000000000004p+0, false,
-	true,
-	0x1.00000000000000004p+0, false,
-	0x1.00000000000000004p+0, false,
-	0x1.00000000000000004p+0, false,
-	0x1.00000000000000004p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.00000000000000004p+0, false, false,
+	0x1.00000000000000004p+0, false, false,
+	0x1.00000000000000004p+0, false, false,
+	0x1.00000000000000004p+0, false, false,
+	true,
+	0x1.00000000000000004p+0, false, false,
+	0x1.00000000000000004p+0, false, false,
+	0x1.00000000000000004p+0, false, false,
+	0x1.00000000000000004p+0, false, false),
   TEST ("1.0000000000000000000067762635780344027125465800054371356964"
 	"111328125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.00000000000000002p+0, false,
-	0x1.00000000000000002p+0, false,
-	0x1.00000000000000002p+0, false,
-	0x1.00000000000000002p+0, false,
-	true,
-	0x1.00000000000000002p+0, false,
-	0x1.00000000000000002p+0, false,
-	0x1.00000000000000002p+0, false,
-	0x1.00000000000000002p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.00000000000000002p+0, false, false,
+	0x1.00000000000000002p+0, false, false,
+	0x1.00000000000000002p+0, false, false,
+	0x1.00000000000000002p+0, false, false,
+	true,
+	0x1.00000000000000002p+0, false, false,
+	0x1.00000000000000002p+0, false, false,
+	0x1.00000000000000002p+0, false, false,
+	0x1.00000000000000002p+0, false, false),
   TEST ("1.0000000000000000000033881317890172013562732900027185678482"
 	"0556640625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.00000000000000001p+0, false,
-	0x1.00000000000000001p+0, false,
-	0x1.00000000000000001p+0, false,
-	0x1.00000000000000001p+0, false,
-	true,
-	0x1.00000000000000001p+0, false,
-	0x1.00000000000000001p+0, false,
-	0x1.00000000000000001p+0, false,
-	0x1.00000000000000001p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.00000000000000001p+0, false, false,
+	0x1.00000000000000001p+0, false, false,
+	0x1.00000000000000001p+0, false, false,
+	0x1.00000000000000001p+0, false, false,
+	true,
+	0x1.00000000000000001p+0, false, false,
+	0x1.00000000000000001p+0, false, false,
+	0x1.00000000000000001p+0, false, false,
+	0x1.00000000000000001p+0, false, false),
   TEST ("1.0000000000000000000016940658945086006781366450013592839241"
 	"02783203125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.000000000000000008p+0, false,
-	0x1.000000000000000008p+0, false,
-	0x1.000000000000000008p+0, false,
-	0x1.000000000000000008p+0, false,
-	true,
-	0x1.000000000000000008p+0, false,
-	0x1.000000000000000008p+0, false,
-	0x1.000000000000000008p+0, false,
-	0x1.000000000000000008p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.000000000000000008p+0, false, false,
+	0x1.000000000000000008p+0, false, false,
+	0x1.000000000000000008p+0, false, false,
+	0x1.000000000000000008p+0, false, false,
+	true,
+	0x1.000000000000000008p+0, false, false,
+	0x1.000000000000000008p+0, false, false,
+	0x1.000000000000000008p+0, false, false,
+	0x1.000000000000000008p+0, false, false),
   TEST ("1.0000000000000000000008470329472543003390683225006796419620"
 	"513916015625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.000000000000000004p+0, false,
-	0x1.000000000000000004p+0, false,
-	0x1.000000000000000004p+0, false,
-	0x1.000000000000000004p+0, false,
-	true,
-	0x1.000000000000000004p+0, false,
-	0x1.000000000000000004p+0, false,
-	0x1.000000000000000004p+0, false,
-	0x1.000000000000000004p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.000000000000000004p+0, false, false,
+	0x1.000000000000000004p+0, false, false,
+	0x1.000000000000000004p+0, false, false,
+	0x1.000000000000000004p+0, false, false,
+	true,
+	0x1.000000000000000004p+0, false, false,
+	0x1.000000000000000004p+0, false, false,
+	0x1.000000000000000004p+0, false, false,
+	0x1.000000000000000004p+0, false, false),
   TEST ("1.0000000000000000000004235164736271501695341612503398209810"
 	"2569580078125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.000000000000000002p+0, false,
-	0x1.000000000000000002p+0, false,
-	0x1.000000000000000002p+0, false,
-	0x1.000000000000000002p+0, false,
-	true,
-	0x1.000000000000000002p+0, false,
-	0x1.000000000000000002p+0, false,
-	0x1.000000000000000002p+0, false,
-	0x1.000000000000000002p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.000000000000000002p+0, false, false,
+	0x1.000000000000000002p+0, false, false,
+	0x1.000000000000000002p+0, false, false,
+	0x1.000000000000000002p+0, false, false,
+	true,
+	0x1.000000000000000002p+0, false, false,
+	0x1.000000000000000002p+0, false, false,
+	0x1.000000000000000002p+0, false, false,
+	0x1.000000000000000002p+0, false, false),
   TEST ("1.0000000000000000000002117582368135750847670806251699104905"
 	"12847900390625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.000000000000000001p+0, false,
-	0x1.000000000000000001p+0, false,
-	0x1.000000000000000001p+0, false,
-	0x1.000000000000000001p+0, false,
-	true,
-	0x1.000000000000000001p+0, false,
-	0x1.000000000000000001p+0, false,
-	0x1.000000000000000001p+0, false,
-	0x1.000000000000000001p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.000000000000000001p+0, false, false,
+	0x1.000000000000000001p+0, false, false,
+	0x1.000000000000000001p+0, false, false,
+	0x1.000000000000000001p+0, false, false,
+	true,
+	0x1.000000000000000001p+0, false, false,
+	0x1.000000000000000001p+0, false, false,
+	0x1.000000000000000001p+0, false, false,
+	0x1.000000000000000001p+0, false, false),
   TEST ("1.0000000000000000000001058791184067875423835403125849552452"
 	"564239501953125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.0000000000000000008p+0, false,
-	0x1.0000000000000000008p+0, false,
-	0x1.0000000000000000008p+0, false,
-	0x1.0000000000000000008p+0, false,
-	true,
-	0x1.0000000000000000008p+0, false,
-	0x1.0000000000000000008p+0, false,
-	0x1.0000000000000000008p+0, false,
-	0x1.0000000000000000008p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.0000000000000000008p+0, false, false,
+	0x1.0000000000000000008p+0, false, false,
+	0x1.0000000000000000008p+0, false, false,
+	0x1.0000000000000000008p+0, false, false,
+	true,
+	0x1.0000000000000000008p+0, false, false,
+	0x1.0000000000000000008p+0, false, false,
+	0x1.0000000000000000008p+0, false, false,
+	0x1.0000000000000000008p+0, false, false),
   TEST ("1.0000000000000000000000529395592033937711917701562924776226"
 	"2821197509765625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.0000000000000000004p+0, false,
-	0x1.0000000000000000004p+0, false,
-	0x1.0000000000000000004p+0, false,
-	0x1.0000000000000000004p+0, false,
-	true,
-	0x1.0000000000000000004p+0, false,
-	0x1.0000000000000000004p+0, false,
-	0x1.0000000000000000004p+0, false,
-	0x1.0000000000000000004p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.0000000000000000004p+0, false, false,
+	0x1.0000000000000000004p+0, false, false,
+	0x1.0000000000000000004p+0, false, false,
+	0x1.0000000000000000004p+0, false, false,
+	true,
+	0x1.0000000000000000004p+0, false, false,
+	0x1.0000000000000000004p+0, false, false,
+	0x1.0000000000000000004p+0, false, false,
+	0x1.0000000000000000004p+0, false, false),
   TEST ("1.0000000000000000000000264697796016968855958850781462388113"
 	"14105987548828125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.0000000000000000002p+0, false,
-	0x1.0000000000000000002p+0, false,
-	0x1.0000000000000000002p+0, false,
-	0x1.0000000000000000002p+0, false,
-	true,
-	0x1.0000000000000000002p+0, false,
-	0x1.0000000000000000002p+0, false,
-	0x1.0000000000000000002p+0, false,
-	0x1.0000000000000000002p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.0000000000000000002p+0, false, false,
+	0x1.0000000000000000002p+0, false, false,
+	0x1.0000000000000000002p+0, false, false,
+	0x1.0000000000000000002p+0, false, false,
+	true,
+	0x1.0000000000000000002p+0, false, false,
+	0x1.0000000000000000002p+0, false, false,
+	0x1.0000000000000000002p+0, false, false,
+	0x1.0000000000000000002p+0, false, false),
   TEST ("1.0000000000000000000000132348898008484427979425390731194056"
 	"570529937744140625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.0000000000000000001p+0, false,
-	0x1.0000000000000000001p+0, false,
-	0x1.0000000000000000001p+0, false,
-	0x1.0000000000000000001p+0, false,
-	true,
-	0x1.0000000000000000001p+0, false,
-	0x1.0000000000000000001p+0, false,
-	0x1.0000000000000000001p+0, false,
-	0x1.0000000000000000001p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.0000000000000000001p+0, false, false,
+	0x1.0000000000000000001p+0, false, false,
+	0x1.0000000000000000001p+0, false, false,
+	0x1.0000000000000000001p+0, false, false,
+	true,
+	0x1.0000000000000000001p+0, false, false,
+	0x1.0000000000000000001p+0, false, false,
+	0x1.0000000000000000001p+0, false, false,
+	0x1.0000000000000000001p+0, false, false),
   TEST ("1.0000000000000000000000066174449004242213989712695365597028"
 	"2852649688720703125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.00000000000000000008p+0, false,
-	0x1.00000000000000000008p+0, false,
-	0x1.00000000000000000008p+0, false,
-	0x1.00000000000000000008p+0, false,
-	true,
-	0x1.00000000000000000008p+0, false,
-	0x1.00000000000000000008p+0, false,
-	0x1.00000000000000000008p+0, false,
-	0x1.00000000000000000008p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.00000000000000000008p+0, false, false,
+	0x1.00000000000000000008p+0, false, false,
+	0x1.00000000000000000008p+0, false, false,
+	0x1.00000000000000000008p+0, false, false,
+	true,
+	0x1.00000000000000000008p+0, false, false,
+	0x1.00000000000000000008p+0, false, false,
+	0x1.00000000000000000008p+0, false, false,
+	0x1.00000000000000000008p+0, false, false),
   TEST ("1.0000000000000000000000033087224502121106994856347682798514"
 	"14263248443603515625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.00000000000000000004p+0, false,
-	0x1.00000000000000000004p+0, false,
-	0x1.00000000000000000004p+0, false,
-	0x1.00000000000000000004p+0, false,
-	true,
-	0x1.00000000000000000004p+0, false,
-	0x1.00000000000000000004p+0, false,
-	0x1.00000000000000000004p+0, false,
-	0x1.00000000000000000004p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.00000000000000000004p+0, false, false,
+	0x1.00000000000000000004p+0, false, false,
+	0x1.00000000000000000004p+0, false, false,
+	0x1.00000000000000000004p+0, false, false,
+	true,
+	0x1.00000000000000000004p+0, false, false,
+	0x1.00000000000000000004p+0, false, false,
+	0x1.00000000000000000004p+0, false, false,
+	0x1.00000000000000000004p+0, false, false),
   TEST ("1.0000000000000000000000016543612251060553497428173841399257"
 	"071316242218017578125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.00000000000000000002p+0, false,
-	0x1.00000000000000000002p+0, false,
-	0x1.00000000000000000002p+0, false,
-	0x1.00000000000000000002p+0, false,
-	true,
-	0x1.00000000000000000002p+0, false,
-	0x1.00000000000000000002p+0, false,
-	0x1.00000000000000000002p+0, false,
-	0x1.00000000000000000002p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.00000000000000000002p+0, false, false,
+	0x1.00000000000000000002p+0, false, false,
+	0x1.00000000000000000002p+0, false, false,
+	0x1.00000000000000000002p+0, false, false,
+	true,
+	0x1.00000000000000000002p+0, false, false,
+	0x1.00000000000000000002p+0, false, false,
+	0x1.00000000000000000002p+0, false, false,
+	0x1.00000000000000000002p+0, false, false),
   TEST ("1.0000000000000000000000008271806125530276748714086920699628"
 	"5356581211090087890625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.00000000000000000001p+0, false,
-	0x1.00000000000000000001p+0, false,
-	0x1.00000000000000000001p+0, false,
-	0x1.00000000000000000001p+0, false,
-	true,
-	0x1.00000000000000000001p+0, false,
-	0x1.00000000000000000001p+0, false,
-	0x1.00000000000000000001p+0, false,
-	0x1.00000000000000000001p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.00000000000000000001p+0, false, false,
+	0x1.00000000000000000001p+0, false, false,
+	0x1.00000000000000000001p+0, false, false,
+	0x1.00000000000000000001p+0, false, false,
+	true,
+	0x1.00000000000000000001p+0, false, false,
+	0x1.00000000000000000001p+0, false, false,
+	0x1.00000000000000000001p+0, false, false,
+	0x1.00000000000000000001p+0, false, false),
   TEST ("1.0000000000000000000000004135903062765138374357043460349814"
 	"26782906055450439453125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.000000000000000000008p+0, false,
-	0x1.000000000000000000008p+0, false,
-	0x1.000000000000000000008p+0, false,
-	0x1.000000000000000000008p+0, false,
-	true,
-	0x1.000000000000000000008p+0, false,
-	0x1.000000000000000000008p+0, false,
-	0x1.000000000000000000008p+0, false,
-	0x1.000000000000000000008p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.000000000000000000008p+0, false, false,
+	0x1.000000000000000000008p+0, false, false,
+	0x1.000000000000000000008p+0, false, false,
+	0x1.000000000000000000008p+0, false, false,
+	true,
+	0x1.000000000000000000008p+0, false, false,
+	0x1.000000000000000000008p+0, false, false,
+	0x1.000000000000000000008p+0, false, false,
+	0x1.000000000000000000008p+0, false, false),
   TEST ("1.0000000000000000000000002067951531382569187178521730174907"
 	"133914530277252197265625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.000000000000000000004p+0, false,
-	0x1.000000000000000000004p+0, false,
-	0x1.000000000000000000004p+0, false,
-	0x1.000000000000000000004p+0, false,
-	true,
-	0x1.000000000000000000004p+0, false,
-	0x1.000000000000000000004p+0, false,
-	0x1.000000000000000000004p+0, false,
-	0x1.000000000000000000004p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.000000000000000000004p+0, false, false,
+	0x1.000000000000000000004p+0, false, false,
+	0x1.000000000000000000004p+0, false, false,
+	0x1.000000000000000000004p+0, false, false,
+	true,
+	0x1.000000000000000000004p+0, false, false,
+	0x1.000000000000000000004p+0, false, false,
+	0x1.000000000000000000004p+0, false, false,
+	0x1.000000000000000000004p+0, false, false),
   TEST ("1.0000000000000000000000001033975765691284593589260865087453"
 	"5669572651386260986328125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.000000000000000000002p+0, false,
-	0x1.000000000000000000002p+0, false,
-	0x1.000000000000000000002p+0, false,
-	0x1.000000000000000000002p+0, false,
-	true,
-	0x1.000000000000000000002p+0, false,
-	0x1.000000000000000000002p+0, false,
-	0x1.000000000000000000002p+0, false,
-	0x1.000000000000000000002p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.000000000000000000002p+0, false, false,
+	0x1.000000000000000000002p+0, false, false,
+	0x1.000000000000000000002p+0, false, false,
+	0x1.000000000000000000002p+0, false, false,
+	true,
+	0x1.000000000000000000002p+0, false, false,
+	0x1.000000000000000000002p+0, false, false,
+	0x1.000000000000000000002p+0, false, false,
+	0x1.000000000000000000002p+0, false, false),
   TEST ("1.0000000000000000000000000516987882845642296794630432543726"
 	"78347863256931304931640625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.000000000000000000001p+0, false,
-	0x1.000000000000000000001p+0, false,
-	0x1.000000000000000000001p+0, false,
-	0x1.000000000000000000001p+0, false,
-	true,
-	0x1.000000000000000000001p+0, false,
-	0x1.000000000000000000001p+0, false,
-	0x1.000000000000000000001p+0, false,
-	0x1.000000000000000000001p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.000000000000000000001p+0, false, false,
+	0x1.000000000000000000001p+0, false, false,
+	0x1.000000000000000000001p+0, false, false,
+	0x1.000000000000000000001p+0, false, false,
+	true,
+	0x1.000000000000000000001p+0, false, false,
+	0x1.000000000000000000001p+0, false, false,
+	0x1.000000000000000000001p+0, false, false,
+	0x1.000000000000000000001p+0, false, false),
   TEST ("1.0000000000000000000000000258493941422821148397315216271863"
 	"391739316284656524658203125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.0000000000000000000008p+0, false,
-	0x1.0000000000000000000008p+0, false,
-	0x1.0000000000000000000008p+0, false,
-	0x1.0000000000000000000008p+0, false,
-	true,
-	0x1.0000000000000000000008p+0, false,
-	0x1.0000000000000000000008p+0, false,
-	0x1.0000000000000000000008p+0, false,
-	0x1.0000000000000000000008p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.0000000000000000000008p+0, false, false,
+	0x1.0000000000000000000008p+0, false, false,
+	0x1.0000000000000000000008p+0, false, false,
+	0x1.0000000000000000000008p+0, false, false,
+	true,
+	0x1.0000000000000000000008p+0, false, false,
+	0x1.0000000000000000000008p+0, false, false,
+	0x1.0000000000000000000008p+0, false, false,
+	0x1.0000000000000000000008p+0, false, false),
   TEST ("1.0000000000000000000000000129246970711410574198657608135931"
 	"6958696581423282623291015625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.0000000000000000000004p+0, false,
-	0x1.0000000000000000000004p+0, false,
-	0x1.0000000000000000000004p+0, false,
-	0x1.0000000000000000000004p+0, false,
-	true,
-	0x1.0000000000000000000004p+0, false,
-	0x1.0000000000000000000004p+0, false,
-	0x1.0000000000000000000004p+0, false,
-	0x1.0000000000000000000004p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.0000000000000000000004p+0, false, false,
+	0x1.0000000000000000000004p+0, false, false,
+	0x1.0000000000000000000004p+0, false, false,
+	0x1.0000000000000000000004p+0, false, false,
+	true,
+	0x1.0000000000000000000004p+0, false, false,
+	0x1.0000000000000000000004p+0, false, false,
+	0x1.0000000000000000000004p+0, false, false,
+	0x1.0000000000000000000004p+0, false, false),
   TEST ("1.0000000000000000000000000064623485355705287099328804067965"
 	"84793482907116413116455078125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.0000000000000000000002p+0, false,
-	0x1.0000000000000000000002p+0, false,
-	0x1.0000000000000000000002p+0, false,
-	0x1.0000000000000000000002p+0, false,
-	true,
-	0x1.0000000000000000000002p+0, false,
-	0x1.0000000000000000000002p+0, false,
-	0x1.0000000000000000000002p+0, false,
-	0x1.0000000000000000000002p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.0000000000000000000002p+0, false, false,
+	0x1.0000000000000000000002p+0, false, false,
+	0x1.0000000000000000000002p+0, false, false,
+	0x1.0000000000000000000002p+0, false, false,
+	true,
+	0x1.0000000000000000000002p+0, false, false,
+	0x1.0000000000000000000002p+0, false, false,
+	0x1.0000000000000000000002p+0, false, false,
+	0x1.0000000000000000000002p+0, false, false),
   TEST ("1.0000000000000000000000000032311742677852643549664402033982"
 	"923967414535582065582275390625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.0000000000000000000001p+0, false,
-	0x1.0000000000000000000001p+0, false,
-	0x1.0000000000000000000001p+0, false,
-	0x1.0000000000000000000001p+0, false,
-	true,
-	0x1.0000000000000000000001p+0, false,
-	0x1.0000000000000000000001p+0, false,
-	0x1.0000000000000000000001p+0, false,
-	0x1.0000000000000000000001p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.0000000000000000000001p+0, false, false,
+	0x1.0000000000000000000001p+0, false, false,
+	0x1.0000000000000000000001p+0, false, false,
+	0x1.0000000000000000000001p+0, false, false,
+	true,
+	0x1.0000000000000000000001p+0, false, false,
+	0x1.0000000000000000000001p+0, false, false,
+	0x1.0000000000000000000001p+0, false, false,
+	0x1.0000000000000000000001p+0, false, false),
   TEST ("1.0000000000000000000000000016155871338926321774832201016991"
 	"4619837072677910327911376953125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.00000000000000000000008p+0, false,
-	0x1.00000000000000000000008p+0, false,
-	0x1.00000000000000000000008p+0, false,
-	0x1.00000000000000000000008p+0, false,
-	true,
-	0x1.00000000000000000000008p+0, false,
-	0x1.00000000000000000000008p+0, false,
-	0x1.00000000000000000000008p+0, false,
-	0x1.00000000000000000000008p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.00000000000000000000008p+0, false, false,
+	0x1.00000000000000000000008p+0, false, false,
+	0x1.00000000000000000000008p+0, false, false,
+	0x1.00000000000000000000008p+0, false, false,
+	true,
+	0x1.00000000000000000000008p+0, false, false,
+	0x1.00000000000000000000008p+0, false, false,
+	0x1.00000000000000000000008p+0, false, false,
+	0x1.00000000000000000000008p+0, false, false),
   TEST ("1.0000000000000000000000000008077935669463160887416100508495"
 	"73099185363389551639556884765625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.00000000000000000000004p+0, false,
-	0x1.00000000000000000000004p+0, false,
-	0x1.00000000000000000000004p+0, false,
-	0x1.00000000000000000000004p+0, false,
-	true,
-	0x1.00000000000000000000004p+0, false,
-	0x1.00000000000000000000004p+0, false,
-	0x1.00000000000000000000004p+0, false,
-	0x1.00000000000000000000004p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.00000000000000000000004p+0, false, false,
+	0x1.00000000000000000000004p+0, false, false,
+	0x1.00000000000000000000004p+0, false, false,
+	0x1.00000000000000000000004p+0, false, false,
+	true,
+	0x1.00000000000000000000004p+0, false, false,
+	0x1.00000000000000000000004p+0, false, false,
+	0x1.00000000000000000000004p+0, false, false,
+	0x1.00000000000000000000004p+0, false, false),
   TEST ("1.0000000000000000000000000004038967834731580443708050254247"
 	"865495926816947758197784423828125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.00000000000000000000002p+0, false,
-	0x1.00000000000000000000002p+0, false,
-	0x1.00000000000000000000002p+0, false,
-	0x1.00000000000000000000002p+0, false,
-	true,
-	0x1.00000000000000000000002p+0, false,
-	0x1.00000000000000000000002p+0, false,
-	0x1.00000000000000000000002p+0, false,
-	0x1.00000000000000000000002p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.00000000000000000000002p+0, false, false,
+	0x1.00000000000000000000002p+0, false, false,
+	0x1.00000000000000000000002p+0, false, false,
+	0x1.00000000000000000000002p+0, false, false,
+	true,
+	0x1.00000000000000000000002p+0, false, false,
+	0x1.00000000000000000000002p+0, false, false,
+	0x1.00000000000000000000002p+0, false, false,
+	0x1.00000000000000000000002p+0, false, false),
   TEST ("1.0000000000000000000000000002019483917365790221854025127123"
 	"9327479634084738790988922119140625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.00000000000000000000001p+0, false,
-	0x1.00000000000000000000001p+0, false,
-	0x1.00000000000000000000001p+0, false,
-	0x1.00000000000000000000001p+0, false,
-	true,
-	0x1.00000000000000000000001p+0, false,
-	0x1.00000000000000000000001p+0, false,
-	0x1.00000000000000000000001p+0, false,
-	0x1.00000000000000000000001p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.00000000000000000000001p+0, false, false,
+	0x1.00000000000000000000001p+0, false, false,
+	0x1.00000000000000000000001p+0, false, false,
+	0x1.00000000000000000000001p+0, false, false,
+	true,
+	0x1.00000000000000000000001p+0, false, false,
+	0x1.00000000000000000000001p+0, false, false,
+	0x1.00000000000000000000001p+0, false, false,
+	0x1.00000000000000000000001p+0, false, false),
   TEST ("1.0000000000000000000000000001009741958682895110927012563561"
 	"96637398170423693954944610595703125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.000000000000000000000008p+0, false,
-	0x1.000000000000000000000008p+0, false,
-	0x1.000000000000000000000008p+0, false,
-	0x1.000000000000000000000008p+0, false,
-	true,
-	0x1.000000000000000000000008p+0, false,
-	0x1.000000000000000000000008p+0, false,
-	0x1.000000000000000000000008p+0, false,
-	0x1.000000000000000000000008p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.000000000000000000000008p+0, false, false,
+	0x1.000000000000000000000008p+0, false, false,
+	0x1.000000000000000000000008p+0, false, false,
+	0x1.000000000000000000000008p+0, false, false,
+	true,
+	0x1.000000000000000000000008p+0, false, false,
+	0x1.000000000000000000000008p+0, false, false,
+	0x1.000000000000000000000008p+0, false, false,
+	0x1.000000000000000000000008p+0, false, false),
   TEST ("1.0000000000000000000000000000504870979341447555463506281780"
 	"983186990852118469774723052978515625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.000000000000000000000004p+0, false,
-	0x1.000000000000000000000004p+0, false,
-	0x1.000000000000000000000004p+0, false,
-	0x1.000000000000000000000004p+0, false,
-	true,
-	0x1.000000000000000000000004p+0, false,
-	0x1.000000000000000000000004p+0, false,
-	0x1.000000000000000000000004p+0, false,
-	0x1.000000000000000000000004p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.000000000000000000000004p+0, false, false,
+	0x1.000000000000000000000004p+0, false, false,
+	0x1.000000000000000000000004p+0, false, false,
+	0x1.000000000000000000000004p+0, false, false,
+	true,
+	0x1.000000000000000000000004p+0, false, false,
+	0x1.000000000000000000000004p+0, false, false,
+	0x1.000000000000000000000004p+0, false, false,
+	0x1.000000000000000000000004p+0, false, false),
   TEST ("1.0000000000000000000000000000252435489670723777731753140890"
 	"4915934954260592348873615264892578125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.000000000000000000000002p+0, false,
-	0x1.000000000000000000000002p+0, false,
-	0x1.000000000000000000000002p+0, false,
-	0x1.000000000000000000000002p+0, false,
-	true,
-	0x1.000000000000000000000002p+0, false,
-	0x1.000000000000000000000002p+0, false,
-	0x1.000000000000000000000002p+0, false,
-	0x1.000000000000000000000002p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.000000000000000000000002p+0, false, false,
+	0x1.000000000000000000000002p+0, false, false,
+	0x1.000000000000000000000002p+0, false, false,
+	0x1.000000000000000000000002p+0, false, false,
+	true,
+	0x1.000000000000000000000002p+0, false, false,
+	0x1.000000000000000000000002p+0, false, false,
+	0x1.000000000000000000000002p+0, false, false,
+	0x1.000000000000000000000002p+0, false, false),
   TEST ("1.0000000000000000000000000000126217744835361888865876570445"
 	"24579674771302961744368076324462890625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.000000000000000000000001p+0, false,
-	0x1.000000000000000000000001p+0, false,
-	0x1.000000000000000000000001p+0, false,
-	0x1.000000000000000000000001p+0, false,
-	true,
-	0x1.000000000000000000000001p+0, false,
-	0x1.000000000000000000000001p+0, false,
-	0x1.000000000000000000000001p+0, false,
-	0x1.000000000000000000000001p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.000000000000000000000001p+0, false, false,
+	0x1.000000000000000000000001p+0, false, false,
+	0x1.000000000000000000000001p+0, false, false,
+	0x1.000000000000000000000001p+0, false, false,
+	true,
+	0x1.000000000000000000000001p+0, false, false,
+	0x1.000000000000000000000001p+0, false, false,
+	0x1.000000000000000000000001p+0, false, false,
+	0x1.000000000000000000000001p+0, false, false),
   TEST ("1.0000000000000000000000000000063108872417680944432938285222"
 	"622898373856514808721840381622314453125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.0000000000000000000000008p+0, false,
-	0x1.0000000000000000000000008p+0, false,
-	0x1.0000000000000000000000008p+0, false,
-	0x1.0000000000000000000000008p+0, false,
-	true,
-	0x1.0000000000000000000000008p+0, false,
-	0x1.0000000000000000000000008p+0, false,
-	0x1.0000000000000000000000008p+0, false,
-	0x1.0000000000000000000000008p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.0000000000000000000000008p+0, false, false,
+	0x1.0000000000000000000000008p+0, false, false,
+	0x1.0000000000000000000000008p+0, false, false,
+	0x1.0000000000000000000000008p+0, false, false,
+	true,
+	0x1.0000000000000000000000008p+0, false, false,
+	0x1.0000000000000000000000008p+0, false, false,
+	0x1.0000000000000000000000008p+0, false, false,
+	0x1.0000000000000000000000008p+0, false, false),
   TEST ("1.0000000000000000000000000000031554436208840472216469142611"
 	"3114491869282574043609201908111572265625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.0000000000000000000000004p+0, false,
-	0x1.0000000000000000000000004p+0, false,
-	0x1.0000000000000000000000004p+0, false,
-	0x1.0000000000000000000000004p+0, false,
-	true,
-	0x1.0000000000000000000000004p+0, false,
-	0x1.0000000000000000000000004p+0, false,
-	0x1.0000000000000000000000004p+0, false,
-	0x1.0000000000000000000000004p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.0000000000000000000000004p+0, false, false,
+	0x1.0000000000000000000000004p+0, false, false,
+	0x1.0000000000000000000000004p+0, false, false,
+	0x1.0000000000000000000000004p+0, false, false,
+	true,
+	0x1.0000000000000000000000004p+0, false, false,
+	0x1.0000000000000000000000004p+0, false, false,
+	0x1.0000000000000000000000004p+0, false, false,
+	0x1.0000000000000000000000004p+0, false, false),
   TEST ("1.0000000000000000000000000000015777218104420236108234571305"
 	"65572459346412870218046009540557861328125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.0000000000000000000000002p+0, false,
-	0x1.0000000000000000000000002p+0, false,
-	0x1.0000000000000000000000002p+0, false,
-	0x1.0000000000000000000000002p+0, false,
-	true,
-	0x1.0000000000000000000000002p+0, false,
-	0x1.0000000000000000000000002p+0, false,
-	0x1.0000000000000000000000002p+0, false,
-	0x1.0000000000000000000000002p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.0000000000000000000000002p+0, false, false,
+	0x1.0000000000000000000000002p+0, false, false,
+	0x1.0000000000000000000000002p+0, false, false,
+	0x1.0000000000000000000000002p+0, false, false,
+	true,
+	0x1.0000000000000000000000002p+0, false, false,
+	0x1.0000000000000000000000002p+0, false, false,
+	0x1.0000000000000000000000002p+0, false, false,
+	0x1.0000000000000000000000002p+0, false, false),
   TEST ("1.0000000000000000000000000000007888609052210118054117285652"
 	"827862296732064351090230047702789306640625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.0000000000000000000000001p+0, false,
-	0x1.0000000000000000000000001p+0, false,
-	0x1.0000000000000000000000001p+0, false,
-	0x1.0000000000000000000000001p+0, false,
-	true,
-	0x1.0000000000000000000000001p+0, false,
-	0x1.0000000000000000000000001p+0, false,
-	0x1.0000000000000000000000001p+0, false,
-	0x1.0000000000000000000000001p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.0000000000000000000000001p+0, false, false,
+	0x1.0000000000000000000000001p+0, false, false,
+	0x1.0000000000000000000000001p+0, false, false,
+	0x1.0000000000000000000000001p+0, false, false,
+	true,
+	0x1.0000000000000000000000001p+0, false, false,
+	0x1.0000000000000000000000001p+0, false, false,
+	0x1.0000000000000000000000001p+0, false, false,
+	0x1.0000000000000000000000001p+0, false, false),
   TEST ("1.0000000000000000000000000000003944304526105059027058642826"
 	"4139311483660321755451150238513946533203125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.00000000000000000000000008p+0, false,
-	0x1.00000000000000000000000008p+0, false,
-	0x1.00000000000000000000000008p+0, false,
-	0x1.00000000000000000000000008p+0, false,
-	true,
-	0x1.00000000000000000000000008p+0, false,
-	0x1.00000000000000000000000008p+0, false,
-	0x1.00000000000000000000000008p+0, false,
-	0x1.00000000000000000000000008p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.00000000000000000000000008p+0, false, false,
+	0x1.00000000000000000000000008p+0, false, false,
+	0x1.00000000000000000000000008p+0, false, false,
+	0x1.00000000000000000000000008p+0, false, false,
+	true,
+	0x1.00000000000000000000000008p+0, false, false,
+	0x1.00000000000000000000000008p+0, false, false,
+	0x1.00000000000000000000000008p+0, false, false,
+	0x1.00000000000000000000000008p+0, false, false),
   TEST ("1.0000000000000000000000000000001972152263052529513529321413"
 	"20696557418301608777255751192569732666015625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.00000000000000000000000004p+0, false,
-	0x1.00000000000000000000000004p+0, false,
-	0x1.00000000000000000000000004p+0, false,
-	0x1.00000000000000000000000004p+0, false,
-	true,
-	0x1.00000000000000000000000004p+0, false,
-	0x1.00000000000000000000000004p+0, false,
-	0x1.00000000000000000000000004p+0, false,
-	0x1.00000000000000000000000004p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.00000000000000000000000004p+0, false, false,
+	0x1.00000000000000000000000004p+0, false, false,
+	0x1.00000000000000000000000004p+0, false, false,
+	0x1.00000000000000000000000004p+0, false, false,
+	true,
+	0x1.00000000000000000000000004p+0, false, false,
+	0x1.00000000000000000000000004p+0, false, false,
+	0x1.00000000000000000000000004p+0, false, false,
+	0x1.00000000000000000000000004p+0, false, false),
   TEST ("1.0000000000000000000000000000000986076131526264756764660706"
 	"603482787091508043886278755962848663330078125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.00000000000000000000000002p+0, false,
-	0x1.00000000000000000000000002p+0, false,
-	0x1.00000000000000000000000002p+0, false,
-	0x1.00000000000000000000000002p+0, false,
-	true,
-	0x1.00000000000000000000000002p+0, false,
-	0x1.00000000000000000000000002p+0, false,
-	0x1.00000000000000000000000002p+0, false,
-	0x1.00000000000000000000000002p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.00000000000000000000000002p+0, false, false,
+	0x1.00000000000000000000000002p+0, false, false,
+	0x1.00000000000000000000000002p+0, false, false,
+	0x1.00000000000000000000000002p+0, false, false,
+	true,
+	0x1.00000000000000000000000002p+0, false, false,
+	0x1.00000000000000000000000002p+0, false, false,
+	0x1.00000000000000000000000002p+0, false, false,
+	0x1.00000000000000000000000002p+0, false, false),
   TEST ("1.0000000000000000000000000000000493038065763132378382330353"
 	"3017413935457540219431393779814243316650390625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.00000000000000000000000001p+0, false,
-	0x1.00000000000000000000000001p+0, false,
-	0x1.00000000000000000000000001p+0, false,
-	0x1.00000000000000000000000001p+0, false,
-	true,
-	0x1.00000000000000000000000001p+0, false,
-	0x1.00000000000000000000000001p+0, false,
-	0x1.00000000000000000000000001p+0, false,
-	0x1.00000000000000000000000001p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.00000000000000000000000001p+0, false, false,
+	0x1.00000000000000000000000001p+0, false, false,
+	0x1.00000000000000000000000001p+0, false, false,
+	0x1.00000000000000000000000001p+0, false, false,
+	true,
+	0x1.00000000000000000000000001p+0, false, false,
+	0x1.00000000000000000000000001p+0, false, false,
+	0x1.00000000000000000000000001p+0, false, false,
+	0x1.00000000000000000000000001p+0, false, false),
   TEST ("1.0000000000000000000000000000000246519032881566189191165176"
 	"65087069677287701097156968899071216583251953125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	true,
-	0x1.000000000000000000000000008p+0, false,
-	0x1.000000000000000000000000008p+0, false,
-	0x1.000000000000000000000000008p+0, false,
-	0x1.000000000000000000000000008p+0, false,
-	true,
-	0x1.000000000000000000000000008p+0, false,
-	0x1.000000000000000000000000008p+0, false,
-	0x1.000000000000000000000000008p+0, false,
-	0x1.000000000000000000000000008p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	true,
+	0x1.000000000000000000000000008p+0, false, false,
+	0x1.000000000000000000000000008p+0, false, false,
+	0x1.000000000000000000000000008p+0, false, false,
+	0x1.000000000000000000000000008p+0, false, false,
+	true,
+	0x1.000000000000000000000000008p+0, false, false,
+	0x1.000000000000000000000000008p+0, false, false,
+	0x1.000000000000000000000000008p+0, false, false,
+	0x1.000000000000000000000000008p+0, false, false),
   TEST ("1.0000000000000000000000000000000123259516440783094595582588"
 	"325435348386438505485784844495356082916259765625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000000000000000000000000008p+0, false,
-	true,
-	0x1.000000000000000000000000004p+0, false,
-	0x1.000000000000000000000000004p+0, false,
-	0x1.000000000000000000000000004p+0, false,
-	0x1.000000000000000000000000004p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000000000000000000000000008p+0, false, false,
+	true,
+	0x1.000000000000000000000000004p+0, false, false,
+	0x1.000000000000000000000000004p+0, false, false,
+	0x1.000000000000000000000000004p+0, false, false,
+	0x1.000000000000000000000000004p+0, false, false),
   TEST ("1.0000000000000000000000000000000061629758220391547297791294"
 	"1627176741932192527428924222476780414581298828125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000000000000000000000000008p+0, false,
-	true,
-	0x1.000000000000000000000000002p+0, false,
-	0x1.000000000000000000000000002p+0, false,
-	0x1.000000000000000000000000002p+0, false,
-	0x1.000000000000000000000000002p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000000000000000000000000008p+0, false, false,
+	true,
+	0x1.000000000000000000000000002p+0, false, false,
+	0x1.000000000000000000000000002p+0, false, false,
+	0x1.000000000000000000000000002p+0, false, false,
+	0x1.000000000000000000000000002p+0, false, false),
   TEST ("1.0000000000000000000000000000000030814879110195773648895647"
 	"08135883709660962637144621112383902072906494140625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000000000000000000000000008p+0, false,
-	true,
-	0x1.000000000000000000000000001p+0, false,
-	0x1.000000000000000000000000001p+0, false,
-	0x1.000000000000000000000000001p+0, false,
-	0x1.000000000000000000000000001p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000000000000000000000000008p+0, false, false,
+	true,
+	0x1.000000000000000000000000001p+0, false, false,
+	0x1.000000000000000000000000001p+0, false, false,
+	0x1.000000000000000000000000001p+0, false, false,
+	0x1.000000000000000000000000001p+0, false, false),
   TEST ("1.0000000000000000000000000000000015407439555097886824447823"
 	"540679418548304813185723105561919510364532470703125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000000000000000000000000008p+0, false,
-	true,
-	0x1.0000000000000000000000000008p+0, false,
-	0x1.0000000000000000000000000008p+0, false,
-	0x1.0000000000000000000000000008p+0, false,
-	0x1.0000000000000000000000000008p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000000000000000000000000008p+0, false, false,
+	true,
+	0x1.0000000000000000000000000008p+0, false, false,
+	0x1.0000000000000000000000000008p+0, false, false,
+	0x1.0000000000000000000000000008p+0, false, false,
+	0x1.0000000000000000000000000008p+0, false, false),
   TEST ("1.0000000000000000000000000000000007703719777548943412223911"
 	"7703397092741524065928615527809597551822662353515625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000000000000000000000000008p+0, false,
-	true,
-	0x1.0000000000000000000000000004p+0, false,
-	0x1.0000000000000000000000000004p+0, false,
-	0x1.0000000000000000000000000004p+0, false,
-	0x1.0000000000000000000000000004p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000000000000000000000000008p+0, false, false,
+	true,
+	0x1.0000000000000000000000000004p+0, false, false,
+	0x1.0000000000000000000000000004p+0, false, false,
+	0x1.0000000000000000000000000004p+0, false, false,
+	0x1.0000000000000000000000000004p+0, false, false),
   TEST ("1.0000000000000000000000000000000003851859888774471706111955"
 	"88516985463707620329643077639047987759113311767578125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000000000000000000000000008p+0, false,
-	true,
-	0x1.0000000000000000000000000002p+0, false,
-	0x1.0000000000000000000000000002p+0, false,
-	0x1.0000000000000000000000000002p+0, false,
-	0x1.0000000000000000000000000002p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000000000000000000000000008p+0, false, false,
+	true,
+	0x1.0000000000000000000000000002p+0, false, false,
+	0x1.0000000000000000000000000002p+0, false, false,
+	0x1.0000000000000000000000000002p+0, false, false,
+	0x1.0000000000000000000000000002p+0, false, false),
   TEST ("1.0000000000000000000000000000000001925929944387235853055977"
 	"942584927318538101648215388195239938795566558837890625",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000000000000000000000000008p+0, false,
-	true,
-	0x1.0000000000000000000000000001p+0, false,
-	0x1.0000000000000000000000000001p+0, false,
-	0x1.0000000000000000000000000001p+0, false,
-	0x1.0000000000000000000000000001p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000000000000000000000000008p+0, false, false,
+	true,
+	0x1.0000000000000000000000000001p+0, false, false,
+	0x1.0000000000000000000000000001p+0, false, false,
+	0x1.0000000000000000000000000001p+0, false, false,
+	0x1.0000000000000000000000000001p+0, false, false),
   TEST ("1.0000000000000000000000000000000000962964972193617926527988"
 	"9712924636592690508241076940976199693977832794189453125",
 	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000001p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000002p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.000000000000000000000000008p+0, false,
-	false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1p+0, false,
-	0x1.0000000000000000000000000001p+0, false),
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000001p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000002p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.000000000000000000000000008p+0, false, false,
+	false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1p+0, false, false,
+	0x1.0000000000000000000000000001p+0, false, false),
+  TEST ("0x30000002222225p-1077",
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x1.800000111111p-1024, false, true,
+	0x1.8000001111114p-1024, false, true,
+	0x1.800000111111p-1024, false, true,
+	0x1.8000001111114p-1024, false, true,
+	true,
+	0x1.80000011111128p-1024, false, false,
+	0x1.80000011111128p-1024, false, false,
+	0x1.80000011111128p-1024, false, false,
+	0x1.80000011111128p-1024, false, false,
+	true,
+	0x1.80000011111128p-1024, false, false,
+	0x1.80000011111128p-1024, false, false,
+	0x1.80000011111128p-1024, false, false,
+	0x1.80000011111128p-1024, false, false,
+	false,
+	0x1.800000111111p-1024, false, true,
+	0x1.8000001111114p-1024, false, true,
+	0x1.800000111111p-1024, false, true,
+	0x1.8000001111114p-1024, false, true,
+	true,
+	0x1.80000011111128p-1024, false, false,
+	0x1.80000011111128p-1024, false, false,
+	0x1.80000011111128p-1024, false, false,
+	0x1.80000011111128p-1024, false, false),
+  TEST ("0x0.7fffffffffffeap-1022",
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x1.ffffffffffff8p-1024, false, true,
+	0x1.ffffffffffffcp-1024, false, true,
+	0x1.ffffffffffff8p-1024, false, true,
+	0x1.ffffffffffffcp-1024, false, true,
+	true,
+	0x1.ffffffffffffa8p-1024, false, false,
+	0x1.ffffffffffffa8p-1024, false, false,
+	0x1.ffffffffffffa8p-1024, false, false,
+	0x1.ffffffffffffa8p-1024, false, false,
+	true,
+	0x1.ffffffffffffa8p-1024, false, false,
+	0x1.ffffffffffffa8p-1024, false, false,
+	0x1.ffffffffffffa8p-1024, false, false,
+	0x1.ffffffffffffa8p-1024, false, false,
+	false,
+	0x1.ffffffffffff8p-1024, false, true,
+	0x1.ffffffffffffcp-1024, false, true,
+	0x1.ffffffffffff8p-1024, false, true,
+	0x1.ffffffffffffcp-1024, false, true,
+	true,
+	0x1.ffffffffffffa8p-1024, false, false,
+	0x1.ffffffffffffa8p-1024, false, false,
+	0x1.ffffffffffffa8p-1024, false, false,
+	0x1.ffffffffffffa8p-1024, false, false),
+  TEST ("0x0.7fffffffffffe9p-1022",
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x1.ffffffffffff8p-1024, false, true,
+	0x1.ffffffffffffcp-1024, false, true,
+	0x1.ffffffffffff8p-1024, false, true,
+	0x1.ffffffffffffcp-1024, false, true,
+	true,
+	0x1.ffffffffffffa4p-1024, false, false,
+	0x1.ffffffffffffa4p-1024, false, false,
+	0x1.ffffffffffffa4p-1024, false, false,
+	0x1.ffffffffffffa4p-1024, false, false,
+	true,
+	0x1.ffffffffffffa4p-1024, false, false,
+	0x1.ffffffffffffa4p-1024, false, false,
+	0x1.ffffffffffffa4p-1024, false, false,
+	0x1.ffffffffffffa4p-1024, false, false,
+	false,
+	0x1.ffffffffffff8p-1024, false, true,
+	0x1.ffffffffffffcp-1024, false, true,
+	0x1.ffffffffffff8p-1024, false, true,
+	0x1.ffffffffffffcp-1024, false, true,
+	true,
+	0x1.ffffffffffffa4p-1024, false, false,
+	0x1.ffffffffffffa4p-1024, false, false,
+	0x1.ffffffffffffa4p-1024, false, false,
+	0x1.ffffffffffffa4p-1024, false, false),
+  TEST ("0x0.7ffffd4p-126",
+	false,
+	0x1.fffffp-128, false, true,
+	0x1.fffff8p-128, false, true,
+	0x1.fffffp-128, false, true,
+	0x1.fffff8p-128, false, true,
+	true,
+	0x1.fffff5p-128, false, false,
+	0x1.fffff5p-128, false, false,
+	0x1.fffff5p-128, false, false,
+	0x1.fffff5p-128, false, false,
+	true,
+	0x1.fffff5p-128, false, false,
+	0x1.fffff5p-128, false, false,
+	0x1.fffff5p-128, false, false,
+	0x1.fffff5p-128, false, false,
+	true,
+	0x1.fffff5p-128, false, false,
+	0x1.fffff5p-128, false, false,
+	0x1.fffff5p-128, false, false,
+	0x1.fffff5p-128, false, false,
+	true,
+	0x1.fffff5p-128, false, false,
+	0x1.fffff5p-128, false, false,
+	0x1.fffff5p-128, false, false,
+	0x1.fffff5p-128, false, false,
+	true,
+	0x1.fffff5p-128, false, false,
+	0x1.fffff5p-128, false, false,
+	0x1.fffff5p-128, false, false,
+	0x1.fffff5p-128, false, false),
+  TEST ("0x0.7ffffffffffffffd4p-16382",
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x1.fffffffffffffffp-16384, false, true,
+	0x1.fffffffffffffff8p-16384, false, true,
+	0x1.fffffffffffffffp-16384, false, true,
+	0x1.fffffffffffffff8p-16384, false, true,
+	false,
+	0x1.fffffffffffffff4p-16384, false, true,
+	0x1.fffffffffffffff4p-16384, false, true,
+	0x1.fffffffffffffff4p-16384, false, true,
+	0x1.fffffffffffffff8p-16384, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	true,
+	0x1.fffffffffffffff5p-16384, false, false,
+	0x1.fffffffffffffff5p-16384, false, false,
+	0x1.fffffffffffffff5p-16384, false, false,
+	0x1.fffffffffffffff5p-16384, false, false),
+  TEST ("0x0.7ffffffffffffffd4p-16383",
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0xf.ffffffffffffff8p-16388, false, true,
+	0xf.ffffffffffffff8p-16388, false, true,
+	0xf.ffffffffffffff8p-16388, false, true,
+	0x1p-16384, false, true,
+	false,
+	0xf.ffffffffffffff8p-16388, false, true,
+	0xf.ffffffffffffffcp-16388, false, true,
+	0xf.ffffffffffffff8p-16388, false, true,
+	0xf.ffffffffffffffcp-16388, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	true,
+	0xf.ffffffffffffffa8p-16388, false, false,
+	0xf.ffffffffffffffa8p-16388, false, false,
+	0xf.ffffffffffffffa8p-16388, false, false,
+	0xf.ffffffffffffffa8p-16388, false, false),
+  TEST ("0x0.7ffffffffffffffffffffffffffeap-16382",
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x1.fffffffffffffff8p-16384, false, true,
+	0x2p-16384, false, true,
+	0x1.fffffffffffffff8p-16384, false, true,
+	0x2p-16384, false, true,
+	false,
+	0x1.fffffffffffffffcp-16384, false, true,
+	0x2p-16384, false, true,
+	0x1.fffffffffffffffcp-16384, false, true,
+	0x2p-16384, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x1.fffffffffffffffffffffffffff8p-16384, false, true,
+	0x1.fffffffffffffffffffffffffffcp-16384, false, true,
+	0x1.fffffffffffffffffffffffffff8p-16384, false, true,
+	0x1.fffffffffffffffffffffffffffcp-16384, false, true),
+  TEST ("0x0.7000004p-126",
+	false,
+	0x1.cp-128, false, true,
+	0x1.cp-128, false, true,
+	0x1.cp-128, false, true,
+	0x1.c00008p-128, false, true,
+	true,
+	0x1.c00001p-128, false, false,
+	0x1.c00001p-128, false, false,
+	0x1.c00001p-128, false, false,
+	0x1.c00001p-128, false, false,
+	true,
+	0x1.c00001p-128, false, false,
+	0x1.c00001p-128, false, false,
+	0x1.c00001p-128, false, false,
+	0x1.c00001p-128, false, false,
+	true,
+	0x1.c00001p-128, false, false,
+	0x1.c00001p-128, false, false,
+	0x1.c00001p-128, false, false,
+	0x1.c00001p-128, false, false,
+	true,
+	0x1.c00001p-128, false, false,
+	0x1.c00001p-128, false, false,
+	0x1.c00001p-128, false, false,
+	0x1.c00001p-128, false, false,
+	true,
+	0x1.c00001p-128, false, false,
+	0x1.c00001p-128, false, false,
+	0x1.c00001p-128, false, false,
+	0x1.c00001p-128, false, false),
+  TEST ("0x0.70000000000002p-1022",
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x1.cp-1024, false, true,
+	0x1.cp-1024, false, true,
+	0x1.cp-1024, false, true,
+	0x1.c000000000004p-1024, false, true,
+	true,
+	0x1.c0000000000008p-1024, false, false,
+	0x1.c0000000000008p-1024, false, false,
+	0x1.c0000000000008p-1024, false, false,
+	0x1.c0000000000008p-1024, false, false,
+	true,
+	0x1.c0000000000008p-1024, false, false,
+	0x1.c0000000000008p-1024, false, false,
+	0x1.c0000000000008p-1024, false, false,
+	0x1.c0000000000008p-1024, false, false,
+	false,
+	0x1.cp-1024, false, true,
+	0x1.cp-1024, false, true,
+	0x1.cp-1024, false, true,
+	0x1.c000000000004p-1024, false, true,
+	true,
+	0x1.c0000000000008p-1024, false, false,
+	0x1.c0000000000008p-1024, false, false,
+	0x1.c0000000000008p-1024, false, false,
+	0x1.c0000000000008p-1024, false, false),
+  TEST ("0x0.70000000000000004p-16382",
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x1.cp-16384, false, true,
+	0x1.cp-16384, false, true,
+	0x1.cp-16384, false, true,
+	0x1.c000000000000008p-16384, false, true,
+	false,
+	0x1.cp-16384, false, true,
+	0x1.cp-16384, false, true,
+	0x1.cp-16384, false, true,
+	0x1.c000000000000004p-16384, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	true,
+	0x1.c000000000000001p-16384, false, false,
+	0x1.c000000000000001p-16384, false, false,
+	0x1.c000000000000001p-16384, false, false,
+	0x1.c000000000000001p-16384, false, false),
+  TEST ("0x0.70000000000000004p-16383",
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0xep-16388, false, true,
+	0xep-16388, false, true,
+	0xep-16388, false, true,
+	0xe.000000000000008p-16388, false, true,
+	false,
+	0xep-16388, false, true,
+	0xep-16388, false, true,
+	0xep-16388, false, true,
+	0xe.000000000000004p-16388, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	true,
+	0xe.0000000000000008p-16388, false, false,
+	0xe.0000000000000008p-16388, false, false,
+	0xe.0000000000000008p-16388, false, false,
+	0xe.0000000000000008p-16388, false, false),
+  TEST ("0x0.70000000000000000000000000002p-16382",
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x8p-152, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x1.cp-16384, false, true,
+	0x1.cp-16384, false, true,
+	0x1.cp-16384, false, true,
+	0x1.c000000000000008p-16384, false, true,
+	false,
+	0x1.cp-16384, false, true,
+	0x1.cp-16384, false, true,
+	0x1.cp-16384, false, true,
+	0x1.c000000000000004p-16384, false, true,
+	false,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x0p+0, false, true,
+	0x4p-1076, false, true,
+	false,
+	0x1.cp-16384, false, true,
+	0x1.cp-16384, false, true,
+	0x1.cp-16384, false, true,
+	0x1.c000000000000000000000000004p-16384, false, true),
 };
diff --git a/stdlib/tst-strtod-round-skeleton.c b/stdlib/tst-strtod-round-skeleton.c
index 6fba4b5228..be081ba416 100644
--- a/stdlib/tst-strtod-round-skeleton.c
+++ b/stdlib/tst-strtod-round-skeleton.c
@@ -21,6 +21,7 @@
    declared in the headers.  */
 #define _LIBC_TEST 1
 #define __STDC_WANT_IEC_60559_TYPES_EXT__
+#include <errno.h>
 #include <fenv.h>
 #include <float.h>
 #include <math.h>
@@ -29,6 +30,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <math-tests.h>
+#include <tininess.h>
 
 #include "tst-strtod.h"
 
@@ -138,16 +140,26 @@
    gen-tst-strtod-round utility to select the appropriately
    rounded long double value for a given format.  */
 #define TEST(s,							\
-	     fx, fd, fdo, fn, fno, fz, fzo, fu, fuo,		\
-	     dx, dd, ddo, dn, dno, dz, dzo, du, duo,		\
-	     ld64ix, ld64id, ld64ido, ld64in, ld64ino,		\
-	     ld64iz, ld64izo, ld64iu, ld64iuo,			\
-	     ld64mx, ld64md, ld64mdo, ld64mn, ld64mno,		\
-	     ld64mz, ld64mzo, ld64mu, ld64muo,			\
-	     ld106x, ld106d, ld106do, ld106n, ld106no,		\
-	     ld106z, ld106zo, ld106u, ld106uo,			\
-	     ld113x, ld113d, ld113do, ld113n, ld113no,		\
-	     ld113z, ld113zo, ld113u, ld113uo)			\
+	     fx, fd, fdo, fdu, fn, fno, fnu,			\
+	     fz, fzo, fzu, fu, fuo, fuu,			\
+	     dx, dd, ddo, ddu, dn, dno, dnu,			\
+	     dz, dzo, dzu, du, duo, duu,			\
+	     ld64ix, ld64id, ld64ido, ld64idu,			\
+	     ld64in, ld64ino, ld64inu,				\
+	     ld64iz, ld64izo, ld64izu,				\
+	     ld64iu, ld64iuo, ld64iuu,				\
+	     ld64mx, ld64md, ld64mdo, ld64mdu,			\
+	     ld64mn, ld64mno, ld64mnu,				\
+	     ld64mz, ld64mzo, ld64mzu,				\
+	     ld64mu, ld64muo, ld64muu,				\
+	     ld106x, ld106d, ld106do, ld106du,			\
+	     ld106n, ld106no, ld106nu,				\
+	     ld106z, ld106zo, ld106zu,				\
+	     ld106u, ld106uo, ld106uu,				\
+	     ld113x, ld113d, ld113do, ld113du,			\
+	     ld113n, ld113no, ld113nu,				\
+	     ld113z, ld113zo, ld113zu,				\
+	     ld113u, ld113uo, ld113uu)				\
   {								\
     L_ (s),							\
     { XNTRY (fx, dx, ld64ix, ld64mx, ld106x, ld113x) },		\
@@ -162,6 +174,12 @@
     { XNTRY (fdo, ddo, ld64ido, ld64mdo, ld106do, ld113do) },	\
     { XNTRY (fzo, dzo, ld64izo, ld64mzo, ld106zo, ld113zo) },	\
     { XNTRY (fuo, duo, ld64iuo, ld64muo, ld106uo, ld113uo) }	\
+    },								\
+    {								\
+    { XNTRY (fnu, dnu, ld64inu, ld64mnu, ld106nu, ld113nu) },	\
+    { XNTRY (fdu, ddu, ld64idu, ld64mdu, ld106du, ld113du) },	\
+    { XNTRY (fzu, dzu, ld64izu, ld64mzu, ld106zu, ld113zu) },	\
+    { XNTRY (fuu, duu, ld64iuu, ld64muu, ld106uu, ld113uu) }	\
     }								\
   }
 
@@ -180,11 +198,17 @@ struct test_overflow
   STRUCT_FOREACH_FLOAT_BOOL
   };
 
+struct test_underflow
+  {
+  STRUCT_FOREACH_FLOAT_BOOL
+  };
+
 struct test {
   const CHAR *s;
   struct test_exactness exact;
   struct test_results r[4];
   struct test_overflow o[4];
+  struct test_underflow u[4];
 };
 
 /* Include the generated test data.  */
@@ -202,10 +226,16 @@ struct test {
 # define FE_OVERFLOW 0
 #endif
 
+#ifndef FE_UNDERFLOW
+# define FE_UNDERFLOW 0
+#endif
+
 #define GEN_ONE_TEST(FSUF, FTYPE, FTOSTR, LSUF, CSUF)		\
 {								\
   feclearexcept (FE_ALL_EXCEPT);				\
+  errno = 12345;						\
   FTYPE f = STRTO (FSUF) (s, NULL);				\
+  int new_errno = errno;					\
   if (f != expected->FSUF					\
       || (copysign ## CSUF) (1.0 ## LSUF, f)			\
 	 != (copysign ## CSUF) (1.0 ## LSUF, expected->FSUF))	\
@@ -254,6 +284,48 @@ struct test {
 		printf ("ignoring this exception error\n");	\
 	    }							\
 	}							\
+      if (overflow->FSUF && new_errno != ERANGE)		\
+	{							\
+	  printf (FNPFXS "to" #FSUF				\
+		  " (" STRM ") left errno == %d,"		\
+		  " not %d (ERANGE)\n",				\
+		  s, new_errno, ERANGE);			\
+	  result = 1;						\
+	}							\
+      if (FE_UNDERFLOW != 0)					\
+	{							\
+	  bool underflow_raised					\
+	    = fetestexcept (FE_UNDERFLOW) != 0;			\
+	  if (underflow_raised != underflow->FSUF)		\
+	    {							\
+	      printf (FNPFXS "to" #FSUF				\
+		      " (" STRM ") underflow %d "		\
+		      "not %d\n", s, underflow_raised,		\
+		      underflow->FSUF);				\
+	      if (EXCEPTION_TESTS (FTYPE))			\
+		result = 1;					\
+	      else						\
+		printf ("ignoring this exception error\n");	\
+	    }							\
+	}							\
+      if (underflow->FSUF && new_errno != ERANGE)		\
+	{							\
+	  printf (FNPFXS "to" #FSUF				\
+		  " (" STRM ") left errno == %d,"		\
+		  " not %d (ERANGE)\n",				\
+		  s, new_errno, ERANGE);			\
+	  result = 1;						\
+	}							\
+      if (!overflow->FSUF					\
+	  && !underflow->FSUF					\
+	  && new_errno != 12345)				\
+	{							\
+	  printf (FNPFXS "to" #FSUF				\
+		  " (" STRM ") set errno == %d,"		\
+		  " should be unchanged\n",			\
+		  s, new_errno);				\
+	  result = 1;						\
+	}							\
     }								\
 }
 
@@ -261,6 +333,7 @@ static int
 test_in_one_mode (const CHAR *s, const struct test_results *expected,
 		    const struct test_exactness *exact,
 		    const struct test_overflow *overflow,
+		    const struct test_underflow *underflow,
 		    const char *mode_name, int rnd_mode)
 {
   int result = 0;
@@ -296,6 +369,7 @@ do_test (void)
     {
       result |= test_in_one_mode (tests[i].s, &tests[i].r[modes[0].rnd_i],
 				  &tests[i].exact, &tests[i].o[modes[0].rnd_i],
+				  &tests[i].u[modes[0].rnd_i],
 				  modes[0].mode_name, modes[0].rnd_mode);
       for (const struct fetestmodes *m = &modes[1]; m->mode_name != NULL; m++)
 	{
@@ -303,7 +377,9 @@ do_test (void)
 	    {
 	      result |= test_in_one_mode (tests[i].s, &tests[i].r[m->rnd_i],
 					  &tests[i].exact,
-					  &tests[i].o[m->rnd_i], m->mode_name,
+					  &tests[i].o[m->rnd_i],
+					  &tests[i].u[m->rnd_i],
+					  m->mode_name,
 					  m->rnd_mode);
 	      fesetround (save_round_mode);
 	    }
diff --git a/stdlib/tst-strtod-underflow.c b/stdlib/tst-strtod-underflow.c
index a5ced18599..8598b95b6d 100644
--- a/stdlib/tst-strtod-underflow.c
+++ b/stdlib/tst-strtod-underflow.c
@@ -17,6 +17,10 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
+/* Defining _LIBC_TEST ensures long double math functions are
+   declared in the headers.  */
+#define _LIBC_TEST 1
+#define __STDC_WANT_IEC_60559_TYPES_EXT__
 #include <errno.h>
 #include <fenv.h>
 #include <float.h>
@@ -25,6 +29,60 @@
 #include <stdlib.h>
 #include <tininess.h>
 
+#include "tst-strtod.h"
+
+/* Logic for selecting between tests for different formats is as in
+   tst-strtod-skeleton.c, but here it is selecting string inputs with
+   different underflow properties, rather than generated test
+   data.  */
+
+#define _CONCAT(a, b) a ## b
+#define CONCAT(a, b) _CONCAT (a, b)
+
+#define MEMBER(FSUF, FTYPE, FTOSTR, LSUF, CSUF)	\
+  const char *s_ ## FSUF;
+
+#if LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024
+# define CHOOSE_ld(f,d,...) d
+#elif LDBL_MANT_DIG == 64 && LDBL_MAX_EXP == 16384 && LDBL_MIN_EXP == -16381
+# define CHOOSE_ld(f,d,ld64i,...) ld64i
+#elif LDBL_MANT_DIG == 64 && LDBL_MAX_EXP == 16384 && LDBL_MIN_EXP == -16382
+# define CHOOSE_ld(f,d,ld64i,ld64m,...) ld64m
+#elif LDBL_MANT_DIG == 106 && LDBL_MAX_EXP == 1024
+# define CHOOSE_ld(f,d,ld64i,ld64m,ld106,...) ld106
+#elif LDBL_MANT_DIG == 113 && LDBL_MAX_EXP == 16384
+# define CHOOSE_ld(f,d,ld64i,ld64m,ld106,ld113,...) ld113
+#else
+# error "unknown long double format"
+#endif
+
+#define CHOOSE_f(f,...) f
+#define CHOOSE_f32(f,...) f
+#define CHOOSE_d(f,d,...) d
+#define CHOOSE_f64(f,d,...) d
+#define CHOOSE_f32x(f,d,...) d
+#define CHOOSE_f128(f,d,ld64i,ld64m,ld106,ld113,...) ld113
+
+#if __HAVE_FLOAT64X
+# if FLT64X_MANT_DIG == 113 && FLT64X_MAX_EXP == 16384
+#  define CHOOSE_f64x(f,d,ld64i,ld64m,ld106,ld113,...) ld113
+# elif (FLT64X_MANT_DIG == 64			\
+	&& FLT64X_MAX_EXP == 16384		\
+	&& FLT64X_MIN_EXP == -16381)
+#  define CHOOSE_f64x(f,d,ld64i,...) ld64i
+# else
+#  error "unknown _Float64x format"
+# endif
+#endif
+
+#define _XNTRY(FSUF, FTYPE, FTOSTR, LSUF, CSUF, ...)	\
+  CHOOSE_ ## FSUF (__VA_ARGS__),
+#define XNTRY(...) \
+  GEN_TEST_STRTOD_FOREACH (_XNTRY, __VA_ARGS__)
+
+#define TEST(f, d, ld64i, ld64m, ld106, ld113, u) \
+  { XNTRY(f, d, ld64i, ld64m, ld106, ld113) u }
+
 enum underflow_case
   {
     /* Result is exact or outside the subnormal range.  */
@@ -55,38 +113,194 @@ enum underflow_case
 
 struct test
 {
-  const char *s;
+  GEN_TEST_STRTOD_FOREACH (MEMBER)
   enum underflow_case c;
 };
 
 static const struct test tests[] =
   {
-    { "0x1p-1022", UNDERFLOW_NONE },
-    { "-0x1p-1022", UNDERFLOW_NONE },
-    { "0x0p-10000000000000000000000000", UNDERFLOW_NONE },
-    { "-0x0p-10000000000000000000000000", UNDERFLOW_NONE },
-    { "0x1p-10000000000000000000000000", UNDERFLOW_ALWAYS },
-    { "-0x1p-10000000000000000000000000", UNDERFLOW_ALWAYS },
-    { "0x1.000000000000000000001p-1022", UNDERFLOW_NONE },
-    { "-0x1.000000000000000000001p-1022", UNDERFLOW_NONE },
-    { "0x1p-1075", UNDERFLOW_ALWAYS },
-    { "-0x1p-1075", UNDERFLOW_ALWAYS },
-    { "0x1p-1023", UNDERFLOW_NONE },
-    { "-0x1p-1023", UNDERFLOW_NONE },
-    { "0x1p-1074", UNDERFLOW_NONE },
-    { "-0x1p-1074", UNDERFLOW_NONE },
-    { "0x1.ffffffffffffep-1023", UNDERFLOW_NONE },
-    { "-0x1.ffffffffffffep-1023", UNDERFLOW_NONE },
-    { "0x1.fffffffffffffp-1023", UNDERFLOW_ALWAYS },
-    { "-0x1.fffffffffffffp-1023", UNDERFLOW_ALWAYS },
-    { "0x1.fffffffffffff0001p-1023", UNDERFLOW_EXCEPT_UPWARD },
-    { "-0x1.fffffffffffff0001p-1023", UNDERFLOW_EXCEPT_DOWNWARD },
-    { "0x1.fffffffffffff7fffp-1023", UNDERFLOW_EXCEPT_UPWARD },
-    { "-0x1.fffffffffffff7fffp-1023", UNDERFLOW_EXCEPT_DOWNWARD },
-    { "0x1.fffffffffffff8p-1023", UNDERFLOW_ONLY_DOWNWARD_ZERO },
-    { "-0x1.fffffffffffff8p-1023", UNDERFLOW_ONLY_UPWARD_ZERO },
-    { "0x1.fffffffffffffffffp-1023", UNDERFLOW_ONLY_DOWNWARD_ZERO },
-    { "-0x1.fffffffffffffffffp-1023", UNDERFLOW_ONLY_UPWARD_ZERO },
+    TEST ("0x1p-126",
+	  "0x1p-1022",
+	  "0x1p-16382",
+	  "0x1p-16383",
+	  "0x1p-969",
+	  "0x1p-16382",
+	  UNDERFLOW_NONE),
+    TEST ("-0x1p-126",
+	  "-0x1p-1022",
+	  "-0x1p-16382",
+	  "-0x1p-16383",
+	  "-0x1p-969",
+	  "-0x1p-16382",
+	  UNDERFLOW_NONE),
+    TEST ("0x0p-10000000000000000000000000",
+	  "0x0p-10000000000000000000000000",
+	  "0x0p-10000000000000000000000000",
+	  "0x0p-10000000000000000000000000",
+	  "0x0p-10000000000000000000000000",
+	  "0x0p-10000000000000000000000000",
+	  UNDERFLOW_NONE),
+    TEST ("-0x0p-10000000000000000000000000",
+	  "-0x0p-10000000000000000000000000",
+	  "-0x0p-10000000000000000000000000",
+	  "-0x0p-10000000000000000000000000",
+	  "-0x0p-10000000000000000000000000",
+	  "-0x0p-10000000000000000000000000",
+	  UNDERFLOW_NONE),
+    TEST ("0x1p-10000000000000000000000000",
+	  "0x1p-10000000000000000000000000",
+	  "0x1p-10000000000000000000000000",
+	  "0x1p-10000000000000000000000000",
+	  "0x1p-10000000000000000000000000",
+	  "0x1p-10000000000000000000000000",
+	  UNDERFLOW_ALWAYS),
+    TEST ("-0x1p-10000000000000000000000000",
+	  "-0x1p-10000000000000000000000000",
+	  "-0x1p-10000000000000000000000000",
+	  "-0x1p-10000000000000000000000000",
+	  "-0x1p-10000000000000000000000000",
+	  "-0x1p-10000000000000000000000000",
+	  UNDERFLOW_ALWAYS),
+    TEST ("0x1.000000000000000000001p-126",
+	  "0x1.000000000000000000001p-1022",
+	  "0x1.000000000000000000001p-16382",
+	  "0x1.000000000000000000001p-16383",
+	  "0x1.000000000000000000001p-969",
+	  "0x1.00000000000000000000000000000000000000001p-16382",
+	  UNDERFLOW_NONE),
+    TEST ("-0x1.000000000000000000001p-126",
+	  "-0x1.000000000000000000001p-1022",
+	  "-0x1.000000000000000000001p-16382",
+	  "-0x1.000000000000000000001p-16383",
+	  "-0x1.000000000000000000001p-969",
+	  "-0x1.00000000000000000000000000000000000000001p-16382",
+	  UNDERFLOW_NONE),
+    TEST ("0x1p-150",
+	  "0x1p-1075",
+	  "0x1p-16446",
+	  "0x1p-16447",
+	  "0x1p-1075",
+	  "0x1p-16495",
+	  UNDERFLOW_ALWAYS),
+    TEST ("-0x1p-150",
+	  "-0x1p-1075",
+	  "-0x1p-16446",
+	  "-0x1p-16447",
+	  "-0x1p-1075",
+	  "-0x1p-16495",
+	  UNDERFLOW_ALWAYS),
+    TEST ("0x1p-127",
+	  "0x1p-1023",
+	  "0x1p-16383",
+	  "0x1p-16384",
+	  "0x1p-970",
+	  "0x1p-16383",
+	  UNDERFLOW_NONE),
+    TEST ("-0x1p-127",
+	  "-0x1p-1023",
+	  "-0x1p-16383",
+	  "-0x1p-16384",
+	  "-0x1p-970",
+	  "-0x1p-16383",
+	  UNDERFLOW_NONE),
+    TEST ("0x1p-149",
+	  "0x1p-1074",
+	  "0x1p-16445",
+	  "0x1p-16446",
+	  "0x1p-1074",
+	  "0x1p-16494",
+	  UNDERFLOW_NONE),
+    TEST ("-0x1p-149",
+	  "-0x1p-1074",
+	  "-0x1p-16445",
+	  "-0x1p-16446",
+	  "-0x1p-1074",
+	  "-0x1p-16494",
+	  UNDERFLOW_NONE),
+    TEST ("0x1.fffffcp-127",
+	  "0x1.ffffffffffffep-1023",
+	  "0x1.fffffffffffffffcp-16383",
+	  "0x1.fffffffffffffffcp-16384",
+	  "0x1.ffffffffffffffffffffffffffp-970",
+	  "0x1.fffffffffffffffffffffffffffep-16383",
+	  UNDERFLOW_NONE),
+    TEST ("-0x1.fffffcp-127",
+	  "-0x1.ffffffffffffep-1023",
+	  "-0x1.fffffffffffffffcp-16383",
+	  "-0x1.fffffffffffffffcp-16384",
+	  "-0x1.ffffffffffffffffffffffffffp-970",
+	  "-0x1.fffffffffffffffffffffffffffep-16383",
+	  UNDERFLOW_NONE),
+    TEST ("0x1.fffffep-127",
+	  "0x1.fffffffffffffp-1023",
+	  "0x1.fffffffffffffffep-16383",
+	  "0x1.fffffffffffffffep-16384",
+	  "0x1.ffffffffffffffffffffffffff8p-970",
+	  "0x1.ffffffffffffffffffffffffffffp-16383",
+	  UNDERFLOW_ALWAYS),
+    TEST ("-0x1.fffffep-127",
+	  "-0x1.fffffffffffffp-1023",
+	  "-0x1.fffffffffffffffep-16383",
+	  "-0x1.fffffffffffffffep-16384",
+	  "-0x1.ffffffffffffffffffffffffff8p-970",
+	  "-0x1.ffffffffffffffffffffffffffffp-16383",
+	  UNDERFLOW_ALWAYS),
+    TEST ("0x1.fffffe0001p-127",
+	  "0x1.fffffffffffff0001p-1023",
+	  "0x1.fffffffffffffffe0001p-16383",
+	  "0x1.fffffffffffffffe0001p-16384",
+	  "0x1.ffffffffffffffffffffffffff80001p-970",
+	  "0x1.ffffffffffffffffffffffffffff0001p-16383",
+	  UNDERFLOW_EXCEPT_UPWARD),
+    TEST ("-0x1.fffffe0001p-127",
+	  "-0x1.fffffffffffff0001p-1023",
+	  "-0x1.fffffffffffffffe0001p-16383",
+	  "-0x1.fffffffffffffffe0001p-16384",
+	  "-0x1.ffffffffffffffffffffffffff80001p-970",
+	  "-0x1.ffffffffffffffffffffffffffff0001p-16383",
+	  UNDERFLOW_EXCEPT_DOWNWARD),
+    TEST ("0x1.fffffeffffp-127",
+	  "0x1.fffffffffffff7fffp-1023",
+	  "0x1.fffffffffffffffeffffp-16383",
+	  "0x1.fffffffffffffffeffffp-16384",
+	  "0x1.ffffffffffffffffffffffffffbffffp-970",
+	  "0x1.ffffffffffffffffffffffffffff7fffp-16383",
+	  UNDERFLOW_EXCEPT_UPWARD),
+    TEST ("-0x1.fffffeffffp-127",
+	  "-0x1.fffffffffffff7fffp-1023",
+	  "-0x1.fffffffffffffffeffffp-16383",
+	  "-0x1.fffffffffffffffeffffp-16384",
+	  "-0x1.ffffffffffffffffffffffffffbffffp-970",
+	  "-0x1.ffffffffffffffffffffffffffff7fffp-16383",
+	  UNDERFLOW_EXCEPT_DOWNWARD),
+    TEST ("0x1.ffffffp-127",
+	  "0x1.fffffffffffff8p-1023",
+	  "0x1.ffffffffffffffffp-16383",
+	  "0x1.ffffffffffffffffp-16384",
+	  "0x1.ffffffffffffffffffffffffffcp-970",
+	  "0x1.ffffffffffffffffffffffffffff8p-16383",
+	  UNDERFLOW_ONLY_DOWNWARD_ZERO),
+    TEST ("-0x1.ffffffp-127",
+	  "-0x1.fffffffffffff8p-1023",
+	  "-0x1.ffffffffffffffffp-16383",
+	  "-0x1.ffffffffffffffffp-16384",
+	  "-0x1.ffffffffffffffffffffffffffcp-970",
+	  "-0x1.ffffffffffffffffffffffffffff8p-16383",
+	  UNDERFLOW_ONLY_UPWARD_ZERO),
+    TEST ("0x1.ffffffffffp-127",
+	  "0x1.fffffffffffffffffp-1023",
+	  "0x1.ffffffffffffffffffffp-16383",
+	  "0x1.ffffffffffffffffffffp-16384",
+	  "0x1.ffffffffffffffffffffffffffffffp-970",
+	  "0x1.ffffffffffffffffffffffffffffffffp-16383",
+	  UNDERFLOW_ONLY_DOWNWARD_ZERO),
+    TEST ("-0x1.ffffffffffp-127",
+	  "-0x1.fffffffffffffffffp-1023",
+	  "-0x1.ffffffffffffffffffffp-16383",
+	  "-0x1.ffffffffffffffffffffp-16384",
+	  "-0x1.ffffffffffffffffffffffffffffffp-970",
+	  "-0x1.ffffffffffffffffffffffffffffffffp-16383",
+	  UNDERFLOW_ONLY_UPWARD_ZERO),
   };
 
 /* Return whether to expect underflow from a particular testcase, in a
@@ -133,39 +347,62 @@ static bool support_underflow_exception = false;
 volatile double d = DBL_MIN;
 volatile double dd;
 
-static int
-test_in_one_mode (const char *s, enum underflow_case c, int rm,
-		  const char *mode_name)
+static bool
+test_got_fe_underflow (void)
 {
-  int result = 0;
-  feclearexcept (FE_ALL_EXCEPT);
-  errno = 0;
-  double d = strtod (s, NULL);
-  int got_errno = errno;
 #ifdef FE_UNDERFLOW
-  bool got_fe_underflow = fetestexcept (FE_UNDERFLOW) != 0;
+  return fetestexcept (FE_UNDERFLOW) != 0;
 #else
-  bool got_fe_underflow = false;
+  return false;
 #endif
-  printf ("strtod (%s) (%s) returned %a, errno = %d, %sunderflow exception\n",
-	  s, mode_name, d, got_errno, got_fe_underflow ? "" : "no ");
-  bool this_expect_underflow = expect_underflow (c, rm);
-  if (got_errno != 0 && got_errno != ERANGE)
-    {
-      puts ("FAIL: errno neither 0 nor ERANGE");
-      result = 1;
-    }
-  else if (this_expect_underflow != (errno == ERANGE))
-    {
-      puts ("FAIL: underflow from errno differs from expectations");
-      result = 1;
-    }
-  if (support_underflow_exception && got_fe_underflow != this_expect_underflow)
-    {
-      puts ("FAIL: underflow from exceptions differs from expectations");
-      result = 1;
-    }
-  return result;
+}
+
+#define TEST_STRTOD(FSUF, FTYPE, FTOSTR, LSUF, CSUF)			\
+static int								\
+test_strto ## FSUF (int i, int rm, const char *mode_name)		\
+{									\
+  const char *s = tests[i].s_ ## FSUF;					\
+  enum underflow_case c = tests[i].c;					\
+  int result = 0;							\
+  feclearexcept (FE_ALL_EXCEPT);					\
+  errno = 0;								\
+  FTYPE d = strto ## FSUF (s, NULL);					\
+  int got_errno = errno;						\
+  bool got_fe_underflow = test_got_fe_underflow ();			\
+  char buf[FSTRLENMAX];							\
+  FTOSTR (buf, sizeof (buf), "%a", d);					\
+  printf ("strto" #FSUF							\
+	  " (%s) (%s) returned %s, errno = %d, "			\
+	  "%sunderflow exception\n",					\
+	  s, mode_name, buf, got_errno,					\
+	  got_fe_underflow ? "" : "no ");				\
+  bool this_expect_underflow = expect_underflow (c, rm);		\
+  if (got_errno != 0 && got_errno != ERANGE)				\
+    {									\
+      puts ("FAIL: errno neither 0 nor ERANGE");			\
+      result = 1;							\
+    }									\
+  else if (this_expect_underflow != (errno == ERANGE))			\
+    {									\
+      puts ("FAIL: underflow from errno differs from expectations");	\
+      result = 1;							\
+    }									\
+  if (support_underflow_exception					\
+      && got_fe_underflow != this_expect_underflow)			\
+    {									\
+      puts ("FAIL: underflow from exceptions "				\
+	    "differs from expectations");				\
+      result = 1;							\
+    }									\
+  return result;							\
+}
+
+GEN_TEST_STRTOD_FOREACH (TEST_STRTOD)
+
+static int
+test_in_one_mode (size_t i, int rm, const char *mode_name)
+{
+  return STRTOD_TEST_FOREACH (test_strto, i, rm, mode_name);
 }
 
 static int
@@ -191,12 +428,12 @@ do_test (void)
 #endif
   for (size_t i = 0; i < sizeof (tests) / sizeof (tests[0]); i++)
     {
-      result |= test_in_one_mode (tests[i].s, tests[i].c, fe_tonearest,
+      result |= test_in_one_mode (i, fe_tonearest,
 				  "default rounding mode");
 #ifdef FE_DOWNWARD
       if (!fesetround (FE_DOWNWARD))
 	{
-	  result |= test_in_one_mode (tests[i].s, tests[i].c, FE_DOWNWARD,
+	  result |= test_in_one_mode (i, FE_DOWNWARD,
 				      "FE_DOWNWARD");
 	  fesetround (save_round_mode);
 	}
@@ -204,7 +441,7 @@ do_test (void)
 #ifdef FE_TOWARDZERO
       if (!fesetround (FE_TOWARDZERO))
 	{
-	  result |= test_in_one_mode (tests[i].s, tests[i].c, FE_TOWARDZERO,
+	  result |= test_in_one_mode (i, FE_TOWARDZERO,
 				      "FE_TOWARDZERO");
 	  fesetround (save_round_mode);
 	}
@@ -212,7 +449,7 @@ do_test (void)
 #ifdef FE_UPWARD
       if (!fesetround (FE_UPWARD))
 	{
-	  result |= test_in_one_mode (tests[i].s, tests[i].c, FE_UPWARD,
+	  result |= test_in_one_mode (i, FE_UPWARD,
 				      "FE_UPWARD");
 	  fesetround (save_round_mode);
 	}
diff --git a/stdlib/tst-strtod1i.c b/stdlib/tst-strtod1i.c
index 9d6bb760fb..44ae0264f4 100644
--- a/stdlib/tst-strtod1i.c
+++ b/stdlib/tst-strtod1i.c
@@ -25,60 +25,91 @@
 #include <string.h>
 #include <math.h>
 
-/* Perform a few tests in a locale with thousands separators.  */
-static int
-do_test (void)
-{
-  static const struct
-  {
-    const char *loc;
-    const char *str;
-    double exp;
-    ptrdiff_t nread;
-  } tests[] =
-    {
-      { "de_DE.UTF-8", "1,5", 1.5, 3 },
-      { "de_DE.UTF-8", "1.5", 1.0, 1 },
-      { "de_DE.UTF-8", "1.500", 1500.0, 5 },
-      { "de_DE.UTF-8", "36.893.488.147.419.103.232", 0x1.0p65, 26 }
-    };
-#define ntests (sizeof (tests) / sizeof (tests[0]))
-  size_t n;
-  int result = 0;
-
-  puts ("\nLocale tests");
+#include "tst-strtod.h"
 
-  for (n = 0; n < ntests; ++n)
-    {
-      double d;
-      char *endp;
+/* This tests internal interfaces, which are only defined for types
+   with distinct ABIs, so disable testing for types without distinct
+   ABIs.  */
+#undef IF_FLOAT32
+#define IF_FLOAT32(x)
+#undef IF_FLOAT64
+#define IF_FLOAT64(x)
+#undef IF_FLOAT32X
+#define IF_FLOAT32X(x)
+#undef IF_FLOAT64X
+#define IF_FLOAT64X(x)
+#if !__HAVE_DISTINCT_FLOAT128
+# undef IF_FLOAT128
+# define IF_FLOAT128(x)
+#endif
 
-      if (setlocale (LC_ALL, tests[n].loc) == NULL)
-	{
-	  printf ("cannot set locale %s\n", tests[n].loc);
-	  result = 1;
-	  continue;
-	}
+#define ntests (sizeof (tests) / sizeof (tests[0]))
 
-      d = __strtod_internal (tests[n].str, &endp, 1);
-      if (d != tests[n].exp)
-	{
-	  printf ("strtod(\"%s\") returns %g and not %g\n",
-		  tests[n].str, d, tests[n].exp);
-	  result = 1;
-	}
-      else if (endp - tests[n].str != tests[n].nread)
-	{
-	  printf ("strtod(\"%s\") read %td bytes and not %td\n",
-		  tests[n].str, endp - tests[n].str, tests[n].nread);
-	  result = 1;
-	}
-    }
+/* Perform a few tests in a locale with thousands separators.  */
+#define TEST_STRTOD(FSUF, FTYPE, FTOSTR, LSUF, CSUF)			\
+static int								\
+test_strto ## FSUF (void)						\
+{									\
+  static const struct							\
+  {									\
+    const char *loc;							\
+    const char *str;							\
+    FTYPE exp;								\
+    ptrdiff_t nread;							\
+  } tests[] =								\
+    {									\
+      { "de_DE.UTF-8", "1,5", 1.5 ## LSUF, 3 },				\
+      { "de_DE.UTF-8", "1.5", 1.0 ## LSUF, 1 },				\
+      { "de_DE.UTF-8", "1.500", 1500.0 ## LSUF, 5 },			\
+      { "de_DE.UTF-8", "36.893.488.147.419.103.232", 0x1.0p65 ## LSUF, 26 } \
+    };									\
+  size_t n;								\
+  int result = 0;							\
+									\
+  puts ("\nLocale tests");						\
+									\
+  for (n = 0; n < ntests; ++n)						\
+    {									\
+      FTYPE d;								\
+      char *endp;							\
+									\
+      if (setlocale (LC_ALL, tests[n].loc) == NULL)			\
+	{								\
+	  printf ("cannot set locale %s\n", tests[n].loc);		\
+	  result = 1;							\
+	  continue;							\
+	}								\
+									\
+      d = __strto ## FSUF ## _internal (tests[n].str, &endp, 1);	\
+      if (d != tests[n].exp)						\
+	{								\
+	  char buf1[FSTRLENMAX], buf2[FSTRLENMAX];			\
+	  FTOSTR (buf1, sizeof (buf1), "%g", d);			\
+	  FTOSTR (buf2, sizeof (buf2), "%g", tests[n].exp);		\
+	  printf ("strto" # FSUF "(\"%s\") returns %s and not %s\n",	\
+		  tests[n].str, buf1, buf2);				\
+	  result = 1;							\
+	}								\
+      else if (endp - tests[n].str != tests[n].nread)			\
+	{								\
+	  printf ("strto" # FSUF "(\"%s\") read %td bytes and not %td\n", \
+		  tests[n].str, endp - tests[n].str, tests[n].nread);	\
+	  result = 1;							\
+	}								\
+    }									\
+									\
+  if (result == 0)							\
+    puts ("all OK");							\
+									\
+  return result ? EXIT_FAILURE : EXIT_SUCCESS;				\
+}
 
-  if (result == 0)
-    puts ("all OK");
+GEN_TEST_STRTOD_FOREACH (TEST_STRTOD)
 
-  return result ? EXIT_FAILURE : EXIT_SUCCESS;
+static int
+do_test (void)
+{
+  return STRTOD_TEST_FOREACH (test_strto);
 }
 
 #include <support/test-driver.c>
diff --git a/stdlib/tst-strtod2.c b/stdlib/tst-strtod2.c
index a7df82ebbd..d00bc13323 100644
--- a/stdlib/tst-strtod2.c
+++ b/stdlib/tst-strtod2.c
@@ -1,43 +1,112 @@
+#include <math.h>
 #include <stdio.h>
 #include <stdlib.h>
 
-struct test
-{
-  const char *str;
-  double result;
-  size_t offset;
-} tests[] =
-{
-  { "0xy", 0.0, 1 },
-  { "0x.y", 0.0, 1 },
-  { "0x0.y", 0.0, 4 },
-  { "0x.0y", 0.0, 4 },
-  { ".y", 0.0, 0 },
-  { "0.y", 0.0, 2 },
-  { ".0y", 0.0, 2 }
-};
+#include "tst-strtod.h"
+
+#define TEST_STRTOD(FSUF, FTYPE, FTOSTR, LSUF, CSUF)			\
+struct test_strto ## FSUF						\
+{									\
+  const char *str;							\
+  FTYPE result;								\
+  size_t offset;							\
+} tests_strto ## FSUF[] =						\
+{									\
+  { "0xy", 0.0 ## LSUF, 1 },						\
+  { "0x.y", 0.0 ## LSUF, 1 },						\
+  { "0x0.y", 0.0 ## LSUF, 4 },						\
+  { "0x.0y", 0.0 ## LSUF, 4 },						\
+  { ".y", 0.0 ## LSUF, 0 },						\
+  { "0.y", 0.0 ## LSUF, 2 },						\
+  { ".0y", 0.0 ## LSUF, 2 },						\
+  { "1.0e", 1.0 ## LSUF, 3 },						\
+  { "1.0e+", 1.0 ## LSUF, 3 },						\
+  { "1.0e-", 1.0 ## LSUF, 3 },						\
+  { "1.0ex", 1.0 ## LSUF, 3 },						\
+  { "1.0e+x", 1.0 ## LSUF, 3 },						\
+  { "1.0e-x", 1.0 ## LSUF, 3 },						\
+  { "0x1p", 1.0 ## LSUF, 3 },						\
+  { "0x1p+", 1.0 ## LSUF, 3 },						\
+  { "0x1p-", 1.0 ## LSUF, 3 },						\
+  { "0x1px", 1.0 ## LSUF, 3 },						\
+  { "0x1p+x", 1.0 ## LSUF, 3 },						\
+  { "0x1p-x", 1.0 ## LSUF, 3 },						\
+  { "", 0.0 ## LSUF, 0 },						\
+  { ".", 0.0 ## LSUF, 0 },						\
+  { "-", 0.0 ## LSUF, 0 },						\
+  { "-.", 0.0 ## LSUF, 0 },						\
+  { ".e", 0.0 ## LSUF, 0 },						\
+  { "-.e", 0.0 ## LSUF, 0 },						\
+  { " \t", 0.0 ## LSUF, 0 },						\
+  { " \t.", 0.0 ## LSUF, 0 },						\
+  { " \t-", 0.0 ## LSUF, 0 },						\
+  { " \t-.", 0.0 ## LSUF, 0 },						\
+  { " \t.e", 0.0 ## LSUF, 0 },						\
+  { " \t-.e", 0.0 ## LSUF, 0 },						\
+  { " \t\f\r\n\v1", 1.0 ## LSUF, 7 },					\
+  { " \t\f\r\n\v-1.5e2", -150.0 ## LSUF, 12 },				\
+  { "INFx", INFINITY, 3 },						\
+  { "infx", INFINITY, 3 },						\
+  { "INFINITx", INFINITY, 3 },						\
+  { "infinitx", INFINITY, 3 },						\
+  { "INFINITYY", INFINITY, 8 },						\
+  { "infinityy", INFINITY, 8 },						\
+  { "NANx", NAN, 3 },							\
+  { "nanx", NAN, 3 },							\
+  { "NAN(", NAN, 3 },							\
+  { "nan(", NAN, 3 },							\
+  { "NAN(x", NAN, 3 },							\
+  { "nan(x", NAN, 3 },							\
+  { "NAN(x)y", NAN, 6 },						\
+  { "nan(x)y", NAN, 6 },						\
+  { "NAN(*)y", NAN, 3 },						\
+  { "nan(*)y", NAN, 3 }							\
+};									\
+									\
+static int								\
+compare_strto ## FSUF (FTYPE x, FTYPE y)				\
+{									\
+  if (isnan (x) && isnan (y))						\
+    return 1;								\
+  return x == y;							\
+}									\
+									\
+static int								\
+test_strto ## FSUF (void)						\
+{									\
+  int status = 0;							\
+  for (size_t i = 0;							\
+       i < sizeof (tests_strto ## FSUF) / sizeof (tests_strto ## FSUF[0]); \
+       ++i)								\
+    {									\
+      char *ep;								\
+      FTYPE r = strto ## FSUF (tests_strto ## FSUF[i].str, &ep);	\
+      if (!compare_strto ## FSUF (r, tests_strto ## FSUF[i].result))	\
+	{								\
+	  char buf1[FSTRLENMAX], buf2[FSTRLENMAX];			\
+	  FTOSTR (buf1, sizeof (buf1), "%g", r);			\
+	  FTOSTR (buf2, sizeof (buf2), "%g", tests_strto ## FSUF[i].result); \
+	  printf ("test %zu r = %s, expect %s\n", i, buf1, buf2);	\
+	  status = 1;							\
+	}								\
+      if (ep != tests_strto ## FSUF[i].str + tests_strto ## FSUF[i].offset) \
+	{								\
+	  printf ("test %zu strto" #FSUF				\
+		  " parsed %tu characters, expected %zu\n",		\
+		  i, ep - tests_strto ## FSUF[i].str,			\
+		  tests_strto ## FSUF[i].offset);			\
+	  status = 1;							\
+	}								\
+    }									\
+  return status;							\
+}
+
+GEN_TEST_STRTOD_FOREACH (TEST_STRTOD)
 
 static int
 do_test (void)
 {
-  int status = 0;
-  for (size_t i = 0; i < sizeof (tests) / sizeof (tests[0]); ++i)
-    {
-      char *ep;
-      double r = strtod (tests[i].str, &ep);
-      if (r != tests[i].result)
-	{
-	  printf ("test %zu r = %g, expect %g\n", i, r, tests[i].result);
-	  status = 1;
-	}
-      if (ep != tests[i].str + tests[i].offset)
-	{
-	  printf ("test %zu strtod parsed %tu characters, expected %zu\n",
-		  i, ep - tests[i].str, tests[i].offset);
-	  status = 1;
-	}
-    }
-  return status;
+  return STRTOD_TEST_FOREACH (test_strto);
 }
 
 #define TEST_FUNCTION do_test ()
diff --git a/stdlib/tst-strtod3.c b/stdlib/tst-strtod3.c
index 23abec1896..0d662d8be8 100644
--- a/stdlib/tst-strtod3.c
+++ b/stdlib/tst-strtod3.c
@@ -3,19 +3,73 @@
 #include <stdlib.h>
 #include <string.h>
 
-static const struct
-{
-  const char *in;
-  const char *out;
-  double expected;
-} tests[] =
-  {
-    { "000,,,e1", ",,,e1", 0.0 },
-    { "000e1", "", 0.0 },
-    { "000,1e1", ",1e1", 0.0 }
-  };
-#define NTESTS (sizeof (tests) / sizeof (tests[0]))
+#include "tst-strtod.h"
+
+/* This tests internal interfaces, which are only defined for types
+   with distinct ABIs, so disable testing for types without distinct
+   ABIs.  */
+#undef IF_FLOAT32
+#define IF_FLOAT32(x)
+#undef IF_FLOAT64
+#define IF_FLOAT64(x)
+#undef IF_FLOAT32X
+#define IF_FLOAT32X(x)
+#undef IF_FLOAT64X
+#define IF_FLOAT64X(x)
+#if !__HAVE_DISTINCT_FLOAT128
+# undef IF_FLOAT128
+# define IF_FLOAT128(x)
+#endif
 
+#define TEST_STRTOD(FSUF, FTYPE, FTOSTR, LSUF, CSUF)			\
+static const struct							\
+{									\
+  const char *in;							\
+  const char *out;							\
+  FTYPE expected;							\
+} tests_strto ## FSUF[] =						\
+  {									\
+    { "000,,,e1", ",,,e1", 0.0 ## LSUF },				\
+    { "000e1", "", 0.0 ## LSUF },					\
+    { "000,1e1", ",1e1", 0.0 ## LSUF }					\
+  };									\
+									\
+static int								\
+test_strto ## FSUF (void)						\
+{									\
+  int status = 0;							\
+									\
+  for (int i = 0;							\
+       i < sizeof (tests_strto ## FSUF) / sizeof (tests_strto ## FSUF[0]); \
+       ++i)								\
+    {									\
+      char *ep;								\
+      FTYPE r = __strto ## FSUF ## _internal (tests_strto ## FSUF[i].in, \
+					      &ep, 1);			\
+									\
+      if (strcmp (ep, tests_strto ## FSUF[i].out) != 0)			\
+	{								\
+	  printf ("%d: got rest string \"%s\", expected \"%s\"\n",	\
+		  i, ep, tests_strto ## FSUF[i].out);			\
+	  status = 1;							\
+	}								\
+									\
+      if (r != tests_strto ## FSUF[i].expected)				\
+	{								\
+	  char buf1[FSTRLENMAX], buf2[FSTRLENMAX];			\
+	  FTOSTR (buf1, sizeof (buf1), "%g", r);			\
+	  FTOSTR (buf2, sizeof (buf2), "%g",				\
+		  tests_strto ## FSUF[i].expected);			\
+	  printf ("%d: got wrong results %s, expected %s\n",		\
+		  i, buf1, buf2);					\
+	  status = 1;							\
+	}								\
+    }									\
+									\
+  return status;							\
+}
+
+GEN_TEST_STRTOD_FOREACH (TEST_STRTOD)
 
 static int
 do_test (void)
@@ -26,29 +80,7 @@ do_test (void)
       return 1;
     }
 
-  int status = 0;
-
-  for (int i = 0; i < NTESTS; ++i)
-    {
-      char *ep;
-      double r = __strtod_internal (tests[i].in, &ep, 1);
-
-      if (strcmp (ep, tests[i].out) != 0)
-	{
-	  printf ("%d: got rest string \"%s\", expected \"%s\"\n",
-		  i, ep, tests[i].out);
-	  status = 1;
-	}
-
-      if (r != tests[i].expected)
-	{
-	  printf ("%d: got wrong results %g, expected %g\n",
-		  i, r, tests[i].expected);
-	  status = 1;
-	}
-    }
-
-  return status;
+  return STRTOD_TEST_FOREACH (test_strto);
 }
 
 #define TEST_FUNCTION do_test ()
diff --git a/stdlib/tst-strtod4.c b/stdlib/tst-strtod4.c
index 6cc4e843c7..dfd3f05027 100644
--- a/stdlib/tst-strtod4.c
+++ b/stdlib/tst-strtod4.c
@@ -3,22 +3,76 @@
 #include <stdlib.h>
 #include <string.h>
 
+#include "tst-strtod.h"
+
+/* This tests internal interfaces, which are only defined for types
+   with distinct ABIs, so disable testing for types without distinct
+   ABIs.  */
+#undef IF_FLOAT32
+#define IF_FLOAT32(x)
+#undef IF_FLOAT64
+#define IF_FLOAT64(x)
+#undef IF_FLOAT32X
+#define IF_FLOAT32X(x)
+#undef IF_FLOAT64X
+#define IF_FLOAT64X(x)
+#if !__HAVE_DISTINCT_FLOAT128
+# undef IF_FLOAT128
+# define IF_FLOAT128(x)
+#endif
+
 #define NNBSP "\xe2\x80\xaf"
 
-static const struct
-{
-  const char *in;
-  const char *out;
-  double expected;
-} tests[] =
-  {
-    { "000"NNBSP"000"NNBSP"000", "", 0.0 },
-    { "1"NNBSP"000"NNBSP"000,5x", "x", 1000000.5 },
-    /* Bug 30964 */
-    { "10"NNBSP NNBSP"200", NNBSP NNBSP"200", 10.0 }
-  };
-#define NTESTS (sizeof (tests) / sizeof (tests[0]))
+#define TEST_STRTOD(FSUF, FTYPE, FTOSTR, LSUF, CSUF)			\
+static const struct							\
+{									\
+  const char *in;							\
+  const char *out;							\
+  FTYPE expected;							\
+} tests_strto ## FSUF[] =						\
+  {									\
+    { "000"NNBSP"000"NNBSP"000", "", 0.0 ## LSUF },			\
+    { "1"NNBSP"000"NNBSP"000,5x", "x", 1000000.5 ## LSUF },		\
+    /* Bug 30964 */							\
+    { "10"NNBSP NNBSP"200", NNBSP NNBSP"200", 10.0 ## LSUF }		\
+  };									\
+									\
+static int								\
+test_strto ## FSUF (void)						\
+{									\
+  int status = 0;							\
+									\
+  for (int i = 0;							\
+       i < sizeof (tests_strto ## FSUF) / sizeof (tests_strto ## FSUF[0]); \
+       ++i)								\
+    {									\
+      char *ep;								\
+      FTYPE r = __strto ## FSUF ## _internal (tests_strto ## FSUF[i].in, \
+					      &ep, 1);			\
+									\
+      if (strcmp (ep, tests_strto ## FSUF[i].out) != 0)			\
+	{								\
+	  printf ("%d: got rest string \"%s\", expected \"%s\"\n",	\
+		  i, ep, tests_strto ## FSUF[i].out);			\
+	  status = 1;							\
+	}								\
+									\
+      if (r != tests_strto ## FSUF[i].expected)				\
+	{								\
+	  char buf1[FSTRLENMAX], buf2[FSTRLENMAX];			\
+	  FTOSTR (buf1, sizeof (buf1), "%g", r);			\
+	  FTOSTR (buf2, sizeof (buf2), "%g",				\
+		  tests_strto ## FSUF[i].expected);			\
+	  printf ("%d: got wrong results %s, expected %s\n",		\
+		  i, buf1, buf2);					\
+	  status = 1;							\
+	}								\
+    }									\
+									\
+  return status;							\
+}
 
+GEN_TEST_STRTOD_FOREACH (TEST_STRTOD)
 
 static int
 do_test (void)
@@ -29,29 +83,7 @@ do_test (void)
       return 1;
     }
 
-  int status = 0;
-
-  for (int i = 0; i < NTESTS; ++i)
-    {
-      char *ep;
-      double r = __strtod_internal (tests[i].in, &ep, 1);
-
-      if (strcmp (ep, tests[i].out) != 0)
-	{
-	  printf ("%d: got rest string \"%s\", expected \"%s\"\n",
-		  i, ep, tests[i].out);
-	  status = 1;
-	}
-
-      if (r != tests[i].expected)
-	{
-	  printf ("%d: got wrong results %g, expected %g\n",
-		  i, r, tests[i].expected);
-	  status = 1;
-	}
-    }
-
-  return status;
+  return STRTOD_TEST_FOREACH (test_strto);
 }
 
 #define TEST_FUNCTION do_test ()
diff --git a/stdlib/tst-strtod5.c b/stdlib/tst-strtod5.c
index 29153ec005..7eb9b3a2d7 100644
--- a/stdlib/tst-strtod5.c
+++ b/stdlib/tst-strtod5.c
@@ -22,35 +22,75 @@
 #include <string.h>
 #include <math.h>
 
+#include "tst-strtod.h"
+
 #define NBSP "\xc2\xa0"
 
-static const struct
-{
-  const char *in;
-  double expected;
-} tests[] =
-  {
-    { "0", 0.0 },
-    { "000", 0.0 },
-    { "-0", -0.0 },
-    { "-000", -0.0 },
-    { "0,", 0.0 },
-    { "-0,", -0.0 },
-    { "0,0", 0.0 },
-    { "-0,0", -0.0 },
-    { "0e-10", 0.0 },
-    { "-0e-10", -0.0 },
-    { "0,e-10", 0.0 },
-    { "-0,e-10", -0.0 },
-    { "0,0e-10", 0.0 },
-    { "-0,0e-10", -0.0 },
-    { "0e-1000000", 0.0 },
-    { "-0e-1000000", -0.0 },
-    { "0,0e-1000000", 0.0 },
-    { "-0,0e-1000000", -0.0 },
-  };
-#define NTESTS (sizeof (tests) / sizeof (tests[0]))
+#define TEST_STRTOD(FSUF, FTYPE, FTOSTR, LSUF, CSUF)			\
+static const struct							\
+{									\
+  const char *in;							\
+  FTYPE expected;							\
+} tests_strto ## FSUF[] =						\
+  {									\
+    { "0", 0.0 ## LSUF },						\
+    { "000", 0.0 ## LSUF },						\
+    { "-0", -0.0 ## LSUF },						\
+    { "-000", -0.0 ## LSUF },						\
+    { "0,", 0.0 ## LSUF },						\
+    { "-0,", -0.0 ## LSUF },						\
+    { "0,0", 0.0 ## LSUF },						\
+    { "-0,0", -0.0 ## LSUF },						\
+    { "0e-10", 0.0 ## LSUF },						\
+    { "-0e-10", -0.0 ## LSUF },						\
+    { "0,e-10", 0.0 ## LSUF },						\
+    { "-0,e-10", -0.0 ## LSUF },					\
+    { "0,0e-10", 0.0 ## LSUF },						\
+    { "-0,0e-10", -0.0 ## LSUF },					\
+    { "0e-1000000", 0.0 ## LSUF },					\
+    { "-0e-1000000", -0.0 ## LSUF },					\
+    { "0,0e-1000000", 0.0 ## LSUF },					\
+    { "-0,0e-1000000", -0.0 ## LSUF },					\
+  };									\
+									\
+									\
+static int								\
+test_strto ## FSUF (void)						\
+{									\
+  int status = 0;							\
+									\
+  for (int i = 0;							\
+       i < sizeof (tests_strto ## FSUF) / sizeof (tests_strto ## FSUF[0]); \
+       ++i)								\
+    {									\
+      char *ep;								\
+      FTYPE r = strto ## FSUF (tests_strto ## FSUF[i].in, &ep);		\
+									\
+      if (*ep != '\0')							\
+	{								\
+	  printf ("%d: got rest string \"%s\", expected \"\"\n", i, ep); \
+	  status = 1;							\
+	}								\
+									\
+      if (r != tests_strto ## FSUF[i].expected				\
+	  || (copysign ## CSUF (10.0 ## LSUF, r)			\
+	      != copysign ## CSUF (10.0 ## LSUF,			\
+				   tests_strto ## FSUF[i].expected)))	\
+	{								\
+	  char buf1[FSTRLENMAX], buf2[FSTRLENMAX];			\
+	  FTOSTR (buf1, sizeof (buf1), "%g", r);			\
+	  FTOSTR (buf2, sizeof (buf2), "%g",				\
+		  tests_strto ## FSUF[i].expected);			\
+	  printf ("%d: got wrong results %s, expected %s\n",		\
+		  i, buf1, buf2);					\
+	  status = 1;							\
+	}								\
+    }									\
+									\
+  return status;							\
+}
 
+GEN_TEST_STRTOD_FOREACH (TEST_STRTOD)
 
 static int
 do_test (void)
@@ -61,29 +101,7 @@ do_test (void)
       return 1;
     }
 
-  int status = 0;
-
-  for (int i = 0; i < NTESTS; ++i)
-    {
-      char *ep;
-      double r = strtod (tests[i].in, &ep);
-
-      if (*ep != '\0')
-	{
-	  printf ("%d: got rest string \"%s\", expected \"\"\n", i, ep);
-	  status = 1;
-	}
-
-      if (r != tests[i].expected
-	  || copysign (10.0, r) != copysign (10.0, tests[i].expected))
-	{
-	  printf ("%d: got wrong results %g, expected %g\n",
-		  i, r, tests[i].expected);
-	  status = 1;
-	}
-    }
-
-  return status;
+  return STRTOD_TEST_FOREACH (test_strto);
 }
 
 #include <support/test-driver.c>
diff --git a/stdlib/tst-strtod5i.c b/stdlib/tst-strtod5i.c
index ee54e3404c..136aedea68 100644
--- a/stdlib/tst-strtod5i.c
+++ b/stdlib/tst-strtod5i.c
@@ -16,52 +16,112 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
+/* Defining _LIBC_TEST ensures long double math functions are
+   declared in the headers.  */
+#define _LIBC_TEST 1
 #include <locale.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <math.h>
 
+#include "tst-strtod.h"
+
+/* This tests internal interfaces, which are only defined for types
+   with distinct ABIs, so disable testing for types without distinct
+   ABIs.  */
+#undef IF_FLOAT32
+#define IF_FLOAT32(x)
+#undef IF_FLOAT64
+#define IF_FLOAT64(x)
+#undef IF_FLOAT32X
+#define IF_FLOAT32X(x)
+#undef IF_FLOAT64X
+#define IF_FLOAT64X(x)
+#if !__HAVE_DISTINCT_FLOAT128
+# undef IF_FLOAT128
+# define IF_FLOAT128(x)
+#endif
+
 #define NNBSP "\xe2\x80\xaf"
 
-static const struct
-{
-  const char *in;
-  int group;
-  double expected;
-} tests[] =
-  {
-    { "0", 0, 0.0 },
-    { "000", 0, 0.0 },
-    { "-0", 0, -0.0 },
-    { "-000", 0, -0.0 },
-    { "0,", 0, 0.0 },
-    { "-0,", 0, -0.0 },
-    { "0,0", 0, 0.0 },
-    { "-0,0", 0, -0.0 },
-    { "0e-10", 0, 0.0 },
-    { "-0e-10", 0, -0.0 },
-    { "0,e-10", 0, 0.0 },
-    { "-0,e-10", 0, -0.0 },
-    { "0,0e-10", 0, 0.0 },
-    { "-0,0e-10", 0, -0.0 },
-    { "0e-1000000", 0, 0.0 },
-    { "-0e-1000000", 0, -0.0 },
-    { "0,0e-1000000", 0, 0.0 },
-    { "-0,0e-1000000", 0, -0.0 },
-    { "0", 1, 0.0 },
-    { "000", 1, 0.0 },
-    { "-0", 1, -0.0 },
-    { "-000", 1, -0.0 },
-    { "0e-10", 1, 0.0 },
-    { "-0e-10", 1, -0.0 },
-    { "0e-1000000", 1, 0.0 },
-    { "-0e-1000000", 1, -0.0 },
-    { "000"NNBSP"000"NNBSP"000", 1, 0.0 },
-    { "-000"NNBSP"000"NNBSP"000", 1, -0.0 }
-  };
-#define NTESTS (sizeof (tests) / sizeof (tests[0]))
+#define TEST_STRTOD(FSUF, FTYPE, FTOSTR, LSUF, CSUF)			\
+static const struct							\
+{									\
+  const char *in;							\
+  int group;								\
+  FTYPE expected;							\
+} tests_strto ## FSUF[] =						\
+  {									\
+    { "0", 0, 0.0 ## LSUF },						\
+    { "000", 0, 0.0 ## LSUF },						\
+    { "-0", 0, -0.0 ## LSUF },						\
+    { "-000", 0, -0.0 ## LSUF },					\
+    { "0,", 0, 0.0 ## LSUF },						\
+    { "-0,", 0, -0.0 ## LSUF },						\
+    { "0,0", 0, 0.0 ## LSUF },						\
+    { "-0,0", 0, -0.0 ## LSUF },					\
+    { "0e-10", 0, 0.0 ## LSUF },					\
+    { "-0e-10", 0, -0.0 ## LSUF },					\
+    { "0,e-10", 0, 0.0 ## LSUF },					\
+    { "-0,e-10", 0, -0.0 ## LSUF },					\
+    { "0,0e-10", 0, 0.0 ## LSUF },					\
+    { "-0,0e-10", 0, -0.0 ## LSUF },					\
+    { "0e-1000000", 0, 0.0 ## LSUF },					\
+    { "-0e-1000000", 0, -0.0 ## LSUF },					\
+    { "0,0e-1000000", 0, 0.0 ## LSUF },					\
+    { "-0,0e-1000000", 0, -0.0 ## LSUF },				\
+    { "0", 1, 0.0 ## LSUF },						\
+    { "000", 1, 0.0 ## LSUF },						\
+    { "-0", 1, -0.0 ## LSUF },						\
+    { "-000", 1, -0.0 ## LSUF },					\
+    { "0e-10", 1, 0.0 ## LSUF },					\
+    { "-0e-10", 1, -0.0 ## LSUF },					\
+    { "0e-1000000", 1, 0.0 ## LSUF },					\
+    { "-0e-1000000", 1, -0.0 ## LSUF },					\
+    { "000"NNBSP"000"NNBSP"000", 1, 0.0 ## LSUF },			\
+    { "-000"NNBSP"000"NNBSP"000", 1, -0.0 ## LSUF }			\
+  };									\
+									\
+static int								\
+test_strto ## FSUF (void)						\
+{									\
+  int status = 0;							\
+									\
+  for (int i = 0;							\
+       i < sizeof (tests_strto ## FSUF) / sizeof (tests_strto ## FSUF[0]); \
+       ++i)								\
+    {									\
+      char *ep;								\
+      FTYPE r = __strto ## FSUF ## _internal (tests_strto ## FSUF[i].in, \
+					      &ep,			\
+					      tests_strto ## FSUF[i].group); \
+									\
+      if (*ep != '\0')							\
+	{								\
+	  printf ("%d: got rest string \"%s\", expected \"\"\n", i, ep); \
+	  status = 1;							\
+	}								\
+									\
+      if (r != tests_strto ## FSUF[i].expected				\
+	  || (copysign ## CSUF (10.0 ## LSUF, r)			\
+	      != copysign ## CSUF (10.0 ## LSUF,			\
+				   tests_strto ## FSUF[i].expected)))	\
+	{								\
+	  char buf1[FSTRLENMAX], buf2[FSTRLENMAX];			\
+	  FTOSTR (buf1, sizeof (buf1), "%g", r);			\
+	  FTOSTR (buf2, sizeof (buf2), "%g",				\
+		  tests_strto ## FSUF[i].expected);			\
+	  printf ("%d: got wrong results %s, expected %s\n",		\
+		  i, buf1, buf2);					\
+	  status = 1;							\
+	}								\
+    }									\
+									\
+  return status;							\
+}
 
+GEN_TEST_STRTOD_FOREACH (TEST_STRTOD)
 
 static int
 do_test (void)
@@ -72,29 +132,7 @@ do_test (void)
       return 1;
     }
 
-  int status = 0;
-
-  for (int i = 0; i < NTESTS; ++i)
-    {
-      char *ep;
-      double r = __strtod_internal (tests[i].in, &ep, tests[i].group);
-
-      if (*ep != '\0')
-	{
-	  printf ("%d: got rest string \"%s\", expected \"\"\n", i, ep);
-	  status = 1;
-	}
-
-      if (r != tests[i].expected
-	  || copysign (10.0, r) != copysign (10.0, tests[i].expected))
-	{
-	  printf ("%d: got wrong results %g, expected %g\n",
-		  i, r, tests[i].expected);
-	  status = 1;
-	}
-    }
-
-  return status;
+  return STRTOD_TEST_FOREACH (test_strto);
 }
 
 #include <support/test-driver.c>
diff --git a/stdlib/tst-swapcontext2.c b/stdlib/tst-swapcontext2.c
index f679755649..a9c1dc827c 100644
--- a/stdlib/tst-swapcontext2.c
+++ b/stdlib/tst-swapcontext2.c
@@ -85,7 +85,7 @@ do_test (void)
 {
   /* ____longjmp_chk has  */
 #if 0
-#ifdef _STACK_GROWS_DOWN
+#if _STACK_GROWS_DOWN
 #define called_from(this, saved) ((this) < (saved))
 #else
 #define called_from(this, saved) ((this) > (saved))
@@ -98,7 +98,7 @@ do_test (void)
   /* Arrange stacks for uctx_func1 and uctx_func2 so that called_from
      is true when setjmp is called from uctx_func1 and longjmp is called
      from uctx_func2.  */
-#ifdef _STACK_GROWS_DOWN
+#if _STACK_GROWS_DOWN
 # define UCTX_FUNC1_STACK	1
 # define UCTX_FUNC2_STACK	0
 #else
diff --git a/string/Makefile b/string/Makefile
index 8f31fa49e6..1dff405c27 100644
--- a/string/Makefile
+++ b/string/Makefile
@@ -184,6 +184,7 @@ tests := \
   test-strncpy \
   test-strndup \
   test-strnlen \
+  test-strnlen-nonarray \
   test-strpbrk \
   test-strrchr \
   test-strspn \
@@ -235,7 +236,10 @@ tests-unsupported += $(tests-translation)
 endif
 
 # This test allocates a lot of memory and can run for a long time.
-xtests = tst-strcoll-overflow
+xtests += tst-strcoll-overflow
+
+# This test runs for a long time.
+xtests += test-strncmp-nonarray
 
 # This test needs libdl.
 ifeq (yes,$(build-shared))
diff --git a/string/strerror.c b/string/strerror.c
index 107d9d39c2..efa4e903ea 100644
--- a/string/strerror.c
+++ b/string/strerror.c
@@ -21,5 +21,5 @@
 char *
 strerror (int errnum)
 {
-  return __strerror_l (errnum, __libc_tsd_get (locale_t, LOCALE));
+  return __strerror_l (errnum, __libc_tsd_LOCALE);
 }
diff --git a/string/strerror_l.c b/string/strerror_l.c
index 15cce261e6..70456e5bb4 100644
--- a/string/strerror_l.c
+++ b/string/strerror_l.c
@@ -20,7 +20,7 @@
 #include <stdio.h>
 #include <string.h>
 #include <tls-internal.h>
-
+#include <libc-internal.h>
 
 static const char *
 translate (const char *str, locale_t loc)
@@ -31,6 +31,12 @@ translate (const char *str, locale_t loc)
   return res;
 }
 
+static char *
+unknown_error (locale_t loc)
+{
+  return (char *) translate ("Unknown error", loc);
+}
+
 
 /* Return a string describing the errno code in ERRNUM.  */
 char *
@@ -40,18 +46,25 @@ __strerror_l (int errnum, locale_t loc)
   char *err = (char *) __get_errlist (errnum);
   if (__glibc_unlikely (err == NULL))
     {
-      struct tls_internal_t *tls_internal = __glibc_tls_internal ();
-      free (tls_internal->strerror_l_buf);
-      if (__asprintf (&tls_internal->strerror_l_buf, "%s%d",
-		      translate ("Unknown error ", loc), errnum) > 0)
-	err = tls_internal->strerror_l_buf;
-      else
+      if (__libc_initial)
 	{
-	  /* The memory was freed above.  */
-	  tls_internal->strerror_l_buf = NULL;
-	  /* Provide a fallback translation.  */
-	  err = (char *) translate ("Unknown error", loc);
+	  struct tls_internal_t *tls_internal = __glibc_tls_internal ();
+	  free (tls_internal->strerror_l_buf);
+	  if (__asprintf (&tls_internal->strerror_l_buf, "%s%d",
+			  translate ("Unknown error ", loc), errnum) > 0)
+	    err = tls_internal->strerror_l_buf;
+	  else
+	    {
+	      /* The memory was freed above.  */
+	      tls_internal->strerror_l_buf = NULL;
+	      /* Provide a fallback translation.  */
+	      err = unknown_error (loc);
+	    }
 	}
+      else
+	/* Secondary namespaces use a different malloc, so cannot
+	   participate in the buffer management.  */
+	err = unknown_error (loc);
     }
   else
     err = (char *) translate (err, loc);
diff --git a/string/strsignal.c b/string/strsignal.c
index 3114601564..d9b0365468 100644
--- a/string/strsignal.c
+++ b/string/strsignal.c
@@ -21,6 +21,7 @@
 #include <string.h>
 #include <libintl.h>
 #include <tls-internal.h>
+#include <libc-internal.h>
 
 /* Return a string describing the meaning of the signal number SIGNUM.  */
 char *
@@ -30,21 +31,28 @@ strsignal (int signum)
   if (desc != NULL)
     return _(desc);
 
-  struct tls_internal_t *tls_internal = __glibc_tls_internal ();
-  free (tls_internal->strsignal_buf);
+  if (__libc_initial)
+    {
+      struct tls_internal_t *tls_internal = __glibc_tls_internal ();
+      free (tls_internal->strsignal_buf);
 
-  int r;
+      int r;
 #ifdef SIGRTMIN
-  if (signum >= SIGRTMIN && signum <= SIGRTMAX)
-    r = __asprintf (&tls_internal->strsignal_buf, _("Real-time signal %d"),
-		    signum - SIGRTMIN);
-  else
+      if (signum >= SIGRTMIN && signum <= SIGRTMAX)
+	r = __asprintf (&tls_internal->strsignal_buf, _("Real-time signal %d"),
+			signum - SIGRTMIN);
+      else
 #endif
-    r = __asprintf (&tls_internal->strsignal_buf, _("Unknown signal %d"),
-		    signum);
-
-  if (r == -1)
-    tls_internal->strsignal_buf = NULL;
-
-  return tls_internal->strsignal_buf;
+	r = __asprintf (&tls_internal->strsignal_buf, _("Unknown signal %d"),
+			signum);
+
+      if (r >= 0)
+	return tls_internal->strsignal_buf;
+      else
+	tls_internal->strsignal_buf = NULL;
+    }
+  /* Fall through on asprintf error, and for !__libc_initial:
+     secondary namespaces use a different malloc and cannot
+     participate in the buffer management.  */
+  return _("Unknown signal");
 }
diff --git a/string/test-Xncmp-nonarray.c b/string/test-Xncmp-nonarray.c
new file mode 100644
index 0000000000..9f3a3ca75d
--- /dev/null
+++ b/string/test-Xncmp-nonarray.c
@@ -0,0 +1,183 @@
+/* Test non-array inputs to string comparison functions.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* This skeleton file is included from string/test-strncmp-nonarray.c and
+   wcsmbs/test-wcsncmp-nonarray.c to test that reading of the arrays stops
+   at the first null character.
+
+   TEST_IDENTIFIER must be the test function identifier.  TEST_NAME is
+   the same as a string.
+
+   CHAR must be defined as the character type.  */
+
+#include <array_length.h>
+#include <string.h>
+#include <support/check.h>
+#include <support/next_to_fault.h>
+#include <support/test-driver.h>
+#include <sys/param.h>
+#include <unistd.h>
+
+/* Much shorter than test-Xnlen-nonarray.c because of deeply nested loops.  */
+enum { buffer_length = 80 };
+
+/* The test buffer layout follows what is described test-Xnlen-nonarray.c,
+   except that there two buffers, left and right.  The variables
+   a_count, zero_count, start_offset are all duplicated.  */
+
+/* Return the maximum string length for a string that starts at
+   start_offset.  */
+static int
+string_length (int a_count, int start_offset)
+{
+  if (start_offset == buffer_length || start_offset >= a_count)
+    return 0;
+  else
+    return a_count - start_offset;
+}
+
+/* This is the valid maximum length argument computation for
+   strnlen/wcsnlen.  See text-Xnlen-nonarray.c.  */
+static int
+maximum_length (int start_offset, int zero_count)
+{
+  if (start_offset == buffer_length)
+    return 0;
+  else if (zero_count > 0)
+    /* Effectively unbounded, but we need to stop fairly low,
+       otherwise testing takes too long.  */
+    return buffer_length + 32;
+  else
+    return buffer_length - start_offset;
+}
+
+typedef __typeof (TEST_IDENTIFIER) *proto_t;
+
+#define TEST_MAIN
+#include "test-string.h"
+
+IMPL (TEST_IDENTIFIER, 1)
+
+static int
+test_main (void)
+{
+  TEST_VERIFY_EXIT (sysconf (_SC_PAGESIZE) >= buffer_length);
+  test_init ();
+
+  struct support_next_to_fault left_ntf
+    = support_next_to_fault_allocate (buffer_length * sizeof (CHAR));
+  CHAR *left_buffer = (CHAR *) left_ntf.buffer;
+  struct support_next_to_fault right_ntf
+    = support_next_to_fault_allocate (buffer_length * sizeof (CHAR));
+  CHAR *right_buffer = (CHAR *) right_ntf.buffer;
+
+  FOR_EACH_IMPL (impl, 0)
+    {
+      printf ("info: testing %s\n", impl->name);
+      for (size_t i = 0; i < buffer_length; ++i)
+        left_buffer[i] = 'A';
+
+      for (int left_zero_count = 0; left_zero_count <= buffer_length;
+           ++left_zero_count)
+        {
+          if (left_zero_count > 0)
+            left_buffer[buffer_length - left_zero_count] = 0;
+          int left_a_count = buffer_length - left_zero_count;
+          for (size_t i = 0; i < buffer_length; ++i)
+            right_buffer[i] = 'A';
+          for (int right_zero_count = 0; right_zero_count <= buffer_length;
+               ++right_zero_count)
+            {
+              if (right_zero_count > 0)
+                right_buffer[buffer_length - right_zero_count] = 0;
+              int right_a_count = buffer_length - right_zero_count;
+              for (int left_start_offset = 0;
+                   left_start_offset <= buffer_length;
+                   ++left_start_offset)
+                {
+                  CHAR *left_start_pointer = left_buffer + left_start_offset;
+                  int left_maxlen
+                    = maximum_length (left_start_offset, left_zero_count);
+                  int left_length
+                    = string_length (left_a_count, left_start_offset);
+                  for (int right_start_offset = 0;
+                       right_start_offset <= buffer_length;
+                       ++right_start_offset)
+                    {
+                      CHAR *right_start_pointer
+                        = right_buffer + right_start_offset;
+                      int right_maxlen
+                        = maximum_length (right_start_offset, right_zero_count);
+                      int right_length
+                        = string_length (right_a_count, right_start_offset);
+
+                      /* Maximum length is modelled after strnlen/wcsnlen,
+                         and must be valid for both pointer arguments at
+                         the same time.  */
+                      int maxlen = MIN (left_maxlen, right_maxlen);
+
+                      for (int length_argument = 0; length_argument <= maxlen;
+                           ++length_argument)
+                        {
+                          if (test_verbose)
+                            {
+                              printf ("left: zero_count=%d"
+                                      " a_count=%d start_offset=%d\n",
+                                      left_zero_count, left_a_count,
+                                      left_start_offset);
+                              printf ("right: zero_count=%d"
+                                      " a_count=%d start_offset=%d\n",
+                                      right_zero_count, right_a_count,
+                                      right_start_offset);
+                              printf ("length argument: %d\n",
+                                      length_argument);
+                            }
+
+                          /* Effective lengths bounded by length argument.
+                             The effective length determines the
+                             outcome of the comparison.  */
+                          int left_effective
+                            = MIN (left_length, length_argument);
+                          int right_effective
+                            = MIN (right_length, length_argument);
+                          if (left_effective == right_effective)
+                            TEST_COMPARE (CALL (impl,
+                                                left_start_pointer,
+                                                right_start_pointer,
+                                                length_argument), 0);
+                          else if (left_effective < right_effective)
+                            TEST_COMPARE (CALL (impl,
+                                                left_start_pointer,
+                                                right_start_pointer,
+                                                length_argument) < 0, 1);
+                          else
+                            TEST_COMPARE (CALL (impl,
+                                                left_start_pointer,
+                                                right_start_pointer,
+                                                length_argument) > 0, 1);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/string/test-Xnlen-nonarray.c b/string/test-Xnlen-nonarray.c
new file mode 100644
index 0000000000..499bef2041
--- /dev/null
+++ b/string/test-Xnlen-nonarray.c
@@ -0,0 +1,133 @@
+/* Test non-array inputs to string length functions.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* This skeleton file is included from string/test-strnlen-nonarray.c
+   and wcsmbs/test-wcsnlen-nonarray.c to test that reading of the array
+   stops at the first null character.
+
+   TEST_IDENTIFIER must be the test function identifier.  TEST_NAME is
+   the same as a string.
+
+   CHAR must be defined as the character type.  */
+
+#include <array_length.h>
+#include <string.h>
+#include <support/check.h>
+#include <support/next_to_fault.h>
+#include <support/test-driver.h>
+#include <sys/param.h>
+#include <unistd.h>
+
+typedef __typeof (TEST_IDENTIFIER) *proto_t;
+
+#define TEST_MAIN
+#include "test-string.h"
+
+IMPL (TEST_IDENTIFIER, 1)
+
+static int
+test_main (void)
+{
+  enum { buffer_length = 256 };
+  TEST_VERIFY_EXIT (sysconf (_SC_PAGESIZE) >= buffer_length);
+
+  test_init ();
+
+  /* Buffer layout: There are a_count 'A' character followed by
+     zero_count null character, for a total of buffer_length
+     character:
+
+     AAAAA...AAAAA 00000 ... 00000 (unmapped page follows)
+     \           / \             /
+       (a_count)     (zero_count)
+       \___ (buffer_length) ___/
+          ^
+          |
+          start_offset
+
+    The buffer length does not change, but a_count (and thus _zero)
+    and start_offset vary.
+
+    If start_offset == buffer_length, only 0 is a valid length
+    argument.  The result is 0.
+
+    Otherwwise, if zero_count > 0 (if there a null characters in the
+    buffer), then any length argument is valid.  If start_offset <
+    a_count (i.e., there is a non-null character at start_offset), the
+    result is the minimum of a_count - start_offset and the length
+    argument.  Otherwise the result is 0.
+
+    Otherwise, there are no null characters before the unmapped page.
+    The length argument must not be greater than buffer_length -
+    start_offset, and the result is the length argument.  */
+
+  struct support_next_to_fault ntf
+    = support_next_to_fault_allocate (buffer_length * sizeof (CHAR));
+  CHAR *buffer = (CHAR *) ntf.buffer;
+
+  FOR_EACH_IMPL (impl, 0)
+    {
+      printf ("info: testing %s\n", impl->name);
+      for (size_t i = 0; i < buffer_length; ++i)
+        buffer[i] = 'A';
+
+      for (int zero_count = 0; zero_count <= buffer_length; ++zero_count)
+        {
+          if (zero_count > 0)
+            buffer[buffer_length - zero_count] = 0;
+          int a_count = buffer_length - zero_count;
+          for (int start_offset = 0; start_offset <= buffer_length;
+               ++start_offset)
+            {
+              CHAR *start_pointer = buffer + start_offset;
+              if (start_offset == buffer_length)
+                TEST_COMPARE (CALL (impl, buffer + start_offset, 0), 0);
+              else if (zero_count > 0)
+                for (int length_argument = 0;
+                     length_argument <= 2 * buffer_length;
+                     ++length_argument)
+                  {
+                    if (test_verbose)
+                      printf ("zero_count=%d a_count=%d start_offset=%d"
+                              " length_argument=%d\n",
+                              zero_count, a_count, start_offset,
+                              length_argument);
+                    if (start_offset < a_count)
+                      TEST_COMPARE (CALL (impl, start_pointer, length_argument),
+                                    MIN (a_count - start_offset,
+                                         length_argument));
+                    else
+                      TEST_COMPARE (CALL (impl, start_pointer, length_argument),
+                                    0);
+                  }
+              else
+                for (int length_argument = 0;
+                     length_argument <= buffer_length - start_offset;
+                     ++length_argument)
+                  TEST_COMPARE (CALL (impl, start_pointer, length_argument),
+                                length_argument);
+            }
+        }
+    }
+
+  support_next_to_fault_free (&ntf);
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/string/test-strchr.c b/string/test-strchr.c
index c795eac6fa..72b17af687 100644
--- a/string/test-strchr.c
+++ b/string/test-strchr.c
@@ -255,6 +255,69 @@ check1 (void)
     check_result (impl, s, c, exp_result);
 }
 
+static void
+check2 (void)
+{
+  CHAR *s = (CHAR *) (buf1 + getpagesize () - 4 * sizeof (CHAR));
+  CHAR *s_begin = (CHAR *) (buf1 + getpagesize () - 64);
+#ifndef USE_FOR_STRCHRNUL
+  CHAR *exp_result = NULL;
+#else
+  CHAR *exp_result = s + 1;
+#endif
+  CHAR val = 0x12;
+  for (; s_begin != s; ++s_begin)
+    *s_begin = val;
+
+  s[0] = val + 1;
+  s[1] = 0;
+  s[2] = val + 1;
+  s[3] = val + 1;
+
+  {
+    FOR_EACH_IMPL (impl, 0)
+      check_result (impl, s, val, exp_result);
+  }
+  s[3] = val;
+  {
+    FOR_EACH_IMPL (impl, 0)
+      check_result (impl, s, val, exp_result);
+  }
+  exp_result = s;
+  s[0] = val;
+  {
+    FOR_EACH_IMPL (impl, 0)
+      check_result (impl, s, val, exp_result);
+  }
+
+  s[3] = val + 1;
+  {
+    FOR_EACH_IMPL (impl, 0)
+      check_result (impl, s, val, exp_result);
+  }
+
+  s[0] = val + 1;
+  s[1] = val + 1;
+  s[2] = val + 1;
+  s[3] = val + 1;
+  s[4] = val;
+  exp_result = s + 4;
+  {
+    FOR_EACH_IMPL (impl, 0)
+      check_result (impl, s, val, exp_result);
+  }
+  s[4] = 0;
+#ifndef USE_FOR_STRCHRNUL
+  exp_result = NULL;
+#else
+  exp_result = s + 4;
+#endif
+  {
+    FOR_EACH_IMPL (impl, 0)
+      check_result (impl, s, val, exp_result);
+  }
+}
+
 int
 test_main (void)
 {
@@ -263,7 +326,7 @@ test_main (void)
   test_init ();
 
   check1 ();
-
+  check2 ();
   printf ("%20s", "");
   FOR_EACH_IMPL (impl, 0)
     printf ("\t%s", impl->name);
diff --git a/string/test-strncmp-nonarray.c b/string/test-strncmp-nonarray.c
new file mode 100644
index 0000000000..581e52d01b
--- /dev/null
+++ b/string/test-strncmp-nonarray.c
@@ -0,0 +1,4 @@
+#define TEST_IDENTIFIER strncmp
+#define TEST_NAME "strncmp"
+typedef char CHAR;
+#include "test-Xncmp-nonarray.c"
diff --git a/string/test-strnlen-nonarray.c b/string/test-strnlen-nonarray.c
new file mode 100644
index 0000000000..0ad05756d9
--- /dev/null
+++ b/string/test-strnlen-nonarray.c
@@ -0,0 +1,4 @@
+#define TEST_IDENTIFIER strnlen
+#define TEST_NAME "strnlen"
+typedef char CHAR;
+#include "test-Xnlen-nonarray.c"
diff --git a/sunrpc/rpc_thread.c b/sunrpc/rpc_thread.c
index a04b7ec47f..e20f0a6230 100644
--- a/sunrpc/rpc_thread.c
+++ b/sunrpc/rpc_thread.c
@@ -3,7 +3,6 @@
 #include <assert.h>
 
 #include <libc-lock.h>
-#include <libc-tsd.h>
 #include <shlib-compat.h>
 #include <libc-symbols.h>
 
diff --git a/support/Makefile b/support/Makefile
index 362a51f882..aa57207bdc 100644
--- a/support/Makefile
+++ b/support/Makefile
@@ -131,6 +131,7 @@ libsupport-routines = \
   xfreopen \
   xftruncate \
   xgetline \
+  xgetpeername \
   xgetsockname \
   xlisten \
   xlseek \
diff --git a/support/capture_subprocess.h b/support/capture_subprocess.h
index 1ecbdfe4fc..8cbdca3b9d 100644
--- a/support/capture_subprocess.h
+++ b/support/capture_subprocess.h
@@ -41,11 +41,12 @@ struct support_capture_subprocess support_capture_subprocess
 struct support_capture_subprocess support_capture_subprogram
   (const char *file, char *const argv[]);
 
-/* Copy the running program into a setgid binary and run it with CHILD_ID
-   argument.  If execution is successful, return the exit status of the child
-   program, otherwise return a non-zero failure exit code.  */
-int support_capture_subprogram_self_sgid
-  (char *child_id);
+/* Copy the running program into a setgid binary and run it with
+   CHILD_ID argument.  If the program exits with a non-zero status,
+   exit with that exit status (or status 1 if the program did not exit
+   normally).  If the test cannot be performed, exit with
+   EXIT_UNSUPPORTED.  */
+void support_capture_subprogram_self_sgid (const char *child_id);
 
 /* Deallocate the subprocess data captured by
    support_capture_subprocess.  */
diff --git a/support/check.h b/support/check.h
index 711f34b83b..8f41e5b99f 100644
--- a/support/check.h
+++ b/support/check.h
@@ -24,6 +24,11 @@
 
 __BEGIN_DECLS
 
+/* Record a test failure, print the failure message to standard output
+   and pass the result of 1 through.  */
+#define FAIL(...) \
+  support_print_failure_impl (__FILE__, __LINE__, __VA_ARGS__)
+
 /* Record a test failure, print the failure message to standard output
    and return 1.  */
 #define FAIL_RET(...) \
@@ -202,6 +207,9 @@ void support_record_failure_reset (void);
    failures or not.  */
 int support_record_failure_is_failed (void);
 
+/* Terminate the process if any failures have been encountered so far.  */
+void support_record_failure_barrier (void);
+
 __END_DECLS
 
 #endif /* SUPPORT_CHECK_H */
diff --git a/support/support.h b/support/support.h
index ba21ec9b5a..1a77f79793 100644
--- a/support/support.h
+++ b/support/support.h
@@ -113,7 +113,7 @@ void *xposix_memalign (size_t alignment, size_t n)
   __attribute_malloc__ __attribute_alloc_align__ ((1))
   __attribute_alloc_size__ ((2)) __attr_dealloc_free __returns_nonnull;
 char *xasprintf (const char *format, ...)
-  __attribute__ ((format (printf, 1, 2), malloc)) __attr_dealloc_free
+  __attribute__ ((format (printf, 1, 2), __malloc__)) __attr_dealloc_free
   __returns_nonnull;
 char *xstrdup (const char *) __attr_dealloc_free __returns_nonnull;
 char *xstrndup (const char *, size_t) __attr_dealloc_free __returns_nonnull;
diff --git a/support/support_capture_subprocess.c b/support/support_capture_subprocess.c
index ffced8a89f..8dc95f8aa7 100644
--- a/support/support_capture_subprocess.c
+++ b/support/support_capture_subprocess.c
@@ -21,12 +21,17 @@
 
 #include <errno.h>
 #include <fcntl.h>
+#include <grp.h>
+#include <scratch_buffer.h>
+#include <stdio_ext.h>
 #include <stdlib.h>
+#include <string.h>
 #include <support/check.h>
 #include <support/xunistd.h>
 #include <support/xsocket.h>
 #include <support/xspawn.h>
 #include <support/support.h>
+#include <support/temp_file.h>
 #include <support/test-driver.h>
 
 static void
@@ -108,111 +113,88 @@ support_capture_subprogram (const char *file, char *const argv[])
 /* Copies the executable into a restricted directory, so that we can
    safely make it SGID with the TARGET group ID.  Then runs the
    executable.  */
-static int
-copy_and_spawn_sgid (char *child_id, gid_t gid)
+static void
+copy_and_spawn_sgid (const char *child_id, gid_t gid)
 {
-  char *dirname = xasprintf ("%s/tst-tunables-setuid.%jd",
-			     test_dir, (intmax_t) getpid ());
+  char *dirname = support_create_temp_directory ("tst-glibc-sgid-");
   char *execname = xasprintf ("%s/bin", dirname);
-  int infd = -1;
-  int outfd = -1;
-  int ret = 1, status = 1;
-
-  TEST_VERIFY (mkdir (dirname, 0700) == 0);
-  if (support_record_failure_is_failed ())
-    goto err;
+  add_temp_file (execname);
 
-  infd = open ("/proc/self/exe", O_RDONLY);
-  if (infd < 0)
+  if (access ("/proc/self/exe", R_OK) != 0)
     FAIL_UNSUPPORTED ("unsupported: Cannot read binary from procfs\n");
 
-  outfd = open (execname, O_WRONLY | O_CREAT | O_EXCL, 0700);
-  TEST_VERIFY (outfd >= 0);
-  if (support_record_failure_is_failed ())
-    goto err;
-
-  char buf[4096];
-  for (;;)
-    {
-      ssize_t rdcount = read (infd, buf, sizeof (buf));
-      TEST_VERIFY (rdcount >= 0);
-      if (support_record_failure_is_failed ())
-	goto err;
-      if (rdcount == 0)
-	break;
-      char *p = buf;
-      char *end = buf + rdcount;
-      while (p != end)
-	{
-	  ssize_t wrcount = write (outfd, buf, end - p);
-	  if (wrcount == 0)
-	    errno = ENOSPC;
-	  TEST_VERIFY (wrcount > 0);
-	  if (support_record_failure_is_failed ())
-	    goto err;
-	  p += wrcount;
-	}
-    }
+  support_copy_file ("/proc/self/exe", execname);
 
-  bool chowned = false;
-  TEST_VERIFY ((chowned = fchown (outfd, getuid (), gid) == 0)
-	       || errno == EPERM);
-  if (support_record_failure_is_failed ())
-    goto err;
-  else if (!chowned)
-    {
-      ret = 77;
-      goto err;
-    }
+  if (chown (execname, getuid (), gid) != 0)
+    FAIL_UNSUPPORTED ("cannot change group of \"%s\" to %jd: %m",
+		      execname, (intmax_t) gid);
 
-  TEST_VERIFY (fchmod (outfd, 02750) == 0);
-  if (support_record_failure_is_failed ())
-    goto err;
-  TEST_VERIFY (close (outfd) == 0);
-  if (support_record_failure_is_failed ())
-    goto err;
-  TEST_VERIFY (close (infd) == 0);
-  if (support_record_failure_is_failed ())
-    goto err;
+  if (chmod (execname, 02750) != 0)
+    FAIL_UNSUPPORTED ("cannot make \"%s\" SGID: %m ", execname);
 
   /* We have the binary, now spawn the subprocess.  Avoid using
      support_subprogram because we only want the program exit status, not the
      contents.  */
-  ret = 0;
-  infd = outfd = -1;
 
-  char * const args[] = {execname, child_id, NULL};
+  char * const args[] = {execname, (char *) child_id, NULL};
+  int status = support_subprogram_wait (args[0], args);
 
-  status = support_subprogram_wait (args[0], args);
+  free (execname);
+  free (dirname);
 
-err:
-  if (outfd >= 0)
-    close (outfd);
-  if (infd >= 0)
-    close (infd);
-  if (execname != NULL)
+  if (WIFEXITED (status))
     {
-      unlink (execname);
-      free (execname);
+      if (WEXITSTATUS (status) == 0)
+	return;
+      else
+	exit (WEXITSTATUS (status));
     }
-  if (dirname != NULL)
+  else
+    FAIL_EXIT1 ("subprogram failed with status %d", status);
+}
+
+/* Returns true if a group with NAME has been found, and writes its
+   GID to *TARGET.  */
+static bool
+find_sgid_group (gid_t *target, const char *name)
+{
+  /* Do not use getgrname_r because it does not work in statically
+     linked binaries if the system libc is different.  */
+  FILE *fp = fopen ("/etc/group", "rce");
+  if (fp == NULL)
+    return false;
+  __fsetlocking (fp, FSETLOCKING_BYCALLER);
+
+  bool ok = false;
+  struct scratch_buffer buf;
+  scratch_buffer_init (&buf);
+  while (true)
     {
-      rmdir (dirname);
-      free (dirname);
+      struct group grp;
+      struct group *result = NULL;
+      int status = fgetgrent_r (fp, &grp, buf.data, buf.length, &result);
+      if (status == 0 && result != NULL)
+	{
+	  if (strcmp (result->gr_name, name) == 0)
+	    {
+	      *target = result->gr_gid;
+	      ok = true;
+	      break;
+	    }
+	}
+      else if (errno != ERANGE)
+	break;
+      else if (!scratch_buffer_grow (&buf))
+	break;
     }
-
-  if (ret == 77)
-    FAIL_UNSUPPORTED ("Failed to make sgid executable for test\n");
-  if (ret != 0)
-    FAIL_EXIT1 ("Failed to make sgid executable for test\n");
-
-  return status;
+  scratch_buffer_free (&buf);
+  fclose (fp);
+  return ok;
 }
 
-int
-support_capture_subprogram_self_sgid (char *child_id)
+void
+support_capture_subprogram_self_sgid (const char *child_id)
 {
-  gid_t target = 0;
   const int count = 64;
   gid_t groups[count];
 
@@ -224,6 +206,7 @@ support_capture_subprogram_self_sgid (char *child_id)
 		     (intmax_t) getuid ());
 
   gid_t current = getgid ();
+  gid_t target = current;
   for (int i = 0; i < ret; ++i)
     {
       if (groups[i] != current)
@@ -233,11 +216,18 @@ support_capture_subprogram_self_sgid (char *child_id)
 	}
     }
 
-  if (target == 0)
-    FAIL_UNSUPPORTED("Could not find a suitable GID for user %jd\n",
-		     (intmax_t) getuid ());
+  if (target == current)
+    {
+      /* If running as root, try to find a harmless group for SGID.  */
+      if (getuid () != 0
+	  || (!find_sgid_group (&target, "nogroup")
+	      && !find_sgid_group (&target, "bin")
+	      && !find_sgid_group (&target, "daemon")))
+	FAIL_UNSUPPORTED("Could not find a suitable GID for user %jd\n",
+			 (intmax_t) getuid ());
+    }
 
-  return copy_and_spawn_sgid (child_id, target);
+  copy_and_spawn_sgid (child_id, target);
 }
 
 void
diff --git a/support/support_record_failure.c b/support/support_record_failure.c
index 978123701d..72ee2b232f 100644
--- a/support/support_record_failure.c
+++ b/support/support_record_failure.c
@@ -112,3 +112,13 @@ support_record_failure_is_failed (void)
      synchronization for reliable test error reporting anyway.  */
   return __atomic_load_n (&state->failed, __ATOMIC_RELAXED);
 }
+
+void
+support_record_failure_barrier (void)
+{
+  if (__atomic_load_n (&state->failed, __ATOMIC_RELAXED))
+    {
+      puts ("error: exiting due to previous errors");
+      exit (1);
+    }
+}
diff --git a/support/test-driver.c b/support/test-driver.c
index f4c3e4d666..04ceebc08f 100644
--- a/support/test-driver.c
+++ b/support/test-driver.c
@@ -155,6 +155,7 @@ main (int argc, char **argv)
     {
       CMDLINE_OPTIONS
       TEST_DEFAULT_OPTIONS
+      { 0, }
     };
   test_config.options = &options;
 #endif
diff --git a/support/timespec.h b/support/timespec.h
index 42f32bcc2c..5ccc7163a5 100644
--- a/support/timespec.h
+++ b/support/timespec.h
@@ -35,7 +35,7 @@ make_timespec (time_t s, long int ns)
 
 enum { TIMESPEC_HZ = 1000000000 };
 
-#ifndef __USE_TIME_BITS64
+#ifndef __USE_TIME64_REDIRECTS
 struct timespec timespec_add (struct timespec, struct timespec)
   __attribute__((const));
 struct timespec timespec_sub (struct timespec, struct timespec)
diff --git a/support/xgetpeername.c b/support/xgetpeername.c
new file mode 100644
index 0000000000..6f448e456a
--- /dev/null
+++ b/support/xgetpeername.c
@@ -0,0 +1,30 @@
+/* getpeername with error checking.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <support/xsocket.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <support/check.h>
+
+void
+xgetpeername (int fd, struct sockaddr *sa, socklen_t *plen)
+{
+  if (getpeername (fd, sa, plen) != 0)
+    FAIL_EXIT1 ("getpeername (%d): %m", fd);
+}
diff --git a/support/xsocket.h b/support/xsocket.h
index 3e44103546..4ac0e1f5ff 100644
--- a/support/xsocket.h
+++ b/support/xsocket.h
@@ -26,6 +26,7 @@
 int xsocket (int, int, int);
 void xsetsockopt (int, int, int, const void *, socklen_t);
 void xgetsockname (int, struct sockaddr *, socklen_t *);
+void xgetpeername (int, struct sockaddr *, socklen_t *);
 void xconnect (int, const struct sockaddr *, socklen_t);
 void xbind (int, const struct sockaddr *, socklen_t);
 void xlisten (int, int);
diff --git a/support/xtime.h b/support/xtime.h
index 5200eef2e0..9961899634 100644
--- a/support/xtime.h
+++ b/support/xtime.h
@@ -30,7 +30,7 @@ __BEGIN_DECLS
 /* The following functions call the corresponding libc functions and
    terminate the process on error.  */
 
-#ifndef __USE_TIME_BITS64
+#ifndef __USE_TIME64_REDIRECTS
 void xclock_gettime (clockid_t clock, struct timespec *ts);
 void xclock_settime (clockid_t clock, const struct timespec *ts);
 #else
diff --git a/support/xunistd.h b/support/xunistd.h
index b5e8c2f420..13be9a46a3 100644
--- a/support/xunistd.h
+++ b/support/xunistd.h
@@ -36,7 +36,7 @@ pid_t xwaitpid (pid_t, int *status, int flags);
 void xpipe (int[2]);
 void xdup2 (int, int);
 int xopen (const char *path, int flags, mode_t);
-#ifndef __USE_TIME_BITS64
+#ifndef __USE_TIME64_REDIRECTS
 # ifdef __USE_FILE_OFFSET64
 void xstat (const char *path, struct stat *);
 void xlstat (const char *path, struct stat *);
diff --git a/sysdeps/aarch64/Makefile b/sysdeps/aarch64/Makefile
index 141d7d9cc2..f205884fe1 100644
--- a/sysdeps/aarch64/Makefile
+++ b/sysdeps/aarch64/Makefile
@@ -2,11 +2,15 @@ long-double-fcts = yes
 
 ifeq (yes,$(aarch64-bti))
 # Mark linker output BTI compatible, it warns on non-BTI inputs.
+# Do not do this for conform tests because they may not be compiled
+# with the appropriate compiler flags.
+ifneq ($(subdir),conform)
 sysdep-LDFLAGS += -Wl,-z,force-bti
 # Make warnings fatal outside the test system.
 LDFLAGS-lib.so += -Wl,--fatal-warnings
 LDFLAGS-rtld += -Wl,-z,force-bti,--fatal-warnings
-endif
+endif # $(subdir) != conform
+endif # $(aarch64-bit)
 
 ifeq ($(subdir),elf)
 sysdep-dl-routines += dl-bti
@@ -70,7 +74,19 @@ sysdep_routines += \
   __arm_za_disable
 
 tests += \
-  tst-sme-jmp
+  tst-sme-jmp \
+  tst-sme-signal \
+  tst-sme-za-state \
+  # tests
+tests-internal += \
+  tst-sme-clone \
+  tst-sme-clone3 \
+  tst-sme-fork \
+  tst-sme-vfork \
+  # tests-internal
+
+$(objpfx)tst-sme-clone3: $(objpfx)clone3.o $(objpfx)__arm_za_disable.o
+
 endif
 
 ifeq ($(subdir),malloc)
diff --git a/sysdeps/aarch64/__longjmp.S b/sysdeps/aarch64/__longjmp.S
index 7b6add751e..84156ee6ef 100644
--- a/sysdeps/aarch64/__longjmp.S
+++ b/sysdeps/aarch64/__longjmp.S
@@ -51,24 +51,7 @@ ENTRY (__longjmp)
 
 #if IS_IN(libc)
 	/* Disable ZA state of SME in libc.a and libc.so, but not in ld.so.  */
-# if HAVE_AARCH64_PAC_RET
-	PACIASP
-	cfi_window_save
-# endif
-	stp	x29, x30, [sp, -16]!
-	cfi_adjust_cfa_offset (16)
-	cfi_rel_offset (x29, 0)
-	cfi_rel_offset (x30, 8)
-	mov	x29, sp
-	bl	__libc_arm_za_disable
-	ldp	x29, x30, [sp], 16
-	cfi_adjust_cfa_offset (-16)
-	cfi_restore (x29)
-	cfi_restore (x30)
-# if HAVE_AARCH64_PAC_RET
-	AUTIASP
-	cfi_window_save
-# endif
+	CALL_LIBC_ARM_ZA_DISABLE
 #endif
 
 	ldp	x19, x20, [x0, #JB_X19<<3]
diff --git a/sysdeps/aarch64/configure b/sysdeps/aarch64/configure
old mode 100644
new mode 100755
index ca57edce47..9606137e8d
--- a/sysdeps/aarch64/configure
+++ b/sysdeps/aarch64/configure
@@ -325,9 +325,10 @@ then :
   printf %s "(cached) " >&6
 else $as_nop
   cat > conftest.s <<\EOF
-        ptrue p0.b
+	.arch armv8.2-a+sve
+	ptrue p0.b
 EOF
-if { ac_try='${CC-cc} -c -march=armv8.2-a+sve conftest.s 1>&5'
+if { ac_try='${CC-cc} -c conftest.s 1>&5'
   { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
   (eval $ac_try) 2>&5
   ac_status=$?
diff --git a/sysdeps/aarch64/configure.ac b/sysdeps/aarch64/configure.ac
index 27874eceb4..56d12d661d 100644
--- a/sysdeps/aarch64/configure.ac
+++ b/sysdeps/aarch64/configure.ac
@@ -90,9 +90,10 @@ LIBC_CONFIG_VAR([aarch64-variant-pcs], [$libc_cv_aarch64_variant_pcs])
 # Check if asm support armv8.2-a+sve
 AC_CACHE_CHECK([for SVE support in assembler], [libc_cv_aarch64_sve_asm], [dnl
 cat > conftest.s <<\EOF
-        ptrue p0.b
+	.arch armv8.2-a+sve
+	ptrue p0.b
 EOF
-if AC_TRY_COMMAND(${CC-cc} -c -march=armv8.2-a+sve conftest.s 1>&AS_MESSAGE_LOG_FD); then
+if AC_TRY_COMMAND(${CC-cc} -c conftest.s 1>&AS_MESSAGE_LOG_FD); then
   libc_cv_aarch64_sve_asm=yes
 else
   libc_cv_aarch64_sve_asm=no
diff --git a/sysdeps/aarch64/cpu-features.h b/sysdeps/aarch64/cpu-features.h
index 77a782422a..5f2da91ebb 100644
--- a/sysdeps/aarch64/cpu-features.h
+++ b/sysdeps/aarch64/cpu-features.h
@@ -71,6 +71,7 @@ struct cpu_features
   /* Currently, the GLIBC memory tagging tunable only defines 8 bits.  */
   uint8_t mte_state;
   bool sve;
+  bool prefer_sve_ifuncs;
   bool mops;
 };
 
diff --git a/sysdeps/aarch64/fpu/acos_advsimd.c b/sysdeps/aarch64/fpu/acos_advsimd.c
index a8eabb5e71..aaf874f4ea 100644
--- a/sysdeps/aarch64/fpu/acos_advsimd.c
+++ b/sysdeps/aarch64/fpu/acos_advsimd.c
@@ -18,30 +18,29 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include "v_math.h"
-#include "poly_advsimd_f64.h"
 
 static const struct data
 {
-  float64x2_t poly[12];
-  float64x2_t pi, pi_over_2;
+  double c1, c3, c5, c7, c9, c11;
+  float64x2_t c0, c2, c4, c6, c8, c10;
   uint64x2_t abs_mask;
+  float64x2_t pi, pi_over_2;
 } data = {
   /* Polynomial approximation of  (asin(sqrt(x)) - sqrt(x)) / (x * sqrt(x))
      on [ 0x1p-106, 0x1p-2 ], relative error: 0x1.c3d8e169p-57.  */
-  .poly = { V2 (0x1.555555555554ep-3), V2 (0x1.3333333337233p-4),
-	    V2 (0x1.6db6db67f6d9fp-5), V2 (0x1.f1c71fbd29fbbp-6),
-	    V2 (0x1.6e8b264d467d6p-6), V2 (0x1.1c5997c357e9dp-6),
-	    V2 (0x1.c86a22cd9389dp-7), V2 (0x1.856073c22ebbep-7),
-	    V2 (0x1.fd1151acb6bedp-8), V2 (0x1.087182f799c1dp-6),
-	    V2 (-0x1.6602748120927p-7), V2 (0x1.cfa0dd1f9478p-6), },
-  .pi = V2 (0x1.921fb54442d18p+1),
-  .pi_over_2 = V2 (0x1.921fb54442d18p+0),
+  .c0 = V2 (0x1.555555555554ep-3),     .c1 = 0x1.3333333337233p-4,
+  .c2 = V2 (0x1.6db6db67f6d9fp-5),     .c3 = 0x1.f1c71fbd29fbbp-6,
+  .c4 = V2 (0x1.6e8b264d467d6p-6),     .c5 = 0x1.1c5997c357e9dp-6,
+  .c6 = V2 (0x1.c86a22cd9389dp-7),     .c7 = 0x1.856073c22ebbep-7,
+  .c8 = V2 (0x1.fd1151acb6bedp-8),     .c9 = 0x1.087182f799c1dp-6,
+  .c10 = V2 (-0x1.6602748120927p-7),   .c11 = 0x1.cfa0dd1f9478p-6,
+  .pi = V2 (0x1.921fb54442d18p+1),     .pi_over_2 = V2 (0x1.921fb54442d18p+0),
   .abs_mask = V2 (0x7fffffffffffffff),
 };
 
 #define AllMask v_u64 (0xffffffffffffffff)
-#define Oneu (0x3ff0000000000000)
-#define Small (0x3e50000000000000) /* 2^-53.  */
+#define Oneu 0x3ff0000000000000
+#define Small 0x3e50000000000000 /* 2^-53.  */
 
 #if WANT_SIMD_EXCEPT
 static float64x2_t VPCS_ATTR NOINLINE
@@ -63,7 +62,7 @@ special_case (float64x2_t x, float64x2_t y, uint64x2_t special)
 
      acos(x) ~ pi/2 - (x + x^3 P(x^2)).
 
-   The largest observed error in this region is 1.18 ulps,
+   The largest observed error in this region is 1.18 ulp:
    _ZGVnN2v_acos (0x1.fbab0a7c460f6p-2) got 0x1.0d54d1985c068p+0
 				       want 0x1.0d54d1985c069p+0.
 
@@ -71,9 +70,9 @@ special_case (float64x2_t x, float64x2_t y, uint64x2_t special)
 
      acos(x) = y + y * z * P(z), with  z = (1-x)/2 and y = sqrt(z).
 
-   The largest observed error in this region is 1.52 ulps,
-   _ZGVnN2v_acos (0x1.23d362722f591p-1) got 0x1.edbbedf8a7d6ep-1
-				       want 0x1.edbbedf8a7d6cp-1.  */
+   The largest observed error in this region is 1.50 ulp:
+   _ZGVnN2v_acos (0x1.252a2cf3fb9acp-1) got 0x1.ec1a46aa82901p-1
+				       want 0x1.ec1a46aa829p-1.  */
 float64x2_t VPCS_ATTR V_NAME_D1 (acos) (float64x2_t x)
 {
   const struct data *d = ptr_barrier (&data);
@@ -99,13 +98,32 @@ float64x2_t VPCS_ATTR V_NAME_D1 (acos) (float64x2_t x)
   float64x2_t z = vbslq_f64 (a_le_half, ax, vsqrtq_f64 (z2));
 
   /* Use a single polynomial approximation P for both intervals.  */
+  float64x2_t z3 = vmulq_f64 (z2, z);
   float64x2_t z4 = vmulq_f64 (z2, z2);
   float64x2_t z8 = vmulq_f64 (z4, z4);
-  float64x2_t z16 = vmulq_f64 (z8, z8);
-  float64x2_t p = v_estrin_11_f64 (z2, z4, z8, z16, d->poly);
 
-  /* Finalize polynomial: z + z * z2 * P(z2).  */
-  p = vfmaq_f64 (z, vmulq_f64 (z, z2), p);
+  /* Order-11 Estrin.  */
+  float64x2_t c13 = vld1q_f64 (&d->c1);
+  float64x2_t c57 = vld1q_f64 (&d->c5);
+  float64x2_t c911 = vld1q_f64 (&d->c9);
+
+  float64x2_t p01 = vfmaq_laneq_f64 (d->c0, z2, c13, 0);
+  float64x2_t p23 = vfmaq_laneq_f64 (d->c2, z2, c13, 1);
+  float64x2_t p03 = vfmaq_f64 (p01, z4, p23);
+
+  float64x2_t p45 = vfmaq_laneq_f64 (d->c4, z2, c57, 0);
+  float64x2_t p67 = vfmaq_laneq_f64 (d->c6, z2, c57, 1);
+  float64x2_t p47 = vfmaq_f64 (p45, z4, p67);
+
+  float64x2_t p89 = vfmaq_laneq_f64 (d->c8, z2, c911, 0);
+  float64x2_t p1011 = vfmaq_laneq_f64 (d->c10, z2, c911, 1);
+  float64x2_t p811 = vfmaq_f64 (p89, z4, p1011);
+
+  float64x2_t p411 = vfmaq_f64 (p47, z8, p811);
+  float64x2_t p = vfmaq_f64 (p03, z8, p411);
+
+  /* Finalize polynomial: z + z3 * P(z2).  */
+  p = vfmaq_f64 (z, z3, p);
 
   /* acos(|x|) = pi/2 - sign(x) * Q(|x|), for  |x| < 0.5
 	       = 2 Q(|x|)               , for  0.5 < x < 1.0
diff --git a/sysdeps/aarch64/fpu/acos_sve.c b/sysdeps/aarch64/fpu/acos_sve.c
index 99dbfac3e6..870d8062cf 100644
--- a/sysdeps/aarch64/fpu/acos_sve.c
+++ b/sysdeps/aarch64/fpu/acos_sve.c
@@ -18,20 +18,21 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include "sv_math.h"
-#include "poly_sve_f64.h"
 
 static const struct data
 {
-  float64_t poly[12];
-  float64_t pi, pi_over_2;
+  float64_t c1, c3, c5, c7, c9, c11;
+  float64_t c0, c2, c4, c6, c8, c10;
+  float64_t pi_over_2;
 } data = {
   /* Polynomial approximation of  (asin(sqrt(x)) - sqrt(x)) / (x * sqrt(x))
      on [ 0x1p-106, 0x1p-2 ], relative error: 0x1.c3d8e169p-57.  */
-  .poly = { 0x1.555555555554ep-3, 0x1.3333333337233p-4, 0x1.6db6db67f6d9fp-5,
-	    0x1.f1c71fbd29fbbp-6, 0x1.6e8b264d467d6p-6, 0x1.1c5997c357e9dp-6,
-	    0x1.c86a22cd9389dp-7, 0x1.856073c22ebbep-7, 0x1.fd1151acb6bedp-8,
-	    0x1.087182f799c1dp-6, -0x1.6602748120927p-7, 0x1.cfa0dd1f9478p-6, },
-  .pi = 0x1.921fb54442d18p+1,
+  .c0 = 0x1.555555555554ep-3,	     .c1 = 0x1.3333333337233p-4,
+  .c2 = 0x1.6db6db67f6d9fp-5,	     .c3 = 0x1.f1c71fbd29fbbp-6,
+  .c4 = 0x1.6e8b264d467d6p-6,	     .c5 = 0x1.1c5997c357e9dp-6,
+  .c6 = 0x1.c86a22cd9389dp-7,	     .c7 = 0x1.856073c22ebbep-7,
+  .c8 = 0x1.fd1151acb6bedp-8,	     .c9 = 0x1.087182f799c1dp-6,
+  .c10 = -0x1.6602748120927p-7,	     .c11 = 0x1.cfa0dd1f9478p-6,
   .pi_over_2 = 0x1.921fb54442d18p+0,
 };
 
@@ -42,20 +43,21 @@ static const struct data
 
      acos(x) ~ pi/2 - (x + x^3 P(x^2)).
 
-   The largest observed error in this region is 1.18 ulps,
-   _ZGVsMxv_acos (0x1.fbc5fe28ee9e3p-2) got 0x1.0d4d0f55667f6p+0
-				       want 0x1.0d4d0f55667f7p+0.
+   The largest observed error in this region is 1.18 ulp:
+   _ZGVsMxv_acos (0x1.fbb7c9079b429p-2) got 0x1.0d51266607582p+0
+				       want 0x1.0d51266607583p+0.
 
    For |x| in [0.5, 1.0], use same approximation with a change of variable
 
      acos(x) = y + y * z * P(z), with  z = (1-x)/2 and y = sqrt(z).
 
-   The largest observed error in this region is 1.52 ulps,
-   _ZGVsMxv_acos (0x1.24024271a500ap-1) got 0x1.ed82df4243f0dp-1
-				       want 0x1.ed82df4243f0bp-1.  */
+   The largest observed error in this region is 1.50 ulp:
+   _ZGVsMxv_acos (0x1.252a2cf3fb9acp-1) got 0x1.ec1a46aa82901p-1
+				       want 0x1.ec1a46aa829p-1.  */
 svfloat64_t SV_NAME_D1 (acos) (svfloat64_t x, const svbool_t pg)
 {
   const struct data *d = ptr_barrier (&data);
+  svbool_t ptrue = svptrue_b64 ();
 
   svuint64_t sign = svand_x (pg, svreinterpret_u64 (x), 0x8000000000000000);
   svfloat64_t ax = svabs_x (pg, x);
@@ -70,24 +72,41 @@ svfloat64_t SV_NAME_D1 (acos) (svfloat64_t x, const svbool_t pg)
   svfloat64_t z = svsqrt_m (ax, a_gt_half, z2);
 
   /* Use a single polynomial approximation P for both intervals.  */
-  svfloat64_t z4 = svmul_x (pg, z2, z2);
-  svfloat64_t z8 = svmul_x (pg, z4, z4);
-  svfloat64_t z16 = svmul_x (pg, z8, z8);
-  svfloat64_t p = sv_estrin_11_f64_x (pg, z2, z4, z8, z16, d->poly);
+  svfloat64_t z3 = svmul_x (ptrue, z2, z);
+  svfloat64_t z4 = svmul_x (ptrue, z2, z2);
+  svfloat64_t z8 = svmul_x (ptrue, z4, z4);
+
+  svfloat64_t c13 = svld1rq (ptrue, &d->c1);
+  svfloat64_t c57 = svld1rq (ptrue, &d->c5);
+  svfloat64_t c911 = svld1rq (ptrue, &d->c9);
+
+  svfloat64_t p01 = svmla_lane (sv_f64 (d->c0), z2, c13, 0);
+  svfloat64_t p23 = svmla_lane (sv_f64 (d->c2), z2, c13, 1);
+  svfloat64_t p03 = svmla_x (pg, p01, z4, p23);
+
+  svfloat64_t p45 = svmla_lane (sv_f64 (d->c4), z2, c57, 0);
+  svfloat64_t p67 = svmla_lane (sv_f64 (d->c6), z2, c57, 1);
+  svfloat64_t p47 = svmla_x (pg, p45, z4, p67);
+
+  svfloat64_t p89 = svmla_lane (sv_f64 (d->c8), z2, c911, 0);
+  svfloat64_t p1011 = svmla_lane (sv_f64 (d->c10), z2, c911, 1);
+  svfloat64_t p811 = svmla_x (pg, p89, z4, p1011);
+
+  svfloat64_t p411 = svmla_x (pg, p47, z8, p811);
+  svfloat64_t p = svmad_x (pg, p411, z8, p03);
 
   /* Finalize polynomial: z + z * z2 * P(z2).  */
-  p = svmla_x (pg, z, svmul_x (pg, z, z2), p);
+  p = svmad_x (pg, p, z3, z);
 
   /* acos(|x|) = pi/2 - sign(x) * Q(|x|), for  |x| < 0.5
 	       = 2 Q(|x|)               , for  0.5 < x < 1.0
 	       = pi - 2 Q(|x|)          , for -1.0 < x < -0.5.  */
-  svfloat64_t y
-      = svreinterpret_f64 (svorr_x (pg, svreinterpret_u64 (p), sign));
-
-  svbool_t is_neg = svcmplt (pg, x, 0.0);
-  svfloat64_t off = svdup_f64_z (is_neg, d->pi);
-  svfloat64_t mul = svsel (a_gt_half, sv_f64 (2.0), sv_f64 (-1.0));
-  svfloat64_t add = svsel (a_gt_half, off, sv_f64 (d->pi_over_2));
-
-  return svmla_x (pg, add, mul, y);
+  svfloat64_t mul = svreinterpret_f64 (
+      svlsl_m (a_gt_half, svreinterpret_u64 (sv_f64 (1.0)), 10));
+  mul = svreinterpret_f64 (sveor_x (ptrue, svreinterpret_u64 (mul), sign));
+  svfloat64_t add = svreinterpret_f64 (
+      svorr_x (ptrue, sign, svreinterpret_u64 (sv_f64 (d->pi_over_2))));
+  add = svsub_m (a_gt_half, sv_f64 (d->pi_over_2), add);
+
+  return svmsb_x (pg, p, mul, add);
 }
diff --git a/sysdeps/aarch64/fpu/asin_advsimd.c b/sysdeps/aarch64/fpu/asin_advsimd.c
index 141646e954..f4884227a5 100644
--- a/sysdeps/aarch64/fpu/asin_advsimd.c
+++ b/sysdeps/aarch64/fpu/asin_advsimd.c
@@ -18,29 +18,28 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include "v_math.h"
-#include "poly_advsimd_f64.h"
 
 static const struct data
 {
-  float64x2_t poly[12];
+  float64x2_t c0, c2, c4, c6, c8, c10;
   float64x2_t pi_over_2;
   uint64x2_t abs_mask;
+  double c1, c3, c5, c7, c9, c11;
 } data = {
   /* Polynomial approximation of  (asin(sqrt(x)) - sqrt(x)) / (x * sqrt(x))
      on [ 0x1p-106, 0x1p-2 ], relative error: 0x1.c3d8e169p-57.  */
-  .poly = { V2 (0x1.555555555554ep-3), V2 (0x1.3333333337233p-4),
-	    V2 (0x1.6db6db67f6d9fp-5), V2 (0x1.f1c71fbd29fbbp-6),
-	    V2 (0x1.6e8b264d467d6p-6), V2 (0x1.1c5997c357e9dp-6),
-	    V2 (0x1.c86a22cd9389dp-7), V2 (0x1.856073c22ebbep-7),
-	    V2 (0x1.fd1151acb6bedp-8), V2 (0x1.087182f799c1dp-6),
-	    V2 (-0x1.6602748120927p-7), V2 (0x1.cfa0dd1f9478p-6), },
-  .pi_over_2 = V2 (0x1.921fb54442d18p+0),
-  .abs_mask = V2 (0x7fffffffffffffff),
+  .c0 = V2 (0x1.555555555554ep-3),	  .c1 = 0x1.3333333337233p-4,
+  .c2 = V2 (0x1.6db6db67f6d9fp-5),	  .c3 = 0x1.f1c71fbd29fbbp-6,
+  .c4 = V2 (0x1.6e8b264d467d6p-6),	  .c5 = 0x1.1c5997c357e9dp-6,
+  .c6 = V2 (0x1.c86a22cd9389dp-7),	  .c7 = 0x1.856073c22ebbep-7,
+  .c8 = V2 (0x1.fd1151acb6bedp-8),	  .c9 = 0x1.087182f799c1dp-6,
+  .c10 = V2 (-0x1.6602748120927p-7),	  .c11 = 0x1.cfa0dd1f9478p-6,
+  .pi_over_2 = V2 (0x1.921fb54442d18p+0), .abs_mask = V2 (0x7fffffffffffffff),
 };
 
 #define AllMask v_u64 (0xffffffffffffffff)
-#define One (0x3ff0000000000000)
-#define Small (0x3e50000000000000) /* 2^-12.  */
+#define One 0x3ff0000000000000
+#define Small 0x3e50000000000000 /* 2^-12.  */
 
 #if WANT_SIMD_EXCEPT
 static float64x2_t VPCS_ATTR NOINLINE
@@ -68,8 +67,8 @@ special_case (float64x2_t x, float64x2_t y, uint64x2_t special)
      asin(x) = pi/2 - (y + y * z * P(z)), with  z = (1-x)/2 and y = sqrt(z).
 
    The largest observed error in this region is 2.69 ulps,
-   _ZGVnN2v_asin (0x1.044ac9819f573p-1) got 0x1.110d7e85fdd5p-1
-				       want 0x1.110d7e85fdd53p-1.  */
+   _ZGVnN2v_asin (0x1.044e8cefee301p-1) got 0x1.1111dd54ddf96p-1
+				       want 0x1.1111dd54ddf99p-1.  */
 float64x2_t VPCS_ATTR V_NAME_D1 (asin) (float64x2_t x)
 {
   const struct data *d = ptr_barrier (&data);
@@ -86,7 +85,7 @@ float64x2_t VPCS_ATTR V_NAME_D1 (asin) (float64x2_t x)
     return special_case (x, x, AllMask);
 #endif
 
-  uint64x2_t a_lt_half = vcltq_f64 (ax, v_f64 (0.5));
+  uint64x2_t a_lt_half = vcaltq_f64 (x, v_f64 (0.5));
 
   /* Evaluate polynomial Q(x) = y + y * z * P(z) with
      z = x ^ 2 and y = |x|            , if |x| < 0.5
@@ -99,7 +98,26 @@ float64x2_t VPCS_ATTR V_NAME_D1 (asin) (float64x2_t x)
   float64x2_t z4 = vmulq_f64 (z2, z2);
   float64x2_t z8 = vmulq_f64 (z4, z4);
   float64x2_t z16 = vmulq_f64 (z8, z8);
-  float64x2_t p = v_estrin_11_f64 (z2, z4, z8, z16, d->poly);
+
+  /* order-11 estrin.  */
+  float64x2_t c13 = vld1q_f64 (&d->c1);
+  float64x2_t c57 = vld1q_f64 (&d->c5);
+  float64x2_t c911 = vld1q_f64 (&d->c9);
+
+  float64x2_t p01 = vfmaq_laneq_f64 (d->c0, z2, c13, 0);
+  float64x2_t p23 = vfmaq_laneq_f64 (d->c2, z2, c13, 1);
+  float64x2_t p03 = vfmaq_f64 (p01, z4, p23);
+
+  float64x2_t p45 = vfmaq_laneq_f64 (d->c4, z2, c57, 0);
+  float64x2_t p67 = vfmaq_laneq_f64 (d->c6, z2, c57, 1);
+  float64x2_t p47 = vfmaq_f64 (p45, z4, p67);
+
+  float64x2_t p89 = vfmaq_laneq_f64 (d->c8, z2, c911, 0);
+  float64x2_t p1011 = vfmaq_laneq_f64 (d->c10, z2, c911, 1);
+  float64x2_t p811 = vfmaq_f64 (p89, z4, p1011);
+
+  float64x2_t p07 = vfmaq_f64 (p03, z8, p47);
+  float64x2_t p = vfmaq_f64 (p07, z16, p811);
 
   /* Finalize polynomial: z + z * z2 * P(z2).  */
   p = vfmaq_f64 (z, vmulq_f64 (z, z2), p);
diff --git a/sysdeps/aarch64/fpu/asin_sve.c b/sysdeps/aarch64/fpu/asin_sve.c
index 9daa382e34..acbf1b3bdd 100644
--- a/sysdeps/aarch64/fpu/asin_sve.c
+++ b/sysdeps/aarch64/fpu/asin_sve.c
@@ -18,45 +18,43 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include "sv_math.h"
-#include "poly_sve_f64.h"
 
 static const struct data
 {
-  float64_t poly[12];
-  float64_t pi_over_2f;
+  float64_t c1, c3, c5, c7, c9, c11;
+  float64_t c0, c2, c4, c6, c8, c10;
+  float64_t pi_over_2;
 } data = {
   /* Polynomial approximation of  (asin(sqrt(x)) - sqrt(x)) / (x * sqrt(x))
      on [ 0x1p-106, 0x1p-2 ], relative error: 0x1.c3d8e169p-57.  */
-  .poly = { 0x1.555555555554ep-3, 0x1.3333333337233p-4,
-	    0x1.6db6db67f6d9fp-5, 0x1.f1c71fbd29fbbp-6,
-	    0x1.6e8b264d467d6p-6, 0x1.1c5997c357e9dp-6,
-	    0x1.c86a22cd9389dp-7, 0x1.856073c22ebbep-7,
-	    0x1.fd1151acb6bedp-8, 0x1.087182f799c1dp-6,
-	    -0x1.6602748120927p-7, 0x1.cfa0dd1f9478p-6, },
-  .pi_over_2f = 0x1.921fb54442d18p+0,
+  .c0 = 0x1.555555555554ep-3,	     .c1 = 0x1.3333333337233p-4,
+  .c2 = 0x1.6db6db67f6d9fp-5,	     .c3 = 0x1.f1c71fbd29fbbp-6,
+  .c4 = 0x1.6e8b264d467d6p-6,	     .c5 = 0x1.1c5997c357e9dp-6,
+  .c6 = 0x1.c86a22cd9389dp-7,	     .c7 = 0x1.856073c22ebbep-7,
+  .c8 = 0x1.fd1151acb6bedp-8,	     .c9 = 0x1.087182f799c1dp-6,
+  .c10 = -0x1.6602748120927p-7,	     .c11 = 0x1.cfa0dd1f9478p-6,
+  .pi_over_2 = 0x1.921fb54442d18p+0,
 };
 
-#define P(i) sv_f64 (d->poly[i])
-
 /* Double-precision SVE implementation of vector asin(x).
 
    For |x| in [0, 0.5], use an order 11 polynomial P such that the final
    approximation is an odd polynomial: asin(x) ~ x + x^3 P(x^2).
 
-   The largest observed error in this region is 0.52 ulps,
-   _ZGVsMxv_asin(0x1.d95ae04998b6cp-2) got 0x1.ec13757305f27p-2
-				      want 0x1.ec13757305f26p-2.
-
-   For |x| in [0.5, 1.0], use same approximation with a change of variable
+   The largest observed error in this region is 0.98 ulp:
+   _ZGVsMxv_asin (0x1.d98f6a748ed8ap-2) got 0x1.ec4eb661a73d3p-2
+				       want 0x1.ec4eb661a73d2p-2.
 
-     asin(x) = pi/2 - (y + y * z * P(z)), with  z = (1-x)/2 and y = sqrt(z).
+   For |x| in [0.5, 1.0], use same approximation with a change of variable:
+   asin(x) = pi/2 - (y + y * z * P(z)), with  z = (1-x)/2 and y = sqrt(z).
 
-   The largest observed error in this region is 2.69 ulps,
-   _ZGVsMxv_asin(0x1.044ac9819f573p-1) got 0x1.110d7e85fdd5p-1
-				      want 0x1.110d7e85fdd53p-1.  */
+   The largest observed error in this region is 2.66 ulp:
+   _ZGVsMxv_asin (0x1.04024f6e2a2fbp-1) got 0x1.10b9586f087a8p-1
+				       want 0x1.10b9586f087abp-1.  */
 svfloat64_t SV_NAME_D1 (asin) (svfloat64_t x, const svbool_t pg)
 {
   const struct data *d = ptr_barrier (&data);
+  svbool_t ptrue = svptrue_b64 ();
 
   svuint64_t sign = svand_x (pg, svreinterpret_u64 (x), 0x8000000000000000);
   svfloat64_t ax = svabs_x (pg, x);
@@ -70,17 +68,37 @@ svfloat64_t SV_NAME_D1 (asin) (svfloat64_t x, const svbool_t pg)
   svfloat64_t z = svsqrt_m (ax, a_ge_half, z2);
 
   /* Use a single polynomial approximation P for both intervals.  */
+  svfloat64_t z3 = svmul_x (pg, z2, z);
   svfloat64_t z4 = svmul_x (pg, z2, z2);
   svfloat64_t z8 = svmul_x (pg, z4, z4);
-  svfloat64_t z16 = svmul_x (pg, z8, z8);
-  svfloat64_t p = sv_estrin_11_f64_x (pg, z2, z4, z8, z16, d->poly);
+
+  svfloat64_t c13 = svld1rq (ptrue, &d->c1);
+  svfloat64_t c57 = svld1rq (ptrue, &d->c5);
+  svfloat64_t c911 = svld1rq (ptrue, &d->c9);
+
+  /* Order-11 Estrin scheme.  */
+  svfloat64_t p01 = svmla_lane (sv_f64 (d->c0), z2, c13, 0);
+  svfloat64_t p23 = svmla_lane (sv_f64 (d->c2), z2, c13, 1);
+  svfloat64_t p03 = svmla_x (pg, p01, z4, p23);
+
+  svfloat64_t p45 = svmla_lane (sv_f64 (d->c4), z2, c57, 0);
+  svfloat64_t p67 = svmla_lane (sv_f64 (d->c6), z2, c57, 1);
+  svfloat64_t p47 = svmla_x (pg, p45, z4, p67);
+
+  svfloat64_t p89 = svmla_lane (sv_f64 (d->c8), z2, c911, 0);
+  svfloat64_t p1011 = svmla_lane (sv_f64 (d->c10), z2, c911, 1);
+  svfloat64_t p811 = svmla_x (pg, p89, z4, p1011);
+
+  svfloat64_t p411 = svmla_x (pg, p47, z8, p811);
+  svfloat64_t p = svmla_x (pg, p03, z8, p411);
+
   /* Finalize polynomial: z + z * z2 * P(z2).  */
-  p = svmla_x (pg, z, svmul_x (pg, z, z2), p);
+  p = svmla_x (pg, z, z3, p);
 
-  /* asin(|x|) = Q(|x|)         , for |x| < 0.5
-	       = pi/2 - 2 Q(|x|), for |x| >= 0.5.  */
-  svfloat64_t y = svmad_m (a_ge_half, p, sv_f64 (-2.0), d->pi_over_2f);
+  /* asin(|x|) = Q(|x|), for |x| <  0.5
+	    = pi/2 - 2 Q(|x|), for |x| >= 0.5.  */
+  svfloat64_t y = svmad_m (a_ge_half, p, sv_f64 (-2.0), d->pi_over_2);
 
-  /* Copy sign.  */
+  /* Reinsert the sign from the argument.  */
   return svreinterpret_f64 (svorr_x (pg, svreinterpret_u64 (y), sign));
 }
diff --git a/sysdeps/aarch64/fpu/asinf_advsimd.c b/sysdeps/aarch64/fpu/asinf_advsimd.c
index 59d870ca36..88437f85ab 100644
--- a/sysdeps/aarch64/fpu/asinf_advsimd.c
+++ b/sysdeps/aarch64/fpu/asinf_advsimd.c
@@ -18,22 +18,21 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include "v_math.h"
-#include "poly_advsimd_f32.h"
 
 static const struct data
 {
-  float32x4_t poly[5];
+  float32x4_t c0, c2, c4;
+  float c1, c3;
   float32x4_t pi_over_2f;
 } data = {
   /* Polynomial approximation of  (asin(sqrt(x)) - sqrt(x)) / (x * sqrt(x))  on
      [ 0x1p-24 0x1p-2 ] order = 4 rel error: 0x1.00a23bbp-29 .  */
-  .poly = { V4 (0x1.55555ep-3), V4 (0x1.33261ap-4), V4 (0x1.70d7dcp-5),
-	    V4 (0x1.b059dp-6), V4 (0x1.3af7d8p-5) },
-  .pi_over_2f = V4 (0x1.921fb6p+0f),
+  .c0 = V4 (0x1.55555ep-3f), .c1 = 0x1.33261ap-4f,
+  .c2 = V4 (0x1.70d7dcp-5f), .c3 = 0x1.b059dp-6f,
+  .c4 = V4 (0x1.3af7d8p-5f), .pi_over_2f = V4 (0x1.921fb6p+0f),
 };
 
 #define AbsMask 0x7fffffff
-#define Half 0x3f000000
 #define One 0x3f800000
 #define Small 0x39800000 /* 2^-12.  */
 
@@ -47,11 +46,8 @@ special_case (float32x4_t x, float32x4_t y, uint32x4_t special)
 
 /* Single-precision implementation of vector asin(x).
 
-   For |x| < Small, approximate asin(x) by x. Small = 2^-12 for correct
-   rounding. If WANT_SIMD_EXCEPT = 0, Small = 0 and we proceed with the
-   following approximation.
 
-   For |x| in [Small, 0.5], use order 4 polynomial P such that the final
+   For |x| <0.5, use order 4 polynomial P such that the final
    approximation is an odd polynomial: asin(x) ~ x + x^3 P(x^2).
 
     The largest observed error in this region is 0.83 ulps,
@@ -80,24 +76,31 @@ float32x4_t VPCS_ATTR NOINLINE V_NAME_F1 (asin) (float32x4_t x)
 #endif
 
   float32x4_t ax = vreinterpretq_f32_u32 (ia);
-  uint32x4_t a_lt_half = vcltq_u32 (ia, v_u32 (Half));
+  uint32x4_t a_lt_half = vcaltq_f32 (x, v_f32 (0.5f));
 
   /* Evaluate polynomial Q(x) = y + y * z * P(z) with
      z = x ^ 2 and y = |x|            , if |x| < 0.5
      z = (1 - |x|) / 2 and y = sqrt(z), if |x| >= 0.5.  */
   float32x4_t z2 = vbslq_f32 (a_lt_half, vmulq_f32 (x, x),
-			      vfmsq_n_f32 (v_f32 (0.5), ax, 0.5));
+			      vfmsq_n_f32 (v_f32 (0.5f), ax, 0.5f));
   float32x4_t z = vbslq_f32 (a_lt_half, ax, vsqrtq_f32 (z2));
 
   /* Use a single polynomial approximation P for both intervals.  */
-  float32x4_t p = v_horner_4_f32 (z2, d->poly);
+
+  /* PW Horner 3 evaluation scheme.  */
+  float32x4_t z4 = vmulq_f32 (z2, z2);
+  float32x4_t c13 = vld1q_f32 (&d->c1);
+  float32x4_t p01 = vfmaq_laneq_f32 (d->c0, z2, c13, 0);
+  float32x4_t p23 = vfmaq_laneq_f32 (d->c2, z2, c13, 1);
+  float32x4_t p = vfmaq_f32 (p23, d->c4, z4);
+  p = vfmaq_f32 (p01, p, z4);
   /* Finalize polynomial: z + z * z2 * P(z2).  */
   p = vfmaq_f32 (z, vmulq_f32 (z, z2), p);
 
   /* asin(|x|) = Q(|x|)         , for |x| < 0.5
 	       = pi/2 - 2 Q(|x|), for |x| >= 0.5.  */
   float32x4_t y
-      = vbslq_f32 (a_lt_half, p, vfmsq_n_f32 (d->pi_over_2f, p, 2.0));
+      = vbslq_f32 (a_lt_half, p, vfmsq_n_f32 (d->pi_over_2f, p, 2.0f));
 
   /* Copy sign.  */
   return vbslq_f32 (v_u32 (AbsMask), y, x);
diff --git a/sysdeps/aarch64/fpu/atan2_advsimd.c b/sysdeps/aarch64/fpu/atan2_advsimd.c
index 2fd6164134..36be4ce83a 100644
--- a/sysdeps/aarch64/fpu/atan2_advsimd.c
+++ b/sysdeps/aarch64/fpu/atan2_advsimd.c
@@ -18,59 +18,74 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include "v_math.h"
-#include "poly_advsimd_f64.h"
 
 static const struct data
 {
+  double c1, c3, c5, c7, c9, c11, c13, c15, c17, c19;
+  float64x2_t c0, c2, c4, c6, c8, c10, c12, c14, c16, c18;
   float64x2_t pi_over_2;
-  float64x2_t poly[20];
+  uint64x2_t zeroinfnan;
 } data = {
-  /* Coefficients of polynomial P such that atan(x)~x+x*P(x^2) on
-     the interval [2**-1022, 1.0].  */
-  .poly = { V2 (-0x1.5555555555555p-2),	 V2 (0x1.99999999996c1p-3),
-	    V2 (-0x1.2492492478f88p-3),	 V2 (0x1.c71c71bc3951cp-4),
-	    V2 (-0x1.745d160a7e368p-4),	 V2 (0x1.3b139b6a88ba1p-4),
-	    V2 (-0x1.11100ee084227p-4),	 V2 (0x1.e1d0f9696f63bp-5),
-	    V2 (-0x1.aebfe7b418581p-5),	 V2 (0x1.842dbe9b0d916p-5),
-	    V2 (-0x1.5d30140ae5e99p-5),	 V2 (0x1.338e31eb2fbbcp-5),
-	    V2 (-0x1.00e6eece7de8p-5),	 V2 (0x1.860897b29e5efp-6),
-	    V2 (-0x1.0051381722a59p-6),	 V2 (0x1.14e9dc19a4a4ep-7),
-	    V2 (-0x1.d0062b42fe3bfp-9),	 V2 (0x1.17739e210171ap-10),
-	    V2 (-0x1.ab24da7be7402p-13), V2 (0x1.358851160a528p-16), },
+  /* Coefficients of polynomial P such that
+     atan(x)~x+x*P(x^2) on [2^-1022, 1.0].  */
+  .c0 = V2 (-0x1.555555555552ap-2),
+  .c1 = 0x1.9999999995aebp-3,
+  .c2 = V2 (-0x1.24924923923f6p-3),
+  .c3 = 0x1.c71c7184288a2p-4,
+  .c4 = V2 (-0x1.745d11fb3d32bp-4),
+  .c5 = 0x1.3b136a18051b9p-4,
+  .c6 = V2 (-0x1.110e6d985f496p-4),
+  .c7 = 0x1.e1bcf7f08801dp-5,
+  .c8 = V2 (-0x1.ae644e28058c3p-5),
+  .c9 = 0x1.82eeb1fed85c6p-5,
+  .c10 = V2 (-0x1.59d7f901566cbp-5),
+  .c11 = 0x1.2c982855ab069p-5,
+  .c12 = V2 (-0x1.eb49592998177p-6),
+  .c13 = 0x1.69d8b396e3d38p-6,
+  .c14 = V2 (-0x1.ca980345c4204p-7),
+  .c15 = 0x1.dc050eafde0b3p-8,
+  .c16 = V2 (-0x1.7ea70755b8eccp-9),
+  .c17 = 0x1.ba3da3de903e8p-11,
+  .c18 = V2 (-0x1.44a4b059b6f67p-13),
+  .c19 = 0x1.c4a45029e5a91p-17,
   .pi_over_2 = V2 (0x1.921fb54442d18p+0),
+  .zeroinfnan = V2 (2 * 0x7ff0000000000000ul - 1),
 };
 
 #define SignMask v_u64 (0x8000000000000000)
 
 /* Special cases i.e. 0, infinity, NaN (fall back to scalar calls).  */
 static float64x2_t VPCS_ATTR NOINLINE
-special_case (float64x2_t y, float64x2_t x, float64x2_t ret, uint64x2_t cmp)
+special_case (float64x2_t y, float64x2_t x, float64x2_t ret,
+	      uint64x2_t sign_xy, uint64x2_t cmp)
 {
+  /* Account for the sign of x and y.  */
+  ret = vreinterpretq_f64_u64 (
+      veorq_u64 (vreinterpretq_u64_f64 (ret), sign_xy));
   return v_call2_f64 (atan2, y, x, ret, cmp);
 }
 
 /* Returns 1 if input is the bit representation of 0, infinity or nan.  */
 static inline uint64x2_t
-zeroinfnan (uint64x2_t i)
+zeroinfnan (uint64x2_t i, const struct data *d)
 {
   /* (2 * i - 1) >= (2 * asuint64 (INFINITY) - 1).  */
-  return vcgeq_u64 (vsubq_u64 (vaddq_u64 (i, i), v_u64 (1)),
-		    v_u64 (2 * asuint64 (INFINITY) - 1));
+  return vcgeq_u64 (vsubq_u64 (vaddq_u64 (i, i), v_u64 (1)), d->zeroinfnan);
 }
 
 /* Fast implementation of vector atan2.
-   Maximum observed error is 2.8 ulps:
-   _ZGVnN2vv_atan2 (0x1.9651a429a859ap+5, 0x1.953075f4ee26p+5)
-	got 0x1.92d628ab678ccp-1
-       want 0x1.92d628ab678cfp-1.  */
+   Maximum observed error is 1.97 ulps:
+   _ZGVnN2vv_atan2 (0x1.42337dba73768p+5, 0x1.422d748cd3e29p+5)
+   got 0x1.9224810264efcp-1 want 0x1.9224810264efep-1.  */
 float64x2_t VPCS_ATTR V_NAME_D2 (atan2) (float64x2_t y, float64x2_t x)
 {
-  const struct data *data_ptr = ptr_barrier (&data);
+  const struct data *d = ptr_barrier (&data);
 
   uint64x2_t ix = vreinterpretq_u64_f64 (x);
   uint64x2_t iy = vreinterpretq_u64_f64 (y);
 
-  uint64x2_t special_cases = vorrq_u64 (zeroinfnan (ix), zeroinfnan (iy));
+  uint64x2_t special_cases
+      = vorrq_u64 (zeroinfnan (ix, d), zeroinfnan (iy, d));
 
   uint64x2_t sign_x = vandq_u64 (ix, SignMask);
   uint64x2_t sign_y = vandq_u64 (iy, SignMask);
@@ -80,42 +95,75 @@ float64x2_t VPCS_ATTR V_NAME_D2 (atan2) (float64x2_t y, float64x2_t x)
   float64x2_t ay = vabsq_f64 (y);
 
   uint64x2_t pred_xlt0 = vcltzq_f64 (x);
-  uint64x2_t pred_aygtax = vcgtq_f64 (ay, ax);
-
-  /* Set up z for call to atan.  */
-  float64x2_t n = vbslq_f64 (pred_aygtax, vnegq_f64 (ax), ay);
-  float64x2_t d = vbslq_f64 (pred_aygtax, ay, ax);
-  float64x2_t z = vdivq_f64 (n, d);
-
-  /* Work out the correct shift.  */
+  uint64x2_t pred_aygtax = vcagtq_f64 (y, x);
+
+  /* Set up z for evaluation of atan.  */
+  float64x2_t num = vbslq_f64 (pred_aygtax, vnegq_f64 (ax), ay);
+  float64x2_t den = vbslq_f64 (pred_aygtax, ay, ax);
+  float64x2_t z = vdivq_f64 (num, den);
+
+  /* Work out the correct shift for atan2:
+     Multiplication by pi is done later.
+     -pi   when x < 0  and ax < ay
+     -pi/2 when x < 0  and ax > ay
+      0    when x >= 0 and ax < ay
+      pi/2 when x >= 0 and ax > ay.  */
   float64x2_t shift = vreinterpretq_f64_u64 (
       vandq_u64 (pred_xlt0, vreinterpretq_u64_f64 (v_f64 (-2.0))));
-  shift = vbslq_f64 (pred_aygtax, vaddq_f64 (shift, v_f64 (1.0)), shift);
-  shift = vmulq_f64 (shift, data_ptr->pi_over_2);
-
-  /* Calculate the polynomial approximation.
-     Use split Estrin scheme for P(z^2) with deg(P)=19. Use split instead of
-     full scheme to avoid underflow in x^16.
-     The order 19 polynomial P approximates
-     (atan(sqrt(x))-sqrt(x))/x^(3/2).  */
+  float64x2_t shift2 = vreinterpretq_f64_u64 (
+      vandq_u64 (pred_aygtax, vreinterpretq_u64_f64 (v_f64 (1.0))));
+  shift = vaddq_f64 (shift, shift2);
+
+  /* Calculate the polynomial approximation.  */
   float64x2_t z2 = vmulq_f64 (z, z);
-  float64x2_t x2 = vmulq_f64 (z2, z2);
-  float64x2_t x4 = vmulq_f64 (x2, x2);
-  float64x2_t x8 = vmulq_f64 (x4, x4);
-  float64x2_t ret
-      = vfmaq_f64 (v_estrin_7_f64 (z2, x2, x4, data_ptr->poly),
-		   v_estrin_11_f64 (z2, x2, x4, x8, data_ptr->poly + 8), x8);
+  float64x2_t z3 = vmulq_f64 (z2, z);
+  float64x2_t z4 = vmulq_f64 (z2, z2);
+  float64x2_t z8 = vmulq_f64 (z4, z4);
+  float64x2_t z16 = vmulq_f64 (z8, z8);
 
-  /* Finalize. y = shift + z + z^3 * P(z^2).  */
-  ret = vfmaq_f64 (z, ret, vmulq_f64 (z2, z));
-  ret = vaddq_f64 (ret, shift);
+  float64x2_t c13 = vld1q_f64 (&d->c1);
+  float64x2_t c57 = vld1q_f64 (&d->c5);
+  float64x2_t c911 = vld1q_f64 (&d->c9);
+  float64x2_t c1315 = vld1q_f64 (&d->c13);
+  float64x2_t c1719 = vld1q_f64 (&d->c17);
 
-  /* Account for the sign of x and y.  */
-  ret = vreinterpretq_f64_u64 (
-      veorq_u64 (vreinterpretq_u64_f64 (ret), sign_xy));
+  /* Order-7 Estrin.  */
+  float64x2_t p01 = vfmaq_laneq_f64 (d->c0, z2, c13, 0);
+  float64x2_t p23 = vfmaq_laneq_f64 (d->c2, z2, c13, 1);
+  float64x2_t p03 = vfmaq_f64 (p01, z4, p23);
+
+  float64x2_t p45 = vfmaq_laneq_f64 (d->c4, z2, c57, 0);
+  float64x2_t p67 = vfmaq_laneq_f64 (d->c6, z2, c57, 1);
+  float64x2_t p47 = vfmaq_f64 (p45, z4, p67);
+
+  float64x2_t p07 = vfmaq_f64 (p03, z8, p47);
+
+  /* Order-11 Estrin.  */
+  float64x2_t p89 = vfmaq_laneq_f64 (d->c8, z2, c911, 0);
+  float64x2_t p1011 = vfmaq_laneq_f64 (d->c10, z2, c911, 1);
+  float64x2_t p811 = vfmaq_f64 (p89, z4, p1011);
+
+  float64x2_t p1213 = vfmaq_laneq_f64 (d->c12, z2, c1315, 0);
+  float64x2_t p1415 = vfmaq_laneq_f64 (d->c14, z2, c1315, 1);
+  float64x2_t p1215 = vfmaq_f64 (p1213, z4, p1415);
+
+  float64x2_t p1617 = vfmaq_laneq_f64 (d->c16, z2, c1719, 0);
+  float64x2_t p1819 = vfmaq_laneq_f64 (d->c18, z2, c1719, 1);
+  float64x2_t p1619 = vfmaq_f64 (p1617, z4, p1819);
+
+  float64x2_t p815 = vfmaq_f64 (p811, z8, p1215);
+  float64x2_t p819 = vfmaq_f64 (p815, z16, p1619);
+
+  float64x2_t poly = vfmaq_f64 (p07, p819, z16);
+
+  /* Finalize. y = shift + z + z^3 * P(z^2).  */
+  float64x2_t ret = vfmaq_f64 (z, shift, d->pi_over_2);
+  ret = vfmaq_f64 (ret, z3, poly);
 
   if (__glibc_unlikely (v_any_u64 (special_cases)))
-    return special_case (y, x, ret, special_cases);
+    return special_case (y, x, ret, sign_xy, special_cases);
 
-  return ret;
+  /* Account for the sign of x and y.  */
+  return vreinterpretq_f64_u64 (
+      veorq_u64 (vreinterpretq_u64_f64 (ret), sign_xy));
 }
diff --git a/sysdeps/aarch64/fpu/atan2_sve.c b/sysdeps/aarch64/fpu/atan2_sve.c
index 09a4c559b8..7af4931cdb 100644
--- a/sysdeps/aarch64/fpu/atan2_sve.c
+++ b/sysdeps/aarch64/fpu/atan2_sve.c
@@ -18,28 +18,25 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include "sv_math.h"
-#include "poly_sve_f64.h"
 
 static const struct data
 {
-  float64_t poly[20];
-  float64_t pi_over_2;
+  float64_t c0, c2, c4, c6, c8, c10, c12, c14, c16, c18;
+  float64_t c1, c3, c5, c7, c9, c11, c13, c15, c17, c19;
 } data = {
   /* Coefficients of polynomial P such that atan(x)~x+x*P(x^2) on
      [2**-1022, 1.0].  */
-  .poly = { -0x1.5555555555555p-2,  0x1.99999999996c1p-3, -0x1.2492492478f88p-3,
-            0x1.c71c71bc3951cp-4,   -0x1.745d160a7e368p-4, 0x1.3b139b6a88ba1p-4,
-            -0x1.11100ee084227p-4,  0x1.e1d0f9696f63bp-5, -0x1.aebfe7b418581p-5,
-            0x1.842dbe9b0d916p-5,   -0x1.5d30140ae5e99p-5, 0x1.338e31eb2fbbcp-5,
-            -0x1.00e6eece7de8p-5,   0x1.860897b29e5efp-6, -0x1.0051381722a59p-6,
-            0x1.14e9dc19a4a4ep-7,  -0x1.d0062b42fe3bfp-9, 0x1.17739e210171ap-10,
-            -0x1.ab24da7be7402p-13, 0x1.358851160a528p-16, },
-  .pi_over_2 = 0x1.921fb54442d18p+0,
+  .c0 = -0x1.555555555552ap-2,	 .c1 = 0x1.9999999995aebp-3,
+  .c2 = -0x1.24924923923f6p-3,	 .c3 = 0x1.c71c7184288a2p-4,
+  .c4 = -0x1.745d11fb3d32bp-4,	 .c5 = 0x1.3b136a18051b9p-4,
+  .c6 = -0x1.110e6d985f496p-4,	 .c7 = 0x1.e1bcf7f08801dp-5,
+  .c8 = -0x1.ae644e28058c3p-5,	 .c9 = 0x1.82eeb1fed85c6p-5,
+  .c10 = -0x1.59d7f901566cbp-5,	 .c11 = 0x1.2c982855ab069p-5,
+  .c12 = -0x1.eb49592998177p-6,	 .c13 = 0x1.69d8b396e3d38p-6,
+  .c14 = -0x1.ca980345c4204p-7,	 .c15 = 0x1.dc050eafde0b3p-8,
+  .c16 = -0x1.7ea70755b8eccp-9,	 .c17 = 0x1.ba3da3de903e8p-11,
+  .c18 = -0x1.44a4b059b6f67p-13, .c19 = 0x1.c4a45029e5a91p-17,
 };
-
-/* Useful constants.  */
-#define SignMask sv_u64 (0x8000000000000000)
-
 /* Special cases i.e. 0, infinity, nan (fall back to scalar calls).  */
 static svfloat64_t NOINLINE
 special_case (svfloat64_t y, svfloat64_t x, svfloat64_t ret,
@@ -58,61 +55,100 @@ zeroinfnan (svuint64_t i, const svbool_t pg)
 }
 
 /* Fast implementation of SVE atan2. Errors are greatest when y and
-   x are reasonably close together. The greatest observed error is 2.28 ULP:
-   _ZGVsMxvv_atan2 (-0x1.5915b1498e82fp+732, 0x1.54d11ef838826p+732)
-   got -0x1.954f42f1fa841p-1 want -0x1.954f42f1fa843p-1.  */
-svfloat64_t SV_NAME_D2 (atan2) (svfloat64_t y, svfloat64_t x, const svbool_t pg)
+   x are reasonably close together. The greatest observed error is 1.94 ULP:
+   _ZGVsMxvv_atan2 (0x1.8a4bf7167228ap+5, 0x1.84971226bb57bp+5)
+   got 0x1.95db19dfef9ccp-1 want 0x1.95db19dfef9cep-1.  */
+svfloat64_t SV_NAME_D2 (atan2) (svfloat64_t y, svfloat64_t x,
+				const svbool_t pg)
 {
-  const struct data *data_ptr = ptr_barrier (&data);
+  const struct data *d = ptr_barrier (&data);
 
   svuint64_t ix = svreinterpret_u64 (x);
   svuint64_t iy = svreinterpret_u64 (y);
+  svbool_t ptrue = svptrue_b64 ();
 
   svbool_t cmp_x = zeroinfnan (ix, pg);
   svbool_t cmp_y = zeroinfnan (iy, pg);
   svbool_t cmp_xy = svorr_z (pg, cmp_x, cmp_y);
 
-  svuint64_t sign_x = svand_x (pg, ix, SignMask);
-  svuint64_t sign_y = svand_x (pg, iy, SignMask);
-  svuint64_t sign_xy = sveor_x (pg, sign_x, sign_y);
-
   svfloat64_t ax = svabs_x (pg, x);
   svfloat64_t ay = svabs_x (pg, y);
+  svuint64_t iax = svreinterpret_u64 (ax);
+  svuint64_t iay = svreinterpret_u64 (ay);
 
-  svbool_t pred_xlt0 = svcmplt (pg, x, 0.0);
-  svbool_t pred_aygtax = svcmpgt (pg, ay, ax);
+  svuint64_t sign_x = sveor_x (pg, ix, iax);
+  svuint64_t sign_y = sveor_x (pg, iy, iay);
+  svuint64_t sign_xy = sveor_x (pg, sign_x, sign_y);
 
-  /* Set up z for call to atan.  */
-  svfloat64_t n = svsel (pred_aygtax, svneg_x (pg, ax), ay);
-  svfloat64_t d = svsel (pred_aygtax, ay, ax);
-  svfloat64_t z = svdiv_x (pg, n, d);
+  svbool_t pred_aygtax = svcmpgt (pg, ay, ax);
 
-  /* Work out the correct shift.  */
-  svfloat64_t shift = svsel (pred_xlt0, sv_f64 (-2.0), sv_f64 (0.0));
-  shift = svsel (pred_aygtax, svadd_x (pg, shift, 1.0), shift);
-  shift = svmul_x (pg, shift, data_ptr->pi_over_2);
+  /* Set up z for evaluation of atan.  */
+  svfloat64_t num = svsel (pred_aygtax, svneg_x (pg, ax), ay);
+  svfloat64_t den = svsel (pred_aygtax, ay, ax);
+  svfloat64_t z = svdiv_x (pg, num, den);
+
+  /* Work out the correct shift for atan2:
+     Multiplication by pi is done later.
+     -pi   when x < 0  and ax < ay
+     -pi/2 when x < 0  and ax > ay
+      0    when x >= 0 and ax < ay
+      pi/2 when x >= 0 and ax > ay.  */
+  svfloat64_t shift = svreinterpret_f64 (svlsr_x (pg, sign_x, 1));
+  svfloat64_t shift_mul = svreinterpret_f64 (
+      svorr_x (pg, sign_x, svreinterpret_u64 (sv_f64 (0x1.921fb54442d18p+0))));
+  shift = svsel (pred_aygtax, sv_f64 (1.0), shift);
+  shift = svmla_x (pg, z, shift, shift_mul);
 
   /* Use split Estrin scheme for P(z^2) with deg(P)=19.  */
   svfloat64_t z2 = svmul_x (pg, z, z);
-  svfloat64_t x2 = svmul_x (pg, z2, z2);
-  svfloat64_t x4 = svmul_x (pg, x2, x2);
-  svfloat64_t x8 = svmul_x (pg, x4, x4);
+  svfloat64_t z3 = svmul_x (pg, z2, z);
+  svfloat64_t z4 = svmul_x (pg, z2, z2);
+  svfloat64_t z8 = svmul_x (pg, z4, z4);
+  svfloat64_t z16 = svmul_x (pg, z8, z8);
 
-  svfloat64_t ret = svmla_x (
-      pg, sv_estrin_7_f64_x (pg, z2, x2, x4, data_ptr->poly),
-      sv_estrin_11_f64_x (pg, z2, x2, x4, x8, data_ptr->poly + 8), x8);
+  /* Order-7 Estrin.  */
+  svfloat64_t c13 = svld1rq (ptrue, &d->c1);
+  svfloat64_t c57 = svld1rq (ptrue, &d->c5);
 
-  /* y = shift + z + z^3 * P(z^2).  */
-  svfloat64_t z3 = svmul_x (pg, z2, z);
-  ret = svmla_x (pg, z, z3, ret);
+  svfloat64_t p01 = svmla_lane (sv_f64 (d->c0), z2, c13, 0);
+  svfloat64_t p23 = svmla_lane (sv_f64 (d->c2), z2, c13, 1);
+  svfloat64_t p45 = svmla_lane (sv_f64 (d->c4), z2, c57, 0);
+  svfloat64_t p67 = svmla_lane (sv_f64 (d->c6), z2, c57, 1);
 
-  ret = svadd_m (pg, ret, shift);
+  svfloat64_t p03 = svmla_x (pg, p01, z4, p23);
+  svfloat64_t p47 = svmla_x (pg, p45, z4, p67);
+  svfloat64_t p07 = svmla_x (pg, p03, z8, p47);
 
-  /* Account for the sign of x and y.  */
-  ret = svreinterpret_f64 (sveor_x (pg, svreinterpret_u64 (ret), sign_xy));
+  /* Order-11 Estrin.  */
+  svfloat64_t c911 = svld1rq (ptrue, &d->c9);
+  svfloat64_t c1315 = svld1rq (ptrue, &d->c13);
+  svfloat64_t c1719 = svld1rq (ptrue, &d->c17);
 
-  if (__glibc_unlikely (svptest_any (pg, cmp_xy)))
-    return special_case (y, x, ret, cmp_xy);
+  svfloat64_t p89 = svmla_lane (sv_f64 (d->c8), z2, c911, 0);
+  svfloat64_t p1011 = svmla_lane (sv_f64 (d->c10), z2, c911, 1);
+  svfloat64_t p811 = svmla_x (pg, p89, z4, p1011);
+
+  svfloat64_t p1213 = svmla_lane (sv_f64 (d->c12), z2, c1315, 0);
+  svfloat64_t p1415 = svmla_lane (sv_f64 (d->c14), z2, c1315, 1);
+  svfloat64_t p1215 = svmla_x (pg, p1213, z4, p1415);
+
+  svfloat64_t p1617 = svmla_lane (sv_f64 (d->c16), z2, c1719, 0);
+  svfloat64_t p1819 = svmla_lane (sv_f64 (d->c18), z2, c1719, 1);
+  svfloat64_t p1619 = svmla_x (pg, p1617, z4, p1819);
+
+  svfloat64_t p815 = svmla_x (pg, p811, z8, p1215);
+  svfloat64_t p819 = svmla_x (pg, p815, z16, p1619);
 
-  return ret;
+  svfloat64_t poly = svmla_x (pg, p07, z16, p819);
+
+  /* y = shift + z + z^3 * P(z^2).  */
+  svfloat64_t ret = svmla_x (pg, shift, z3, poly);
+
+  /* Account for the sign of x and y.  */
+  if (__glibc_unlikely (svptest_any (pg, cmp_xy)))
+    return special_case (
+	y, x,
+	svreinterpret_f64 (sveor_x (pg, svreinterpret_u64 (ret), sign_xy)),
+	cmp_xy);
+  return svreinterpret_f64 (sveor_x (pg, svreinterpret_u64 (ret), sign_xy));
 }
diff --git a/sysdeps/aarch64/fpu/atan2f_advsimd.c b/sysdeps/aarch64/fpu/atan2f_advsimd.c
index 56e610caf1..23a825e63b 100644
--- a/sysdeps/aarch64/fpu/atan2f_advsimd.c
+++ b/sysdeps/aarch64/fpu/atan2f_advsimd.c
@@ -18,52 +18,58 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include "v_math.h"
-#include "poly_advsimd_f32.h"
 
 static const struct data
 {
-  float32x4_t poly[8];
-  float32x4_t pi_over_2;
+  float32x4_t c0, c4, c6, c2;
+  float c1, c3, c5, c7;
+  uint32x4_t comp_const;
+  float32x4_t pi;
 } data = {
   /* Coefficients of polynomial P such that atan(x)~x+x*P(x^2) on
      [2**-128, 1.0].
      Generated using fpminimax between FLT_MIN and 1.  */
-  .poly = { V4 (-0x1.55555p-2f), V4 (0x1.99935ep-3f), V4 (-0x1.24051ep-3f),
-	    V4 (0x1.bd7368p-4f), V4 (-0x1.491f0ep-4f), V4 (0x1.93a2c0p-5f),
-	    V4 (-0x1.4c3c60p-6f), V4 (0x1.01fd88p-8f) },
-  .pi_over_2 = V4 (0x1.921fb6p+0f),
+  .c0 = V4 (-0x1.5554dcp-2), .c1 = 0x1.9978ecp-3,
+  .c2 = V4 (-0x1.230a94p-3), .c3 = 0x1.b4debp-4,
+  .c4 = V4 (-0x1.3550dap-4), .c5 = 0x1.61eebp-5,
+  .c6 = V4 (-0x1.0c17d4p-6), .c7 = 0x1.7ea694p-9,
+  .pi = V4 (0x1.921fb6p+1f), .comp_const = V4 (2 * 0x7f800000lu - 1),
 };
 
 #define SignMask v_u32 (0x80000000)
 
 /* Special cases i.e. 0, infinity and nan (fall back to scalar calls).  */
 static float32x4_t VPCS_ATTR NOINLINE
-special_case (float32x4_t y, float32x4_t x, float32x4_t ret, uint32x4_t cmp)
+special_case (float32x4_t y, float32x4_t x, float32x4_t ret,
+	      uint32x4_t sign_xy, uint32x4_t cmp)
 {
+  /* Account for the sign of y.  */
+  ret = vreinterpretq_f32_u32 (
+      veorq_u32 (vreinterpretq_u32_f32 (ret), sign_xy));
   return v_call2_f32 (atan2f, y, x, ret, cmp);
 }
 
 /* Returns 1 if input is the bit representation of 0, infinity or nan.  */
 static inline uint32x4_t
-zeroinfnan (uint32x4_t i)
+zeroinfnan (uint32x4_t i, const struct data *d)
 {
   /* 2 * i - 1 >= 2 * 0x7f800000lu - 1.  */
-  return vcgeq_u32 (vsubq_u32 (vmulq_n_u32 (i, 2), v_u32 (1)),
-		    v_u32 (2 * 0x7f800000lu - 1));
+  return vcgeq_u32 (vsubq_u32 (vshlq_n_u32 (i, 1), v_u32 (1)), d->comp_const);
 }
 
 /* Fast implementation of vector atan2f. Maximum observed error is
-   2.95 ULP in [0x1.9300d6p+6 0x1.93c0c6p+6] x [0x1.8c2dbp+6 0x1.8cea6p+6]:
-   _ZGVnN4vv_atan2f (0x1.93836cp+6, 0x1.8cae1p+6) got 0x1.967f06p-1
-						 want 0x1.967f00p-1.  */
+   2.13 ULP in [0x1.9300d6p+6 0x1.93c0c6p+6] x [0x1.8c2dbp+6 0x1.8cea6p+6]:
+   _ZGVnN4vv_atan2f (0x1.14a9d4p-87, 0x1.0eb886p-87) got 0x1.97aea2p-1
+						    want 0x1.97ae9ep-1.  */
 float32x4_t VPCS_ATTR NOINLINE V_NAME_F2 (atan2) (float32x4_t y, float32x4_t x)
 {
-  const struct data *data_ptr = ptr_barrier (&data);
+  const struct data *d = ptr_barrier (&data);
 
   uint32x4_t ix = vreinterpretq_u32_f32 (x);
   uint32x4_t iy = vreinterpretq_u32_f32 (y);
 
-  uint32x4_t special_cases = vorrq_u32 (zeroinfnan (ix), zeroinfnan (iy));
+  uint32x4_t special_cases
+      = vorrq_u32 (zeroinfnan (ix, d), zeroinfnan (iy, d));
 
   uint32x4_t sign_x = vandq_u32 (ix, SignMask);
   uint32x4_t sign_y = vandq_u32 (iy, SignMask);
@@ -75,44 +81,52 @@ float32x4_t VPCS_ATTR NOINLINE V_NAME_F2 (atan2) (float32x4_t y, float32x4_t x)
   uint32x4_t pred_xlt0 = vcltzq_f32 (x);
   uint32x4_t pred_aygtax = vcgtq_f32 (ay, ax);
 
-  /* Set up z for call to atanf.  */
-  float32x4_t n = vbslq_f32 (pred_aygtax, vnegq_f32 (ax), ay);
-  float32x4_t d = vbslq_f32 (pred_aygtax, ay, ax);
-  float32x4_t z = vdivq_f32 (n, d);
-
-  /* Work out the correct shift.  */
+  /* Set up z for evaluation of atanf.  */
+  float32x4_t num = vbslq_f32 (pred_aygtax, vnegq_f32 (ax), ay);
+  float32x4_t den = vbslq_f32 (pred_aygtax, ay, ax);
+  float32x4_t z = vdivq_f32 (num, den);
+
+  /* Work out the correct shift for atan2:
+     Multiplication by pi is done later.
+     -pi   when x < 0  and ax < ay
+     -pi/2 when x < 0  and ax > ay
+      0    when x >= 0 and ax < ay
+      pi/2 when x >= 0 and ax > ay.  */
   float32x4_t shift = vreinterpretq_f32_u32 (
-      vandq_u32 (pred_xlt0, vreinterpretq_u32_f32 (v_f32 (-2.0f))));
-  shift = vbslq_f32 (pred_aygtax, vaddq_f32 (shift, v_f32 (1.0f)), shift);
-  shift = vmulq_f32 (shift, data_ptr->pi_over_2);
-
-  /* Calculate the polynomial approximation.
-     Use 2-level Estrin scheme for P(z^2) with deg(P)=7. However,
-     a standard implementation using z8 creates spurious underflow
-     in the very last fma (when z^8 is small enough).
-     Therefore, we split the last fma into a mul and an fma.
-     Horner and single-level Estrin have higher errors that exceed
-     threshold.  */
+      vandq_u32 (pred_xlt0, vreinterpretq_u32_f32 (v_f32 (-1.0f))));
+  float32x4_t shift2 = vreinterpretq_f32_u32 (
+      vandq_u32 (pred_aygtax, vreinterpretq_u32_f32 (v_f32 (0.5f))));
+  shift = vaddq_f32 (shift, shift2);
+
+  /* Calculate the polynomial approximation.  */
   float32x4_t z2 = vmulq_f32 (z, z);
+  float32x4_t z3 = vmulq_f32 (z2, z);
   float32x4_t z4 = vmulq_f32 (z2, z2);
+  float32x4_t z8 = vmulq_f32 (z4, z4);
 
-  float32x4_t ret = vfmaq_f32 (
-      v_pairwise_poly_3_f32 (z2, z4, data_ptr->poly), z4,
-      vmulq_f32 (z4, v_pairwise_poly_3_f32 (z2, z4, data_ptr->poly + 4)));
+  float32x4_t c1357 = vld1q_f32 (&d->c1);
 
-  /* y = shift + z * P(z^2).  */
-  ret = vaddq_f32 (vfmaq_f32 (z, ret, vmulq_f32 (z2, z)), shift);
+  float32x4_t p01 = vfmaq_laneq_f32 (d->c0, z2, c1357, 0);
+  float32x4_t p23 = vfmaq_laneq_f32 (d->c2, z2, c1357, 1);
+  float32x4_t p45 = vfmaq_laneq_f32 (d->c4, z2, c1357, 2);
+  float32x4_t p67 = vfmaq_laneq_f32 (d->c6, z2, c1357, 3);
+  float32x4_t p03 = vfmaq_f32 (p01, z4, p23);
+  float32x4_t p47 = vfmaq_f32 (p45, z4, p67);
 
-  /* Account for the sign of y.  */
-  ret = vreinterpretq_f32_u32 (
-      veorq_u32 (vreinterpretq_u32_f32 (ret), sign_xy));
+  float32x4_t poly = vfmaq_f32 (p03, z8, p47);
+
+  /* y = shift + z * P(z^2).  */
+  float32x4_t ret = vfmaq_f32 (z, shift, d->pi);
+  ret = vfmaq_f32 (ret, z3, poly);
 
   if (__glibc_unlikely (v_any_u32 (special_cases)))
     {
-      return special_case (y, x, ret, special_cases);
+      return special_case (y, x, ret, sign_xy, special_cases);
     }
 
-  return ret;
+  /* Account for the sign of y.  */
+  return vreinterpretq_f32_u32 (
+      veorq_u32 (vreinterpretq_u32_f32 (ret), sign_xy));
 }
 libmvec_hidden_def (V_NAME_F2 (atan2))
 HALF_WIDTH_ALIAS_F2(atan2)
diff --git a/sysdeps/aarch64/fpu/atan2f_sve.c b/sysdeps/aarch64/fpu/atan2f_sve.c
index b92f83cdea..f7f6d40ca6 100644
--- a/sysdeps/aarch64/fpu/atan2f_sve.c
+++ b/sysdeps/aarch64/fpu/atan2f_sve.c
@@ -18,24 +18,22 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include "sv_math.h"
-#include "poly_sve_f32.h"
 
 static const struct data
 {
-  float32_t poly[8];
+  float32_t c0, c2, c4, c6;
+  float32_t c1, c3, c5, c7;
   float32_t pi_over_2;
 } data = {
   /* Coefficients of polynomial P such that atan(x)~x+x*P(x^2) on
      [2**-128, 1.0].  */
-  .poly = { -0x1.55555p-2f, 0x1.99935ep-3f, -0x1.24051ep-3f, 0x1.bd7368p-4f,
-	    -0x1.491f0ep-4f, 0x1.93a2c0p-5f, -0x1.4c3c60p-6f, 0x1.01fd88p-8f },
-  .pi_over_2 = 0x1.921fb6p+0f,
+  .c0 = -0x1.5554dcp-2, .c1 = 0x1.9978ecp-3,  .c2 = -0x1.230a94p-3,
+  .c3 = 0x1.b4debp-4,	.c4 = -0x1.3550dap-4, .c5 = 0x1.61eebp-5,
+  .c6 = -0x1.0c17d4p-6, .c7 = 0x1.7ea694p-9,  .pi_over_2 = 0x1.921fb6p+0f,
 };
 
-#define SignMask sv_u32 (0x80000000)
-
 /* Special cases i.e. 0, infinity, nan (fall back to scalar calls).  */
-static inline svfloat32_t
+static svfloat32_t NOINLINE
 special_case (svfloat32_t y, svfloat32_t x, svfloat32_t ret,
 	      const svbool_t cmp)
 {
@@ -53,12 +51,14 @@ zeroinfnan (svuint32_t i, const svbool_t pg)
 
 /* Fast implementation of SVE atan2f based on atan(x) ~ shift + z + z^3 *
    P(z^2) with reduction to [0,1] using z=1/x and shift = pi/2. Maximum
-   observed error is 2.95 ULP:
-   _ZGVsMxvv_atan2f (0x1.93836cp+6, 0x1.8cae1p+6) got 0x1.967f06p-1
-						 want 0x1.967f00p-1.  */
-svfloat32_t SV_NAME_F2 (atan2) (svfloat32_t y, svfloat32_t x, const svbool_t pg)
+   observed error is 2.21 ULP:
+   _ZGVnN4vv_atan2f (0x1.a04aa8p+6, 0x1.9a274p+6) got 0x1.95ed3ap-1
+						 want 0x1.95ed36p-1.  */
+svfloat32_t SV_NAME_F2 (atan2) (svfloat32_t y, svfloat32_t x,
+				const svbool_t pg)
 {
-  const struct data *data_ptr = ptr_barrier (&data);
+  const struct data *d = ptr_barrier (&data);
+  svbool_t ptrue = svptrue_b32 ();
 
   svuint32_t ix = svreinterpret_u32 (x);
   svuint32_t iy = svreinterpret_u32 (y);
@@ -67,44 +67,61 @@ svfloat32_t SV_NAME_F2 (atan2) (svfloat32_t y, svfloat32_t x, const svbool_t pg)
   svbool_t cmp_y = zeroinfnan (iy, pg);
   svbool_t cmp_xy = svorr_z (pg, cmp_x, cmp_y);
 
-  svuint32_t sign_x = svand_x (pg, ix, SignMask);
-  svuint32_t sign_y = svand_x (pg, iy, SignMask);
-  svuint32_t sign_xy = sveor_x (pg, sign_x, sign_y);
-
   svfloat32_t ax = svabs_x (pg, x);
   svfloat32_t ay = svabs_x (pg, y);
+  svuint32_t iax = svreinterpret_u32 (ax);
+  svuint32_t iay = svreinterpret_u32 (ay);
 
-  svbool_t pred_xlt0 = svcmplt (pg, x, 0.0);
-  svbool_t pred_aygtax = svcmpgt (pg, ay, ax);
-
-  /* Set up z for call to atan.  */
-  svfloat32_t n = svsel (pred_aygtax, svneg_x (pg, ax), ay);
-  svfloat32_t d = svsel (pred_aygtax, ay, ax);
-  svfloat32_t z = svdiv_x (pg, n, d);
+  svuint32_t sign_x = sveor_x (pg, ix, iax);
+  svuint32_t sign_y = sveor_x (pg, iy, iay);
+  svuint32_t sign_xy = sveor_x (pg, sign_x, sign_y);
 
-  /* Work out the correct shift.  */
-  svfloat32_t shift = svsel (pred_xlt0, sv_f32 (-2.0), sv_f32 (0.0));
-  shift = svsel (pred_aygtax, svadd_x (pg, shift, 1.0), shift);
-  shift = svmul_x (pg, shift, sv_f32 (data_ptr->pi_over_2));
+  svbool_t pred_aygtax = svcmpgt (pg, ay, ax);
 
-  /* Use split Estrin scheme for P(z^2) with deg(P)=7.  */
-  svfloat32_t z2 = svmul_x (pg, z, z);
+  /* Set up z for evaluation of atanf.  */
+  svfloat32_t num = svsel (pred_aygtax, svneg_x (pg, ax), ay);
+  svfloat32_t den = svsel (pred_aygtax, ay, ax);
+  svfloat32_t z = svdiv_x (ptrue, num, den);
+
+  /* Work out the correct shift for atan2:
+     Multiplication by pi is done later.
+     -pi   when x < 0  and ax < ay
+     -pi/2 when x < 0  and ax > ay
+      0    when x >= 0 and ax < ay
+      pi/2 when x >= 0 and ax > ay.  */
+  svfloat32_t shift = svreinterpret_f32 (svlsr_x (pg, sign_x, 1));
+  shift = svsel (pred_aygtax, sv_f32 (1.0), shift);
+  shift = svreinterpret_f32 (svorr_x (pg, sign_x, svreinterpret_u32 (shift)));
+
+  /* Use pure Estrin scheme for P(z^2) with deg(P)=7.  */
+  svfloat32_t z2 = svmul_x (ptrue, z, z);
+  svfloat32_t z3 = svmul_x (pg, z2, z);
   svfloat32_t z4 = svmul_x (pg, z2, z2);
   svfloat32_t z8 = svmul_x (pg, z4, z4);
 
-  svfloat32_t ret = sv_estrin_7_f32_x (pg, z2, z4, z8, data_ptr->poly);
+  svfloat32_t odd_coeffs = svld1rq (ptrue, &d->c1);
 
-  /* ret = shift + z + z^3 * P(z^2).  */
-  svfloat32_t z3 = svmul_x (pg, z2, z);
-  ret = svmla_x (pg, z, z3, ret);
+  svfloat32_t p01 = svmla_lane (sv_f32 (d->c0), z2, odd_coeffs, 0);
+  svfloat32_t p23 = svmla_lane (sv_f32 (d->c2), z2, odd_coeffs, 1);
+  svfloat32_t p45 = svmla_lane (sv_f32 (d->c4), z2, odd_coeffs, 2);
+  svfloat32_t p67 = svmla_lane (sv_f32 (d->c6), z2, odd_coeffs, 3);
 
-  ret = svadd_m (pg, ret, shift);
+  svfloat32_t p03 = svmla_x (pg, p01, z4, p23);
+  svfloat32_t p47 = svmla_x (pg, p45, z4, p67);
+
+  svfloat32_t poly = svmla_x (pg, p03, z8, p47);
+
+  /* ret = shift + z + z^3 * P(z^2).  */
+  svfloat32_t ret = svmla_x (pg, z, shift, sv_f32 (d->pi_over_2));
+  ret = svmla_x (pg, ret, z3, poly);
 
   /* Account for the sign of x and y.  */
-  ret = svreinterpret_f32 (sveor_x (pg, svreinterpret_u32 (ret), sign_xy));
 
   if (__glibc_unlikely (svptest_any (pg, cmp_xy)))
-    return special_case (y, x, ret, cmp_xy);
+    return special_case (
+	y, x,
+	svreinterpret_f32 (sveor_x (pg, svreinterpret_u32 (ret), sign_xy)),
+	cmp_xy);
 
-  return ret;
+  return svreinterpret_f32 (sveor_x (pg, svreinterpret_u32 (ret), sign_xy));
 }
diff --git a/sysdeps/aarch64/fpu/atan_advsimd.c b/sysdeps/aarch64/fpu/atan_advsimd.c
index a962be0f78..f835dae828 100644
--- a/sysdeps/aarch64/fpu/atan_advsimd.c
+++ b/sysdeps/aarch64/fpu/atan_advsimd.c
@@ -18,25 +18,25 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include "v_math.h"
-#include "poly_advsimd_f64.h"
 
 static const struct data
 {
+  float64x2_t c0, c2, c4, c6, c8, c10, c12, c14, c16, c18;
   float64x2_t pi_over_2;
-  float64x2_t poly[20];
+  double c1, c3, c5, c7, c9, c11, c13, c15, c17, c19;
 } data = {
   /* Coefficients of polynomial P such that atan(x)~x+x*P(x^2) on
 	      [2**-1022, 1.0].  */
-  .poly = { V2 (-0x1.5555555555555p-2),	 V2 (0x1.99999999996c1p-3),
-	    V2 (-0x1.2492492478f88p-3),	 V2 (0x1.c71c71bc3951cp-4),
-	    V2 (-0x1.745d160a7e368p-4),	 V2 (0x1.3b139b6a88ba1p-4),
-	    V2 (-0x1.11100ee084227p-4),	 V2 (0x1.e1d0f9696f63bp-5),
-	    V2 (-0x1.aebfe7b418581p-5),	 V2 (0x1.842dbe9b0d916p-5),
-	    V2 (-0x1.5d30140ae5e99p-5),	 V2 (0x1.338e31eb2fbbcp-5),
-	    V2 (-0x1.00e6eece7de8p-5),	 V2 (0x1.860897b29e5efp-6),
-	    V2 (-0x1.0051381722a59p-6),	 V2 (0x1.14e9dc19a4a4ep-7),
-	    V2 (-0x1.d0062b42fe3bfp-9),	 V2 (0x1.17739e210171ap-10),
-	    V2 (-0x1.ab24da7be7402p-13), V2 (0x1.358851160a528p-16), },
+  .c0 = V2 (-0x1.555555555552ap-2),	  .c1 = 0x1.9999999995aebp-3,
+  .c2 = V2 (-0x1.24924923923f6p-3),	  .c3 = 0x1.c71c7184288a2p-4,
+  .c4 = V2 (-0x1.745d11fb3d32bp-4),	  .c5 = 0x1.3b136a18051b9p-4,
+  .c6 = V2 (-0x1.110e6d985f496p-4),	  .c7 = 0x1.e1bcf7f08801dp-5,
+  .c8 = V2 (-0x1.ae644e28058c3p-5),	  .c9 = 0x1.82eeb1fed85c6p-5,
+  .c10 = V2 (-0x1.59d7f901566cbp-5),	  .c11 = 0x1.2c982855ab069p-5,
+  .c12 = V2 (-0x1.eb49592998177p-6),	  .c13 = 0x1.69d8b396e3d38p-6,
+  .c14 = V2 (-0x1.ca980345c4204p-7),	  .c15 = 0x1.dc050eafde0b3p-8,
+  .c16 = V2 (-0x1.7ea70755b8eccp-9),	  .c17 = 0x1.ba3da3de903e8p-11,
+  .c18 = V2 (-0x1.44a4b059b6f67p-13),	  .c19 = 0x1.c4a45029e5a91p-17,
   .pi_over_2 = V2 (0x1.921fb54442d18p+0),
 };
 
@@ -46,12 +46,17 @@ static const struct data
 
 /* Fast implementation of vector atan.
    Based on atan(x) ~ shift + z + z^3 * P(z^2) with reduction to [0,1] using
-   z=1/x and shift = pi/2. Maximum observed error is 2.27 ulps:
-   _ZGVnN2v_atan (0x1.0005af27c23e9p+0) got 0x1.9225645bdd7c1p-1
-				       want 0x1.9225645bdd7c3p-1.  */
+   z=1/x and shift = pi/2. Maximum observed error is 2.45 ulps:
+   _ZGVnN2v_atan (0x1.0008d737eb3e6p+0) got 0x1.92288c551a4c1p-1
+				       want 0x1.92288c551a4c3p-1.  */
 float64x2_t VPCS_ATTR V_NAME_D1 (atan) (float64x2_t x)
 {
   const struct data *d = ptr_barrier (&data);
+  float64x2_t c13 = vld1q_f64 (&d->c1);
+  float64x2_t c57 = vld1q_f64 (&d->c5);
+  float64x2_t c911 = vld1q_f64 (&d->c9);
+  float64x2_t c1315 = vld1q_f64 (&d->c13);
+  float64x2_t c1719 = vld1q_f64 (&d->c17);
 
   /* Small cases, infs and nans are supported by our approximation technique,
      but do not set fenv flags correctly. Only trigger special case if we need
@@ -72,33 +77,53 @@ float64x2_t VPCS_ATTR V_NAME_D1 (atan) (float64x2_t x)
      y := arctan(x) for x < 1
      y := pi/2 + arctan(-1/x) for x > 1
      Hence, use z=-1/a if x>=1, otherwise z=a.  */
-  uint64x2_t red = vcagtq_f64 (x, v_f64 (1.0));
+  uint64x2_t red = vcagtq_f64 (x, v_f64 (-1.0));
   /* Avoid dependency in abs(x) in division (and comparison).  */
-  float64x2_t z = vbslq_f64 (red, vdivq_f64 (v_f64 (1.0), x), x);
+  float64x2_t z = vbslq_f64 (red, vdivq_f64 (v_f64 (-1.0), x), x);
+
   float64x2_t shift = vreinterpretq_f64_u64 (
       vandq_u64 (red, vreinterpretq_u64_f64 (d->pi_over_2)));
-  /* Use absolute value only when needed (odd powers of z).  */
-  float64x2_t az = vbslq_f64 (
-      SignMask, vreinterpretq_f64_u64 (vandq_u64 (SignMask, red)), z);
-
-  /* Calculate the polynomial approximation.
-     Use split Estrin scheme for P(z^2) with deg(P)=19. Use split instead of
-     full scheme to avoid underflow in x^16.
-     The order 19 polynomial P approximates
-     (atan(sqrt(x))-sqrt(x))/x^(3/2).  */
+
+  /* Reinsert sign bit from argument into the shift value.  */
+  shift = vreinterpretq_f64_u64 (
+      veorq_u64 (vreinterpretq_u64_f64 (shift), sign));
+
+  /* Calculate polynomial approximation P(z^2) with deg(P)=19.  */
   float64x2_t z2 = vmulq_f64 (z, z);
-  float64x2_t x2 = vmulq_f64 (z2, z2);
-  float64x2_t x4 = vmulq_f64 (x2, x2);
-  float64x2_t x8 = vmulq_f64 (x4, x4);
-  float64x2_t y
-      = vfmaq_f64 (v_estrin_7_f64 (z2, x2, x4, d->poly),
-		   v_estrin_11_f64 (z2, x2, x4, x8, d->poly + 8), x8);
+  float64x2_t z4 = vmulq_f64 (z2, z2);
+  float64x2_t z8 = vmulq_f64 (z4, z4);
+  float64x2_t z16 = vmulq_f64 (z8, z8);
 
-  /* Finalize. y = shift + z + z^3 * P(z^2).  */
-  y = vfmaq_f64 (az, y, vmulq_f64 (z2, az));
-  y = vaddq_f64 (y, shift);
+  /* Order-7 Estrin.  */
+  float64x2_t p01 = vfmaq_laneq_f64 (d->c0, z2, c13, 0);
+  float64x2_t p23 = vfmaq_laneq_f64 (d->c2, z2, c13, 1);
+  float64x2_t p03 = vfmaq_f64 (p01, z4, p23);
+
+  float64x2_t p45 = vfmaq_laneq_f64 (d->c4, z2, c57, 0);
+  float64x2_t p67 = vfmaq_laneq_f64 (d->c6, z2, c57, 1);
+  float64x2_t p47 = vfmaq_f64 (p45, z4, p67);
+
+  float64x2_t p07 = vfmaq_f64 (p03, z8, p47);
 
-  /* y = atan(x) if x>0, -atan(-x) otherwise.  */
-  y = vreinterpretq_f64_u64 (veorq_u64 (vreinterpretq_u64_f64 (y), sign));
-  return y;
+  /* Order-11 Estrin.  */
+  float64x2_t p89 = vfmaq_laneq_f64 (d->c8, z2, c911, 0);
+  float64x2_t p1011 = vfmaq_laneq_f64 (d->c10, z2, c911, 1);
+  float64x2_t p811 = vfmaq_f64 (p89, z4, p1011);
+
+  float64x2_t p1213 = vfmaq_laneq_f64 (d->c12, z2, c1315, 0);
+  float64x2_t p1415 = vfmaq_laneq_f64 (d->c14, z2, c1315, 1);
+  float64x2_t p1215 = vfmaq_f64 (p1213, z4, p1415);
+
+  float64x2_t p1617 = vfmaq_laneq_f64 (d->c16, z2, c1719, 0);
+  float64x2_t p1819 = vfmaq_laneq_f64 (d->c18, z2, c1719, 1);
+  float64x2_t p1619 = vfmaq_f64 (p1617, z4, p1819);
+
+  float64x2_t p815 = vfmaq_f64 (p811, z8, p1215);
+  float64x2_t p819 = vfmaq_f64 (p815, z16, p1619);
+
+  float64x2_t y = vfmaq_f64 (p07, p819, z16);
+
+  /* Finalize. y = shift + z + z^3 * P(z^2).  */
+  y = vfmsq_f64 (v_f64 (-1.0), z2, y);
+  return vfmsq_f64 (shift, z, y);
 }
diff --git a/sysdeps/aarch64/fpu/atan_sve.c b/sysdeps/aarch64/fpu/atan_sve.c
index fa1630304c..046c04fbb1 100644
--- a/sysdeps/aarch64/fpu/atan_sve.c
+++ b/sysdeps/aarch64/fpu/atan_sve.c
@@ -18,23 +18,26 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include "sv_math.h"
-#include "poly_sve_f64.h"
 
 static const struct data
 {
-  float64_t poly[20];
-  float64_t pi_over_2;
+  float64_t c0, c2, c4, c6, c8, c10, c12, c14, c16, c18;
+  float64_t c1, c3, c5, c7, c9, c11, c13, c15, c17, c19;
+  float64_t shift_val, neg_one;
 } data = {
   /* Coefficients of polynomial P such that atan(x)~x+x*P(x^2) on
      [2**-1022, 1.0].  */
-  .poly = { -0x1.5555555555555p-2,  0x1.99999999996c1p-3, -0x1.2492492478f88p-3,
-            0x1.c71c71bc3951cp-4,   -0x1.745d160a7e368p-4, 0x1.3b139b6a88ba1p-4,
-            -0x1.11100ee084227p-4,  0x1.e1d0f9696f63bp-5, -0x1.aebfe7b418581p-5,
-            0x1.842dbe9b0d916p-5,   -0x1.5d30140ae5e99p-5, 0x1.338e31eb2fbbcp-5,
-            -0x1.00e6eece7de8p-5,   0x1.860897b29e5efp-6, -0x1.0051381722a59p-6,
-            0x1.14e9dc19a4a4ep-7,  -0x1.d0062b42fe3bfp-9, 0x1.17739e210171ap-10,
-            -0x1.ab24da7be7402p-13, 0x1.358851160a528p-16, },
-  .pi_over_2 = 0x1.921fb54442d18p+0,
+  .c0 = -0x1.555555555552ap-2,	     .c1 = 0x1.9999999995aebp-3,
+  .c2 = -0x1.24924923923f6p-3,	     .c3 = 0x1.c71c7184288a2p-4,
+  .c4 = -0x1.745d11fb3d32bp-4,	     .c5 = 0x1.3b136a18051b9p-4,
+  .c6 = -0x1.110e6d985f496p-4,	     .c7 = 0x1.e1bcf7f08801dp-5,
+  .c8 = -0x1.ae644e28058c3p-5,	     .c9 = 0x1.82eeb1fed85c6p-5,
+  .c10 = -0x1.59d7f901566cbp-5,	     .c11 = 0x1.2c982855ab069p-5,
+  .c12 = -0x1.eb49592998177p-6,	     .c13 = 0x1.69d8b396e3d38p-6,
+  .c14 = -0x1.ca980345c4204p-7,	     .c15 = 0x1.dc050eafde0b3p-8,
+  .c16 = -0x1.7ea70755b8eccp-9,	     .c17 = 0x1.ba3da3de903e8p-11,
+  .c18 = -0x1.44a4b059b6f67p-13,     .c19 = 0x1.c4a45029e5a91p-17,
+  .shift_val = 0x1.490fdaa22168cp+1, .neg_one = -1,
 };
 
 /* Useful constants.  */
@@ -43,15 +46,14 @@ static const struct data
 /* Fast implementation of SVE atan.
    Based on atan(x) ~ shift + z + z^3 * P(z^2) with reduction to [0,1] using
    z=1/x and shift = pi/2. Largest errors are close to 1. The maximum observed
-   error is 2.27 ulps:
-   _ZGVsMxv_atan (0x1.0005af27c23e9p+0) got 0x1.9225645bdd7c1p-1
-				       want 0x1.9225645bdd7c3p-1.  */
+   error is 2.08 ulps:
+   _ZGVsMxv_atan (0x1.000a7c56975e8p+0) got 0x1.922a3163e15c2p-1
+				       want 0x1.922a3163e15c4p-1.  */
 svfloat64_t SV_NAME_D1 (atan) (svfloat64_t x, const svbool_t pg)
 {
   const struct data *d = ptr_barrier (&data);
 
-  /* No need to trigger special case. Small cases, infs and nans
-     are supported by our approximation technique.  */
+  svbool_t ptrue = svptrue_b64 ();
   svuint64_t ix = svreinterpret_u64 (x);
   svuint64_t sign = svand_x (pg, ix, SignMask);
 
@@ -59,32 +61,60 @@ svfloat64_t SV_NAME_D1 (atan) (svfloat64_t x, const svbool_t pg)
      y := arctan(x) for x < 1
      y := pi/2 + arctan(-1/x) for x > 1
      Hence, use z=-1/a if x>=1, otherwise z=a.  */
-  svbool_t red = svacgt (pg, x, 1.0);
-  /* Avoid dependency in abs(x) in division (and comparison).  */
-  svfloat64_t z = svsel (red, svdivr_x (pg, x, 1.0), x);
-  /* Use absolute value only when needed (odd powers of z).  */
-  svfloat64_t az = svabs_x (pg, z);
-  az = svneg_m (az, red, az);
+  svbool_t red = svacgt (pg, x, d->neg_one);
+  svfloat64_t z = svsel (red, svdiv_x (pg, sv_f64 (d->neg_one), x), x);
+
+  /* Reuse of -1.0f to reduce constant loads,
+     We need a shift value of 1/2, which is created via -1 + (1 + 1/2).  */
+  svfloat64_t shift
+      = svadd_z (red, sv_f64 (d->neg_one), sv_f64 (d->shift_val));
+
+  /* Reinserts the sign bit of the argument to handle the case of x < -1.  */
+  shift = svreinterpret_f64 (sveor_x (pg, svreinterpret_u64 (shift), sign));
 
   /* Use split Estrin scheme for P(z^2) with deg(P)=19.  */
-  svfloat64_t z2 = svmul_x (pg, z, z);
-  svfloat64_t x2 = svmul_x (pg, z2, z2);
-  svfloat64_t x4 = svmul_x (pg, x2, x2);
-  svfloat64_t x8 = svmul_x (pg, x4, x4);
+  svfloat64_t z2 = svmul_x (ptrue, z, z);
+  svfloat64_t z4 = svmul_x (ptrue, z2, z2);
+  svfloat64_t z8 = svmul_x (ptrue, z4, z4);
+  svfloat64_t z16 = svmul_x (ptrue, z8, z8);
 
-  svfloat64_t y
-      = svmla_x (pg, sv_estrin_7_f64_x (pg, z2, x2, x4, d->poly),
-		 sv_estrin_11_f64_x (pg, z2, x2, x4, x8, d->poly + 8), x8);
+  /* Order-7 Estrin.  */
+  svfloat64_t c13 = svld1rq (ptrue, &d->c1);
+  svfloat64_t c57 = svld1rq (ptrue, &d->c5);
 
-  /* y = shift + z + z^3 * P(z^2).  */
-  svfloat64_t z3 = svmul_x (pg, z2, az);
-  y = svmla_x (pg, az, z3, y);
+  svfloat64_t p01 = svmla_lane (sv_f64 (d->c0), z2, c13, 0);
+  svfloat64_t p23 = svmla_lane (sv_f64 (d->c2), z2, c13, 1);
+  svfloat64_t p45 = svmla_lane (sv_f64 (d->c4), z2, c57, 0);
+  svfloat64_t p67 = svmla_lane (sv_f64 (d->c6), z2, c57, 1);
+
+  svfloat64_t p03 = svmla_x (pg, p01, z4, p23);
+  svfloat64_t p47 = svmla_x (pg, p45, z4, p67);
+  svfloat64_t p07 = svmla_x (pg, p03, z8, p47);
+
+  /* Order-11 Estrin.  */
+  svfloat64_t c911 = svld1rq (ptrue, &d->c9);
+  svfloat64_t c1315 = svld1rq (ptrue, &d->c13);
+  svfloat64_t c1719 = svld1rq (ptrue, &d->c17);
 
-  /* Apply shift as indicated by `red` predicate.  */
-  y = svadd_m (red, y, d->pi_over_2);
+  svfloat64_t p89 = svmla_lane (sv_f64 (d->c8), z2, c911, 0);
+  svfloat64_t p1011 = svmla_lane (sv_f64 (d->c10), z2, c911, 1);
+  svfloat64_t p811 = svmla_x (pg, p89, z4, p1011);
 
-  /* y = atan(x) if x>0, -atan(-x) otherwise.  */
-  y = svreinterpret_f64 (sveor_x (pg, svreinterpret_u64 (y), sign));
+  svfloat64_t p1213 = svmla_lane (sv_f64 (d->c12), z2, c1315, 0);
+  svfloat64_t p1415 = svmla_lane (sv_f64 (d->c14), z2, c1315, 1);
+  svfloat64_t p1215 = svmla_x (pg, p1213, z4, p1415);
 
-  return y;
+  svfloat64_t p1617 = svmla_lane (sv_f64 (d->c16), z2, c1719, 0);
+  svfloat64_t p1819 = svmla_lane (sv_f64 (d->c18), z2, c1719, 1);
+  svfloat64_t p1619 = svmla_x (pg, p1617, z4, p1819);
+
+  svfloat64_t p815 = svmla_x (pg, p811, z8, p1215);
+  svfloat64_t p819 = svmla_x (pg, p815, z16, p1619);
+
+  svfloat64_t y = svmla_x (pg, p07, z16, p819);
+
+  /* y = shift + z + z^3 * P(z^2).  */
+  shift = svadd_m (red, z, shift);
+  y = svmul_x (pg, z2, y);
+  return svmla_x (pg, shift, z, y);
 }
diff --git a/sysdeps/aarch64/fpu/atanf_advsimd.c b/sysdeps/aarch64/fpu/atanf_advsimd.c
index d015cc70ad..e72074ec62 100644
--- a/sysdeps/aarch64/fpu/atanf_advsimd.c
+++ b/sysdeps/aarch64/fpu/atanf_advsimd.c
@@ -22,26 +22,35 @@
 
 static const struct data
 {
+  uint32x4_t sign_mask, pi_over_2;
+  float32x4_t neg_one;
+#if WANT_SIMD_EXCEPT
   float32x4_t poly[8];
-  float32x4_t pi_over_2;
+} data = {
+  .poly = { V4 (-0x1.5554dcp-2), V4 (0x1.9978ecp-3), V4 (-0x1.230a94p-3),
+	    V4 (0x1.b4debp-4), V4 (-0x1.3550dap-4), V4 (0x1.61eebp-5),
+	    V4 (-0x1.0c17d4p-6), V4 (0x1.7ea694p-9) },
+#else
+  float32x4_t c0, c2, c4, c6;
+  float c1, c3, c5, c7;
 } data = {
   /* Coefficients of polynomial P such that atan(x)~x+x*P(x^2) on
      [2**-128, 1.0].
      Generated using fpminimax between FLT_MIN and 1.  */
-  .poly = { V4 (-0x1.55555p-2f), V4 (0x1.99935ep-3f), V4 (-0x1.24051ep-3f),
-	    V4 (0x1.bd7368p-4f), V4 (-0x1.491f0ep-4f), V4 (0x1.93a2c0p-5f),
-	    V4 (-0x1.4c3c60p-6f), V4 (0x1.01fd88p-8f) },
-  .pi_over_2 = V4 (0x1.921fb6p+0f),
+  .c0 = V4 (-0x1.5554dcp-2),	.c1 = 0x1.9978ecp-3,
+  .c2 = V4 (-0x1.230a94p-3),	.c3 = 0x1.b4debp-4,
+  .c4 = V4 (-0x1.3550dap-4),	.c5 = 0x1.61eebp-5,
+  .c6 = V4 (-0x1.0c17d4p-6),	.c7 = 0x1.7ea694p-9,
+#endif
+  .pi_over_2 = V4 (0x3fc90fdb),
+  .neg_one = V4 (-1.0f),
+  .sign_mask = V4 (0x80000000),
 };
 
-#define SignMask v_u32 (0x80000000)
-
-#define P(i) d->poly[i]
-
+#if WANT_SIMD_EXCEPT
 #define TinyBound 0x30800000 /* asuint(0x1p-30).  */
 #define BigBound 0x4e800000  /* asuint(0x1p30).  */
 
-#if WANT_SIMD_EXCEPT
 static float32x4_t VPCS_ATTR NOINLINE
 special_case (float32x4_t x, float32x4_t y, uint32x4_t special)
 {
@@ -51,19 +60,20 @@ special_case (float32x4_t x, float32x4_t y, uint32x4_t special)
 
 /* Fast implementation of vector atanf based on
    atan(x) ~ shift + z + z^3 * P(z^2) with reduction to [0,1]
-   using z=-1/x and shift = pi/2. Maximum observed error is 2.9ulps:
-   _ZGVnN4v_atanf (0x1.0468f6p+0) got 0x1.967f06p-1 want 0x1.967fp-1.  */
+   using z=-1/x and shift = pi/2. Maximum observed error is 2.02 ulps:
+   _ZGVnN4v_atanf (0x1.03d4cep+0) got 0x1.95ed3ap-1
+				 want 0x1.95ed36p-1.  */
 float32x4_t VPCS_ATTR NOINLINE V_NAME_F1 (atan) (float32x4_t x)
 {
   const struct data *d = ptr_barrier (&data);
 
-  /* Small cases, infs and nans are supported by our approximation technique,
-     but do not set fenv flags correctly. Only trigger special case if we need
-     fenv.  */
   uint32x4_t ix = vreinterpretq_u32_f32 (x);
-  uint32x4_t sign = vandq_u32 (ix, SignMask);
+  uint32x4_t sign = vandq_u32 (ix, d->sign_mask);
 
 #if WANT_SIMD_EXCEPT
+  /* Small cases, infs and nans are supported by our approximation technique,
+     but do not set fenv flags correctly. Only trigger special case if we need
+     fenv.  */
   uint32x4_t ia = vandq_u32 (ix, v_u32 (0x7ff00000));
   uint32x4_t special = vcgtq_u32 (vsubq_u32 (ia, v_u32 (TinyBound)),
 				  v_u32 (BigBound - TinyBound));
@@ -71,41 +81,52 @@ float32x4_t VPCS_ATTR NOINLINE V_NAME_F1 (atan) (float32x4_t x)
   if (__glibc_unlikely (v_any_u32 (special)))
     return special_case (x, x, v_u32 (-1));
 #endif
-
   /* Argument reduction:
-     y := arctan(x) for x < 1
-     y := pi/2 + arctan(-1/x) for x > 1
-     Hence, use z=-1/a if x>=1, otherwise z=a.  */
-  uint32x4_t red = vcagtq_f32 (x, v_f32 (1.0));
-  /* Avoid dependency in abs(x) in division (and comparison).  */
-  float32x4_t z = vbslq_f32 (red, vdivq_f32 (v_f32 (1.0f), x), x);
+     y := arctan(x) for |x| < 1
+     y := arctan(-1/x) + pi/2 for x > +1
+     y := arctan(-1/x) - pi/2 for x < -1
+     Hence, use z=-1/a if x>=|-1|, otherwise z=a.  */
+  uint32x4_t red = vcagtq_f32 (x, d->neg_one);
+
+  float32x4_t z = vbslq_f32 (red, vdivq_f32 (d->neg_one, x), x);
+
+  /* Shift is calculated as +-pi/2 or 0, depending on the argument case.  */
   float32x4_t shift = vreinterpretq_f32_u32 (
-      vandq_u32 (red, vreinterpretq_u32_f32 (d->pi_over_2)));
-  /* Use absolute value only when needed (odd powers of z).  */
-  float32x4_t az = vbslq_f32 (
-      SignMask, vreinterpretq_f32_u32 (vandq_u32 (SignMask, red)), z);
+      vandq_u32 (red, veorq_u32 (d->pi_over_2, sign)));
+
+  float32x4_t z2 = vmulq_f32 (z, z);
+  float32x4_t z3 = vmulq_f32 (z, z2);
+  float32x4_t z4 = vmulq_f32 (z2, z2);
+#if WANT_SIMD_EXCEPT
 
   /* Calculate the polynomial approximation.
      Use 2-level Estrin scheme for P(z^2) with deg(P)=7. However,
      a standard implementation using z8 creates spurious underflow
      in the very last fma (when z^8 is small enough).
-     Therefore, we split the last fma into a mul and an fma.
-     Horner and single-level Estrin have higher errors that exceed
-     threshold.  */
-  float32x4_t z2 = vmulq_f32 (z, z);
-  float32x4_t z4 = vmulq_f32 (z2, z2);
-
+     Therefore, we split the last fma into a mul and an fma.  */
   float32x4_t y = vfmaq_f32 (
       v_pairwise_poly_3_f32 (z2, z4, d->poly), z4,
       vmulq_f32 (z4, v_pairwise_poly_3_f32 (z2, z4, d->poly + 4)));
 
-  /* y = shift + z * P(z^2).  */
-  y = vaddq_f32 (vfmaq_f32 (az, y, vmulq_f32 (z2, az)), shift);
+#else
+  float32x4_t z8 = vmulq_f32 (z4, z4);
+
+  /* Uses an Estrin scheme for polynomial approximation.  */
+  float32x4_t odd_coeffs = vld1q_f32 (&d->c1);
+
+  float32x4_t p01 = vfmaq_laneq_f32 (d->c0, z2, odd_coeffs, 0);
+  float32x4_t p23 = vfmaq_laneq_f32 (d->c2, z2, odd_coeffs, 1);
+  float32x4_t p45 = vfmaq_laneq_f32 (d->c4, z2, odd_coeffs, 2);
+  float32x4_t p67 = vfmaq_laneq_f32 (d->c6, z2, odd_coeffs, 3);
 
-  /* y = atan(x) if x>0, -atan(-x) otherwise.  */
-  y = vreinterpretq_f32_u32 (veorq_u32 (vreinterpretq_u32_f32 (y), sign));
+  float32x4_t p03 = vfmaq_f32 (p01, z4, p23);
+  float32x4_t p47 = vfmaq_f32 (p45, z4, p67);
 
-  return y;
+  float32x4_t y = vfmaq_f32 (p03, z8, p47);
+#endif
+
+  /* y = shift + z * P(z^2).  */
+  return vfmaq_f32 (vaddq_f32 (shift, z), z3, y);
 }
 libmvec_hidden_def (V_NAME_F1 (atan))
 HALF_WIDTH_ALIAS_F1 (atan)
diff --git a/sysdeps/aarch64/fpu/atanf_sve.c b/sysdeps/aarch64/fpu/atanf_sve.c
index 7b54094586..0f5a054743 100644
--- a/sysdeps/aarch64/fpu/atanf_sve.c
+++ b/sysdeps/aarch64/fpu/atanf_sve.c
@@ -18,18 +18,26 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include "sv_math.h"
-#include "poly_sve_f32.h"
 
 static const struct data
 {
-  float32_t poly[8];
-  float32_t pi_over_2;
+  float32_t c1, c3, c5, c7;
+  float32_t c0, c2, c4, c6;
+  float32_t shift_val, neg_one;
 } data = {
   /* Coefficients of polynomial P such that atan(x)~x+x*P(x^2) on
     [2**-128, 1.0].  */
-  .poly = { -0x1.55555p-2f, 0x1.99935ep-3f, -0x1.24051ep-3f, 0x1.bd7368p-4f,
-	    -0x1.491f0ep-4f, 0x1.93a2c0p-5f, -0x1.4c3c60p-6f, 0x1.01fd88p-8f },
-  .pi_over_2 = 0x1.921fb6p+0f,
+  .c0 = -0x1.5554dcp-2,
+  .c1 = 0x1.9978ecp-3,
+  .c2 = -0x1.230a94p-3,
+  .c3 = 0x1.b4debp-4,
+  .c4 = -0x1.3550dap-4,
+  .c5 = 0x1.61eebp-5,
+  .c6 = -0x1.0c17d4p-6,
+  .c7 = 0x1.7ea694p-9,
+  /*  pi/2, used as a shift value after reduction.  */
+  .shift_val = 0x1.921fb54442d18p+0,
+  .neg_one = -1.0f,
 };
 
 #define SignMask (0x80000000)
@@ -37,43 +45,49 @@ static const struct data
 /* Fast implementation of SVE atanf based on
    atan(x) ~ shift + z + z^3 * P(z^2) with reduction to [0,1] using
    z=-1/x and shift = pi/2.
-   Largest observed error is 2.9 ULP, close to +/-1.0:
-   _ZGVsMxv_atanf (0x1.0468f6p+0) got -0x1.967f06p-1
-				 want -0x1.967fp-1.  */
+   Largest observed error is 2.12 ULP:
+   _ZGVsMxv_atanf (0x1.03d4cep+0) got 0x1.95ed3ap-1
+				 want 0x1.95ed36p-1.  */
 svfloat32_t SV_NAME_F1 (atan) (svfloat32_t x, const svbool_t pg)
 {
   const struct data *d = ptr_barrier (&data);
+  svbool_t ptrue = svptrue_b32 ();
 
   /* No need to trigger special case. Small cases, infs and nans
      are supported by our approximation technique.  */
   svuint32_t ix = svreinterpret_u32 (x);
-  svuint32_t sign = svand_x (pg, ix, SignMask);
+  svuint32_t sign = svand_x (ptrue, ix, SignMask);
 
   /* Argument reduction:
      y := arctan(x) for x < 1
-     y := pi/2 + arctan(-1/x) for x > 1
-     Hence, use z=-1/a if x>=1, otherwise z=a.  */
-  svbool_t red = svacgt (pg, x, 1.0f);
-  /* Avoid dependency in abs(x) in division (and comparison).  */
-  svfloat32_t z = svsel (red, svdiv_x (pg, sv_f32 (1.0f), x), x);
-  /* Use absolute value only when needed (odd powers of z).  */
-  svfloat32_t az = svabs_x (pg, z);
-  az = svneg_m (az, red, az);
-
-  /* Use split Estrin scheme for P(z^2) with deg(P)=7.  */
-  svfloat32_t z2 = svmul_x (pg, z, z);
-  svfloat32_t z4 = svmul_x (pg, z2, z2);
-  svfloat32_t z8 = svmul_x (pg, z4, z4);
-
-  svfloat32_t y = sv_estrin_7_f32_x (pg, z2, z4, z8, d->poly);
-
-  /* y = shift + z + z^3 * P(z^2).  */
-  svfloat32_t z3 = svmul_x (pg, z2, az);
-  y = svmla_x (pg, az, z3, y);
-
-  /* Apply shift as indicated by 'red' predicate.  */
-  y = svadd_m (red, y, sv_f32 (d->pi_over_2));
-
-  /* y = atan(x) if x>0, -atan(-x) otherwise.  */
-  return svreinterpret_f32 (sveor_x (pg, svreinterpret_u32 (y), sign));
+     y := arctan(-1/x) + pi/2 for x > +1
+     y := arctan(-1/x) - pi/2 for x < -1
+     Hence, use z=-1/a if |x|>=|-1|, otherwise z=a.  */
+  svbool_t red = svacgt (pg, x, d->neg_one);
+  svfloat32_t z = svsel (red, svdiv_x (pg, sv_f32 (d->neg_one), x), x);
+
+  /* Reinserts the sign bit of the argument to handle the case of x < -1.  */
+  svfloat32_t shift = svreinterpret_f32 (
+      sveor_x (red, svreinterpret_u32 (sv_f32 (d->shift_val)), sign));
+
+  svfloat32_t z2 = svmul_x (ptrue, z, z);
+  svfloat32_t z3 = svmul_x (ptrue, z2, z);
+  svfloat32_t z4 = svmul_x (ptrue, z2, z2);
+  svfloat32_t z8 = svmul_x (ptrue, z4, z4);
+
+  svfloat32_t odd_coeffs = svld1rq (ptrue, &d->c1);
+
+  svfloat32_t p01 = svmla_lane (sv_f32 (d->c0), z2, odd_coeffs, 0);
+  svfloat32_t p23 = svmla_lane (sv_f32 (d->c2), z2, odd_coeffs, 1);
+  svfloat32_t p45 = svmla_lane (sv_f32 (d->c4), z2, odd_coeffs, 2);
+  svfloat32_t p67 = svmla_lane (sv_f32 (d->c6), z2, odd_coeffs, 3);
+
+  svfloat32_t p03 = svmla_x (pg, p01, z4, p23);
+  svfloat32_t p47 = svmla_x (pg, p45, z4, p67);
+
+  svfloat32_t y = svmla_x (pg, p03, z8, p47);
+
+  /* shift + z + z^3 * P(z^2).  */
+  shift = svadd_m (red, z, shift);
+  return svmla_x (pg, shift, z3, y);
 }
diff --git a/sysdeps/aarch64/fpu/cos_advsimd.c b/sysdeps/aarch64/fpu/cos_advsimd.c
index 2897e8b909..11a89b1530 100644
--- a/sysdeps/aarch64/fpu/cos_advsimd.c
+++ b/sysdeps/aarch64/fpu/cos_advsimd.c
@@ -22,7 +22,7 @@
 static const struct data
 {
   float64x2_t poly[7];
-  float64x2_t range_val, shift, inv_pi, half_pi, pi_1, pi_2, pi_3;
+  float64x2_t range_val, inv_pi, pi_1, pi_2, pi_3;
 } data = {
   /* Worst-case error is 3.3 ulp in [-pi/2, pi/2].  */
   .poly = { V2 (-0x1.555555555547bp-3), V2 (0x1.1111111108a4dp-7),
@@ -30,11 +30,9 @@ static const struct data
 	    V2 (-0x1.ae633919987c6p-26), V2 (0x1.60e277ae07cecp-33),
 	    V2 (-0x1.9e9540300a1p-41) },
   .inv_pi = V2 (0x1.45f306dc9c883p-2),
-  .half_pi = V2 (0x1.921fb54442d18p+0),
   .pi_1 = V2 (0x1.921fb54442d18p+1),
   .pi_2 = V2 (0x1.1a62633145c06p-53),
   .pi_3 = V2 (0x1.c1cd129024e09p-106),
-  .shift = V2 (0x1.8p52),
   .range_val = V2 (0x1p23)
 };
 
@@ -63,16 +61,14 @@ float64x2_t VPCS_ATTR V_NAME_D1 (cos) (float64x2_t x)
        special-case handler later.  */
     r = vbslq_f64 (cmp, v_f64 (1.0), r);
 #else
-  cmp = vcageq_f64 (d->range_val, x);
-  cmp = vceqzq_u64 (cmp); /* cmp = ~cmp.  */
+  cmp = vcageq_f64 (x, d->range_val);
   r = x;
 #endif
 
   /* n = rint((|x|+pi/2)/pi) - 0.5.  */
-  n = vfmaq_f64 (d->shift, d->inv_pi, vaddq_f64 (r, d->half_pi));
-  odd = vshlq_n_u64 (vreinterpretq_u64_f64 (n), 63);
-  n = vsubq_f64 (n, d->shift);
-  n = vsubq_f64 (n, v_f64 (0.5));
+  n = vrndaq_f64 (vfmaq_f64 (v_f64 (0.5), r, d->inv_pi));
+  odd = vshlq_n_u64 (vreinterpretq_u64_s64 (vcvtq_s64_f64 (n)), 63);
+  n = vsubq_f64 (n, v_f64 (0.5f));
 
   /* r = |x| - n*pi  (range reduction into -pi/2 .. pi/2).  */
   r = vfmsq_f64 (r, d->pi_1, n);
diff --git a/sysdeps/aarch64/fpu/cosf_advsimd.c b/sysdeps/aarch64/fpu/cosf_advsimd.c
index 60abc8dfcf..85a1b37373 100644
--- a/sysdeps/aarch64/fpu/cosf_advsimd.c
+++ b/sysdeps/aarch64/fpu/cosf_advsimd.c
@@ -22,7 +22,7 @@
 static const struct data
 {
   float32x4_t poly[4];
-  float32x4_t range_val, inv_pi, half_pi, shift, pi_1, pi_2, pi_3;
+  float32x4_t range_val, inv_pi, pi_1, pi_2, pi_3;
 } data = {
   /* 1.886 ulp error.  */
   .poly = { V4 (-0x1.555548p-3f), V4 (0x1.110df4p-7f), V4 (-0x1.9f42eap-13f),
@@ -33,8 +33,6 @@ static const struct data
   .pi_3 = V4 (-0x1.ee59dap-49f),
 
   .inv_pi = V4 (0x1.45f306p-2f),
-  .shift = V4 (0x1.8p+23f),
-  .half_pi = V4 (0x1.921fb6p0f),
   .range_val = V4 (0x1p20f)
 };
 
@@ -64,15 +62,13 @@ float32x4_t VPCS_ATTR NOINLINE V_NAME_F1 (cos) (float32x4_t x)
        special-case handler later.  */
     r = vbslq_f32 (cmp, v_f32 (1.0f), r);
 #else
-  cmp = vcageq_f32 (d->range_val, x);
-  cmp = vceqzq_u32 (cmp); /* cmp = ~cmp.  */
+  cmp = vcageq_f32 (x, d->range_val);
   r = x;
 #endif
 
   /* n = rint((|x|+pi/2)/pi) - 0.5.  */
-  n = vfmaq_f32 (d->shift, d->inv_pi, vaddq_f32 (r, d->half_pi));
-  odd = vshlq_n_u32 (vreinterpretq_u32_f32 (n), 31);
-  n = vsubq_f32 (n, d->shift);
+  n = vrndaq_f32 (vfmaq_f32 (v_f32 (0.5), r, d->inv_pi));
+  odd = vshlq_n_u32 (vreinterpretq_u32_s32 (vcvtq_s32_f32 (n)), 31);
   n = vsubq_f32 (n, v_f32 (0.5f));
 
   /* r = |x| - n*pi  (range reduction into -pi/2 .. pi/2).  */
diff --git a/sysdeps/aarch64/fpu/exp10_advsimd.c b/sysdeps/aarch64/fpu/exp10_advsimd.c
index fe7149b191..eeb31ca839 100644
--- a/sysdeps/aarch64/fpu/exp10_advsimd.c
+++ b/sysdeps/aarch64/fpu/exp10_advsimd.c
@@ -57,7 +57,7 @@ const static struct data
 # define BigBound v_u64 (0x4070000000000000)  /* asuint64 (0x1p8).  */
 # define Thres v_u64 (0x2070000000000000)     /* BigBound - TinyBound.  */
 
-static inline float64x2_t VPCS_ATTR
+static float64x2_t VPCS_ATTR NOINLINE
 special_case (float64x2_t x, float64x2_t y, uint64x2_t cmp)
 {
   /* If fenv exceptions are to be triggered correctly, fall back to the scalar
@@ -72,7 +72,7 @@ special_case (float64x2_t x, float64x2_t y, uint64x2_t cmp)
 # define SpecialBias1 v_u64 (0x7000000000000000)  /* 0x1p769.  */
 # define SpecialBias2 v_u64 (0x3010000000000000)  /* 0x1p-254.  */
 
-static float64x2_t VPCS_ATTR NOINLINE
+static inline float64x2_t VPCS_ATTR
 special_case (float64x2_t s, float64x2_t y, float64x2_t n,
 	      const struct data *d)
 {
diff --git a/sysdeps/aarch64/fpu/exp10f_advsimd.c b/sysdeps/aarch64/fpu/exp10f_advsimd.c
index 7ee0c90948..cf53e73290 100644
--- a/sysdeps/aarch64/fpu/exp10f_advsimd.c
+++ b/sysdeps/aarch64/fpu/exp10f_advsimd.c
@@ -25,7 +25,9 @@
 static const struct data
 {
   float32x4_t poly[5];
-  float32x4_t shift, log10_2, log2_10_hi, log2_10_lo;
+  float log10_2_and_inv[4];
+  float32x4_t shift;
+
 #if !WANT_SIMD_EXCEPT
   float32x4_t scale_thresh;
 #endif
@@ -38,9 +40,9 @@ static const struct data
   .poly = { V4 (0x1.26bb16p+1f), V4 (0x1.5350d2p+1f), V4 (0x1.04744ap+1f),
 	    V4 (0x1.2d8176p+0f), V4 (0x1.12b41ap-1f) },
   .shift = V4 (0x1.8p23f),
-  .log10_2 = V4 (0x1.a934fp+1),
-  .log2_10_hi = V4 (0x1.344136p-2),
-  .log2_10_lo = V4 (-0x1.ec10cp-27),
+
+  /* Stores constants 1/log10(2), log10(2)_high, log10(2)_low, 0.  */
+  .log10_2_and_inv = { 0x1.a934fp+1, 0x1.344136p-2, -0x1.ec10cp-27, 0 },
 #if !WANT_SIMD_EXCEPT
   .scale_thresh = V4 (ScaleBound)
 #endif
@@ -98,24 +100,23 @@ float32x4_t VPCS_ATTR NOINLINE V_NAME_F1 (exp10) (float32x4_t x)
 #if WANT_SIMD_EXCEPT
   /* asuint(x) - TinyBound >= BigBound - TinyBound.  */
   uint32x4_t cmp = vcgeq_u32 (
-      vsubq_u32 (vandq_u32 (vreinterpretq_u32_f32 (x), v_u32 (0x7fffffff)),
-		 TinyBound),
-      Thres);
+      vsubq_u32 (vreinterpretq_u32_f32 (vabsq_f32 (x)), TinyBound), Thres);
   float32x4_t xm = x;
   /* If any lanes are special, mask them with 1 and retain a copy of x to allow
      special case handler to fix special lanes later. This is only necessary if
      fenv exceptions are to be triggered correctly.  */
   if (__glibc_unlikely (v_any_u32 (cmp)))
-    x = vbslq_f32 (cmp, v_f32 (1), x);
+    x = v_zerofy_f32 (x, cmp);
 #endif
 
   /* exp10(x) = 2^n * 10^r = 2^n * (1 + poly (r)),
      with poly(r) in [1/sqrt(2), sqrt(2)] and
      x = r + n * log10 (2), with r in [-log10(2)/2, log10(2)/2].  */
-  float32x4_t z = vfmaq_f32 (d->shift, x, d->log10_2);
+  float32x4_t log10_2_and_inv = vld1q_f32 (d->log10_2_and_inv);
+  float32x4_t z = vfmaq_laneq_f32 (d->shift, x, log10_2_and_inv, 0);
   float32x4_t n = vsubq_f32 (z, d->shift);
-  float32x4_t r = vfmsq_f32 (x, n, d->log2_10_hi);
-  r = vfmsq_f32 (r, n, d->log2_10_lo);
+  float32x4_t r = vfmsq_laneq_f32 (x, n, log10_2_and_inv, 1);
+  r = vfmsq_laneq_f32 (r, n, log10_2_and_inv, 2);
   uint32x4_t e = vshlq_n_u32 (vreinterpretq_u32_f32 (z), 23);
 
   float32x4_t scale = vreinterpretq_f32_u32 (vaddq_u32 (e, ExponentBias));
diff --git a/sysdeps/aarch64/fpu/exp2_advsimd.c b/sysdeps/aarch64/fpu/exp2_advsimd.c
index 391a93180c..ae1e63d503 100644
--- a/sysdeps/aarch64/fpu/exp2_advsimd.c
+++ b/sysdeps/aarch64/fpu/exp2_advsimd.c
@@ -24,6 +24,7 @@
 #define IndexMask (N - 1)
 #define BigBound 1022.0
 #define UOFlowBound 1280.0
+#define TinyBound 0x2000000000000000 /* asuint64(0x1p-511).  */
 
 static const struct data
 {
@@ -48,14 +49,13 @@ lookup_sbits (uint64x2_t i)
 
 #if WANT_SIMD_EXCEPT
 
-# define TinyBound 0x2000000000000000 /* asuint64(0x1p-511).  */
 # define Thres 0x2080000000000000     /* asuint64(512.0) - TinyBound.  */
 
 /* Call scalar exp2 as a fallback.  */
 static float64x2_t VPCS_ATTR NOINLINE
-special_case (float64x2_t x)
+special_case (float64x2_t x, float64x2_t y, uint64x2_t is_special)
 {
-  return v_call_f64 (exp2, x, x, v_u64 (0xffffffffffffffff));
+  return v_call_f64 (exp2, x, y, is_special);
 }
 
 #else
@@ -65,7 +65,7 @@ special_case (float64x2_t x)
 # define SpecialBias1 0x7000000000000000 /* 0x1p769.  */
 # define SpecialBias2 0x3010000000000000 /* 0x1p-254.  */
 
-static float64x2_t VPCS_ATTR
+static inline float64x2_t VPCS_ATTR
 special_case (float64x2_t s, float64x2_t y, float64x2_t n,
 	      const struct data *d)
 {
@@ -94,10 +94,10 @@ float64x2_t V_NAME_D1 (exp2) (float64x2_t x)
 #if WANT_SIMD_EXCEPT
   uint64x2_t ia = vreinterpretq_u64_f64 (vabsq_f64 (x));
   cmp = vcgeq_u64 (vsubq_u64 (ia, v_u64 (TinyBound)), v_u64 (Thres));
-  /* If any special case (inf, nan, small and large x) is detected,
-     fall back to scalar for all lanes.  */
-  if (__glibc_unlikely (v_any_u64 (cmp)))
-    return special_case (x);
+  /* Mask special lanes and retain a copy of x for passing to special-case
+     handler.  */
+  float64x2_t xc = x;
+  x = v_zerofy_f64 (x, cmp);
 #else
   cmp = vcagtq_f64 (x, d->scale_big_bound);
 #endif
@@ -120,9 +120,11 @@ float64x2_t V_NAME_D1 (exp2) (float64x2_t x)
   float64x2_t y = v_pairwise_poly_3_f64 (r, r2, d->poly);
   y = vmulq_f64 (r, y);
 
-#if !WANT_SIMD_EXCEPT
   if (__glibc_unlikely (v_any_u64 (cmp)))
+#if !WANT_SIMD_EXCEPT
     return special_case (s, y, n, d);
+#else
+    return special_case (xc, vfmaq_f64 (s, s, y), cmp);
 #endif
   return vfmaq_f64 (s, s, y);
 }
diff --git a/sysdeps/aarch64/fpu/exp2f_sve.c b/sysdeps/aarch64/fpu/exp2f_sve.c
index 9a5a523a10..8a686e3e05 100644
--- a/sysdeps/aarch64/fpu/exp2f_sve.c
+++ b/sysdeps/aarch64/fpu/exp2f_sve.c
@@ -20,6 +20,8 @@
 #include "sv_math.h"
 #include "poly_sve_f32.h"
 
+#define Thres 0x1.5d5e2ap+6f
+
 static const struct data
 {
   float poly[5];
@@ -33,7 +35,7 @@ static const struct data
   .shift = 0x1.903f8p17f,
   /* Roughly 87.3. For x < -Thres, the result is subnormal and not handled
      correctly by FEXPA.  */
-  .thres = 0x1.5d5e2ap+6f,
+  .thres = Thres,
 };
 
 static svfloat32_t NOINLINE
diff --git a/sysdeps/aarch64/fpu/exp_advsimd.c b/sysdeps/aarch64/fpu/exp_advsimd.c
index fd215f1d2c..5e3a9a0d44 100644
--- a/sysdeps/aarch64/fpu/exp_advsimd.c
+++ b/sysdeps/aarch64/fpu/exp_advsimd.c
@@ -54,7 +54,7 @@ const static volatile struct
 # define BigBound v_u64 (0x4080000000000000) /* asuint64 (0x1p9).  */
 # define SpecialBound v_u64 (0x2080000000000000) /* BigBound - TinyBound.  */
 
-static inline float64x2_t VPCS_ATTR
+static float64x2_t VPCS_ATTR NOINLINE
 special_case (float64x2_t x, float64x2_t y, uint64x2_t cmp)
 {
   /* If fenv exceptions are to be triggered correctly, fall back to the scalar
@@ -69,7 +69,7 @@ special_case (float64x2_t x, float64x2_t y, uint64x2_t cmp)
 # define SpecialBias1 v_u64 (0x7000000000000000) /* 0x1p769.  */
 # define SpecialBias2 v_u64 (0x3010000000000000) /* 0x1p-254.  */
 
-static float64x2_t VPCS_ATTR NOINLINE
+static inline float64x2_t VPCS_ATTR
 special_case (float64x2_t s, float64x2_t y, float64x2_t n)
 {
   /* 2^(n/N) may overflow, break it up into s1*s2.  */
diff --git a/sysdeps/aarch64/fpu/expf_advsimd.c b/sysdeps/aarch64/fpu/expf_advsimd.c
index 99d2e647aa..5c9cb72620 100644
--- a/sysdeps/aarch64/fpu/expf_advsimd.c
+++ b/sysdeps/aarch64/fpu/expf_advsimd.c
@@ -22,7 +22,7 @@
 static const struct data
 {
   float32x4_t poly[5];
-  float32x4_t shift, inv_ln2, ln2_hi, ln2_lo;
+  float32x4_t inv_ln2, ln2_hi, ln2_lo;
   uint32x4_t exponent_bias;
 #if !WANT_SIMD_EXCEPT
   float32x4_t special_bound, scale_thresh;
@@ -31,7 +31,6 @@ static const struct data
   /* maxerr: 1.45358 +0.5 ulp.  */
   .poly = { V4 (0x1.0e4020p-7f), V4 (0x1.573e2ep-5f), V4 (0x1.555e66p-3f),
 	    V4 (0x1.fffdb6p-2f), V4 (0x1.ffffecp-1f) },
-  .shift = V4 (0x1.8p23f),
   .inv_ln2 = V4 (0x1.715476p+0f),
   .ln2_hi = V4 (0x1.62e4p-1f),
   .ln2_lo = V4 (0x1.7f7d1cp-20f),
@@ -85,7 +84,7 @@ special_case (float32x4_t poly, float32x4_t n, uint32x4_t e, uint32x4_t cmp1,
 float32x4_t VPCS_ATTR NOINLINE V_NAME_F1 (exp) (float32x4_t x)
 {
   const struct data *d = ptr_barrier (&data);
-  float32x4_t n, r, r2, scale, p, q, poly, z;
+  float32x4_t n, r, r2, scale, p, q, poly;
   uint32x4_t cmp, e;
 
 #if WANT_SIMD_EXCEPT
@@ -104,11 +103,10 @@ float32x4_t VPCS_ATTR NOINLINE V_NAME_F1 (exp) (float32x4_t x)
 
   /* exp(x) = 2^n (1 + poly(r)), with 1 + poly(r) in [1/sqrt(2),sqrt(2)]
      x = ln2*n + r, with r in [-ln2/2, ln2/2].  */
-  z = vfmaq_f32 (d->shift, x, d->inv_ln2);
-  n = vsubq_f32 (z, d->shift);
+  n = vrndaq_f32 (vmulq_f32 (x, d->inv_ln2));
   r = vfmsq_f32 (x, n, d->ln2_hi);
   r = vfmsq_f32 (r, n, d->ln2_lo);
-  e = vshlq_n_u32 (vreinterpretq_u32_f32 (z), 23);
+  e = vshlq_n_u32 (vreinterpretq_u32_s32 (vcvtq_s32_f32 (n)), 23);
   scale = vreinterpretq_f32_u32 (vaddq_u32 (e, d->exponent_bias));
 
 #if !WANT_SIMD_EXCEPT
diff --git a/sysdeps/aarch64/fpu/expm1_advsimd.c b/sysdeps/aarch64/fpu/expm1_advsimd.c
index 0b85bd06f3..3db3b80c49 100644
--- a/sysdeps/aarch64/fpu/expm1_advsimd.c
+++ b/sysdeps/aarch64/fpu/expm1_advsimd.c
@@ -23,7 +23,9 @@
 static const struct data
 {
   float64x2_t poly[11];
-  float64x2_t invln2, ln2_lo, ln2_hi, shift;
+  float64x2_t invln2;
+  double ln2[2];
+  float64x2_t shift;
   int64x2_t exponent_bias;
 #if WANT_SIMD_EXCEPT
   uint64x2_t thresh, tiny_bound;
@@ -38,8 +40,7 @@ static const struct data
 	    V2 (0x1.71ddf82db5bb4p-19), V2 (0x1.27e517fc0d54bp-22),
 	    V2 (0x1.af5eedae67435p-26), V2 (0x1.1f143d060a28ap-29) },
   .invln2 = V2 (0x1.71547652b82fep0),
-  .ln2_hi = V2 (0x1.62e42fefa39efp-1),
-  .ln2_lo = V2 (0x1.abc9e3b39803fp-56),
+  .ln2 = { 0x1.62e42fefa39efp-1, 0x1.abc9e3b39803fp-56 },
   .shift = V2 (0x1.8p52),
   .exponent_bias = V2 (0x3ff0000000000000),
 #if WANT_SIMD_EXCEPT
@@ -83,7 +84,7 @@ float64x2_t VPCS_ATTR V_NAME_D1 (expm1) (float64x2_t x)
     x = v_zerofy_f64 (x, special);
 #else
   /* Large input, NaNs and Infs.  */
-  uint64x2_t special = vceqzq_u64 (vcaltq_f64 (x, d->oflow_bound));
+  uint64x2_t special = vcageq_f64 (x, d->oflow_bound);
 #endif
 
   /* Reduce argument to smaller range:
@@ -93,8 +94,9 @@ float64x2_t VPCS_ATTR V_NAME_D1 (expm1) (float64x2_t x)
      where 2^i is exact because i is an integer.  */
   float64x2_t n = vsubq_f64 (vfmaq_f64 (d->shift, d->invln2, x), d->shift);
   int64x2_t i = vcvtq_s64_f64 (n);
-  float64x2_t f = vfmsq_f64 (x, n, d->ln2_hi);
-  f = vfmsq_f64 (f, n, d->ln2_lo);
+  float64x2_t ln2 = vld1q_f64 (&d->ln2[0]);
+  float64x2_t f = vfmsq_laneq_f64 (x, n, ln2, 0);
+  f = vfmsq_laneq_f64 (f, n, ln2, 1);
 
   /* Approximate expm1(f) using polynomial.
      Taylor expansion for expm1(x) has the form:
diff --git a/sysdeps/aarch64/fpu/expm1f_advsimd.c b/sysdeps/aarch64/fpu/expm1f_advsimd.c
index 8d4c9a2193..a0616ec754 100644
--- a/sysdeps/aarch64/fpu/expm1f_advsimd.c
+++ b/sysdeps/aarch64/fpu/expm1f_advsimd.c
@@ -23,7 +23,8 @@
 static const struct data
 {
   float32x4_t poly[5];
-  float32x4_t invln2, ln2_lo, ln2_hi, shift;
+  float invln2_and_ln2[4];
+  float32x4_t shift;
   int32x4_t exponent_bias;
 #if WANT_SIMD_EXCEPT
   uint32x4_t thresh;
@@ -34,9 +35,8 @@ static const struct data
   /* Generated using fpminimax with degree=5 in [-log(2)/2, log(2)/2].  */
   .poly = { V4 (0x1.fffffep-2), V4 (0x1.5554aep-3), V4 (0x1.555736p-5),
 	    V4 (0x1.12287cp-7), V4 (0x1.6b55a2p-10) },
-  .invln2 = V4 (0x1.715476p+0f),
-  .ln2_hi = V4 (0x1.62e4p-1f),
-  .ln2_lo = V4 (0x1.7f7d1cp-20f),
+  /* Stores constants: invln2, ln2_hi, ln2_lo, 0.  */
+  .invln2_and_ln2 = { 0x1.715476p+0f, 0x1.62e4p-1f, 0x1.7f7d1cp-20f, 0 },
   .shift = V4 (0x1.8p23f),
   .exponent_bias = V4 (0x3f800000),
 #if !WANT_SIMD_EXCEPT
@@ -80,7 +80,7 @@ float32x4_t VPCS_ATTR NOINLINE V_NAME_F1 (expm1) (float32x4_t x)
     x = v_zerofy_f32 (x, special);
 #else
   /* Handles very large values (+ve and -ve), +/-NaN, +/-Inf.  */
-  uint32x4_t special = vceqzq_u32 (vcaltq_f32 (x, d->oflow_bound));
+  uint32x4_t special = vcagtq_f32 (x, d->oflow_bound);
 #endif
 
   /* Reduce argument to smaller range:
@@ -88,10 +88,12 @@ float32x4_t VPCS_ATTR NOINLINE V_NAME_F1 (expm1) (float32x4_t x)
      and f = x - i * ln2, then f is in [-ln2/2, ln2/2].
      exp(x) - 1 = 2^i * (expm1(f) + 1) - 1
      where 2^i is exact because i is an integer.  */
-  float32x4_t j = vsubq_f32 (vfmaq_f32 (d->shift, d->invln2, x), d->shift);
+  float32x4_t invln2_and_ln2 = vld1q_f32 (d->invln2_and_ln2);
+  float32x4_t j
+      = vsubq_f32 (vfmaq_laneq_f32 (d->shift, x, invln2_and_ln2, 0), d->shift);
   int32x4_t i = vcvtq_s32_f32 (j);
-  float32x4_t f = vfmsq_f32 (x, j, d->ln2_hi);
-  f = vfmsq_f32 (f, j, d->ln2_lo);
+  float32x4_t f = vfmsq_laneq_f32 (x, j, invln2_and_ln2, 1);
+  f = vfmsq_laneq_f32 (f, j, invln2_and_ln2, 2);
 
   /* Approximate expm1(f) using polynomial.
      Taylor expansion for expm1(x) has the form:
diff --git a/sysdeps/aarch64/fpu/log10_advsimd.c b/sysdeps/aarch64/fpu/log10_advsimd.c
index 1e5ef99e89..f69ed21c39 100644
--- a/sysdeps/aarch64/fpu/log10_advsimd.c
+++ b/sysdeps/aarch64/fpu/log10_advsimd.c
@@ -18,36 +18,36 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include "v_math.h"
-#include "poly_advsimd_f64.h"
-
-#define N (1 << V_LOG10_TABLE_BITS)
 
 static const struct data
 {
-  uint64x2_t min_norm;
+  uint64x2_t off, sign_exp_mask, offset_lower_bound;
   uint32x4_t special_bound;
-  float64x2_t poly[5];
-  float64x2_t invln10, log10_2, ln2;
-  uint64x2_t sign_exp_mask;
+  double invln10, log10_2;
+  double c1, c3;
+  float64x2_t c0, c2, c4;
 } data = {
   /* Computed from log coefficients divided by log(10) then rounded to double
      precision.  */
-  .poly = { V2 (-0x1.bcb7b1526e506p-3), V2 (0x1.287a7636be1d1p-3),
-	    V2 (-0x1.bcb7b158af938p-4), V2 (0x1.63c78734e6d07p-4),
-	    V2 (-0x1.287461742fee4p-4) },
-  .ln2 = V2 (0x1.62e42fefa39efp-1),
-  .invln10 = V2 (0x1.bcb7b1526e50ep-2),
-  .log10_2 = V2 (0x1.34413509f79ffp-2),
-  .min_norm = V2 (0x0010000000000000), /* asuint64(0x1p-1022).  */
-  .special_bound = V4 (0x7fe00000),    /* asuint64(inf) - min_norm.  */
+  .c0 = V2 (-0x1.bcb7b1526e506p-3),
+  .c1 = 0x1.287a7636be1d1p-3,
+  .c2 = V2 (-0x1.bcb7b158af938p-4),
+  .c3 = 0x1.63c78734e6d07p-4,
+  .c4 = V2 (-0x1.287461742fee4p-4),
+  .invln10 = 0x1.bcb7b1526e50ep-2,
+  .log10_2 = 0x1.34413509f79ffp-2,
+  .off = V2 (0x3fe6900900000000),
   .sign_exp_mask = V2 (0xfff0000000000000),
+  /* Lower bound is 0x0010000000000000. For
+     optimised register use subnormals are detected after offset has been
+     subtracted, so lower bound - offset (which wraps around).  */
+  .offset_lower_bound = V2 (0x0010000000000000 - 0x3fe6900900000000),
+  .special_bound = V4 (0x7fe00000), /* asuint64(inf) - 0x0010000000000000.  */
 };
 
-#define Off v_u64 (0x3fe6900900000000)
+#define N (1 << V_LOG10_TABLE_BITS)
 #define IndexMask (N - 1)
 
-#define T(s, i) __v_log10_data.s[i]
-
 struct entry
 {
   float64x2_t invc;
@@ -58,8 +58,10 @@ static inline struct entry
 lookup (uint64x2_t i)
 {
   struct entry e;
-  uint64_t i0 = (i[0] >> (52 - V_LOG10_TABLE_BITS)) & IndexMask;
-  uint64_t i1 = (i[1] >> (52 - V_LOG10_TABLE_BITS)) & IndexMask;
+  uint64_t i0
+      = (vgetq_lane_u64 (i, 0) >> (52 - V_LOG10_TABLE_BITS)) & IndexMask;
+  uint64_t i1
+      = (vgetq_lane_u64 (i, 1) >> (52 - V_LOG10_TABLE_BITS)) & IndexMask;
   float64x2_t e0 = vld1q_f64 (&__v_log10_data.table[i0].invc);
   float64x2_t e1 = vld1q_f64 (&__v_log10_data.table[i1].invc);
   e.invc = vuzp1q_f64 (e0, e1);
@@ -68,10 +70,11 @@ lookup (uint64x2_t i)
 }
 
 static float64x2_t VPCS_ATTR NOINLINE
-special_case (float64x2_t x, float64x2_t y, float64x2_t hi, float64x2_t r2,
-	      uint32x2_t special)
+special_case (float64x2_t hi, uint64x2_t u_off, float64x2_t y, float64x2_t r2,
+	      uint32x2_t special, const struct data *d)
 {
-  return v_call_f64 (log10, x, vfmaq_f64 (hi, r2, y), vmovl_u32 (special));
+  float64x2_t x = vreinterpretq_f64_u64 (vaddq_u64 (u_off, d->off));
+  return v_call_f64 (log10, x, vfmaq_f64 (hi, y, r2), vmovl_u32 (special));
 }
 
 /* Fast implementation of double-precision vector log10
@@ -83,19 +86,24 @@ special_case (float64x2_t x, float64x2_t y, float64x2_t hi, float64x2_t r2,
 float64x2_t VPCS_ATTR V_NAME_D1 (log10) (float64x2_t x)
 {
   const struct data *d = ptr_barrier (&data);
-  uint64x2_t ix = vreinterpretq_u64_f64 (x);
-  uint32x2_t special = vcge_u32 (vsubhn_u64 (ix, d->min_norm),
-				 vget_low_u32 (d->special_bound));
+
+  /* To avoid having to mov x out of the way, keep u after offset has been
+     applied, and recover x by adding the offset back in the special-case
+     handler.  */
+  uint64x2_t u = vreinterpretq_u64_f64 (x);
+  uint64x2_t u_off = vsubq_u64 (u, d->off);
 
   /* x = 2^k z; where z is in range [OFF,2*OFF) and exact.
      The range is split into N subintervals.
      The ith subinterval contains z and c is near its center.  */
-  uint64x2_t tmp = vsubq_u64 (ix, Off);
-  int64x2_t k = vshrq_n_s64 (vreinterpretq_s64_u64 (tmp), 52);
-  uint64x2_t iz = vsubq_u64 (ix, vandq_u64 (tmp, d->sign_exp_mask));
+  int64x2_t k = vshrq_n_s64 (vreinterpretq_s64_u64 (u_off), 52);
+  uint64x2_t iz = vsubq_u64 (u, vandq_u64 (u_off, d->sign_exp_mask));
   float64x2_t z = vreinterpretq_f64_u64 (iz);
 
-  struct entry e = lookup (tmp);
+  struct entry e = lookup (u_off);
+
+  uint32x2_t special = vcge_u32 (vsubhn_u64 (u_off, d->offset_lower_bound),
+				 vget_low_u32 (d->special_bound));
 
   /* log10(x) = log1p(z/c-1)/log(10) + log10(c) + k*log10(2).  */
   float64x2_t r = vfmaq_f64 (v_f64 (-1.0), z, e.invc);
@@ -103,17 +111,22 @@ float64x2_t VPCS_ATTR V_NAME_D1 (log10) (float64x2_t x)
 
   /* hi = r / log(10) + log10(c) + k*log10(2).
      Constants in v_log10_data.c are computed (in extended precision) as
-     e.log10c := e.logc * ivln10.  */
-  float64x2_t w = vfmaq_f64 (e.log10c, r, d->invln10);
+     e.log10c := e.logc * invln10.  */
+  float64x2_t cte = vld1q_f64 (&d->invln10);
+  float64x2_t hi = vfmaq_laneq_f64 (e.log10c, r, cte, 0);
 
   /* y = log10(1+r) + n * log10(2).  */
-  float64x2_t hi = vfmaq_f64 (w, kd, d->log10_2);
+  hi = vfmaq_laneq_f64 (hi, kd, cte, 1);
 
   /* y = r2*(A0 + r*A1 + r2*(A2 + r*A3 + r2*A4)) + hi.  */
   float64x2_t r2 = vmulq_f64 (r, r);
-  float64x2_t y = v_pw_horner_4_f64 (r, r2, d->poly);
+  float64x2_t odd_coeffs = vld1q_f64 (&d->c1);
+  float64x2_t y = vfmaq_laneq_f64 (d->c2, r, odd_coeffs, 1);
+  float64x2_t p = vfmaq_laneq_f64 (d->c0, r, odd_coeffs, 0);
+  y = vfmaq_f64 (y, d->c4, r2);
+  y = vfmaq_f64 (p, y, r2);
 
   if (__glibc_unlikely (v_any_u32h (special)))
-    return special_case (x, y, hi, r2, special);
-  return vfmaq_f64 (hi, r2, y);
+    return special_case (hi, u_off, y, r2, special, d);
+  return vfmaq_f64 (hi, y, r2);
 }
diff --git a/sysdeps/aarch64/fpu/log10_sve.c b/sysdeps/aarch64/fpu/log10_sve.c
index ab7362128d..f1cad2759a 100644
--- a/sysdeps/aarch64/fpu/log10_sve.c
+++ b/sysdeps/aarch64/fpu/log10_sve.c
@@ -23,28 +23,49 @@
 #define Min 0x0010000000000000
 #define Max 0x7ff0000000000000
 #define Thres 0x7fe0000000000000 /* Max - Min.  */
-#define Off 0x3fe6900900000000
 #define N (1 << V_LOG10_TABLE_BITS)
 
+static const struct data
+{
+  double c0, c2;
+  double c1, c3;
+  double invln10, log10_2;
+  double c4;
+  uint64_t off;
+} data = {
+  .c0 = -0x1.bcb7b1526e506p-3,
+  .c1 = 0x1.287a7636be1d1p-3,
+  .c2 = -0x1.bcb7b158af938p-4,
+  .c3 = 0x1.63c78734e6d07p-4,
+  .c4 = -0x1.287461742fee4p-4,
+  .invln10 = 0x1.bcb7b1526e50ep-2,
+  .log10_2 = 0x1.34413509f79ffp-2,
+  .off = 0x3fe6900900000000,
+};
+
 static svfloat64_t NOINLINE
-special_case (svfloat64_t x, svfloat64_t y, svbool_t special)
+special_case (svfloat64_t hi, svuint64_t tmp, svfloat64_t y, svfloat64_t r2,
+	      svbool_t special, const struct data *d)
 {
-  return sv_call_f64 (log10, x, y, special);
+  svfloat64_t x = svreinterpret_f64 (svadd_x (svptrue_b64 (), tmp, d->off));
+  return sv_call_f64 (log10, x, svmla_x (svptrue_b64 (), hi, r2, y), special);
 }
 
-/* SVE log10 algorithm.
+/* Double-precision SVE log10 routine.
    Maximum measured error is 2.46 ulps.
    SV_NAME_D1 (log10)(0x1.131956cd4b627p+0) got 0x1.fffbdf6eaa669p-6
 					   want 0x1.fffbdf6eaa667p-6.  */
 svfloat64_t SV_NAME_D1 (log10) (svfloat64_t x, const svbool_t pg)
 {
+  const struct data *d = ptr_barrier (&data);
+
   svuint64_t ix = svreinterpret_u64 (x);
   svbool_t special = svcmpge (pg, svsub_x (pg, ix, Min), Thres);
 
   /* x = 2^k z; where z is in range [Off,2*Off) and exact.
      The range is split into N subintervals.
      The ith subinterval contains z and c is near its center.  */
-  svuint64_t tmp = svsub_x (pg, ix, Off);
+  svuint64_t tmp = svsub_x (pg, ix, d->off);
   svuint64_t i = svlsr_x (pg, tmp, 51 - V_LOG10_TABLE_BITS);
   i = svand_x (pg, i, (N - 1) << 1);
   svfloat64_t k = svcvt_f64_x (pg, svasr_x (pg, svreinterpret_s64 (tmp), 52));
@@ -62,15 +83,19 @@ svfloat64_t SV_NAME_D1 (log10) (svfloat64_t x, const svbool_t pg)
   svfloat64_t r = svmad_x (pg, invc, z, -1.0);
 
   /* hi = log(c) + k*log(2).  */
-  svfloat64_t w = svmla_x (pg, logc, r, __v_log10_data.invln10);
-  svfloat64_t hi = svmla_x (pg, w, k, __v_log10_data.log10_2);
+  svfloat64_t invln10_log10_2 = svld1rq_f64 (svptrue_b64 (), &d->invln10);
+  svfloat64_t w = svmla_lane_f64 (logc, r, invln10_log10_2, 0);
+  svfloat64_t hi = svmla_lane_f64 (w, k, invln10_log10_2, 1);
 
   /* y = r2*(A0 + r*A1 + r2*(A2 + r*A3 + r2*A4)) + hi.  */
-  svfloat64_t r2 = svmul_x (pg, r, r);
-  svfloat64_t y = sv_pw_horner_4_f64_x (pg, r, r2, __v_log10_data.poly);
+  svfloat64_t odd_coeffs = svld1rq_f64 (svptrue_b64 (), &d->c1);
+  svfloat64_t r2 = svmul_x (svptrue_b64 (), r, r);
+  svfloat64_t y = svmla_lane_f64 (sv_f64 (d->c2), r, odd_coeffs, 1);
+  svfloat64_t p = svmla_lane_f64 (sv_f64 (d->c0), r, odd_coeffs, 0);
+  y = svmla_x (pg, y, r2, d->c4);
+  y = svmla_x (pg, p, r2, y);
 
   if (__glibc_unlikely (svptest_any (pg, special)))
-    return special_case (x, svmla_x (svnot_z (pg, special), hi, r2, y),
-			 special);
+    return special_case (hi, tmp, y, r2, special, d);
   return svmla_x (pg, hi, r2, y);
 }
diff --git a/sysdeps/aarch64/fpu/log10f_advsimd.c b/sysdeps/aarch64/fpu/log10f_advsimd.c
index 9347422a77..0d792c3df9 100644
--- a/sysdeps/aarch64/fpu/log10f_advsimd.c
+++ b/sysdeps/aarch64/fpu/log10f_advsimd.c
@@ -18,35 +18,43 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include "v_math.h"
-#include "poly_advsimd_f32.h"
 
 static const struct data
 {
-  uint32x4_t min_norm;
+  float32x4_t c0, c2, c4, c6, inv_ln10, ln2;
+  uint32x4_t off, offset_lower_bound;
   uint16x8_t special_bound;
-  float32x4_t poly[8];
-  float32x4_t inv_ln10, ln2;
-  uint32x4_t off, mantissa_mask;
+  uint32x4_t mantissa_mask;
+  float c1, c3, c5, c7;
 } data = {
   /* Use order 9 for log10(1+x), i.e. order 8 for log10(1+x)/x, with x in
       [-1/3, 1/3] (offset=2/3). Max. relative error: 0x1.068ee468p-25.  */
-  .poly = { V4 (-0x1.bcb79cp-3f), V4 (0x1.2879c8p-3f), V4 (-0x1.bcd472p-4f),
-	    V4 (0x1.6408f8p-4f), V4 (-0x1.246f8p-4f), V4 (0x1.f0e514p-5f),
-	    V4 (-0x1.0fc92cp-4f), V4 (0x1.f5f76ap-5f) },
+  .c0 = V4 (-0x1.bcb79cp-3f),
+  .c1 = 0x1.2879c8p-3f,
+  .c2 = V4 (-0x1.bcd472p-4f),
+  .c3 = 0x1.6408f8p-4f,
+  .c4 = V4 (-0x1.246f8p-4f),
+  .c5 = 0x1.f0e514p-5f,
+  .c6 = V4 (-0x1.0fc92cp-4f),
+  .c7 = 0x1.f5f76ap-5f,
   .ln2 = V4 (0x1.62e43p-1f),
   .inv_ln10 = V4 (0x1.bcb7b2p-2f),
-  .min_norm = V4 (0x00800000),
-  .special_bound = V8 (0x7f00), /* asuint32(inf) - min_norm.  */
+  /* Lower bound is the smallest positive normal float 0x00800000. For
+     optimised register use subnormals are detected after offset has been
+     subtracted, so lower bound is 0x0080000 - offset (which wraps around).  */
+  .offset_lower_bound = V4 (0x00800000 - 0x3f2aaaab),
+  .special_bound = V8 (0x7f00), /* top16(asuint32(inf) - 0x00800000).  */
   .off = V4 (0x3f2aaaab),	/* 0.666667.  */
   .mantissa_mask = V4 (0x007fffff),
 };
 
 static float32x4_t VPCS_ATTR NOINLINE
-special_case (float32x4_t x, float32x4_t y, float32x4_t p, float32x4_t r2,
-	      uint16x4_t cmp)
+special_case (float32x4_t y, uint32x4_t u_off, float32x4_t p, float32x4_t r2,
+	      uint16x4_t cmp, const struct data *d)
 {
   /* Fall back to scalar code.  */
-  return v_call_f32 (log10f, x, vfmaq_f32 (y, p, r2), vmovl_u16 (cmp));
+  return v_call_f32 (log10f, vreinterpretq_f32_u32 (vaddq_u32 (u_off, d->off)),
+		     vfmaq_f32 (y, p, r2), vmovl_u16 (cmp));
 }
 
 /* Fast implementation of AdvSIMD log10f,
@@ -58,26 +66,41 @@ special_case (float32x4_t x, float32x4_t y, float32x4_t p, float32x4_t r2,
 float32x4_t VPCS_ATTR NOINLINE V_NAME_F1 (log10) (float32x4_t x)
 {
   const struct data *d = ptr_barrier (&data);
-  uint32x4_t u = vreinterpretq_u32_f32 (x);
-  uint16x4_t special = vcge_u16 (vsubhn_u32 (u, d->min_norm),
-				 vget_low_u16 (d->special_bound));
+  float32x4_t c1357 = vld1q_f32 (&d->c1);
+  /* To avoid having to mov x out of the way, keep u after offset has been
+     applied, and recover x by adding the offset back in the special-case
+     handler.  */
+  uint32x4_t u_off = vreinterpretq_u32_f32 (x);
 
   /* x = 2^n * (1+r), where 2/3 < 1+r < 4/3.  */
-  u = vsubq_u32 (u, d->off);
+  u_off = vsubq_u32 (u_off, d->off);
   float32x4_t n = vcvtq_f32_s32 (
-      vshrq_n_s32 (vreinterpretq_s32_u32 (u), 23)); /* signextend.  */
-  u = vaddq_u32 (vandq_u32 (u, d->mantissa_mask), d->off);
+      vshrq_n_s32 (vreinterpretq_s32_u32 (u_off), 23)); /* signextend.  */
+
+  uint16x4_t special = vcge_u16 (vsubhn_u32 (u_off, d->offset_lower_bound),
+				 vget_low_u16 (d->special_bound));
+
+  uint32x4_t u = vaddq_u32 (vandq_u32 (u_off, d->mantissa_mask), d->off);
   float32x4_t r = vsubq_f32 (vreinterpretq_f32_u32 (u), v_f32 (1.0f));
 
   /* y = log10(1+r) + n * log10(2).  */
   float32x4_t r2 = vmulq_f32 (r, r);
-  float32x4_t poly = v_pw_horner_7_f32 (r, r2, d->poly);
+
+  float32x4_t c01 = vfmaq_laneq_f32 (d->c0, r, c1357, 0);
+  float32x4_t c23 = vfmaq_laneq_f32 (d->c2, r, c1357, 1);
+  float32x4_t c45 = vfmaq_laneq_f32 (d->c4, r, c1357, 2);
+  float32x4_t c67 = vfmaq_laneq_f32 (d->c6, r, c1357, 3);
+
+  float32x4_t p47 = vfmaq_f32 (c45, r2, c67);
+  float32x4_t p27 = vfmaq_f32 (c23, r2, p47);
+  float32x4_t poly = vfmaq_f32 (c01, r2, p27);
+
   /* y = Log10(2) * n + poly * InvLn(10).  */
   float32x4_t y = vfmaq_f32 (r, d->ln2, n);
   y = vmulq_f32 (y, d->inv_ln10);
 
   if (__glibc_unlikely (v_any_u16h (special)))
-    return special_case (x, y, poly, r2, special);
+    return special_case (y, u_off, poly, r2, special, d);
   return vfmaq_f32 (y, poly, r2);
 }
 libmvec_hidden_def (V_NAME_F1 (log10))
diff --git a/sysdeps/aarch64/fpu/log1p_sve.c b/sysdeps/aarch64/fpu/log1p_sve.c
index 04f7e5720e..5251f3c075 100644
--- a/sysdeps/aarch64/fpu/log1p_sve.c
+++ b/sysdeps/aarch64/fpu/log1p_sve.c
@@ -22,19 +22,33 @@
 
 static const struct data
 {
-  double poly[19];
+  float64_t c0, c2, c4, c6, c8, c10, c12, c14, c16;
+  float64_t c1, c3, c5, c7, c9, c11, c13, c15, c17, c18;
   double ln2_hi, ln2_lo;
   uint64_t hfrt2_top, onemhfrt2_top, inf, mone;
 } data = {
   /* Generated using Remez in [ sqrt(2)/2 - 1, sqrt(2) - 1]. Order 20
-     polynomial, however first 2 coefficients are 0 and 1 so are not stored.  */
-  .poly = { -0x1.ffffffffffffbp-2, 0x1.55555555551a9p-2, -0x1.00000000008e3p-2,
-	    0x1.9999999a32797p-3, -0x1.555555552fecfp-3, 0x1.249248e071e5ap-3,
-	    -0x1.ffffff8bf8482p-4, 0x1.c71c8f07da57ap-4, -0x1.9999ca4ccb617p-4,
-	    0x1.7459ad2e1dfa3p-4, -0x1.554d2680a3ff2p-4, 0x1.3b4c54d487455p-4,
-	    -0x1.2548a9ffe80e6p-4, 0x1.0f389a24b2e07p-4, -0x1.eee4db15db335p-5,
-	    0x1.e95b494d4a5ddp-5, -0x1.15fdf07cb7c73p-4, 0x1.0310b70800fcfp-4,
-	    -0x1.cfa7385bdb37ep-6, },
+     polynomial, however first 2 coefficients are 0 and 1 so are not
+     stored.  */
+  .c0 = -0x1.ffffffffffffbp-2,
+  .c1 = 0x1.55555555551a9p-2,
+  .c2 = -0x1.00000000008e3p-2,
+  .c3 = 0x1.9999999a32797p-3,
+  .c4 = -0x1.555555552fecfp-3,
+  .c5 = 0x1.249248e071e5ap-3,
+  .c6 = -0x1.ffffff8bf8482p-4,
+  .c7 = 0x1.c71c8f07da57ap-4,
+  .c8 = -0x1.9999ca4ccb617p-4,
+  .c9 = 0x1.7459ad2e1dfa3p-4,
+  .c10 = -0x1.554d2680a3ff2p-4,
+  .c11 = 0x1.3b4c54d487455p-4,
+  .c12 = -0x1.2548a9ffe80e6p-4,
+  .c13 = 0x1.0f389a24b2e07p-4,
+  .c14 = -0x1.eee4db15db335p-5,
+  .c15 = 0x1.e95b494d4a5ddp-5,
+  .c16 = -0x1.15fdf07cb7c73p-4,
+  .c17 = 0x1.0310b70800fcfp-4,
+  .c18 = -0x1.cfa7385bdb37ep-6,
   .ln2_hi = 0x1.62e42fefa3800p-1,
   .ln2_lo = 0x1.ef35793c76730p-45,
   /* top32(asuint64(sqrt(2)/2)) << 32.  */
@@ -49,7 +63,7 @@ static const struct data
 #define BottomMask 0xffffffff
 
 static svfloat64_t NOINLINE
-special_case (svbool_t special, svfloat64_t x, svfloat64_t y)
+special_case (svfloat64_t x, svfloat64_t y, svbool_t special)
 {
   return sv_call_f64 (log1p, x, y, special);
 }
@@ -91,8 +105,9 @@ svfloat64_t SV_NAME_D1 (log1p) (svfloat64_t x, svbool_t pg)
   /* Reduce x to f in [sqrt(2)/2, sqrt(2)].  */
   svuint64_t utop
       = svadd_x (pg, svand_x (pg, u, 0x000fffff00000000), d->hfrt2_top);
-  svuint64_t u_red = svorr_x (pg, utop, svand_x (pg, mi, BottomMask));
-  svfloat64_t f = svsub_x (pg, svreinterpret_f64 (u_red), 1);
+  svuint64_t u_red
+      = svorr_x (pg, utop, svand_x (svptrue_b64 (), mi, BottomMask));
+  svfloat64_t f = svsub_x (svptrue_b64 (), svreinterpret_f64 (u_red), 1);
 
   /* Correction term c/m.  */
   svfloat64_t cm = svdiv_x (pg, svsub_x (pg, x, svsub_x (pg, m, 1)), m);
@@ -103,16 +118,47 @@ svfloat64_t SV_NAME_D1 (log1p) (svfloat64_t x, svbool_t pg)
      Hence approximation has the form f + f^2 * P(f)
      where P(x) = C0 + C1*x + C2x^2 + ...
      Assembling this all correctly is dealt with at the final step.  */
-  svfloat64_t f2 = svmul_x (pg, f, f), f4 = svmul_x (pg, f2, f2),
-	      f8 = svmul_x (pg, f4, f4), f16 = svmul_x (pg, f8, f8);
-  svfloat64_t p = sv_estrin_18_f64_x (pg, f, f2, f4, f8, f16, d->poly);
+  svfloat64_t f2 = svmul_x (svptrue_b64 (), f, f),
+	      f4 = svmul_x (svptrue_b64 (), f2, f2),
+	      f8 = svmul_x (svptrue_b64 (), f4, f4),
+	      f16 = svmul_x (svptrue_b64 (), f8, f8);
+
+  svfloat64_t c13 = svld1rq (svptrue_b64 (), &d->c1);
+  svfloat64_t c57 = svld1rq (svptrue_b64 (), &d->c5);
+  svfloat64_t c911 = svld1rq (svptrue_b64 (), &d->c9);
+  svfloat64_t c1315 = svld1rq (svptrue_b64 (), &d->c13);
+  svfloat64_t c1718 = svld1rq (svptrue_b64 (), &d->c17);
+
+  /* Order-18 Estrin scheme.  */
+  svfloat64_t p01 = svmla_lane (sv_f64 (d->c0), f, c13, 0);
+  svfloat64_t p23 = svmla_lane (sv_f64 (d->c2), f, c13, 1);
+  svfloat64_t p45 = svmla_lane (sv_f64 (d->c4), f, c57, 0);
+  svfloat64_t p67 = svmla_lane (sv_f64 (d->c6), f, c57, 1);
+
+  svfloat64_t p03 = svmla_x (pg, p01, f2, p23);
+  svfloat64_t p47 = svmla_x (pg, p45, f2, p67);
+  svfloat64_t p07 = svmla_x (pg, p03, f4, p47);
+
+  svfloat64_t p89 = svmla_lane (sv_f64 (d->c8), f, c911, 0);
+  svfloat64_t p1011 = svmla_lane (sv_f64 (d->c10), f, c911, 1);
+  svfloat64_t p1213 = svmla_lane (sv_f64 (d->c12), f, c1315, 0);
+  svfloat64_t p1415 = svmla_lane (sv_f64 (d->c14), f, c1315, 1);
+
+  svfloat64_t p811 = svmla_x (pg, p89, f2, p1011);
+  svfloat64_t p1215 = svmla_x (pg, p1213, f2, p1415);
+  svfloat64_t p815 = svmla_x (pg, p811, f4, p1215);
+
+  svfloat64_t p015 = svmla_x (pg, p07, f8, p815);
+  svfloat64_t p1617 = svmla_lane (sv_f64 (d->c16), f, c1718, 0);
+  svfloat64_t p1618 = svmla_lane (p1617, f2, c1718, 1);
+  svfloat64_t p = svmla_x (pg, p015, f16, p1618);
 
   svfloat64_t ylo = svmla_x (pg, cm, k, d->ln2_lo);
   svfloat64_t yhi = svmla_x (pg, f, k, d->ln2_hi);
-  svfloat64_t y = svmla_x (pg, svadd_x (pg, ylo, yhi), f2, p);
 
   if (__glibc_unlikely (svptest_any (pg, special)))
-    return special_case (special, x, y);
-
-  return y;
+    return special_case (
+	x, svmla_x (svptrue_b64 (), svadd_x (svptrue_b64 (), ylo, yhi), f2, p),
+	special);
+  return svmla_x (svptrue_b64 (), svadd_x (svptrue_b64 (), ylo, yhi), f2, p);
 }
diff --git a/sysdeps/aarch64/fpu/log2_advsimd.c b/sysdeps/aarch64/fpu/log2_advsimd.c
index a34978f6cf..1eea1f86eb 100644
--- a/sysdeps/aarch64/fpu/log2_advsimd.c
+++ b/sysdeps/aarch64/fpu/log2_advsimd.c
@@ -18,31 +18,33 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include "v_math.h"
-#include "poly_advsimd_f64.h"
-
-#define N (1 << V_LOG2_TABLE_BITS)
 
 static const struct data
 {
-  uint64x2_t min_norm;
+  uint64x2_t off, sign_exp_mask, offset_lower_bound;
   uint32x4_t special_bound;
-  float64x2_t poly[5];
-  float64x2_t invln2;
-  uint64x2_t sign_exp_mask;
+  float64x2_t c0, c2;
+  double c1, c3, invln2, c4;
 } data = {
   /* Each coefficient was generated to approximate log(r) for |r| < 0x1.fp-9
      and N = 128, then scaled by log2(e) in extended precision and rounded back
      to double precision.  */
-  .poly = { V2 (-0x1.71547652b83p-1), V2 (0x1.ec709dc340953p-2),
-	    V2 (-0x1.71547651c8f35p-2), V2 (0x1.2777ebe12dda5p-2),
-	    V2 (-0x1.ec738d616fe26p-3) },
-  .invln2 = V2 (0x1.71547652b82fep0),
-  .min_norm = V2 (0x0010000000000000), /* asuint64(0x1p-1022).  */
-  .special_bound = V4 (0x7fe00000),    /* asuint64(inf) - min_norm.  */
+  .c0 = V2 (-0x1.71547652b8300p-1),
+  .c1 = 0x1.ec709dc340953p-2,
+  .c2 = V2 (-0x1.71547651c8f35p-2),
+  .c3 = 0x1.2777ebe12dda5p-2,
+  .c4 = -0x1.ec738d616fe26p-3,
+  .invln2 = 0x1.71547652b82fep0,
+  .off = V2 (0x3fe6900900000000),
   .sign_exp_mask = V2 (0xfff0000000000000),
+  /* Lower bound is 0x0010000000000000. For
+     optimised register use subnormals are detected after offset has been
+     subtracted, so lower bound - offset (which wraps around).  */
+  .offset_lower_bound = V2 (0x0010000000000000 - 0x3fe6900900000000),
+  .special_bound = V4 (0x7fe00000), /* asuint64(inf) - asuint64(0x1p-1022).  */
 };
 
-#define Off v_u64 (0x3fe6900900000000)
+#define N (1 << V_LOG2_TABLE_BITS)
 #define IndexMask (N - 1)
 
 struct entry
@@ -55,8 +57,10 @@ static inline struct entry
 lookup (uint64x2_t i)
 {
   struct entry e;
-  uint64_t i0 = (i[0] >> (52 - V_LOG2_TABLE_BITS)) & IndexMask;
-  uint64_t i1 = (i[1] >> (52 - V_LOG2_TABLE_BITS)) & IndexMask;
+  uint64_t i0
+      = (vgetq_lane_u64 (i, 0) >> (52 - V_LOG2_TABLE_BITS)) & IndexMask;
+  uint64_t i1
+      = (vgetq_lane_u64 (i, 1) >> (52 - V_LOG2_TABLE_BITS)) & IndexMask;
   float64x2_t e0 = vld1q_f64 (&__v_log2_data.table[i0].invc);
   float64x2_t e1 = vld1q_f64 (&__v_log2_data.table[i1].invc);
   e.invc = vuzp1q_f64 (e0, e1);
@@ -65,10 +69,11 @@ lookup (uint64x2_t i)
 }
 
 static float64x2_t VPCS_ATTR NOINLINE
-special_case (float64x2_t x, float64x2_t y, float64x2_t w, float64x2_t r2,
-	      uint32x2_t special)
+special_case (float64x2_t hi, uint64x2_t u_off, float64x2_t y, float64x2_t r2,
+	      uint32x2_t special, const struct data *d)
 {
-  return v_call_f64 (log2, x, vfmaq_f64 (w, r2, y), vmovl_u32 (special));
+  float64x2_t x = vreinterpretq_f64_u64 (vaddq_u64 (u_off, d->off));
+  return v_call_f64 (log2, x, vfmaq_f64 (hi, y, r2), vmovl_u32 (special));
 }
 
 /* Double-precision vector log2 routine. Implements the same algorithm as
@@ -79,31 +84,41 @@ special_case (float64x2_t x, float64x2_t y, float64x2_t w, float64x2_t r2,
 float64x2_t VPCS_ATTR V_NAME_D1 (log2) (float64x2_t x)
 {
   const struct data *d = ptr_barrier (&data);
-  uint64x2_t ix = vreinterpretq_u64_f64 (x);
-  uint32x2_t special = vcge_u32 (vsubhn_u64 (ix, d->min_norm),
-				 vget_low_u32 (d->special_bound));
+
+  /* To avoid having to mov x out of the way, keep u after offset has been
+     applied, and recover x by adding the offset back in the special-case
+     handler.  */
+  uint64x2_t u = vreinterpretq_u64_f64 (x);
+  uint64x2_t u_off = vsubq_u64 (u, d->off);
 
   /* x = 2^k z; where z is in range [Off,2*Off) and exact.
      The range is split into N subintervals.
      The ith subinterval contains z and c is near its center.  */
-  uint64x2_t tmp = vsubq_u64 (ix, Off);
-  int64x2_t k = vshrq_n_s64 (vreinterpretq_s64_u64 (tmp), 52);
-  uint64x2_t iz = vsubq_u64 (ix, vandq_u64 (tmp, d->sign_exp_mask));
+  int64x2_t k = vshrq_n_s64 (vreinterpretq_s64_u64 (u_off), 52);
+  uint64x2_t iz = vsubq_u64 (u, vandq_u64 (u_off, d->sign_exp_mask));
   float64x2_t z = vreinterpretq_f64_u64 (iz);
 
-  struct entry e = lookup (tmp);
+  struct entry e = lookup (u_off);
 
-  /* log2(x) = log1p(z/c-1)/log(2) + log2(c) + k.  */
+  uint32x2_t special = vcge_u32 (vsubhn_u64 (u_off, d->offset_lower_bound),
+				 vget_low_u32 (d->special_bound));
 
+  /* log2(x) = log1p(z/c-1)/log(2) + log2(c) + k.  */
   float64x2_t r = vfmaq_f64 (v_f64 (-1.0), z, e.invc);
   float64x2_t kd = vcvtq_f64_s64 (k);
-  float64x2_t w = vfmaq_f64 (e.log2c, r, d->invln2);
+
+  float64x2_t invln2_and_c4 = vld1q_f64 (&d->invln2);
+  float64x2_t hi
+      = vfmaq_laneq_f64 (vaddq_f64 (e.log2c, kd), r, invln2_and_c4, 0);
 
   float64x2_t r2 = vmulq_f64 (r, r);
-  float64x2_t y = v_pw_horner_4_f64 (r, r2, d->poly);
-  w = vaddq_f64 (kd, w);
+  float64x2_t odd_coeffs = vld1q_f64 (&d->c1);
+  float64x2_t y = vfmaq_laneq_f64 (d->c2, r, odd_coeffs, 1);
+  float64x2_t p = vfmaq_laneq_f64 (d->c0, r, odd_coeffs, 0);
+  y = vfmaq_laneq_f64 (y, r2, invln2_and_c4, 1);
+  y = vfmaq_f64 (p, r2, y);
 
   if (__glibc_unlikely (v_any_u32h (special)))
-    return special_case (x, y, w, r2, special);
-  return vfmaq_f64 (w, r2, y);
+    return special_case (hi, u_off, y, r2, special, d);
+  return vfmaq_f64 (hi, y, r2);
 }
diff --git a/sysdeps/aarch64/fpu/log2_sve.c b/sysdeps/aarch64/fpu/log2_sve.c
index 743fa2a913..908e638246 100644
--- a/sysdeps/aarch64/fpu/log2_sve.c
+++ b/sysdeps/aarch64/fpu/log2_sve.c
@@ -21,15 +21,32 @@
 #include "poly_sve_f64.h"
 
 #define N (1 << V_LOG2_TABLE_BITS)
-#define Off 0x3fe6900900000000
 #define Max (0x7ff0000000000000)
 #define Min (0x0010000000000000)
 #define Thresh (0x7fe0000000000000) /* Max - Min.  */
 
+static const struct data
+{
+  double c0, c2;
+  double c1, c3;
+  double invln2, c4;
+  uint64_t off;
+} data = {
+  .c0 = -0x1.71547652b83p-1,
+  .c1 = 0x1.ec709dc340953p-2,
+  .c2 = -0x1.71547651c8f35p-2,
+  .c3 = 0x1.2777ebe12dda5p-2,
+  .c4 = -0x1.ec738d616fe26p-3,
+  .invln2 = 0x1.71547652b82fep0,
+  .off = 0x3fe6900900000000,
+};
+
 static svfloat64_t NOINLINE
-special_case (svfloat64_t x, svfloat64_t y, svbool_t cmp)
+special_case (svfloat64_t w, svuint64_t tmp, svfloat64_t y, svfloat64_t r2,
+	      svbool_t special, const struct data *d)
 {
-  return sv_call_f64 (log2, x, y, cmp);
+  svfloat64_t x = svreinterpret_f64 (svadd_x (svptrue_b64 (), tmp, d->off));
+  return sv_call_f64 (log2, x, svmla_x (svptrue_b64 (), w, r2, y), special);
 }
 
 /* Double-precision SVE log2 routine.
@@ -40,13 +57,15 @@ special_case (svfloat64_t x, svfloat64_t y, svbool_t cmp)
 					  want 0x1.fffb34198d9ddp-5.  */
 svfloat64_t SV_NAME_D1 (log2) (svfloat64_t x, const svbool_t pg)
 {
+  const struct data *d = ptr_barrier (&data);
+
   svuint64_t ix = svreinterpret_u64 (x);
   svbool_t special = svcmpge (pg, svsub_x (pg, ix, Min), Thresh);
 
   /* x = 2^k z; where z is in range [Off,2*Off) and exact.
      The range is split into N subintervals.
      The ith subinterval contains z and c is near its center.  */
-  svuint64_t tmp = svsub_x (pg, ix, Off);
+  svuint64_t tmp = svsub_x (pg, ix, d->off);
   svuint64_t i = svlsr_x (pg, tmp, 51 - V_LOG2_TABLE_BITS);
   i = svand_x (pg, i, (N - 1) << 1);
   svfloat64_t k = svcvt_f64_x (pg, svasr_x (pg, svreinterpret_s64 (tmp), 52));
@@ -59,15 +78,19 @@ svfloat64_t SV_NAME_D1 (log2) (svfloat64_t x, const svbool_t pg)
 
   /* log2(x) = log1p(z/c-1)/log(2) + log2(c) + k.  */
 
+  svfloat64_t invln2_and_c4 = svld1rq_f64 (svptrue_b64 (), &d->invln2);
   svfloat64_t r = svmad_x (pg, invc, z, -1.0);
-  svfloat64_t w = svmla_x (pg, log2c, r, __v_log2_data.invln2);
-
-  svfloat64_t r2 = svmul_x (pg, r, r);
-  svfloat64_t y = sv_pw_horner_4_f64_x (pg, r, r2, __v_log2_data.poly);
+  svfloat64_t w = svmla_lane_f64 (log2c, r, invln2_and_c4, 0);
   w = svadd_x (pg, k, w);
 
+  svfloat64_t odd_coeffs = svld1rq_f64 (svptrue_b64 (), &d->c1);
+  svfloat64_t r2 = svmul_x (svptrue_b64 (), r, r);
+  svfloat64_t y = svmla_lane_f64 (sv_f64 (d->c2), r, odd_coeffs, 1);
+  svfloat64_t p = svmla_lane_f64 (sv_f64 (d->c0), r, odd_coeffs, 0);
+  y = svmla_lane_f64 (y, r2, invln2_and_c4, 1);
+  y = svmla_x (pg, p, r2, y);
+
   if (__glibc_unlikely (svptest_any (pg, special)))
-    return special_case (x, svmla_x (svnot_z (pg, special), w, r2, y),
-			 special);
+    return special_case (w, tmp, y, r2, special, d);
   return svmla_x (pg, w, r2, y);
 }
diff --git a/sysdeps/aarch64/fpu/log2f_advsimd.c b/sysdeps/aarch64/fpu/log2f_advsimd.c
index db21836749..116c36c8e2 100644
--- a/sysdeps/aarch64/fpu/log2f_advsimd.c
+++ b/sysdeps/aarch64/fpu/log2f_advsimd.c
@@ -18,34 +18,43 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include "v_math.h"
-#include "poly_advsimd_f32.h"
 
 static const struct data
 {
-  uint32x4_t min_norm;
+  float32x4_t c0, c2, c4, c6, c8;
+  uint32x4_t off, offset_lower_bound;
   uint16x8_t special_bound;
-  uint32x4_t off, mantissa_mask;
-  float32x4_t poly[9];
+  uint32x4_t mantissa_mask;
+  float c1, c3, c5, c7;
 } data = {
   /* Coefficients generated using Remez algorithm approximate
      log2(1+r)/r for r in [ -1/3, 1/3 ].
      rel error: 0x1.c4c4b0cp-26.  */
-  .poly = { V4 (0x1.715476p0f), /* (float)(1 / ln(2)).  */
-	    V4 (-0x1.715458p-1f), V4 (0x1.ec701cp-2f), V4 (-0x1.7171a4p-2f),
-	    V4 (0x1.27a0b8p-2f), V4 (-0x1.e5143ep-3f), V4 (0x1.9d8ecap-3f),
-	    V4 (-0x1.c675bp-3f), V4 (0x1.9e495p-3f) },
-  .min_norm = V4 (0x00800000),
-  .special_bound = V8 (0x7f00), /* asuint32(inf) - min_norm.  */
+  .c0 = V4 (0x1.715476p0f), /* (float)(1 / ln(2)).  */
+  .c1 = -0x1.715458p-1f,
+  .c2 = V4 (0x1.ec701cp-2f),
+  .c3 = -0x1.7171a4p-2f,
+  .c4 = V4 (0x1.27a0b8p-2f),
+  .c5 = -0x1.e5143ep-3f,
+  .c6 = V4 (0x1.9d8ecap-3f),
+  .c7 = -0x1.c675bp-3f,
+  .c8 = V4 (0x1.9e495p-3f),
+  /* Lower bound is the smallest positive normal float 0x00800000. For
+     optimised register use subnormals are detected after offset has been
+     subtracted, so lower bound is 0x0080000 - offset (which wraps around).  */
+  .offset_lower_bound = V4 (0x00800000 - 0x3f2aaaab),
+  .special_bound = V8 (0x7f00), /* top16(asuint32(inf) - 0x00800000).  */
   .off = V4 (0x3f2aaaab),	/* 0.666667.  */
   .mantissa_mask = V4 (0x007fffff),
 };
 
 static float32x4_t VPCS_ATTR NOINLINE
-special_case (float32x4_t x, float32x4_t n, float32x4_t p, float32x4_t r,
-	      uint16x4_t cmp)
+special_case (float32x4_t n, uint32x4_t u_off, float32x4_t p, float32x4_t r,
+	      uint16x4_t cmp, const struct data *d)
 {
   /* Fall back to scalar code.  */
-  return v_call_f32 (log2f, x, vfmaq_f32 (n, p, r), vmovl_u16 (cmp));
+  return v_call_f32 (log2f, vreinterpretq_f32_u32 (vaddq_u32 (u_off, d->off)),
+		     vfmaq_f32 (n, p, r), vmovl_u16 (cmp));
 }
 
 /* Fast implementation for single precision AdvSIMD log2,
@@ -56,24 +65,40 @@ special_case (float32x4_t x, float32x4_t n, float32x4_t p, float32x4_t r,
 float32x4_t VPCS_ATTR NOINLINE V_NAME_F1 (log2) (float32x4_t x)
 {
   const struct data *d = ptr_barrier (&data);
-  uint32x4_t u = vreinterpretq_u32_f32 (x);
-  uint16x4_t special = vcge_u16 (vsubhn_u32 (u, d->min_norm),
-				 vget_low_u16 (d->special_bound));
+
+  /* To avoid having to mov x out of the way, keep u after offset has been
+     applied, and recover x by adding the offset back in the special-case
+     handler.  */
+  uint32x4_t u_off = vreinterpretq_u32_f32 (x);
 
   /* x = 2^n * (1+r), where 2/3 < 1+r < 4/3.  */
-  u = vsubq_u32 (u, d->off);
+  u_off = vsubq_u32 (u_off, d->off);
   float32x4_t n = vcvtq_f32_s32 (
-      vshrq_n_s32 (vreinterpretq_s32_u32 (u), 23)); /* signextend.  */
-  u = vaddq_u32 (vandq_u32 (u, d->mantissa_mask), d->off);
+      vshrq_n_s32 (vreinterpretq_s32_u32 (u_off), 23)); /* signextend.  */
+
+  uint16x4_t special = vcge_u16 (vsubhn_u32 (u_off, d->offset_lower_bound),
+				 vget_low_u16 (d->special_bound));
+
+  uint32x4_t u = vaddq_u32 (vandq_u32 (u_off, d->mantissa_mask), d->off);
   float32x4_t r = vsubq_f32 (vreinterpretq_f32_u32 (u), v_f32 (1.0f));
 
   /* y = log2(1+r) + n.  */
   float32x4_t r2 = vmulq_f32 (r, r);
-  float32x4_t p = v_pw_horner_8_f32 (r, r2, d->poly);
+
+  float32x4_t c1357 = vld1q_f32 (&d->c1);
+  float32x4_t c01 = vfmaq_laneq_f32 (d->c0, r, c1357, 0);
+  float32x4_t c23 = vfmaq_laneq_f32 (d->c2, r, c1357, 1);
+  float32x4_t c45 = vfmaq_laneq_f32 (d->c4, r, c1357, 2);
+  float32x4_t c67 = vfmaq_laneq_f32 (d->c6, r, c1357, 3);
+  float32x4_t p68 = vfmaq_f32 (c67, r2, d->c8);
+  float32x4_t p48 = vfmaq_f32 (c45, r2, p68);
+  float32x4_t p28 = vfmaq_f32 (c23, r2, p48);
+  float32x4_t p = vfmaq_f32 (c01, r2, p28);
 
   if (__glibc_unlikely (v_any_u16h (special)))
-    return special_case (x, n, p, r, special);
+    return special_case (n, u_off, p, r, special, d);
   return vfmaq_f32 (n, p, r);
 }
+
 libmvec_hidden_def (V_NAME_F1 (log2))
 HALF_WIDTH_ALIAS_F1 (log2)
diff --git a/sysdeps/aarch64/fpu/log_advsimd.c b/sysdeps/aarch64/fpu/log_advsimd.c
index 067ae79613..b1a27fbc29 100644
--- a/sysdeps/aarch64/fpu/log_advsimd.c
+++ b/sysdeps/aarch64/fpu/log_advsimd.c
@@ -21,27 +21,29 @@
 
 static const struct data
 {
-  uint64x2_t min_norm;
+  uint64x2_t off, sign_exp_mask, offset_lower_bound;
   uint32x4_t special_bound;
-  float64x2_t poly[5];
-  float64x2_t ln2;
-  uint64x2_t sign_exp_mask;
+  float64x2_t c0, c2;
+  double c1, c3, ln2, c4;
 } data = {
-  /* Worst-case error: 1.17 + 0.5 ulp.
-     Rel error: 0x1.6272e588p-56 in [ -0x1.fc1p-9 0x1.009p-8 ].  */
-  .poly = { V2 (-0x1.ffffffffffff7p-2), V2 (0x1.55555555170d4p-2),
-	    V2 (-0x1.0000000399c27p-2), V2 (0x1.999b2e90e94cap-3),
-	    V2 (-0x1.554e550bd501ep-3) },
-  .ln2 = V2 (0x1.62e42fefa39efp-1),
-  .min_norm = V2 (0x0010000000000000),
-  .special_bound = V4 (0x7fe00000), /* asuint64(inf) - min_norm.  */
-  .sign_exp_mask = V2 (0xfff0000000000000)
+  /* Rel error: 0x1.6272e588p-56 in [ -0x1.fc1p-9 0x1.009p-8 ].  */
+  .c0 = V2 (-0x1.ffffffffffff7p-2),
+  .c1 = 0x1.55555555170d4p-2,
+  .c2 = V2 (-0x1.0000000399c27p-2),
+  .c3 = 0x1.999b2e90e94cap-3,
+  .c4 = -0x1.554e550bd501ep-3,
+  .ln2 = 0x1.62e42fefa39efp-1,
+  .sign_exp_mask = V2 (0xfff0000000000000),
+  .off = V2 (0x3fe6900900000000),
+  /* Lower bound is 0x0010000000000000. For
+     optimised register use subnormals are detected after offset has been
+     subtracted, so lower bound - offset (which wraps around).  */
+  .offset_lower_bound = V2 (0x0010000000000000 - 0x3fe6900900000000),
+  .special_bound = V4 (0x7fe00000), /* asuint64(inf) -  asuint64(0x1p-126).  */
 };
 
-#define A(i) d->poly[i]
 #define N (1 << V_LOG_TABLE_BITS)
 #define IndexMask (N - 1)
-#define Off v_u64 (0x3fe6900900000000)
 
 struct entry
 {
@@ -54,8 +56,8 @@ lookup (uint64x2_t i)
 {
   /* Since N is a power of 2, n % N = n & (N - 1).  */
   struct entry e;
-  uint64_t i0 = (i[0] >> (52 - V_LOG_TABLE_BITS)) & IndexMask;
-  uint64_t i1 = (i[1] >> (52 - V_LOG_TABLE_BITS)) & IndexMask;
+  uint64_t i0 = (vgetq_lane_u64 (i, 0) >> (52 - V_LOG_TABLE_BITS)) & IndexMask;
+  uint64_t i1 = (vgetq_lane_u64 (i, 1) >> (52 - V_LOG_TABLE_BITS)) & IndexMask;
   float64x2_t e0 = vld1q_f64 (&__v_log_data.table[i0].invc);
   float64x2_t e1 = vld1q_f64 (&__v_log_data.table[i1].invc);
   e.invc = vuzp1q_f64 (e0, e1);
@@ -64,48 +66,56 @@ lookup (uint64x2_t i)
 }
 
 static float64x2_t VPCS_ATTR NOINLINE
-special_case (float64x2_t x, float64x2_t y, float64x2_t hi, float64x2_t r2,
-	      uint32x2_t cmp)
+special_case (float64x2_t hi, uint64x2_t u_off, float64x2_t y, float64x2_t r2,
+	      uint32x2_t special, const struct data *d)
 {
-  return v_call_f64 (log, x, vfmaq_f64 (hi, y, r2), vmovl_u32 (cmp));
+  float64x2_t x = vreinterpretq_f64_u64 (vaddq_u64 (u_off, d->off));
+  return v_call_f64 (log, x, vfmaq_f64 (hi, y, r2), vmovl_u32 (special));
 }
 
+/* Double-precision vector log routine.
+   The maximum observed error is 2.17 ULP:
+   _ZGVnN2v_log(0x1.a6129884398a3p+0) got 0x1.ffffff1cca043p-2
+				     want 0x1.ffffff1cca045p-2.  */
 float64x2_t VPCS_ATTR V_NAME_D1 (log) (float64x2_t x)
 {
   const struct data *d = ptr_barrier (&data);
-  float64x2_t z, r, r2, p, y, kd, hi;
-  uint64x2_t ix, iz, tmp;
-  uint32x2_t cmp;
-  int64x2_t k;
-  struct entry e;
 
-  ix = vreinterpretq_u64_f64 (x);
-  cmp = vcge_u32 (vsubhn_u64 (ix, d->min_norm),
-		  vget_low_u32 (d->special_bound));
+  /* To avoid having to mov x out of the way, keep u after offset has been
+     applied, and recover x by adding the offset back in the special-case
+     handler.  */
+  uint64x2_t u = vreinterpretq_u64_f64 (x);
+  uint64x2_t u_off = vsubq_u64 (u, d->off);
 
   /* x = 2^k z; where z is in range [Off,2*Off) and exact.
      The range is split into N subintervals.
      The ith subinterval contains z and c is near its center.  */
-  tmp = vsubq_u64 (ix, Off);
-  k = vshrq_n_s64 (vreinterpretq_s64_u64 (tmp), 52); /* arithmetic shift.  */
-  iz = vsubq_u64 (ix, vandq_u64 (tmp, d->sign_exp_mask));
-  z = vreinterpretq_f64_u64 (iz);
-  e = lookup (tmp);
+  int64x2_t k = vshrq_n_s64 (vreinterpretq_s64_u64 (u_off), 52);
+  uint64x2_t iz = vsubq_u64 (u, vandq_u64 (u_off, d->sign_exp_mask));
+  float64x2_t z = vreinterpretq_f64_u64 (iz);
+
+  struct entry e = lookup (u_off);
+
+  uint32x2_t special = vcge_u32 (vsubhn_u64 (u_off, d->offset_lower_bound),
+				 vget_low_u32 (d->special_bound));
 
   /* log(x) = log1p(z/c-1) + log(c) + k*Ln2.  */
-  r = vfmaq_f64 (v_f64 (-1.0), z, e.invc);
-  kd = vcvtq_f64_s64 (k);
+  float64x2_t r = vfmaq_f64 (v_f64 (-1.0), z, e.invc);
+  float64x2_t kd = vcvtq_f64_s64 (k);
 
   /* hi = r + log(c) + k*Ln2.  */
-  hi = vfmaq_f64 (vaddq_f64 (e.logc, r), kd, d->ln2);
+  float64x2_t ln2_and_c4 = vld1q_f64 (&d->ln2);
+  float64x2_t hi = vfmaq_laneq_f64 (vaddq_f64 (e.logc, r), kd, ln2_and_c4, 0);
+
   /* y = r2*(A0 + r*A1 + r2*(A2 + r*A3 + r2*A4)) + hi.  */
-  r2 = vmulq_f64 (r, r);
-  y = vfmaq_f64 (A (2), A (3), r);
-  p = vfmaq_f64 (A (0), A (1), r);
-  y = vfmaq_f64 (y, A (4), r2);
-  y = vfmaq_f64 (p, y, r2);
-
-  if (__glibc_unlikely (v_any_u32h (cmp)))
-    return special_case (x, y, hi, r2, cmp);
+  float64x2_t odd_coeffs = vld1q_f64 (&d->c1);
+  float64x2_t r2 = vmulq_f64 (r, r);
+  float64x2_t y = vfmaq_laneq_f64 (d->c2, r, odd_coeffs, 1);
+  float64x2_t p = vfmaq_laneq_f64 (d->c0, r, odd_coeffs, 0);
+  y = vfmaq_laneq_f64 (y, r2, ln2_and_c4, 1);
+  y = vfmaq_f64 (p, r2, y);
+
+  if (__glibc_unlikely (v_any_u32h (special)))
+    return special_case (hi, u_off, y, r2, special, d);
   return vfmaq_f64 (hi, y, r2);
 }
diff --git a/sysdeps/aarch64/fpu/log_sve.c b/sysdeps/aarch64/fpu/log_sve.c
index 9b689f2ec7..044223400b 100644
--- a/sysdeps/aarch64/fpu/log_sve.c
+++ b/sysdeps/aarch64/fpu/log_sve.c
@@ -19,39 +19,54 @@
 
 #include "sv_math.h"
 
-#define P(i) sv_f64 (__v_log_data.poly[i])
 #define N (1 << V_LOG_TABLE_BITS)
-#define Off (0x3fe6900900000000)
-#define MaxTop (0x7ff)
-#define MinTop (0x001)
-#define ThreshTop (0x7fe) /* MaxTop - MinTop.  */
+#define Max (0x7ff0000000000000)
+#define Min (0x0010000000000000)
+#define Thresh (0x7fe0000000000000) /* Max - Min.  */
+
+static const struct data
+{
+  double c0, c2;
+  double c1, c3;
+  double ln2, c4;
+  uint64_t off;
+} data = {
+  .c0 = -0x1.ffffffffffff7p-2,
+  .c1 = 0x1.55555555170d4p-2,
+  .c2 = -0x1.0000000399c27p-2,
+  .c3 = 0x1.999b2e90e94cap-3,
+  .c4 = -0x1.554e550bd501ep-3,
+  .ln2 = 0x1.62e42fefa39efp-1,
+  .off = 0x3fe6900900000000,
+};
 
 static svfloat64_t NOINLINE
-special_case (svfloat64_t x, svfloat64_t y, svbool_t cmp)
+special_case (svfloat64_t hi, svuint64_t tmp, svfloat64_t y, svfloat64_t r2,
+	      svbool_t special, const struct data *d)
 {
-  return sv_call_f64 (log, x, y, cmp);
+  svfloat64_t x = svreinterpret_f64 (svadd_x (svptrue_b64 (), tmp, d->off));
+  return sv_call_f64 (log, x, svmla_x (svptrue_b64 (), hi, r2, y), special);
 }
 
-/* SVE port of AdvSIMD log algorithm.
-   Maximum measured error is 2.17 ulp:
-   SV_NAME_D1 (log)(0x1.a6129884398a3p+0) got 0x1.ffffff1cca043p-2
-					 want 0x1.ffffff1cca045p-2.  */
+/* Double-precision SVE log routine.
+   Maximum measured error is 2.64 ulp:
+   SV_NAME_D1 (log)(0x1.95e54bc91a5e2p+184) got 0x1.fffffffe88cacp+6
+					   want 0x1.fffffffe88cafp+6.  */
 svfloat64_t SV_NAME_D1 (log) (svfloat64_t x, const svbool_t pg)
 {
+  const struct data *d = ptr_barrier (&data);
+
   svuint64_t ix = svreinterpret_u64 (x);
-  svuint64_t top = svlsr_x (pg, ix, 52);
-  svbool_t cmp = svcmpge (pg, svsub_x (pg, top, MinTop), sv_u64 (ThreshTop));
+  svbool_t special = svcmpge (pg, svsub_x (pg, ix, Min), Thresh);
 
   /* x = 2^k z; where z is in range [Off,2*Off) and exact.
      The range is split into N subintervals.
      The ith subinterval contains z and c is near its center.  */
-  svuint64_t tmp = svsub_x (pg, ix, Off);
+  svuint64_t tmp = svsub_x (pg, ix, d->off);
   /* Calculate table index = (tmp >> (52 - V_LOG_TABLE_BITS)) % N.
      The actual value of i is double this due to table layout.  */
   svuint64_t i
       = svand_x (pg, svlsr_x (pg, tmp, (51 - V_LOG_TABLE_BITS)), (N - 1) << 1);
-  svint64_t k
-      = svasr_x (pg, svreinterpret_s64 (tmp), 52); /* Arithmetic shift.  */
   svuint64_t iz = svsub_x (pg, ix, svand_x (pg, tmp, 0xfffULL << 52));
   svfloat64_t z = svreinterpret_f64 (iz);
   /* Lookup in 2 global lists (length N).  */
@@ -59,18 +74,22 @@ svfloat64_t SV_NAME_D1 (log) (svfloat64_t x, const svbool_t pg)
   svfloat64_t logc = svld1_gather_index (pg, &__v_log_data.table[0].logc, i);
 
   /* log(x) = log1p(z/c-1) + log(c) + k*Ln2.  */
-  svfloat64_t r = svmad_x (pg, invc, z, -1);
-  svfloat64_t kd = svcvt_f64_x (pg, k);
+  svfloat64_t kd = svcvt_f64_x (pg, svasr_x (pg, svreinterpret_s64 (tmp), 52));
   /* hi = r + log(c) + k*Ln2.  */
-  svfloat64_t hi = svmla_x (pg, svadd_x (pg, logc, r), kd, __v_log_data.ln2);
+  svfloat64_t ln2_and_c4 = svld1rq_f64 (svptrue_b64 (), &d->ln2);
+  svfloat64_t r = svmad_x (pg, invc, z, -1);
+  svfloat64_t hi = svmla_lane_f64 (logc, kd, ln2_and_c4, 0);
+  hi = svadd_x (pg, r, hi);
+
   /* y = r2*(A0 + r*A1 + r2*(A2 + r*A3 + r2*A4)) + hi.  */
-  svfloat64_t r2 = svmul_x (pg, r, r);
-  svfloat64_t y = svmla_x (pg, P (2), r, P (3));
-  svfloat64_t p = svmla_x (pg, P (0), r, P (1));
-  y = svmla_x (pg, y, r2, P (4));
+  svfloat64_t odd_coeffs = svld1rq_f64 (svptrue_b64 (), &d->c1);
+  svfloat64_t r2 = svmul_x (svptrue_b64 (), r, r);
+  svfloat64_t y = svmla_lane_f64 (sv_f64 (d->c2), r, odd_coeffs, 1);
+  svfloat64_t p = svmla_lane_f64 (sv_f64 (d->c0), r, odd_coeffs, 0);
+  y = svmla_lane_f64 (y, r2, ln2_and_c4, 1);
   y = svmla_x (pg, p, r2, y);
 
-  if (__glibc_unlikely (svptest_any (pg, cmp)))
-    return special_case (x, svmla_x (svnot_z (pg, cmp), hi, r2, y), cmp);
+  if (__glibc_unlikely (svptest_any (pg, special)))
+    return special_case (hi, tmp, y, r2, special, d);
   return svmla_x (pg, hi, r2, y);
 }
diff --git a/sysdeps/aarch64/fpu/logf_advsimd.c b/sysdeps/aarch64/fpu/logf_advsimd.c
index 3c0d0fcdc7..d9e64c732d 100644
--- a/sysdeps/aarch64/fpu/logf_advsimd.c
+++ b/sysdeps/aarch64/fpu/logf_advsimd.c
@@ -21,66 +21,71 @@
 
 static const struct data
 {
-  uint32x4_t min_norm;
+  float32x4_t c2, c4, c6, ln2;
+  uint32x4_t off, offset_lower_bound, mantissa_mask;
   uint16x8_t special_bound;
-  float32x4_t poly[7];
-  float32x4_t ln2, tiny_bound;
-  uint32x4_t off, mantissa_mask;
+  float c1, c3, c5, c0;
 } data = {
   /* 3.34 ulp error.  */
-  .poly = { V4 (-0x1.3e737cp-3f), V4 (0x1.5a9aa2p-3f), V4 (-0x1.4f9934p-3f),
-	    V4 (0x1.961348p-3f), V4 (-0x1.00187cp-2f), V4 (0x1.555d7cp-2f),
-	    V4 (-0x1.ffffc8p-2f) },
+  .c0 = -0x1.3e737cp-3f,
+  .c1 = 0x1.5a9aa2p-3f,
+  .c2 = V4 (-0x1.4f9934p-3f),
+  .c3 = 0x1.961348p-3f,
+  .c4 = V4 (-0x1.00187cp-2f),
+  .c5 = 0x1.555d7cp-2f,
+  .c6 = V4 (-0x1.ffffc8p-2f),
   .ln2 = V4 (0x1.62e43p-1f),
-  .tiny_bound = V4 (0x1p-126),
-  .min_norm = V4 (0x00800000),
-  .special_bound = V8 (0x7f00), /* asuint32(inf) - min_norm.  */
+  /* Lower bound is the smallest positive normal float 0x00800000. For
+     optimised register use subnormals are detected after offset has been
+     subtracted, so lower bound is 0x0080000 - offset (which wraps around).  */
+  .offset_lower_bound = V4 (0x00800000 - 0x3f2aaaab),
+  .special_bound = V8 (0x7f00), /* top16(asuint32(inf) - 0x00800000).  */
   .off = V4 (0x3f2aaaab),	/* 0.666667.  */
   .mantissa_mask = V4 (0x007fffff)
 };
 
-#define P(i) d->poly[7 - i]
-
 static float32x4_t VPCS_ATTR NOINLINE
-special_case (float32x4_t x, float32x4_t y, float32x4_t r2, float32x4_t p,
-	      uint16x4_t cmp)
+special_case (float32x4_t p, uint32x4_t u_off, float32x4_t y, float32x4_t r2,
+	      uint16x4_t cmp, const struct data *d)
 {
   /* Fall back to scalar code.  */
-  return v_call_f32 (logf, x, vfmaq_f32 (p, y, r2), vmovl_u16 (cmp));
+  return v_call_f32 (logf, vreinterpretq_f32_u32 (vaddq_u32 (u_off, d->off)),
+		     vfmaq_f32 (p, y, r2), vmovl_u16 (cmp));
 }
 
 float32x4_t VPCS_ATTR NOINLINE V_NAME_F1 (log) (float32x4_t x)
 {
   const struct data *d = ptr_barrier (&data);
-  float32x4_t n, p, q, r, r2, y;
-  uint32x4_t u;
-  uint16x4_t cmp;
+  float32x4_t c1350 = vld1q_f32 (&d->c1);
 
-  u = vreinterpretq_u32_f32 (x);
-  cmp = vcge_u16 (vsubhn_u32 (u, d->min_norm),
-		  vget_low_u16 (d->special_bound));
+  /* To avoid having to mov x out of the way, keep u after offset has been
+     applied, and recover x by adding the offset back in the special-case
+     handler.  */
+  uint32x4_t u_off = vsubq_u32 (vreinterpretq_u32_f32 (x), d->off);
 
   /* x = 2^n * (1+r), where 2/3 < 1+r < 4/3.  */
-  u = vsubq_u32 (u, d->off);
-  n = vcvtq_f32_s32 (
-      vshrq_n_s32 (vreinterpretq_s32_u32 (u), 23)); /* signextend.  */
-  u = vandq_u32 (u, d->mantissa_mask);
-  u = vaddq_u32 (u, d->off);
-  r = vsubq_f32 (vreinterpretq_f32_u32 (u), v_f32 (1.0f));
+  float32x4_t n = vcvtq_f32_s32 (
+      vshrq_n_s32 (vreinterpretq_s32_u32 (u_off), 23)); /* signextend.  */
+  uint16x4_t cmp = vcge_u16 (vsubhn_u32 (u_off, d->offset_lower_bound),
+			     vget_low_u16 (d->special_bound));
+
+  uint32x4_t u = vaddq_u32 (vandq_u32 (u_off, d->mantissa_mask), d->off);
+  float32x4_t r = vsubq_f32 (vreinterpretq_f32_u32 (u), v_f32 (1.0f));
 
   /* y = log(1+r) + n*ln2.  */
-  r2 = vmulq_f32 (r, r);
+  float32x4_t r2 = vmulq_f32 (r, r);
   /* n*ln2 + r + r2*(P1 + r*P2 + r2*(P3 + r*P4 + r2*(P5 + r*P6 + r2*P7))).  */
-  p = vfmaq_f32 (P (5), P (6), r);
-  q = vfmaq_f32 (P (3), P (4), r);
-  y = vfmaq_f32 (P (1), P (2), r);
-  p = vfmaq_f32 (p, P (7), r2);
+  float32x4_t p = vfmaq_laneq_f32 (d->c2, r, c1350, 0);
+  float32x4_t q = vfmaq_laneq_f32 (d->c4, r, c1350, 1);
+  float32x4_t y = vfmaq_laneq_f32 (d->c6, r, c1350, 2);
+  p = vfmaq_laneq_f32 (p, r2, c1350, 3);
+
   q = vfmaq_f32 (q, p, r2);
   y = vfmaq_f32 (y, q, r2);
   p = vfmaq_f32 (r, d->ln2, n);
 
   if (__glibc_unlikely (v_any_u16h (cmp)))
-    return special_case (x, y, r2, p, cmp);
+    return special_case (p, u_off, y, r2, cmp, d);
   return vfmaq_f32 (p, y, r2);
 }
 libmvec_hidden_def (V_NAME_F1 (log))
diff --git a/sysdeps/aarch64/fpu/sin_advsimd.c b/sysdeps/aarch64/fpu/sin_advsimd.c
index efce183e86..718125cbad 100644
--- a/sysdeps/aarch64/fpu/sin_advsimd.c
+++ b/sysdeps/aarch64/fpu/sin_advsimd.c
@@ -22,7 +22,7 @@
 static const struct data
 {
   float64x2_t poly[7];
-  float64x2_t range_val, inv_pi, shift, pi_1, pi_2, pi_3;
+  float64x2_t range_val, inv_pi, pi_1, pi_2, pi_3;
 } data = {
   .poly = { V2 (-0x1.555555555547bp-3), V2 (0x1.1111111108a4dp-7),
 	    V2 (-0x1.a01a019936f27p-13), V2 (0x1.71de37a97d93ep-19),
@@ -34,12 +34,13 @@ static const struct data
   .pi_1 = V2 (0x1.921fb54442d18p+1),
   .pi_2 = V2 (0x1.1a62633145c06p-53),
   .pi_3 = V2 (0x1.c1cd129024e09p-106),
-  .shift = V2 (0x1.8p52),
 };
 
 #if WANT_SIMD_EXCEPT
-# define TinyBound v_u64 (0x3000000000000000) /* asuint64 (0x1p-255).  */
-# define Thresh v_u64 (0x1160000000000000)    /* RangeVal - TinyBound.  */
+/* asuint64(0x1p-253)), below which multiply by inv_pi underflows.  */
+# define TinyBound v_u64 (0x3020000000000000)
+/* RangeVal - TinyBound.  */
+# define Thresh v_u64 (0x1160000000000000)
 #endif
 
 #define C(i) d->poly[i]
@@ -72,17 +73,15 @@ float64x2_t VPCS_ATTR V_NAME_D1 (sin) (float64x2_t x)
      fenv). These lanes will be fixed by special-case handler later.  */
   uint64x2_t ir = vreinterpretq_u64_f64 (vabsq_f64 (x));
   cmp = vcgeq_u64 (vsubq_u64 (ir, TinyBound), Thresh);
-  r = vbslq_f64 (cmp, vreinterpretq_f64_u64 (cmp), x);
+  r = vreinterpretq_f64_u64 (vbicq_u64 (vreinterpretq_u64_f64 (x), cmp));
 #else
   r = x;
-  cmp = vcageq_f64 (d->range_val, x);
-  cmp = vceqzq_u64 (cmp); /* cmp = ~cmp.  */
+  cmp = vcageq_f64 (x, d->range_val);
 #endif
 
   /* n = rint(|x|/pi).  */
-  n = vfmaq_f64 (d->shift, d->inv_pi, r);
-  odd = vshlq_n_u64 (vreinterpretq_u64_f64 (n), 63);
-  n = vsubq_f64 (n, d->shift);
+  n = vrndaq_f64 (vmulq_f64 (r, d->inv_pi));
+  odd = vshlq_n_u64 (vreinterpretq_u64_s64 (vcvtq_s64_f64 (n)), 63);
 
   /* r = |x| - n*pi  (range reduction into -pi/2 .. pi/2).  */
   r = vfmsq_f64 (r, d->pi_1, n);
diff --git a/sysdeps/aarch64/fpu/sinf_advsimd.c b/sysdeps/aarch64/fpu/sinf_advsimd.c
index 60cf3f2ca1..6ee9a23d5b 100644
--- a/sysdeps/aarch64/fpu/sinf_advsimd.c
+++ b/sysdeps/aarch64/fpu/sinf_advsimd.c
@@ -22,7 +22,7 @@
 static const struct data
 {
   float32x4_t poly[4];
-  float32x4_t range_val, inv_pi, shift, pi_1, pi_2, pi_3;
+  float32x4_t range_val, inv_pi, pi_1, pi_2, pi_3;
 } data = {
   /* 1.886 ulp error.  */
   .poly = { V4 (-0x1.555548p-3f), V4 (0x1.110df4p-7f), V4 (-0x1.9f42eap-13f),
@@ -33,13 +33,14 @@ static const struct data
   .pi_3 = V4 (-0x1.ee59dap-49f),
 
   .inv_pi = V4 (0x1.45f306p-2f),
-  .shift = V4 (0x1.8p+23f),
   .range_val = V4 (0x1p20f)
 };
 
 #if WANT_SIMD_EXCEPT
-# define TinyBound v_u32 (0x21000000) /* asuint32(0x1p-61f).  */
-# define Thresh v_u32 (0x28800000)    /* RangeVal - TinyBound.  */
+/* asuint32(0x1p-59f), below which multiply by inv_pi underflows.  */
+# define TinyBound v_u32 (0x22000000)
+/* RangeVal - TinyBound.  */
+# define Thresh v_u32 (0x27800000)
 #endif
 
 #define C(i) d->poly[i]
@@ -64,24 +65,22 @@ float32x4_t VPCS_ATTR NOINLINE V_NAME_F1 (sin) (float32x4_t x)
   /* If fenv exceptions are to be triggered correctly, set any special lanes
      to 1 (which is neutral w.r.t. fenv). These lanes will be fixed by
      special-case handler later.  */
-  r = vbslq_f32 (cmp, vreinterpretq_f32_u32 (cmp), x);
+  r = vreinterpretq_f32_u32 (vbicq_u32 (vreinterpretq_u32_f32 (x), cmp));
 #else
   r = x;
-  cmp = vcageq_f32 (d->range_val, x);
-  cmp = vceqzq_u32 (cmp); /* cmp = ~cmp.  */
+  cmp = vcageq_f32 (x, d->range_val);
 #endif
 
-  /* n = rint(|x|/pi) */
-  n = vfmaq_f32 (d->shift, d->inv_pi, r);
-  odd = vshlq_n_u32 (vreinterpretq_u32_f32 (n), 31);
-  n = vsubq_f32 (n, d->shift);
+  /* n = rint(|x|/pi).  */
+  n = vrndaq_f32 (vmulq_f32 (r, d->inv_pi));
+  odd = vshlq_n_u32 (vreinterpretq_u32_s32 (vcvtq_s32_f32 (n)), 31);
 
-  /* r = |x| - n*pi  (range reduction into -pi/2 .. pi/2) */
+  /* r = |x| - n*pi  (range reduction into -pi/2 .. pi/2).  */
   r = vfmsq_f32 (r, d->pi_1, n);
   r = vfmsq_f32 (r, d->pi_2, n);
   r = vfmsq_f32 (r, d->pi_3, n);
 
-  /* y = sin(r) */
+  /* y = sin(r).  */
   r2 = vmulq_f32 (r, r);
   y = vfmaq_f32 (C (2), C (3), r2);
   y = vfmaq_f32 (C (1), y, r2);
diff --git a/sysdeps/aarch64/fpu/sv_math.h b/sysdeps/aarch64/fpu/sv_math.h
index 41a2013929..c2dae543a1 100644
--- a/sysdeps/aarch64/fpu/sv_math.h
+++ b/sysdeps/aarch64/fpu/sv_math.h
@@ -24,11 +24,29 @@
 
 #include "vecmath_config.h"
 
+#if !defined(__ARM_FEATURE_SVE_BITS) || __ARM_FEATURE_SVE_BITS == 0
+/* If not specified by -msve-vector-bits, assume maximum vector length.  */
+# define SVE_VECTOR_BYTES 256
+#else
+# define SVE_VECTOR_BYTES (__ARM_FEATURE_SVE_BITS / 8)
+#endif
+#define SVE_NUM_FLTS (SVE_VECTOR_BYTES / sizeof (float))
+#define SVE_NUM_DBLS (SVE_VECTOR_BYTES / sizeof (double))
+/* Predicate is stored as one bit per byte of VL so requires VL / 64 bytes.  */
+#define SVE_NUM_PG_BYTES (SVE_VECTOR_BYTES / sizeof (uint64_t))
+
 #define SV_NAME_F1(fun) _ZGVsMxv_##fun##f
 #define SV_NAME_D1(fun) _ZGVsMxv_##fun
 #define SV_NAME_F2(fun) _ZGVsMxvv_##fun##f
 #define SV_NAME_D2(fun) _ZGVsMxvv_##fun
 
+static inline void
+svstr_p (uint8_t *dst, svbool_t p)
+{
+  /* Predicate STR does not currently have an intrinsic.  */
+  __asm__("str %0, [%x1]\n" : : "Upa"(p), "r"(dst) : "memory");
+}
+
 /* Double precision.  */
 static inline svint64_t
 sv_s64 (int64_t x)
@@ -51,33 +69,35 @@ sv_f64 (double x)
 static inline svfloat64_t
 sv_call_f64 (double (*f) (double), svfloat64_t x, svfloat64_t y, svbool_t cmp)
 {
-  svbool_t p = svpfirst (cmp, svpfalse ());
-  while (svptest_any (cmp, p))
+  double tmp[SVE_NUM_DBLS];
+  uint8_t pg_bits[SVE_NUM_PG_BYTES];
+  svstr_p (pg_bits, cmp);
+  svst1 (svptrue_b64 (), tmp, svsel (cmp, x, y));
+
+  for (int i = 0; i < svcntd (); i++)
     {
-      double elem = svclastb_n_f64 (p, 0, x);
-      elem = (*f) (elem);
-      svfloat64_t y2 = svdup_n_f64 (elem);
-      y = svsel_f64 (p, y2, y);
-      p = svpnext_b64 (cmp, p);
+      if (pg_bits[i] & 1)
+	tmp[i] = f (tmp[i]);
     }
-  return y;
+  return svld1 (svptrue_b64 (), tmp);
 }
 
 static inline svfloat64_t
 sv_call2_f64 (double (*f) (double, double), svfloat64_t x1, svfloat64_t x2,
 	      svfloat64_t y, svbool_t cmp)
 {
-  svbool_t p = svpfirst (cmp, svpfalse ());
-  while (svptest_any (cmp, p))
+  double tmp1[SVE_NUM_DBLS], tmp2[SVE_NUM_DBLS];
+  uint8_t pg_bits[SVE_NUM_PG_BYTES];
+  svstr_p (pg_bits, cmp);
+  svst1 (svptrue_b64 (), tmp1, svsel (cmp, x1, y));
+  svst1 (cmp, tmp2, x2);
+
+  for (int i = 0; i < svcntd (); i++)
     {
-      double elem1 = svclastb_n_f64 (p, 0, x1);
-      double elem2 = svclastb_n_f64 (p, 0, x2);
-      double ret = (*f) (elem1, elem2);
-      svfloat64_t y2 = svdup_n_f64 (ret);
-      y = svsel_f64 (p, y2, y);
-      p = svpnext_b64 (cmp, p);
+      if (pg_bits[i] & 1)
+	tmp1[i] = f (tmp1[i], tmp2[i]);
     }
-  return y;
+  return svld1 (svptrue_b64 (), tmp1);
 }
 
 static inline svuint64_t
@@ -109,33 +129,40 @@ sv_f32 (float x)
 static inline svfloat32_t
 sv_call_f32 (float (*f) (float), svfloat32_t x, svfloat32_t y, svbool_t cmp)
 {
-  svbool_t p = svpfirst (cmp, svpfalse ());
-  while (svptest_any (cmp, p))
+  float tmp[SVE_NUM_FLTS];
+  uint8_t pg_bits[SVE_NUM_PG_BYTES];
+  svstr_p (pg_bits, cmp);
+  svst1 (svptrue_b32 (), tmp, svsel (cmp, x, y));
+
+  for (int i = 0; i < svcntd (); i++)
     {
-      float elem = svclastb_n_f32 (p, 0, x);
-      elem = f (elem);
-      svfloat32_t y2 = svdup_n_f32 (elem);
-      y = svsel_f32 (p, y2, y);
-      p = svpnext_b32 (cmp, p);
+      uint8_t p = pg_bits[i];
+      if (p & 1)
+	tmp[i * 2] = f (tmp[i * 2]);
+      if (p & (1 << 4))
+	tmp[i * 2 + 1] = f (tmp[i * 2 + 1]);
     }
-  return y;
+  return svld1 (svptrue_b32 (), tmp);
 }
 
 static inline svfloat32_t
 sv_call2_f32 (float (*f) (float, float), svfloat32_t x1, svfloat32_t x2,
 	      svfloat32_t y, svbool_t cmp)
 {
-  svbool_t p = svpfirst (cmp, svpfalse ());
-  while (svptest_any (cmp, p))
+  float tmp1[SVE_NUM_FLTS], tmp2[SVE_NUM_FLTS];
+  uint8_t pg_bits[SVE_NUM_PG_BYTES];
+  svstr_p (pg_bits, cmp);
+  svst1 (svptrue_b32 (), tmp1, svsel (cmp, x1, y));
+  svst1 (cmp, tmp2, x2);
+
+  for (int i = 0; i < svcntd (); i++)
     {
-      float elem1 = svclastb_n_f32 (p, 0, x1);
-      float elem2 = svclastb_n_f32 (p, 0, x2);
-      float ret = f (elem1, elem2);
-      svfloat32_t y2 = svdup_n_f32 (ret);
-      y = svsel_f32 (p, y2, y);
-      p = svpnext_b32 (cmp, p);
+      uint8_t p = pg_bits[i];
+      if (p & 1)
+	tmp1[i * 2] = f (tmp1[i * 2], tmp2[i * 2]);
+      if (p & (1 << 4))
+	tmp1[i * 2 + 1] = f (tmp1[i * 2 + 1], tmp2[i * 2 + 1]);
     }
-  return y;
+  return svld1 (svptrue_b32 (), tmp1);
 }
-
 #endif
diff --git a/sysdeps/aarch64/fpu/tan_advsimd.c b/sysdeps/aarch64/fpu/tan_advsimd.c
index d7e5ba7b1a..c6a5a17126 100644
--- a/sysdeps/aarch64/fpu/tan_advsimd.c
+++ b/sysdeps/aarch64/fpu/tan_advsimd.c
@@ -23,10 +23,9 @@
 static const struct data
 {
   float64x2_t poly[9];
-  float64x2_t half_pi_hi, half_pi_lo, two_over_pi, shift;
-#if !WANT_SIMD_EXCEPT
+  double half_pi[2];
+  float64x2_t two_over_pi, shift;
   float64x2_t range_val;
-#endif
 } data = {
   /* Coefficients generated using FPMinimax.  */
   .poly = { V2 (0x1.5555555555556p-2), V2 (0x1.1111111110a63p-3),
@@ -34,45 +33,33 @@ static const struct data
 	    V2 (0x1.226e5e5ecdfa3p-7), V2 (0x1.d6c7ddbf87047p-9),
 	    V2 (0x1.7ea75d05b583ep-10), V2 (0x1.289f22964a03cp-11),
 	    V2 (0x1.4e4fd14147622p-12) },
-  .half_pi_hi = V2 (0x1.921fb54442d18p0),
-  .half_pi_lo = V2 (0x1.1a62633145c07p-54),
+  .half_pi = { 0x1.921fb54442d18p0, 0x1.1a62633145c07p-54 },
   .two_over_pi = V2 (0x1.45f306dc9c883p-1),
   .shift = V2 (0x1.8p52),
-#if !WANT_SIMD_EXCEPT
   .range_val = V2 (0x1p23),
-#endif
 };
 
 #define RangeVal 0x4160000000000000  /* asuint64(0x1p23).  */
 #define TinyBound 0x3e50000000000000 /* asuint64(2^-26).  */
-#define Thresh 0x310000000000000     /* RangeVal - TinyBound.  */
 
 /* Special cases (fall back to scalar calls).  */
 static float64x2_t VPCS_ATTR NOINLINE
-special_case (float64x2_t x)
+special_case (float64x2_t x, float64x2_t n, float64x2_t d, uint64x2_t special)
 {
-  return v_call_f64 (tan, x, x, v_u64 (-1));
+  return v_call_f64 (tan, x, vdivq_f64 (n, d), special);
 }
 
 /* Vector approximation for double-precision tan.
    Maximum measured error is 3.48 ULP:
-   __v_tan(0x1.4457047ef78d8p+20) got -0x1.f6ccd8ecf7dedp+37
-				 want -0x1.f6ccd8ecf7deap+37.   */
+   _ZGVnN2v_tan(0x1.4457047ef78d8p+20) got -0x1.f6ccd8ecf7dedp+37
+				      want -0x1.f6ccd8ecf7deap+37.  */
 float64x2_t VPCS_ATTR V_NAME_D1 (tan) (float64x2_t x)
 {
   const struct data *dat = ptr_barrier (&data);
-  /* Our argument reduction cannot calculate q with sufficient accuracy for very
-     large inputs. Fall back to scalar routine for all lanes if any are too
-     large, or Inf/NaN. If fenv exceptions are expected, also fall back for tiny
-     input to avoid underflow.  */
-#if WANT_SIMD_EXCEPT
-  uint64x2_t iax = vreinterpretq_u64_f64 (vabsq_f64 (x));
-  /* iax - tiny_bound > range_val - tiny_bound.  */
-  uint64x2_t special
-      = vcgtq_u64 (vsubq_u64 (iax, v_u64 (TinyBound)), v_u64 (Thresh));
-  if (__glibc_unlikely (v_any_u64 (special)))
-    return special_case (x);
-#endif
+  /* Our argument reduction cannot calculate q with sufficient accuracy for
+     very large inputs. Fall back to scalar routine for all lanes if any are
+     too large, or Inf/NaN. If fenv exceptions are expected, also fall back for
+     tiny input to avoid underflow.  */
 
   /* q = nearest integer to 2 * x / pi.  */
   float64x2_t q
@@ -81,9 +68,9 @@ float64x2_t VPCS_ATTR V_NAME_D1 (tan) (float64x2_t x)
 
   /* Use q to reduce x to r in [-pi/4, pi/4], by:
      r = x - q * pi/2, in extended precision.  */
-  float64x2_t r = x;
-  r = vfmsq_f64 (r, q, dat->half_pi_hi);
-  r = vfmsq_f64 (r, q, dat->half_pi_lo);
+  float64x2_t half_pi = vld1q_f64 (dat->half_pi);
+  float64x2_t r = vfmsq_laneq_f64 (x, q, half_pi, 0);
+  r = vfmsq_laneq_f64 (r, q, half_pi, 1);
   /* Further reduce r to [-pi/8, pi/8], to be reconstructed using double angle
      formula.  */
   r = vmulq_n_f64 (r, 0.5);
@@ -106,18 +93,20 @@ float64x2_t VPCS_ATTR V_NAME_D1 (tan) (float64x2_t x)
      and reciprocity around pi/2:
      tan(x) = 1 / (tan(pi/2 - x))
      to assemble result using change-of-sign and conditional selection of
-     numerator/denominator, dependent on odd/even-ness of q (hence quadrant). */
+     numerator/denominator, dependent on odd/even-ness of q (hence quadrant).
+   */
   float64x2_t n = vfmaq_f64 (v_f64 (-1), p, p);
   float64x2_t d = vaddq_f64 (p, p);
 
   uint64x2_t no_recip = vtstq_u64 (vreinterpretq_u64_s64 (qi), v_u64 (1));
 
-#if !WANT_SIMD_EXCEPT
-  uint64x2_t special = vceqzq_u64 (vcaleq_f64 (x, dat->range_val));
+  uint64x2_t special = vcageq_f64 (x, dat->range_val);
+  float64x2_t swap = vbslq_f64 (no_recip, n, vnegq_f64 (d));
+  d = vbslq_f64 (no_recip, d, n);
+  n = swap;
+
   if (__glibc_unlikely (v_any_u64 (special)))
-    return special_case (x);
-#endif
+    return special_case (x, n, d, special);
 
-  return vdivq_f64 (vbslq_f64 (no_recip, n, vnegq_f64 (d)),
-		    vbslq_f64 (no_recip, d, n));
+  return vdivq_f64 (n, d);
 }
diff --git a/sysdeps/aarch64/fpu/tan_sve.c b/sysdeps/aarch64/fpu/tan_sve.c
index b2e4447316..a7318fd417 100644
--- a/sysdeps/aarch64/fpu/tan_sve.c
+++ b/sysdeps/aarch64/fpu/tan_sve.c
@@ -22,24 +22,38 @@
 
 static const struct data
 {
-  double poly[9];
-  double half_pi_hi, half_pi_lo, inv_half_pi, range_val, shift;
+  double c2, c4, c6, c8;
+  double poly_1357[4];
+  double c0, inv_half_pi;
+  double half_pi_hi, half_pi_lo, range_val;
 } data = {
   /* Polynomial generated with FPMinimax.  */
-  .poly = { 0x1.5555555555556p-2, 0x1.1111111110a63p-3, 0x1.ba1ba1bb46414p-5,
-	    0x1.664f47e5b5445p-6, 0x1.226e5e5ecdfa3p-7, 0x1.d6c7ddbf87047p-9,
-	    0x1.7ea75d05b583ep-10, 0x1.289f22964a03cp-11,
-	    0x1.4e4fd14147622p-12, },
+  .c2 = 0x1.ba1ba1bb46414p-5,
+  .c4 = 0x1.226e5e5ecdfa3p-7,
+  .c6 = 0x1.7ea75d05b583ep-10,
+  .c8 = 0x1.4e4fd14147622p-12,
+  .poly_1357 = { 0x1.1111111110a63p-3, 0x1.664f47e5b5445p-6,
+		 0x1.d6c7ddbf87047p-9, 0x1.289f22964a03cp-11 },
+  .c0 = 0x1.5555555555556p-2,
+  .inv_half_pi = 0x1.45f306dc9c883p-1,
   .half_pi_hi = 0x1.921fb54442d18p0,
   .half_pi_lo = 0x1.1a62633145c07p-54,
-  .inv_half_pi = 0x1.45f306dc9c883p-1,
   .range_val = 0x1p23,
-  .shift = 0x1.8p52,
 };
 
 static svfloat64_t NOINLINE
-special_case (svfloat64_t x, svfloat64_t y, svbool_t special)
+special_case (svfloat64_t x, svfloat64_t p, svfloat64_t q, svbool_t pg,
+	      svbool_t special)
 {
+  svbool_t use_recip = svcmpeq (
+      pg, svand_x (pg, svreinterpret_u64 (svcvt_s64_x (pg, q)), 1), 0);
+
+  svfloat64_t n = svmad_x (pg, p, p, -1);
+  svfloat64_t d = svmul_x (svptrue_b64 (), p, 2);
+  svfloat64_t swap = n;
+  n = svneg_m (n, use_recip, d);
+  d = svsel (use_recip, swap, d);
+  svfloat64_t y = svdiv_x (svnot_z (pg, special), n, d);
   return sv_call_f64 (tan, x, y, special);
 }
 
@@ -50,15 +64,10 @@ special_case (svfloat64_t x, svfloat64_t y, svbool_t special)
 svfloat64_t SV_NAME_D1 (tan) (svfloat64_t x, svbool_t pg)
 {
   const struct data *dat = ptr_barrier (&data);
-
-  /* Invert condition to catch NaNs and Infs as well as large values.  */
-  svbool_t special = svnot_z (pg, svaclt (pg, x, dat->range_val));
-
+  svfloat64_t half_pi_c0 = svld1rq (svptrue_b64 (), &dat->c0);
   /* q = nearest integer to 2 * x / pi.  */
-  svfloat64_t shift = sv_f64 (dat->shift);
-  svfloat64_t q = svmla_x (pg, shift, x, dat->inv_half_pi);
-  q = svsub_x (pg, q, shift);
-  svint64_t qi = svcvt_s64_x (pg, q);
+  svfloat64_t q = svmul_lane (x, half_pi_c0, 1);
+  q = svrinta_x (pg, q);
 
   /* Use q to reduce x to r in [-pi/4, pi/4], by:
      r = x - q * pi/2, in extended precision.  */
@@ -68,7 +77,7 @@ svfloat64_t SV_NAME_D1 (tan) (svfloat64_t x, svbool_t pg)
   r = svmls_lane (r, q, half_pi, 1);
   /* Further reduce r to [-pi/8, pi/8], to be reconstructed using double angle
      formula.  */
-  r = svmul_x (pg, r, 0.5);
+  r = svmul_x (svptrue_b64 (), r, 0.5);
 
   /* Approximate tan(r) using order 8 polynomial.
      tan(x) is odd, so polynomial has the form:
@@ -76,29 +85,51 @@ svfloat64_t SV_NAME_D1 (tan) (svfloat64_t x, svbool_t pg)
      Hence we first approximate P(r) = C1 + C2 * r^2 + C3 * r^4 + ...
      Then compute the approximation by:
      tan(r) ~= r + r^3 * (C0 + r^2 * P(r)).  */
-  svfloat64_t r2 = svmul_x (pg, r, r);
-  svfloat64_t r4 = svmul_x (pg, r2, r2);
-  svfloat64_t r8 = svmul_x (pg, r4, r4);
+
+  svfloat64_t r2 = svmul_x (svptrue_b64 (), r, r);
+  svfloat64_t r4 = svmul_x (svptrue_b64 (), r2, r2);
+  svfloat64_t r8 = svmul_x (svptrue_b64 (), r4, r4);
   /* Use offset version coeff array by 1 to evaluate from C1 onwards.  */
-  svfloat64_t p = sv_estrin_7_f64_x (pg, r2, r4, r8, dat->poly + 1);
-  p = svmad_x (pg, p, r2, dat->poly[0]);
-  p = svmla_x (pg, r, r2, svmul_x (pg, p, r));
+  svfloat64_t C_24 = svld1rq (svptrue_b64 (), &dat->c2);
+  svfloat64_t C_68 = svld1rq (svptrue_b64 (), &dat->c6);
+
+  /* Use offset version coeff array by 1 to evaluate from C1 onwards.  */
+  svfloat64_t p01 = svmla_lane (sv_f64 (dat->poly_1357[0]), r2, C_24, 0);
+  svfloat64_t p23 = svmla_lane_f64 (sv_f64 (dat->poly_1357[1]), r2, C_24, 1);
+  svfloat64_t p03 = svmla_x (pg, p01, p23, r4);
+
+  svfloat64_t p45 = svmla_lane (sv_f64 (dat->poly_1357[2]), r2, C_68, 0);
+  svfloat64_t p67 = svmla_lane (sv_f64 (dat->poly_1357[3]), r2, C_68, 1);
+  svfloat64_t p47 = svmla_x (pg, p45, p67, r4);
+
+  svfloat64_t p = svmla_x (pg, p03, p47, r8);
+
+  svfloat64_t z = svmul_x (svptrue_b64 (), p, r);
+  z = svmul_x (svptrue_b64 (), r2, z);
+  z = svmla_lane (z, r, half_pi_c0, 0);
+  p = svmla_x (pg, r, r2, z);
 
   /* Recombination uses double-angle formula:
      tan(2x) = 2 * tan(x) / (1 - (tan(x))^2)
      and reciprocity around pi/2:
      tan(x) = 1 / (tan(pi/2 - x))
      to assemble result using change-of-sign and conditional selection of
-     numerator/denominator dependent on odd/even-ness of q (hence quadrant).  */
-  svbool_t use_recip
-      = svcmpeq (pg, svand_x (pg, svreinterpret_u64 (qi), 1), 0);
+     numerator/denominator dependent on odd/even-ness of q (quadrant).  */
+
+  /* Invert condition to catch NaNs and Infs as well as large values.  */
+  svbool_t special = svnot_z (pg, svaclt (pg, x, dat->range_val));
+
+  if (__glibc_unlikely (svptest_any (pg, special)))
+    {
+      return special_case (x, p, q, pg, special);
+    }
+  svbool_t use_recip = svcmpeq (
+      pg, svand_x (pg, svreinterpret_u64 (svcvt_s64_x (pg, q)), 1), 0);
 
   svfloat64_t n = svmad_x (pg, p, p, -1);
-  svfloat64_t d = svmul_x (pg, p, 2);
+  svfloat64_t d = svmul_x (svptrue_b64 (), p, 2);
   svfloat64_t swap = n;
   n = svneg_m (n, use_recip, d);
   d = svsel (use_recip, swap, d);
-  if (__glibc_unlikely (svptest_any (pg, special)))
-    return special_case (x, svdiv_x (svnot_z (pg, special), n, d), special);
   return svdiv_x (pg, n, d);
 }
diff --git a/sysdeps/aarch64/fpu/tanf_advsimd.c b/sysdeps/aarch64/fpu/tanf_advsimd.c
index 1f16103f8a..705586f0c0 100644
--- a/sysdeps/aarch64/fpu/tanf_advsimd.c
+++ b/sysdeps/aarch64/fpu/tanf_advsimd.c
@@ -23,7 +23,8 @@
 static const struct data
 {
   float32x4_t poly[6];
-  float32x4_t neg_half_pi_1, neg_half_pi_2, neg_half_pi_3, two_over_pi, shift;
+  float pi_consts[4];
+  float32x4_t shift;
 #if !WANT_SIMD_EXCEPT
   float32x4_t range_val;
 #endif
@@ -31,10 +32,9 @@ static const struct data
   /* Coefficients generated using FPMinimax.  */
   .poly = { V4 (0x1.55555p-2f), V4 (0x1.11166p-3f), V4 (0x1.b88a78p-5f),
 	    V4 (0x1.7b5756p-6f), V4 (0x1.4ef4cep-8f), V4 (0x1.0e1e74p-7f) },
-  .neg_half_pi_1 = V4 (-0x1.921fb6p+0f),
-  .neg_half_pi_2 = V4 (0x1.777a5cp-25f),
-  .neg_half_pi_3 = V4 (0x1.ee59dap-50f),
-  .two_over_pi = V4 (0x1.45f306p-1f),
+  /* Stores constants: (-pi/2)_high, (-pi/2)_mid, (-pi/2)_low, and 2/pi.  */
+  .pi_consts
+  = { -0x1.921fb6p+0f, 0x1.777a5cp-25f, 0x1.ee59dap-50f, 0x1.45f306p-1f },
   .shift = V4 (0x1.8p+23f),
 #if !WANT_SIMD_EXCEPT
   .range_val = V4 (0x1p15f),
@@ -58,10 +58,11 @@ eval_poly (float32x4_t z, const struct data *d)
 {
   float32x4_t z2 = vmulq_f32 (z, z);
 #if WANT_SIMD_EXCEPT
-  /* Tiny z (<= 0x1p-31) will underflow when calculating z^4. If fp exceptions
-     are to be triggered correctly, sidestep this by fixing such lanes to 0.  */
+  /* Tiny z (<= 0x1p-31) will underflow when calculating z^4.
+     If fp exceptions are to be triggered correctly,
+     sidestep this by fixing such lanes to 0.  */
   uint32x4_t will_uflow
-    = vcleq_u32 (vreinterpretq_u32_f32 (vabsq_f32 (z)), TinyBound);
+      = vcleq_u32 (vreinterpretq_u32_f32 (vabsq_f32 (z)), TinyBound);
   if (__glibc_unlikely (v_any_u32 (will_uflow)))
     z2 = vbslq_f32 (will_uflow, v_f32 (0), z2);
 #endif
@@ -94,16 +95,17 @@ float32x4_t VPCS_ATTR NOINLINE V_NAME_F1 (tan) (float32x4_t x)
 #endif
 
   /* n = rint(x/(pi/2)).  */
-  float32x4_t q = vfmaq_f32 (d->shift, d->two_over_pi, x);
+  float32x4_t pi_consts = vld1q_f32 (d->pi_consts);
+  float32x4_t q = vfmaq_laneq_f32 (d->shift, x, pi_consts, 3);
   float32x4_t n = vsubq_f32 (q, d->shift);
   /* Determine if x lives in an interval, where |tan(x)| grows to infinity.  */
   uint32x4_t pred_alt = vtstq_u32 (vreinterpretq_u32_f32 (q), v_u32 (1));
 
   /* r = x - n * (pi/2)  (range reduction into -pi./4 .. pi/4).  */
   float32x4_t r;
-  r = vfmaq_f32 (x, d->neg_half_pi_1, n);
-  r = vfmaq_f32 (r, d->neg_half_pi_2, n);
-  r = vfmaq_f32 (r, d->neg_half_pi_3, n);
+  r = vfmaq_laneq_f32 (x, n, pi_consts, 0);
+  r = vfmaq_laneq_f32 (r, n, pi_consts, 1);
+  r = vfmaq_laneq_f32 (r, n, pi_consts, 2);
 
   /* If x lives in an interval, where |tan(x)|
      - is finite, then use a polynomial approximation of the form
diff --git a/sysdeps/aarch64/fpu/tanf_sve.c b/sysdeps/aarch64/fpu/tanf_sve.c
index f342583241..e850fb4882 100644
--- a/sysdeps/aarch64/fpu/tanf_sve.c
+++ b/sysdeps/aarch64/fpu/tanf_sve.c
@@ -60,21 +60,16 @@ svfloat32_t SV_NAME_F1 (tan) (svfloat32_t x, const svbool_t pg)
 {
   const struct data *d = ptr_barrier (&data);
 
-  /* Determine whether input is too large to perform fast regression.  */
-  svbool_t cmp = svacge (pg, x, d->range_val);
-
   svfloat32_t odd_coeffs = svld1rq (svptrue_b32 (), &d->c1);
   svfloat32_t pi_vals = svld1rq (svptrue_b32 (), &d->pio2_1);
 
   /* n = rint(x/(pi/2)).  */
-  svfloat32_t q = svmla_lane (sv_f32 (d->shift), x, pi_vals, 3);
-  svfloat32_t n = svsub_x (pg, q, d->shift);
+  svfloat32_t n = svrintn_x (pg, svmul_lane (x, pi_vals, 3));
   /* n is already a signed integer, simply convert it.  */
   svint32_t in = svcvt_s32_x (pg, n);
   /* Determine if x lives in an interval, where |tan(x)| grows to infinity.  */
   svint32_t alt = svand_x (pg, in, 1);
   svbool_t pred_alt = svcmpne (pg, alt, 0);
-
   /* r = x - n * (pi/2)  (range reduction into 0 .. pi/4).  */
   svfloat32_t r;
   r = svmls_lane (x, n, pi_vals, 0);
@@ -93,7 +88,7 @@ svfloat32_t SV_NAME_F1 (tan) (svfloat32_t x, const svbool_t pg)
 
   /* Evaluate polynomial approximation of tangent on [-pi/4, pi/4],
      using Estrin on z^2.  */
-  svfloat32_t z2 = svmul_x (pg, z, z);
+  svfloat32_t z2 = svmul_x (svptrue_b32 (), r, r);
   svfloat32_t p01 = svmla_lane (sv_f32 (d->c0), z2, odd_coeffs, 0);
   svfloat32_t p23 = svmla_lane (sv_f32 (d->c2), z2, odd_coeffs, 1);
   svfloat32_t p45 = svmla_lane (sv_f32 (d->c4), z2, odd_coeffs, 2);
@@ -106,13 +101,14 @@ svfloat32_t SV_NAME_F1 (tan) (svfloat32_t x, const svbool_t pg)
 
   svfloat32_t y = svmla_x (pg, z, p, svmul_x (pg, z, z2));
 
-  /* Transform result back, if necessary.  */
-  svfloat32_t inv_y = svdivr_x (pg, y, 1.0f);
-
   /* No need to pass pg to specialcase here since cmp is a strict subset,
      guaranteed by the cmpge above.  */
+
+  /* Determine whether input is too large to perform fast regression.  */
+  svbool_t cmp = svacge (pg, x, d->range_val);
   if (__glibc_unlikely (svptest_any (pg, cmp)))
-    return special_case (x, svsel (pred_alt, inv_y, y), cmp);
+    return special_case (x, svdivr_x (pg, y, 1.0f), cmp);
 
+  svfloat32_t inv_y = svdivr_x (pg, y, 1.0f);
   return svsel (pred_alt, inv_y, y);
 }
diff --git a/sysdeps/aarch64/libm-test-ulps b/sysdeps/aarch64/libm-test-ulps
index 1d52bf9ebf..10788b790a 100644
--- a/sysdeps/aarch64/libm-test-ulps
+++ b/sysdeps/aarch64/libm-test-ulps
@@ -1316,7 +1316,7 @@ float: 2
 ldouble: 1
 
 Function: "log_sve":
-double: 1
+double: 2
 float: 3
 
 Function: "log_towardzero":
diff --git a/sysdeps/aarch64/memset.S b/sysdeps/aarch64/memset.S
index 7ef77ee8c9..71814d0b2f 100644
--- a/sysdeps/aarch64/memset.S
+++ b/sysdeps/aarch64/memset.S
@@ -1,4 +1,5 @@
-/* Copyright (C) 2012-2024 Free Software Foundation, Inc.
+/* Generic optimized memset using SIMD.
+   Copyright (C) 2012-2024 Free Software Foundation, Inc.
 
    This file is part of the GNU C Library.
 
@@ -17,7 +18,6 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include <sysdep.h>
-#include "memset-reg.h"
 
 #ifndef MEMSET
 # define MEMSET memset
@@ -25,167 +25,117 @@
 
 /* Assumptions:
  *
- * ARMv8-a, AArch64, unaligned accesses
+ * ARMv8-a, AArch64, Advanced SIMD, unaligned accesses.
  *
  */
 
-ENTRY (MEMSET)
+#define dstin	x0
+#define val	x1
+#define valw	w1
+#define count	x2
+#define dst	x3
+#define dstend	x4
+#define zva_val	x5
+#define off	x3
+#define dstend2	x5
 
+ENTRY (MEMSET)
 	PTR_ARG (0)
 	SIZE_ARG (2)
 
 	dup	v0.16B, valw
+	cmp	count, 16
+	b.lo	L(set_small)
+
 	add	dstend, dstin, count
+	cmp	count, 64
+	b.hs	L(set_128)
 
-	cmp	count, 96
-	b.hi	L(set_long)
-	cmp	count, 16
-	b.hs	L(set_medium)
-	mov	val, v0.D[0]
+	/* Set 16..63 bytes.  */
+	mov	off, 16
+	and	off, off, count, lsr 1
+	sub	dstend2, dstend, off
+	str	q0, [dstin]
+	str	q0, [dstin, off]
+	str	q0, [dstend2, -16]
+	str	q0, [dstend, -16]
+	ret
 
+	.p2align 4
 	/* Set 0..15 bytes.  */
-	tbz	count, 3, 1f
-	str	val, [dstin]
-	str	val, [dstend, -8]
-	ret
-	nop
-1:	tbz	count, 2, 2f
-	str	valw, [dstin]
-	str	valw, [dstend, -4]
+L(set_small):
+	add	dstend, dstin, count
+	cmp	count, 4
+	b.lo	2f
+	lsr	off, count, 3
+	sub	dstend2, dstend, off, lsl 2
+	str	s0, [dstin]
+	str	s0, [dstin, off, lsl 2]
+	str	s0, [dstend2, -4]
+	str	s0, [dstend, -4]
 	ret
+
+	/* Set 0..3 bytes.  */
 2:	cbz	count, 3f
+	lsr	off, count, 1
 	strb	valw, [dstin]
-	tbz	count, 1, 3f
-	strh	valw, [dstend, -2]
+	strb	valw, [dstin, off]
+	strb	valw, [dstend, -1]
 3:	ret
 
-	/* Set 17..96 bytes.  */
-L(set_medium):
-	str	q0, [dstin]
-	tbnz	count, 6, L(set96)
-	str	q0, [dstend, -16]
-	tbz	count, 5, 1f
-	str	q0, [dstin, 16]
-	str	q0, [dstend, -32]
-1:	ret
-
 	.p2align 4
-	/* Set 64..96 bytes.  Write 64 bytes from the start and
-	   32 bytes from the end.  */
-L(set96):
-	str	q0, [dstin, 16]
+L(set_128):
+	bic	dst, dstin, 15
+	cmp	count, 128
+	b.hi	L(set_long)
+	stp	q0, q0, [dstin]
 	stp	q0, q0, [dstin, 32]
+	stp	q0, q0, [dstend, -64]
 	stp	q0, q0, [dstend, -32]
 	ret
 
-	.p2align 3
-	nop
+	.p2align 4
 L(set_long):
-	and	valw, valw, 255
-	bic	dst, dstin, 15
 	str	q0, [dstin]
-	cmp	count, 256
-	ccmp	valw, 0, 0, cs
-	b.eq	L(try_zva)
-L(no_zva):
-	sub	count, dstend, dst	/* Count is 16 too large.  */
-	sub	dst, dst, 16		/* Dst is biased by -32.  */
-	sub	count, count, 64 + 16	/* Adjust count and bias for loop.  */
-1:	stp	q0, q0, [dst, 32]
-	stp	q0, q0, [dst, 64]!
-L(tail64):
-	subs	count, count, 64
-	b.hi	1b
-2:	stp	q0, q0, [dstend, -64]
-	stp	q0, q0, [dstend, -32]
-	ret
-
-L(try_zva):
+	str	q0, [dst, 16]
+	tst	valw, 255
+	b.ne	L(no_zva)
 #ifndef ZVA64_ONLY
-	.p2align 3
-	mrs	tmp1, dczid_el0
-	tbnz	tmp1w, 4, L(no_zva)
-	and	tmp1w, tmp1w, 15
-	cmp	tmp1w, 4	/* ZVA size is 64 bytes.  */
-	b.ne	 L(zva_128)
-	nop
+	mrs	zva_val, dczid_el0
+	and	zva_val, zva_val, 31
+	cmp	zva_val, 4		/* ZVA size is 64 bytes.  */
+	b.ne	L(no_zva)
 #endif
-	/* Write the first and last 64 byte aligned block using stp rather
-	   than using DC ZVA.  This is faster on some cores.
-	 */
-	.p2align 4
-L(zva_64):
-	str	q0, [dst, 16]
-	stp	q0, q0, [dst, 32]
-	bic	dst, dst, 63
-	stp	q0, q0, [dst, 64]
-	stp	q0, q0, [dst, 96]
-	sub	count, dstend, dst	/* Count is now 128 too large.	*/
-	sub	count, count, 128+64+64	/* Adjust count and bias for loop.  */
-	add	dst, dst, 128
-1:	dc	zva, dst
-	add	dst, dst, 64
-	subs	count, count, 64
-	b.hi	1b
-	stp	q0, q0, [dst, 0]
 	stp	q0, q0, [dst, 32]
+	bic	dst, dstin, 63
+	sub	count, dstend, dst	/* Count is now 64 too large.  */
+	sub	count, count, 64 + 64	/* Adjust count and bias for loop.  */
+
+	/* Write last bytes before ZVA loop.  */
 	stp	q0, q0, [dstend, -64]
 	stp	q0, q0, [dstend, -32]
+
+	.p2align 4
+L(zva64_loop):
+	add	dst, dst, 64
+	dc	zva, dst
+	subs	count, count, 64
+	b.hi	L(zva64_loop)
 	ret
 
-#ifndef ZVA64_ONLY
 	.p2align 3
-L(zva_128):
-	cmp	tmp1w, 5	/* ZVA size is 128 bytes.  */
-	b.ne	L(zva_other)
-
-	str	q0, [dst, 16]
+L(no_zva):
+	sub	count, dstend, dst	/* Count is 32 too large.  */
+	sub	count, count, 64 + 32	/* Adjust count and bias for loop.  */
+L(no_zva_loop):
 	stp	q0, q0, [dst, 32]
 	stp	q0, q0, [dst, 64]
-	stp	q0, q0, [dst, 96]
-	bic	dst, dst, 127
-	sub	count, dstend, dst	/* Count is now 128 too large.	*/
-	sub	count, count, 128+128	/* Adjust count and bias for loop.  */
-	add	dst, dst, 128
-1:	dc	zva, dst
-	add	dst, dst, 128
-	subs	count, count, 128
-	b.hi	1b
-	stp	q0, q0, [dstend, -128]
-	stp	q0, q0, [dstend, -96]
+	add	dst, dst, 64
+	subs	count, count, 64
+	b.hi	L(no_zva_loop)
 	stp	q0, q0, [dstend, -64]
 	stp	q0, q0, [dstend, -32]
 	ret
 
-L(zva_other):
-	mov	tmp2w, 4
-	lsl	zva_lenw, tmp2w, tmp1w
-	add	tmp1, zva_len, 64	/* Max alignment bytes written.	 */
-	cmp	count, tmp1
-	blo	L(no_zva)
-
-	sub	tmp2, zva_len, 1
-	add	tmp1, dst, zva_len
-	add	dst, dst, 16
-	subs	count, tmp1, dst	/* Actual alignment bytes to write.  */
-	bic	tmp1, tmp1, tmp2	/* Aligned dc zva start address.  */
-	beq	2f
-1:	stp	q0, q0, [dst], 64
-	stp	q0, q0, [dst, -32]
-	subs	count, count, 64
-	b.hi	1b
-2:	mov	dst, tmp1
-	sub	count, dstend, tmp1	/* Remaining bytes to write.  */
-	subs	count, count, zva_len
-	b.lo	4f
-3:	dc	zva, dst
-	add	dst, dst, zva_len
-	subs	count, count, zva_len
-	b.hs	3b
-4:	add	count, count, zva_len
-	sub	dst, dst, 32		/* Bias dst for tail loop.  */
-	b	L(tail64)
-#endif
-
 END (MEMSET)
 libc_hidden_builtin_def (MEMSET)
diff --git a/sysdeps/aarch64/multiarch/Makefile b/sysdeps/aarch64/multiarch/Makefile
index e4720b7468..214b6137b0 100644
--- a/sysdeps/aarch64/multiarch/Makefile
+++ b/sysdeps/aarch64/multiarch/Makefile
@@ -14,6 +14,7 @@ sysdep_routines += \
   memset_generic \
   memset_kunpeng \
   memset_mops \
+  memset_sve_zva64 \
   memset_zva64 \
   strlen_asimd \
   strlen_generic \
diff --git a/sysdeps/aarch64/multiarch/ifunc-impl-list.c b/sysdeps/aarch64/multiarch/ifunc-impl-list.c
index ecd0f87de6..f8544fe3b5 100644
--- a/sysdeps/aarch64/multiarch/ifunc-impl-list.c
+++ b/sysdeps/aarch64/multiarch/ifunc-impl-list.c
@@ -57,6 +57,7 @@ __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
 	      IFUNC_IMPL_ADD (array, i, memset, 1, __memset_kunpeng)
 #if HAVE_AARCH64_SVE_ASM
 	      IFUNC_IMPL_ADD (array, i, memset, sve && !bti && zva_size == 256, __memset_a64fx)
+	      IFUNC_IMPL_ADD (array, i, memset, sve && zva_size == 64, __memset_sve_zva64)
 #endif
 	      IFUNC_IMPL_ADD (array, i, memset, mops, __memset_mops)
 	      IFUNC_IMPL_ADD (array, i, memset, 1, __memset_generic))
diff --git a/sysdeps/aarch64/multiarch/init-arch.h b/sysdeps/aarch64/multiarch/init-arch.h
index c52860efb2..61dc40088f 100644
--- a/sysdeps/aarch64/multiarch/init-arch.h
+++ b/sysdeps/aarch64/multiarch/init-arch.h
@@ -36,5 +36,7 @@
     MTE_ENABLED ();							      \
   bool __attribute__((unused)) sve =					      \
     GLRO(dl_aarch64_cpu_features).sve;					      \
+  bool __attribute__((unused)) prefer_sve_ifuncs =			      \
+    GLRO(dl_aarch64_cpu_features).prefer_sve_ifuncs;			      \
   bool __attribute__((unused)) mops =					      \
     GLRO(dl_aarch64_cpu_features).mops;
diff --git a/sysdeps/aarch64/multiarch/memcpy.c b/sysdeps/aarch64/multiarch/memcpy.c
index d12eccfca5..ce53567dab 100644
--- a/sysdeps/aarch64/multiarch/memcpy.c
+++ b/sysdeps/aarch64/multiarch/memcpy.c
@@ -47,7 +47,7 @@ select_memcpy_ifunc (void)
     {
       if (IS_A64FX (midr))
 	return __memcpy_a64fx;
-      return __memcpy_sve;
+      return prefer_sve_ifuncs ? __memcpy_sve : __memcpy_generic;
     }
 
   if (IS_THUNDERX (midr))
diff --git a/sysdeps/aarch64/multiarch/memmove.c b/sysdeps/aarch64/multiarch/memmove.c
index 2081eeb4d4..fe95037be3 100644
--- a/sysdeps/aarch64/multiarch/memmove.c
+++ b/sysdeps/aarch64/multiarch/memmove.c
@@ -47,7 +47,7 @@ select_memmove_ifunc (void)
     {
       if (IS_A64FX (midr))
 	return __memmove_a64fx;
-      return __memmove_sve;
+      return prefer_sve_ifuncs ? __memmove_sve : __memmove_generic;
     }
 
   if (IS_THUNDERX (midr))
diff --git a/sysdeps/aarch64/multiarch/memset.c b/sysdeps/aarch64/multiarch/memset.c
index 34bce045dd..161624fe60 100644
--- a/sysdeps/aarch64/multiarch/memset.c
+++ b/sysdeps/aarch64/multiarch/memset.c
@@ -34,6 +34,7 @@ extern __typeof (__redirect_memset) __memset_kunpeng attribute_hidden;
 extern __typeof (__redirect_memset) __memset_a64fx attribute_hidden;
 extern __typeof (__redirect_memset) __memset_generic attribute_hidden;
 extern __typeof (__redirect_memset) __memset_mops attribute_hidden;
+extern __typeof (__redirect_memset) __memset_sve_zva64 attribute_hidden;
 
 static inline __typeof (__redirect_memset) *
 select_memset_ifunc (void)
@@ -47,6 +48,9 @@ select_memset_ifunc (void)
     {
       if (IS_A64FX (midr) && zva_size == 256)
 	return __memset_a64fx;
+
+      if (prefer_sve_ifuncs && zva_size == 64)
+	return __memset_sve_zva64;
     }
 
   if (IS_KUNPENG920 (midr))
diff --git a/sysdeps/aarch64/multiarch/memset_generic.S b/sysdeps/aarch64/multiarch/memset_generic.S
index 81748bdbce..e125a5ed85 100644
--- a/sysdeps/aarch64/multiarch/memset_generic.S
+++ b/sysdeps/aarch64/multiarch/memset_generic.S
@@ -33,3 +33,7 @@
 #endif
 
 #include <../memset.S>
+
+#if IS_IN (rtld)
+strong_alias (memset, __memset_generic)
+#endif
diff --git a/sysdeps/aarch64/multiarch/memset_sve_zva64.S b/sysdeps/aarch64/multiarch/memset_sve_zva64.S
new file mode 100644
index 0000000000..7fb40fdd9e
--- /dev/null
+++ b/sysdeps/aarch64/multiarch/memset_sve_zva64.S
@@ -0,0 +1,123 @@
+/* Optimized memset for SVE.
+   Copyright (C) 2025 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+/* Assumptions:
+ *
+ * ARMv8-a, AArch64, Advanced SIMD, SVE, unaligned accesses.
+ * ZVA size is 64.
+ */
+
+#if HAVE_AARCH64_SVE_ASM
+
+.arch armv8.2-a+sve
+
+#define dstin	x0
+#define val	x1
+#define valw	w1
+#define count	x2
+#define dst	x3
+#define dstend	x4
+#define zva_val	x5
+#define vlen	x5
+#define off	x3
+#define dstend2 x5
+
+ENTRY (__memset_sve_zva64)
+	dup	v0.16B, valw
+	cmp	count, 16
+	b.lo	L(set_16)
+
+	add	dstend, dstin, count
+	cmp	count, 64
+	b.hs	L(set_128)
+
+	/* Set 16..63 bytes.  */
+	mov	off, 16
+	and	off, off, count, lsr 1
+	sub	dstend2, dstend, off
+	str	q0, [dstin]
+	str	q0, [dstin, off]
+	str	q0, [dstend2, -16]
+	str	q0, [dstend, -16]
+	ret
+
+	.p2align 4
+L(set_16):
+	whilelo p0.b, xzr, count
+	st1b	z0.b, p0, [dstin]
+	ret
+
+	.p2align 4
+L(set_128):
+	bic	dst, dstin, 15
+	cmp	count, 128
+	b.hi	L(set_long)
+	stp	q0, q0, [dstin]
+	stp	q0, q0, [dstin, 32]
+	stp	q0, q0, [dstend, -64]
+	stp	q0, q0, [dstend, -32]
+	ret
+
+	.p2align 4
+L(set_long):
+	cmp	count, 256
+	b.lo	L(no_zva)
+	tst	valw, 255
+	b.ne	L(no_zva)
+
+	str	q0, [dstin]
+	str	q0, [dst, 16]
+	bic	dst, dstin, 31
+	stp	q0, q0, [dst, 32]
+	bic	dst, dstin, 63
+	sub	count, dstend, dst	/* Count is now 64 too large.  */
+	sub	count, count, 128	/* Adjust count and bias for loop.  */
+
+	sub	x8, dstend, 1		/* Write last bytes before ZVA loop.  */
+	bic	x8, x8, 15
+	stp	q0, q0, [x8, -48]
+	str	q0, [x8, -16]
+	str	q0, [dstend, -16]
+
+	.p2align 4
+L(zva64_loop):
+	add	dst, dst, 64
+	dc	zva, dst
+	subs	count, count, 64
+	b.hi	L(zva64_loop)
+	ret
+
+L(no_zva):
+	str	q0, [dstin]
+	sub	count, dstend, dst	/* Count is 16 too large.  */
+	sub	count, count, 64 + 16	/* Adjust count and bias for loop.  */
+L(no_zva_loop):
+	stp	q0, q0, [dst, 16]
+	stp	q0, q0, [dst, 48]
+	add	dst, dst, 64
+	subs	count, count, 64
+	b.hi	L(no_zva_loop)
+	stp	q0, q0, [dstend, -64]
+	stp	q0, q0, [dstend, -32]
+	ret
+
+END (__memset_sve_zva64)
+#endif
diff --git a/sysdeps/aarch64/preconfigure b/sysdeps/aarch64/preconfigure
index d9bd1f8558..e1b772c586 100644
--- a/sysdeps/aarch64/preconfigure
+++ b/sysdeps/aarch64/preconfigure
@@ -2,5 +2,7 @@ case "$machine" in
 aarch64*)
 	base_machine=aarch64
 	machine=aarch64
+	mtls_descriptor=desc
+	mtls_traditional=trad
 	;;
 esac
diff --git a/sysdeps/aarch64/setjmp.S b/sysdeps/aarch64/setjmp.S
index 43fdb1b2fb..2fa0dc768d 100644
--- a/sysdeps/aarch64/setjmp.S
+++ b/sysdeps/aarch64/setjmp.S
@@ -37,6 +37,12 @@ ENTRY (__sigsetjmp)
 	PTR_ARG (0)
 
 1:
+
+#if IS_IN(libc)
+	/* Disable ZA state of SME in libc.a and libc.so, but not in ld.so.  */
+	CALL_LIBC_ARM_ZA_DISABLE
+#endif
+
 	stp	x19, x20, [x0, #JB_X19<<3]
 	stp	x21, x22, [x0, #JB_X21<<3]
 	stp	x23, x24, [x0, #JB_X23<<3]
diff --git a/sysdeps/aarch64/strlen.S b/sysdeps/aarch64/strlen.S
index ab2a576cdb..352fb40d3a 100644
--- a/sysdeps/aarch64/strlen.S
+++ b/sysdeps/aarch64/strlen.S
@@ -1,4 +1,5 @@
-/* Copyright (C) 2012-2024 Free Software Foundation, Inc.
+/* Generic optimized strlen using SIMD.
+   Copyright (C) 2012-2024 Free Software Foundation, Inc.
 
    This file is part of the GNU C Library.
 
@@ -56,36 +57,50 @@ ENTRY (STRLEN)
 	shrn	vend.8b, vhas_nul.8h, 4		/* 128->64 */
 	fmov	synd, dend
 	lsr	synd, synd, shift
-	cbz	synd, L(loop)
+	cbz	synd, L(next16)
 
 	rbit	synd, synd
 	clz	result, synd
 	lsr	result, result, 2
 	ret
 
+L(next16):
+	ldr	data, [src, 16]
+	cmeq	vhas_nul.16b, vdata.16b, 0
+	shrn	vend.8b, vhas_nul.8h, 4		/* 128->64 */
+	fmov	synd, dend
+	cbz	synd, L(loop)
+	add	src, src, 16
+#ifndef __AARCH64EB__
+	rbit	synd, synd
+#endif
+	sub	result, src, srcin
+	clz	tmp, synd
+	add	result, result, tmp, lsr 2
+	ret
+
 	.p2align 5
 L(loop):
-	ldr	data, [src, 16]
+	ldr	data, [src, 32]!
 	cmeq	vhas_nul.16b, vdata.16b, 0
-	umaxp	vend.16b, vhas_nul.16b, vhas_nul.16b
+	addhn	vend.8b, vhas_nul.8h, vhas_nul.8h
 	fmov	synd, dend
 	cbnz	synd, L(loop_end)
-	ldr	data, [src, 32]!
+	ldr	data, [src, 16]
 	cmeq	vhas_nul.16b, vdata.16b, 0
-	umaxp	vend.16b, vhas_nul.16b, vhas_nul.16b
+	addhn	vend.8b, vhas_nul.8h, vhas_nul.8h
 	fmov	synd, dend
 	cbz	synd, L(loop)
-	sub	src, src, 16
+	add	src, src, 16
 L(loop_end):
-	shrn	vend.8b, vhas_nul.8h, 4		/* 128->64 */
-	sub	result, src, srcin
-	fmov	synd, dend
+	sub	result, shift, src, lsl 2	/* (srcin - src) << 2.  */
 #ifndef __AARCH64EB__
 	rbit	synd, synd
+	sub	result, result, 3
 #endif
-	add	result, result, 16
 	clz	tmp, synd
-	add	result, result, tmp, lsr 2
+	sub	result, tmp, result
+	lsr	result, result, 2
 	ret
 
 END (STRLEN)
diff --git a/sysdeps/aarch64/tst-sme-clone.c b/sysdeps/aarch64/tst-sme-clone.c
new file mode 100644
index 0000000000..b6ad54fa37
--- /dev/null
+++ b/sysdeps/aarch64/tst-sme-clone.c
@@ -0,0 +1,54 @@
+/* Test that ZA state of SME is cleared in both parent and child
+   when clone() syscall is used.
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "tst-sme-skeleton.c"
+
+#include <signal.h>
+#include <support/xsched.h>
+
+static int
+fun (void * const arg)
+{
+  printf ("in child: %s\n", (const char *)arg);
+  /* Check that ZA state of SME was disabled in child.  */
+  check_sme_za_state ("after clone in child", /* Clear.  */ true);
+  return 0;
+}
+
+static char __attribute__((aligned(16)))
+stack[1024 * 1024];
+
+static void
+run (struct blk *ptr)
+{
+  char *syscall_name = (char *)"clone";
+  printf ("in parent: before %s\n", syscall_name);
+
+  /* Enabled ZA state so that effect of disabling be observable.  */
+  enable_sme_za_state (ptr);
+  check_sme_za_state ("before clone", /* Clear.  */ false);
+
+  pid_t pid = xclone (fun, syscall_name, stack, sizeof (stack),
+		      CLONE_NEWUSER | CLONE_NEWNS | SIGCHLD);
+
+  /* Check that ZA state of SME was disabled in parent.  */
+  check_sme_za_state ("after clone in parent", /* Clear.  */ true);
+
+  TEST_VERIFY (xwaitpid (pid, NULL, 0) == pid);
+}
diff --git a/sysdeps/aarch64/tst-sme-clone3.c b/sysdeps/aarch64/tst-sme-clone3.c
new file mode 100644
index 0000000000..f420d5984d
--- /dev/null
+++ b/sysdeps/aarch64/tst-sme-clone3.c
@@ -0,0 +1,84 @@
+/* Test that ZA state of SME is cleared in both parent and child
+   when clone3() syscall is used.
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "tst-sme-skeleton.c"
+
+#include <clone3.h>
+
+#include <errno.h>
+#include <signal.h>
+#include <support/xsched.h>
+
+/* Since clone3 is not a public symbol, we link this test explicitly
+   with clone3.o and have to provide this declaration.  */
+int __clone3 (struct clone_args *cl_args, size_t size,
+	    int (*func)(void *arg), void *arg);
+
+static int
+fun (void * const arg)
+{
+  printf ("in child: %s\n", (const char *)arg);
+  /* Check that ZA state of SME was disabled in child.  */
+  check_sme_za_state ("after clone3 in child", /* Clear.  */ true);
+  return 0;
+}
+
+static char __attribute__((aligned(16)))
+stack[1024 * 1024];
+
+/* Required by __arm_za_disable.o and provided by the startup code
+   as a hidden symbol.  */
+uint64_t _dl_hwcap2;
+
+static void
+run (struct blk *ptr)
+{
+  _dl_hwcap2 = getauxval (AT_HWCAP2);
+
+  char *syscall_name = (char *)"clone3";
+  struct clone_args args = {
+    .flags = CLONE_VM | CLONE_VFORK,
+    .exit_signal = SIGCHLD,
+    .stack = (uintptr_t) stack,
+    .stack_size = sizeof (stack),
+  };
+  printf ("in parent: before %s\n", syscall_name);
+
+  /* Enabled ZA state so that effect of disabling be observable.  */
+  enable_sme_za_state (ptr);
+  check_sme_za_state ("before clone3", /* Clear.  */ false);
+
+  pid_t pid = __clone3 (&args, sizeof (args), fun, syscall_name);
+
+  /* Check that ZA state of SME was disabled in parent.  */
+  check_sme_za_state ("after clone3 in parent", /* Clear.  */ true);
+
+  printf ("%s child pid: %d\n", syscall_name, pid);
+
+  xwaitpid (pid, NULL, 0);
+  printf ("in parent: after %s\n", syscall_name);
+}
+
+/* Workaround to simplify linking with clone3.o.  */
+void __syscall_error(int code)
+{
+  int err = -code;
+  fprintf (stderr, "syscall error %d (%s)\n", err, strerror (err));
+  exit (err);
+}
diff --git a/sysdeps/aarch64/tst-sme-fork.c b/sysdeps/aarch64/tst-sme-fork.c
new file mode 100644
index 0000000000..b003b08884
--- /dev/null
+++ b/sysdeps/aarch64/tst-sme-fork.c
@@ -0,0 +1,43 @@
+/* Test that ZA state of SME is cleared in both parent and child
+   when fork() function is used.
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "tst-sme-skeleton.c"
+
+static void
+run (struct blk *blk)
+{
+  /* Enabled ZA state so that effect of disabling be observable.  */
+  enable_sme_za_state (blk);
+  check_sme_za_state ("before fork", /* Clear.  */ false);
+  fflush (stdout);
+
+  pid_t pid = xfork ();
+
+  if (pid == 0)
+    {
+      /* Check that ZA state of SME was disabled in child.  */
+      check_sme_za_state ("after fork in child", /* Clear.  */ true);
+      exit (0);
+    }
+
+  /* Check that ZA state of SME was disabled in parent.  */
+  check_sme_za_state ("after fork in parent", /* Clear.  */ true);
+
+  TEST_VERIFY (xwaitpid (pid, NULL, 0) == pid);
+}
diff --git a/sysdeps/aarch64/tst-sme-helper.h b/sysdeps/aarch64/tst-sme-helper.h
new file mode 100644
index 0000000000..ab9c503e45
--- /dev/null
+++ b/sysdeps/aarch64/tst-sme-helper.h
@@ -0,0 +1,94 @@
+/* Utility functions for SME tests.
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+struct blk {
+  void *za_save_buffer;
+  uint16_t num_za_save_slices;
+  char __reserved[6];
+};
+
+/* Read SVCR to get SM (bit0) and ZA (bit1) state.  */
+static unsigned long
+get_svcr (void)
+{
+  register unsigned long x0 asm ("x0");
+  asm volatile (
+    ".inst   0xd53b4240  /* mrs     x0, svcr  */\n"
+    : "=r" (x0));
+  return x0;
+}
+
+/* Returns tpidr2.  */
+static void *
+get_tpidr2 (void)
+{
+  register unsigned long x0 asm ("x0");
+  asm volatile (
+    ".inst   0xd53bd0a0  /* mrs     x0, tpidr2_el0  */\n"
+    : "=r"(x0) :: "memory");
+  return (void *) x0;
+}
+
+/* Obtains current streaming SVE vector register size.  */
+static unsigned long
+get_svl (void)
+{
+  register unsigned long x0 asm ("x0");
+  asm volatile (
+    ".inst   0x04bf5820  /* rdsvl   x0, 1  */\n"
+    : "=r" (x0));
+  return x0;
+}
+
+/* PSTATE.ZA = 1, set ZA state to active.  */
+static void
+start_za (void)
+{
+  asm volatile (
+    ".inst   0xd503457f  /* smstart za  */");
+}
+
+/* Load data into ZA byte by byte from p.  */
+static void __attribute__ ((noinline))
+load_za (const void *buf, unsigned long svl)
+{
+  register unsigned long x15 asm ("x15") = 0;
+  register unsigned long x16 asm ("x16") = (unsigned long)buf;
+  register unsigned long x17 asm ("x17") = svl;
+
+  asm volatile (
+    ".inst   0xd503437f  /* smstart sm  */\n"
+    ".L_ldr_loop:\n"
+    ".inst   0xe1006200  /* ldr     za[w15, 0], [x16]  */\n"
+    "add     w15, w15, 1\n"
+    ".inst   0x04305030  /* addvl   x16, x16, 1  */\n"
+    "cmp     w15, w17\n"
+    "bne     .L_ldr_loop\n"
+    ".inst   0xd503427f  /* smstop  sm  */\n"
+    : "+r"(x15), "+r"(x16), "+r"(x17));
+}
+
+/* Set tpidr2 to BLK.  */
+static void
+set_tpidr2 (struct blk *blk)
+{
+  register unsigned long x0 asm ("x0") = (unsigned long)blk;
+  asm volatile (
+    ".inst   0xd51bd0a0  /* msr     tpidr2_el0, x0  */\n"
+    :: "r"(x0) : "memory");
+}
diff --git a/sysdeps/aarch64/tst-sme-jmp.c b/sysdeps/aarch64/tst-sme-jmp.c
index 35769340e7..0c1d1a4ff8 100644
--- a/sysdeps/aarch64/tst-sme-jmp.c
+++ b/sysdeps/aarch64/tst-sme-jmp.c
@@ -27,87 +27,15 @@
 #include <support/support.h>
 #include <support/test-driver.h>
 
-struct blk {
-  void *za_save_buffer;
-  uint16_t num_za_save_slices;
-  char __reserved[6];
-};
+#include "tst-sme-helper.h"
 
+/* Streaming SVE vector register size.  */
 static unsigned long svl;
+
 static uint8_t *za_orig;
 static uint8_t *za_dump;
 static uint8_t *za_save;
 
-static unsigned long
-get_svl (void)
-{
-  register unsigned long x0 asm ("x0");
-  asm volatile (
-    ".inst   0x04bf5820  /* rdsvl   x0, 1  */\n"
-    : "=r" (x0));
-  return x0;
-}
-
-/* PSTATE.ZA = 1, set ZA state to active.  */
-static void
-start_za (void)
-{
-  asm volatile (
-    ".inst   0xd503457f  /* smstart za  */");
-}
-
-/* Read SVCR to get SM (bit0) and ZA (bit1) state.  */
-static unsigned long
-get_svcr (void)
-{
-  register unsigned long x0 asm ("x0");
-  asm volatile (
-    ".inst   0xd53b4240  /* mrs     x0, svcr  */\n"
-    : "=r" (x0));
-  return x0;
-}
-
-/* Load data into ZA byte by byte from p.  */
-static void __attribute__ ((noinline))
-load_za (const void *p)
-{
-  register unsigned long x15 asm ("x15") = 0;
-  register unsigned long x16 asm ("x16") = (unsigned long)p;
-  register unsigned long x17 asm ("x17") = svl;
-
-  asm volatile (
-    ".inst   0xd503437f  /* smstart sm  */\n"
-    ".L_ldr_loop:\n"
-    ".inst   0xe1006200  /* ldr     za[w15, 0], [x16]  */\n"
-    "add     w15, w15, 1\n"
-    ".inst   0x04305030  /* addvl   x16, x16, 1  */\n"
-    "cmp     w15, w17\n"
-    "bne     .L_ldr_loop\n"
-    ".inst   0xd503427f  /* smstop  sm  */\n"
-    : "+r"(x15), "+r"(x16), "+r"(x17));
-}
-
-/* Set tpidr2 to BLK.  */
-static void
-set_tpidr2 (struct blk *blk)
-{
-  register unsigned long x0 asm ("x0") = (unsigned long)blk;
-  asm volatile (
-    ".inst   0xd51bd0a0  /* msr     tpidr2_el0, x0  */\n"
-    :: "r"(x0) : "memory");
-}
-
-/* Returns tpidr2.  */
-static void *
-get_tpidr2 (void)
-{
-  register unsigned long x0 asm ("x0");
-  asm volatile (
-    ".inst   0xd53bd0a0  /* mrs     x0, tpidr2_el0  */\n"
-    : "=r"(x0) :: "memory");
-  return (void *) x0;
-}
-
 static void
 print_data(const char *msg, void *p)
 {
@@ -157,7 +85,7 @@ longjmp_test (void)
     FAIL_EXIT1 ("svcr != 0: %lu", svcr);
   set_tpidr2 (&blk);
   start_za ();
-  load_za (za_orig);
+  load_za (za_orig, svl);
 
   print_data ("za save space", za_save);
   p = get_tpidr2 ();
@@ -168,8 +96,8 @@ longjmp_test (void)
     {
       p = get_tpidr2 ();
       printf ("before longjmp: tp2 = %p\n", p);
-      if (p != &blk)
-	FAIL_EXIT1 ("tpidr2 is clobbered");
+      if (p != NULL)
+	FAIL_EXIT1 ("tpidr2 has not been reset to null");
       do_longjmp (env);
       FAIL_EXIT1 ("longjmp returned");
     }
@@ -206,7 +134,7 @@ setcontext_test (void)
     FAIL_EXIT1 ("svcr != 0: %lu", svcr);
   set_tpidr2 (&blk);
   start_za ();
-  load_za (za_orig);
+  load_za (za_orig, svl);
 
   print_data ("za save space", za_save);
   p = get_tpidr2 ();
diff --git a/sysdeps/aarch64/tst-sme-signal.c b/sysdeps/aarch64/tst-sme-signal.c
new file mode 100644
index 0000000000..b4b07bcc44
--- /dev/null
+++ b/sysdeps/aarch64/tst-sme-signal.c
@@ -0,0 +1,115 @@
+/* Test handling of SME state in a signal handler.
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "tst-sme-skeleton.c"
+
+#include <support/xsignal.h>
+
+static struct _aarch64_ctx *
+extension (void *p)
+{
+  return p;
+}
+
+#ifndef TPIDR2_MAGIC
+#define TPIDR2_MAGIC 0x54504902
+#endif
+
+#ifndef ZA_MAGIC
+#define ZA_MAGIC 0x54366345
+#endif
+
+#ifndef ZT_MAGIC
+#define ZT_MAGIC 0x5a544e01
+#endif
+
+#ifndef EXTRA_MAGIC
+#define EXTRA_MAGIC 0x45585401
+#endif
+
+/* We use a pipe to make sure that the final check of the SME state
+   happens after signal handler finished.  */
+static int pipefd[2];
+
+#define WRITE(msg) xwrite (1, msg, sizeof (msg));
+
+static void
+handler (int signo, siginfo_t *si, void *ctx)
+{
+  TEST_VERIFY (signo == SIGUSR1);
+  WRITE ("in the handler\n");
+  check_sme_za_state ("during signal", true /* State is clear.  */);
+  ucontext_t *uc = ctx;
+  void *p = uc->uc_mcontext.__reserved;
+  unsigned int found = 0;
+  uint32_t m;
+  while ((m = extension (p)->magic))
+    {
+      if (m == TPIDR2_MAGIC)
+        {
+          WRITE ("found TPIDR2_MAGIC\n");
+          found += 1;
+        }
+      if (m == ZA_MAGIC)
+        {
+          WRITE ("found ZA_MAGIC\n");
+          found += 1;
+        }
+      if (m == ZT_MAGIC)
+        {
+          WRITE ("found ZT_MAGIC\n");
+          found += 1;
+        }
+      if (m == EXTRA_MAGIC)
+        {
+          WRITE ("found EXTRA_MAGIC\n");
+          struct { struct _aarch64_ctx h; uint64_t data; } *e = p;
+          p = (char *)e->data;
+          continue;
+        }
+      p = (char *)p + extension (p)->size;
+    }
+  TEST_COMPARE (found, 3);
+
+  /* Signal that the wait is over (see below).  */
+  char message = '\0';
+  xwrite (pipefd[1], &message, 1);
+}
+
+static void
+run (struct blk *blk)
+{
+  xpipe (pipefd);
+
+  struct sigaction sigact;
+  sigemptyset (&sigact.sa_mask);
+  sigact.sa_flags = 0;
+  sigact.sa_flags |= SA_SIGINFO;
+  sigact.sa_sigaction = handler;
+  xsigaction (SIGUSR1, &sigact, NULL);
+
+  enable_sme_za_state (blk);
+  check_sme_za_state ("before signal", false /* State is not clear.  */);
+  xraise (SIGUSR1);
+
+  /* Wait for signal handler to complete.  */
+  char response;
+  xread (pipefd[0], &response, 1);
+
+  check_sme_za_state ("after signal", false /* State is not clear.  */);
+}
diff --git a/sysdeps/aarch64/tst-sme-skeleton.c b/sysdeps/aarch64/tst-sme-skeleton.c
new file mode 100644
index 0000000000..ba84dda1cb
--- /dev/null
+++ b/sysdeps/aarch64/tst-sme-skeleton.c
@@ -0,0 +1,101 @@
+/* Template for SME tests.
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <stdio.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <string.h>
+#include <sys/auxv.h>
+
+#include <support/check.h>
+#include <support/support.h>
+#include <support/xstdlib.h>
+#include <support/xunistd.h>
+#include <support/test-driver.h>
+
+#include "tst-sme-helper.h"
+
+/* Streaming SVE vector register size.  */
+static unsigned long svl;
+
+static uint8_t *state;
+
+static void
+enable_sme_za_state (struct blk *blk)
+{
+  start_za ();
+  set_tpidr2 (blk);
+  load_za (blk, svl);
+}
+
+/* Check if SME state is disabled (when CLEAR is true) or
+   enabled (when CLEAR is false).  */
+static void
+check_sme_za_state (const char msg[], bool clear)
+{
+  unsigned long svcr = get_svcr ();
+  void *tpidr2 = get_tpidr2 ();
+  printf ("[%s]\n", msg);
+  printf ("svcr = %016lx\n", svcr);
+  printf ("tpidr2 = %016lx\n", (unsigned long)tpidr2);
+  if (clear)
+    {
+      TEST_VERIFY (svcr == 0);
+      TEST_VERIFY (tpidr2 == NULL);
+    }
+  else
+    {
+      TEST_VERIFY (svcr != 0);
+      TEST_VERIFY (tpidr2 != NULL);
+    }
+}
+
+/* Should be defined in actual test that includes this
+   skeleton file. */
+static void
+run (struct blk *ptr);
+
+static int
+do_test (void)
+{
+  unsigned long hwcap2 = getauxval (AT_HWCAP2);
+  if ((hwcap2 & HWCAP2_SME) == 0)
+    return EXIT_UNSUPPORTED;
+
+  /* Get current streaming SVE vector length in bytes.  */
+  svl = get_svl ();
+  printf ("svl: %lu\n", svl);
+
+  TEST_VERIFY_EXIT (!(svl < 16 || svl % 16 != 0 || svl >= (1 << 16)));
+
+  /* Initialise buffer for ZA state of SME.  */
+  state = xmalloc (svl * svl);
+  memset (state, 1, svl * svl);
+  struct blk blk = {
+    .za_save_buffer = state,
+    .num_za_save_slices = svl,
+    .__reserved = {0},
+  };
+
+  run (&blk);
+
+  free (state);
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/sysdeps/aarch64/tst-sme-vfork.c b/sysdeps/aarch64/tst-sme-vfork.c
new file mode 100644
index 0000000000..3feea065e5
--- /dev/null
+++ b/sysdeps/aarch64/tst-sme-vfork.c
@@ -0,0 +1,43 @@
+/* Test that ZA state of SME is cleared in both parent and child
+   when vfork() function is used.
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "tst-sme-skeleton.c"
+
+static void
+run (struct blk *blk)
+{
+  /* Enabled ZA state so that effect of disabling be observable.  */
+  enable_sme_za_state (blk);
+  check_sme_za_state ("before vfork", /* Clear.  */ false);
+  fflush (stdout);
+
+  pid_t pid = vfork ();
+
+  if (pid == 0)
+    {
+      /* Check that ZA state of SME was disabled in child.  */
+      check_sme_za_state ("after vfork in child", /* Clear.  */ true);
+      _exit (0);
+    }
+
+  /* Check that ZA state of SME was disabled in parent.  */
+  check_sme_za_state ("after vfork in parent", /* Clear.  */ true);
+
+  TEST_VERIFY (xwaitpid (pid, NULL, 0) == pid);
+}
diff --git a/sysdeps/aarch64/tst-sme-za-state.c b/sysdeps/aarch64/tst-sme-za-state.c
new file mode 100644
index 0000000000..00118ef506
--- /dev/null
+++ b/sysdeps/aarch64/tst-sme-za-state.c
@@ -0,0 +1,52 @@
+/* Test for SME ZA state being cleared on setjmp and longjmp.
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include "tst-sme-skeleton.c"
+
+#include <setjmp.h>
+
+static void
+run (struct blk *ptr)
+{
+  jmp_buf buf;
+  int ret;
+
+  check_sme_za_state ("initial state", /* Clear.  */ true);
+
+  /* Enabled ZA state so that effect of disabling be observable.  */
+  enable_sme_za_state (ptr);
+  check_sme_za_state ("before setjmp", /* Clear.  */ false);
+
+  if ((ret = setjmp (buf)) == 0)
+    {
+      check_sme_za_state ("after setjmp", /* Clear.  */ true);
+
+      /* Enabled ZA state so that effect of disabling be observable.  */
+      enable_sme_za_state (ptr);
+      check_sme_za_state ("before longjmp", /* Clear.  */ false);
+
+      longjmp (buf, 42);
+
+      /* Unreachable.  */
+      TEST_VERIFY (false);
+      __builtin_unreachable ();
+    }
+
+  TEST_COMPARE (ret, 42);
+  check_sme_za_state ("after longjmp", /* Clear.  */ true);
+}
diff --git a/sysdeps/arc/utmp-size.h b/sysdeps/arc/utmp-size.h
new file mode 100644
index 0000000000..a247fcd3da
--- /dev/null
+++ b/sysdeps/arc/utmp-size.h
@@ -0,0 +1,3 @@
+/* arc has less padding than other architectures with 64-bit time_t.  */
+#define UTMP_SIZE 392
+#define LASTLOG_SIZE 296
diff --git a/sysdeps/arm/Makefile b/sysdeps/arm/Makefile
index d5cea717a9..619474eca9 100644
--- a/sysdeps/arm/Makefile
+++ b/sysdeps/arm/Makefile
@@ -13,15 +13,15 @@ $(objpfx)libgcc-stubs.a: $(objpfx)aeabi_unwind_cpp_pr1.os
 lib-noranlib: $(objpfx)libgcc-stubs.a
 
 ifeq ($(build-shared),yes)
-ifeq (yes,$(have-mtls-dialect-gnu2))
+ifneq (no,$(have-mtls-descriptor))
 tests += tst-armtlsdescloc tst-armtlsdescextnow tst-armtlsdescextlazy
 modules-names += tst-armtlsdesclocmod
 modules-names += tst-armtlsdescextlazymod tst-armtlsdescextnowmod
 CPPFLAGS-tst-armtlsdescextnowmod.c += -Dstatic=
 CPPFLAGS-tst-armtlsdescextlazymod.c += -Dstatic=
-CFLAGS-tst-armtlsdesclocmod.c += -mtls-dialect=gnu2
-CFLAGS-tst-armtlsdescextnowmod.c += -mtls-dialect=gnu2
-CFLAGS-tst-armtlsdescextlazymod.c += -mtls-dialect=gnu2
+CFLAGS-tst-armtlsdesclocmod.c += -mtls-dialect=$(have-mtls-descriptor)
+CFLAGS-tst-armtlsdescextnowmod.c += -mtls-dialect=$(have-mtls-descriptor)
+CFLAGS-tst-armtlsdescextlazymod.c += -mtls-dialect=$(have-mtls-descriptor)
 LDFLAGS-tst-armtlsdescextnowmod.so += -Wl,-z,now
 tst-armtlsdescloc-ENV = LD_BIND_NOW=1
 tst-armtlsdescextnow-ENV = LD_BIND_NOW=1
diff --git a/sysdeps/arm/bits/wordsize.h b/sysdeps/arm/bits/wordsize.h
new file mode 100644
index 0000000000..6ecbfe7c86
--- /dev/null
+++ b/sysdeps/arm/bits/wordsize.h
@@ -0,0 +1,21 @@
+/* Copyright (C) 1999-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define __WORDSIZE			32
+#define __WORDSIZE_TIME64_COMPAT32	1
+#define __WORDSIZE32_SIZE_ULONG		0
+#define __WORDSIZE32_PTRDIFF_LONG	0
diff --git a/sysdeps/arm/configure b/sysdeps/arm/configure
index 35e2918922..4ef4d46cbd 100644
--- a/sysdeps/arm/configure
+++ b/sysdeps/arm/configure
@@ -187,6 +187,38 @@ else
 default-abi = soft"
 fi
 
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether VFP supports 32 registers" >&5
+printf %s "checking whether VFP supports 32 registers... " >&6; }
+if test ${libc_cv_arm_pcs_vfp_d32+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+void foo (void)
+{
+  asm volatile ("vldr d16,=17" : : : "d16");
+}
+
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  libc_cv_arm_pcs_vfp_d32=yes
+else $as_nop
+  libc_cv_arm_pcs_vfp_d32=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $libc_cv_arm_pcs_vfp_d32" >&5
+printf "%s\n" "$libc_cv_arm_pcs_vfp_d32" >&6; }
+if test "$libc_cv_arm_pcs_vfp_d32" = yes ;
+then
+  printf "%s\n" "#define HAVE_ARM_PCS_VFP_D32 1" >>confdefs.h
+
+fi
+
 { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether PC-relative relocs in movw/movt work properly" >&5
 printf %s "checking whether PC-relative relocs in movw/movt work properly... " >&6; }
 if test ${libc_cv_arm_pcrel_movw+y}
diff --git a/sysdeps/arm/configure.ac b/sysdeps/arm/configure.ac
index 5172e30bbe..cd00ddc9d9 100644
--- a/sysdeps/arm/configure.ac
+++ b/sysdeps/arm/configure.ac
@@ -21,6 +21,21 @@ else
   LIBC_CONFIG_VAR([default-abi], [soft])
 fi
 
+AC_CACHE_CHECK([whether VFP supports 32 registers],
+		libc_cv_arm_pcs_vfp_d32, [
+AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
+void foo (void)
+{
+  asm volatile ("vldr d16,=17" : : : "d16");
+}
+]])],
+                [libc_cv_arm_pcs_vfp_d32=yes],
+                [libc_cv_arm_pcs_vfp_d32=no])])
+if test "$libc_cv_arm_pcs_vfp_d32" = yes ;
+then
+  AC_DEFINE(HAVE_ARM_PCS_VFP_D32)
+fi
+
 AC_CACHE_CHECK([whether PC-relative relocs in movw/movt work properly],
 	       libc_cv_arm_pcrel_movw, [
 cat > conftest.s <<\EOF
diff --git a/sysdeps/arm/dl-machine.h b/sysdeps/arm/dl-machine.h
index b857bbc868..dd1a0f6b6e 100644
--- a/sysdeps/arm/dl-machine.h
+++ b/sysdeps/arm/dl-machine.h
@@ -139,7 +139,6 @@ _start:\n\
 _dl_start_user:\n\
 	adr	r6, .L_GET_GOT\n\
 	add	sl, sl, r6\n\
-	ldr	r4, [sl, r4]\n\
 	@ save the entry point in another register\n\
 	mov	r6, r0\n\
 	@ get the original arg count\n\
diff --git a/sysdeps/arm/dl-tlsdesc.S b/sysdeps/arm/dl-tlsdesc.S
index 764c56e70f..ada106521d 100644
--- a/sysdeps/arm/dl-tlsdesc.S
+++ b/sysdeps/arm/dl-tlsdesc.S
@@ -19,6 +19,7 @@
 #include <sysdep.h>
 #include <arm-features.h>
 #include <tls.h>
+#include <rtld-global-offsets.h>
 #include "tlsdesc.h"
 
 	.text
@@ -83,14 +84,20 @@ _dl_tlsdesc_dynamic(struct tlsdesc *tdp)
 	.align 2
 _dl_tlsdesc_dynamic:
 	/* Our calling convention is to clobber r0, r1 and the processor
-	   flags.  All others that are modified must be saved */
-	eabi_save ({r2,r3,r4,lr})
-	push	{r2,r3,r4,lr}
-	cfi_adjust_cfa_offset (16)
+	   flags.  All others that are modified must be saved.  r5 is
+	   used as the hwcap value to avoid reload after __tls_get_addr
+	   call.  If required we will save the vector register on the slow
+	   path.  */
+	eabi_save ({r2,r3,r4,r5,ip,lr})
+	push	{r2,r3,r4,r5,ip,lr}
+	cfi_adjust_cfa_offset (24)
 	cfi_rel_offset (r2,0)
 	cfi_rel_offset (r3,4)
 	cfi_rel_offset (r4,8)
-	cfi_rel_offset (lr,12)
+	cfi_rel_offset (r5,12)
+	cfi_rel_offset (ip,16)
+	cfi_rel_offset (lr,20)
+
 	ldr	r1, [r0] /* td */
 	GET_TLS (lr)
 	mov	r4, r0 /* r4 = tp */
@@ -113,22 +120,69 @@ _dl_tlsdesc_dynamic:
 	rsbne	r0, r4, r3
 	bne	2f
 1:	mov	r0, r1
+
+	/* Load the hwcap to check for vector support.  */
+	ldr     r2, 3f
+	ldr     r1, .Lrtld_global_ro
+0:	add     r2, pc, r2
+	ldr     r2, [r2, r1]
+	ldr     r5, [r2, #RTLD_GLOBAL_RO_DL_HWCAP_OFFSET]
+
+#ifdef __SOFTFP__
+	tst     r5, #HWCAP_ARM_VFP
+	beq     .Lno_vfp
+#endif
+
+	/* Store the VFP registers.  Don't use VFP instructions directly
+	   because this code is used in non-VFP multilibs.  */
+#define VFP_STACK_REQ (32*8 + 8)
+	sub	sp, sp, VFP_STACK_REQ
+	cfi_adjust_cfa_offset (VFP_STACK_REQ)
+	mov	r3, sp
+	.inst	0xeca30b20	/* vstmia r3!, {d0-d15} */
+	tst	r5, #HWCAP_ARM_VFPD32
+	beq	4f
+	.inst	0xece30b20	/* vstmia r3!, {d16-d31}  */
+	/* Store the floating-point status register.  */
+4:	.inst	0xeef12a10	/* vmrs	r2, fpscr */
+	str	r2, [r3]
+.Lno_vfp:
 	bl	__tls_get_addr
 	rsb	r0, r4, r0
+#ifdef __SOFTFP__
+	tst     r5, #HWCAP_ARM_VFP
+	beq     2f
+#endif
+	mov	r3, sp
+	.inst	0xecb30b20	/* vldmia r3!, {d0-d15}  */
+	tst	r5, #HWCAP_ARM_VFPD32
+	beq	5f
+	.inst	0xecf30b20	/* vldmia r3!, {d16-d31}  */
+	ldr	r4, [r3]
+5:	.inst	0xeee14a10	/* vmsr	fpscr, r4  */
+	add	sp, sp, VFP_STACK_REQ
+	cfi_adjust_cfa_offset (-VFP_STACK_REQ)
+
 2:
 #if ((defined (__ARM_ARCH_4T__) && defined (__THUMB_INTERWORK__)) \
      || defined (ARM_ALWAYS_BX))
-	pop	{r2,r3,r4, lr}
-	cfi_adjust_cfa_offset (-16)
+	pop	{r2,r3,r4,r5,ip, lr}
+	cfi_adjust_cfa_offset (-20)
 	cfi_restore (lr)
+	cfi_restore (ip)
+	cfi_restore (r5)
 	cfi_restore (r4)
 	cfi_restore (r3)
 	cfi_restore (r2)
 	bx	lr
 #else
-	pop	{r2,r3,r4, pc}
+	pop	{r2,r3,r4,r5,ip, pc}
 #endif
 	eabi_fnend
 	cfi_endproc
 	.size	_dl_tlsdesc_dynamic, .-_dl_tlsdesc_dynamic
+
+3:      .long   _GLOBAL_OFFSET_TABLE_ - 0b - PC_OFS
+.Lrtld_global_ro:
+	.long   C_SYMBOL_NAME(_rtld_global_ro)(GOT)
 #endif /* SHARED */
diff --git a/sysdeps/arm/find_exidx.c b/sysdeps/arm/find_exidx.c
index d647865e5a..4257c26838 100644
--- a/sysdeps/arm/find_exidx.c
+++ b/sysdeps/arm/find_exidx.c
@@ -15,65 +15,17 @@
    License along with the GNU C Library.  If not, see
    <https://www.gnu.org/licenses/>.  */
 
+#include <ldsodefs.h>
 #include <link.h>
-#include <unwind.h>
-
-struct unw_eh_callback_data
-{
-  _Unwind_Ptr pc;
-  _Unwind_Ptr exidx_start;
-  int exidx_len;
-};
-
-
-/* Callback to determines if the PC lies within an object, and remember the
-   location of the exception index table if it does.  */
-
-static int
-find_exidx_callback (struct dl_phdr_info * info, size_t size, void * ptr)
-{
-  struct unw_eh_callback_data * data;
-  const ElfW(Phdr) *phdr;
-  int i;
-  int match;
-  _Unwind_Ptr load_base;
-
-  data = (struct unw_eh_callback_data *) ptr;
-  load_base = info->dlpi_addr;
-  phdr = info->dlpi_phdr;
-
-  match = 0;
-  for (i = info->dlpi_phnum; i > 0; i--, phdr++)
-    {
-      if (phdr->p_type == PT_LOAD)
-        {
-          _Unwind_Ptr vaddr = phdr->p_vaddr + load_base;
-          if (data->pc >= vaddr && data->pc < vaddr + phdr->p_memsz)
-            match = 1;
-        }
-      else if (phdr->p_type == PT_ARM_EXIDX)
-	{
-	  data->exidx_start = (_Unwind_Ptr) (phdr->p_vaddr + load_base);
-	  data->exidx_len = phdr->p_memsz;
-	}
-    }
-
-  return match;
-}
-
 
 /* Find the exception index table containing PC.  */
 
 _Unwind_Ptr
 __gnu_Unwind_Find_exidx (_Unwind_Ptr pc, int * pcount)
 {
-  struct unw_eh_callback_data data;
-
-  data.pc = pc;
-  data.exidx_start = 0;
-  if (__dl_iterate_phdr (find_exidx_callback, &data) <= 0)
+  struct dl_find_object data;
+  if (GLRO(dl_find_object) ((void *) pc, &data) < 0)
     return 0;
-
-  *pcount = data.exidx_len / 8;
-  return data.exidx_start;
+  *pcount = data.dlfo_eh_count;
+  return (_Unwind_Ptr) data.dlfo_eh_frame;
 }
diff --git a/sysdeps/arm/tst-gnu2-tls2.h b/sysdeps/arm/tst-gnu2-tls2.h
new file mode 100644
index 0000000000..e413ac21fb
--- /dev/null
+++ b/sysdeps/arm/tst-gnu2-tls2.h
@@ -0,0 +1,128 @@
+/* Test TLSDESC relocation.  ARM version.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+#include <sys/auxv.h>
+#include <string.h>
+#include <stdlib.h>
+#include <endian.h>
+
+#ifndef __SOFTFP__
+
+# ifdef HAVE_ARM_PCS_VFP_D32
+#  define SAVE_VFP_D32					\
+      asm volatile ("vldr d16,=17" : : : "d16");	\
+      asm volatile ("vldr d17,=18" : : : "d17");	\
+      asm volatile ("vldr d18,=19" : : : "d18");	\
+      asm volatile ("vldr d19,=20" : : : "d19");	\
+      asm volatile ("vldr d20,=21" : : : "d20");	\
+      asm volatile ("vldr d21,=22" : : : "d21");	\
+      asm volatile ("vldr d22,=23" : : : "d22");	\
+      asm volatile ("vldr d23,=24" : : : "d23");	\
+      asm volatile ("vldr d24,=25" : : : "d24");	\
+      asm volatile ("vldr d25,=26" : : : "d25");	\
+      asm volatile ("vldr d26,=27" : : : "d26");	\
+      asm volatile ("vldr d27,=28" : : : "d27");	\
+      asm volatile ("vldr d28,=29" : : : "d28");	\
+      asm volatile ("vldr d29,=30" : : : "d29");	\
+      asm volatile ("vldr d30,=31" : : : "d30");	\
+      asm volatile ("vldr d31,=32" : : : "d31");
+# else
+#  define SAVE_VFP_D32
+# endif
+
+# define INIT_TLSDESC_CALL()				\
+  unsigned long hwcap = getauxval (AT_HWCAP)
+
+/* Set each vector register to a value from 1 to 32 before the TLS access,
+   dump to memory after TLS access, and compare with the expected values.  */
+
+# define BEFORE_TLSDESC_CALL()				\
+  if (hwcap & HWCAP_ARM_VFP)				\
+    {							\
+      asm volatile ("vldr  d0,=1" : : : "d0");		\
+      asm volatile ("vldr  d1,=2" : : : "d1");		\
+      asm volatile ("vldr  d2,=3" : : : "d1");		\
+      asm volatile ("vldr  d3,=4" : : : "d3");		\
+      asm volatile ("vldr  d4,=5" : : : "d4");		\
+      asm volatile ("vldr  d5,=6" : : : "d5");		\
+      asm volatile ("vldr  d6,=7" : : : "d6");		\
+      asm volatile ("vldr  d7,=8" : : : "d7");		\
+      asm volatile ("vldr  d8,=9" : : : "d8");		\
+      asm volatile ("vldr  d9,=10" : : : "d9");		\
+      asm volatile ("vldr d10,=11" : : : "d10");	\
+      asm volatile ("vldr d11,=12" : : : "d11");	\
+      asm volatile ("vldr d12,=13" : : : "d12");	\
+      asm volatile ("vldr d13,=14" : : : "d13");	\
+      asm volatile ("vldr d14,=15" : : : "d14");	\
+      asm volatile ("vldr d15,=16" : : : "d15");	\
+    }							\
+  if (hwcap & HWCAP_ARM_VFPD32)				\
+    {							\
+      SAVE_VFP_D32					\
+    }
+
+# define VFP_STACK_REQ (16*8)
+# if __BYTE_ORDER == __BIG_ENDIAN
+#  define DISP 7
+# else
+#  define DISP 0
+# endif
+
+# ifdef HAVE_ARM_PCS_VFP_D32
+#  define CHECK_VFP_D32							\
+      char vfp[VFP_STACK_REQ];						\
+      asm volatile ("vstmia %0, {d16-d31}\n"				\
+		    :							\
+		    : "r" (vfp)						\
+		    : "memory");					\
+									\
+      char expected[VFP_STACK_REQ] = { 0 };				\
+      for (int i = 0; i < 16; ++i)					\
+	expected[i * 8 + DISP] = i + 17;				\
+									\
+      if (memcmp (vfp, expected, VFP_STACK_REQ) != 0)			\
+        abort ();
+# else
+#  define CHECK_VFP_D32
+# endif
+
+# define AFTER_TLSDESC_CALL()						\
+  if (hwcap & HWCAP_ARM_VFP)						\
+    {									\
+      char vfp[VFP_STACK_REQ];						\
+      asm volatile ("vstmia %0, {d0-d15}\n"				\
+		    :							\
+		    : "r" (vfp)						\
+		    : "memory");					\
+									\
+      char expected[VFP_STACK_REQ] = { 0 };				\
+      for (int i = 0; i < 16; ++i)					\
+	expected[i * 8 + DISP] = i + 1;					\
+									\
+      if (memcmp (vfp, expected, VFP_STACK_REQ) != 0)			\
+        abort ();							\
+    }									\
+  if (hwcap & HWCAP_ARM_VFPD32)						\
+    {									\
+      CHECK_VFP_D32							\
+    }
+
+#endif /* __SOFTFP__ */
+
+#include_next <tst-gnu2-tls2.h>
diff --git a/sysdeps/arm/utmp-size.h b/sysdeps/arm/utmp-size.h
new file mode 100644
index 0000000000..8f21ebe1b6
--- /dev/null
+++ b/sysdeps/arm/utmp-size.h
@@ -0,0 +1,2 @@
+#define UTMP_SIZE 384
+#define LASTLOG_SIZE 292
diff --git a/sysdeps/csky/bits/wordsize.h b/sysdeps/csky/bits/wordsize.h
new file mode 100644
index 0000000000..6ecbfe7c86
--- /dev/null
+++ b/sysdeps/csky/bits/wordsize.h
@@ -0,0 +1,21 @@
+/* Copyright (C) 1999-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define __WORDSIZE			32
+#define __WORDSIZE_TIME64_COMPAT32	1
+#define __WORDSIZE32_SIZE_ULONG		0
+#define __WORDSIZE32_PTRDIFF_LONG	0
diff --git a/sysdeps/csky/utmp-size.h b/sysdeps/csky/utmp-size.h
new file mode 100644
index 0000000000..8f21ebe1b6
--- /dev/null
+++ b/sysdeps/csky/utmp-size.h
@@ -0,0 +1,2 @@
+#define UTMP_SIZE 384
+#define LASTLOG_SIZE 292
diff --git a/sysdeps/generic/ldsodefs.h b/sysdeps/generic/ldsodefs.h
index 117c901ccc..b4c6e6d2ca 100644
--- a/sysdeps/generic/ldsodefs.h
+++ b/sysdeps/generic/ldsodefs.h
@@ -351,7 +351,7 @@ struct rtld_global
       void (*free) (void *);
     } _ns_unique_sym_table;
     /* Keep track of changes to each namespace' list.  */
-    struct r_debug_extended _ns_debug;
+    struct r_debug_extended _ns_debug_unused;
   } _dl_ns[DL_NNS];
   /* One higher than index of last used namespace.  */
   EXTERN size_t _dl_nns;
@@ -646,6 +646,8 @@ struct rtld_global_ro
   /* Mask for more hardware capabilities that are available on some
      platforms.  */
   EXTERN uint64_t _dl_hwcap2;
+  EXTERN uint64_t _dl_hwcap3;
+  EXTERN uint64_t _dl_hwcap4;
 
   EXTERN enum dso_sort_algorithm _dl_dso_sort_algo;
 
@@ -1012,6 +1014,13 @@ extern void _dl_relocate_object (struct link_map *map,
 				 int reloc_mode, int consider_profiling)
      attribute_hidden;
 
+/* Perform relocation, but do not apply RELRO.  Does not check
+   L->relocated.  Otherwise the same as _dl_relocate_object.  */
+void _dl_relocate_object_no_relro (struct link_map *map,
+				   struct r_scope_elem *scope[],
+				   int reloc_mode, int consider_profiling)
+     attribute_hidden;
+
 /* Protect PT_GNU_RELRO area.  */
 extern void _dl_protect_relro (struct link_map *map) attribute_hidden;
 
@@ -1060,15 +1069,29 @@ extern void _dl_debug_state (void);
 rtld_hidden_proto (_dl_debug_state)
 
 /* Initialize `struct r_debug_extended' for the namespace NS.  LDBASE
-   is the run-time load address of the dynamic linker, to be put in the
-   `r_ldbase' member.  Return the address of the structure.  */
+   is the run-time load address of the dynamic linker, to be put in
+   the `r_ldbase' member.
+
+   Return the address of the r_debug structure for the namespace.
+   This is not merely a convenience or optimization, but it is
+   necessary for the LIBC_PROBE Systemtap/debugger probes to work
+   reliably: direct variable access can create probes that tools
+   cannot consume.  */
 extern struct r_debug *_dl_debug_initialize (ElfW(Addr) ldbase, Lmid_t ns)
      attribute_hidden;
 
+/* This is called after relocation processing to handle a potential
+   copy relocation for _r_debug.  */
+void _dl_debug_post_relocate (struct link_map *main_map) attribute_hidden;
+
 /* Update the `r_map' member and return the address of `struct r_debug'
    of the namespace NS.  */
 extern struct r_debug *_dl_debug_update (Lmid_t ns) attribute_hidden;
 
+/* Update R->r_state to STATE and notify the debugger by calling
+   _dl_debug_state.  */
+void _dl_debug_change_state (struct r_debug *r, int state) attribute_hidden;
+
 /* Initialize the basic data structure for the search paths.  SOURCE
    is either "LD_LIBRARY_PATH" or "--library-path".
    GLIBC_HWCAPS_PREPEND adds additional glibc-hwcaps subdirectories to
@@ -1198,10 +1221,8 @@ extern void _dl_get_tls_static_info (size_t *sizep, size_t *alignp);
 
 extern void _dl_allocate_static_tls (struct link_map *map) attribute_hidden;
 
-/* These are internal entry points to the two halves of _dl_allocate_tls,
-   only used within rtld.c itself at startup time.  */
 extern void *_dl_allocate_tls_storage (void) attribute_hidden;
-extern void *_dl_allocate_tls_init (void *, bool);
+extern void *_dl_allocate_tls_init (void *result, bool main_thread);
 rtld_hidden_proto (_dl_allocate_tls_init)
 
 /* True if the TCB has been set up.  */
@@ -1239,13 +1260,7 @@ extern void *_dl_open (const char *name, int mode, const void *caller,
 extern int _dl_scope_free (void *) attribute_hidden;
 
 
-/* Add module to slot information data.  If DO_ADD is false, only the
-   required memory is allocated.  Must be called with GL
-   (dl_load_tls_lock) acquired.  If the function has already been called
-   for the link map L with !do_add, then this function will not raise
-   an exception, otherwise it is possible that it encounters a memory
-   allocation failure.  */
-extern void _dl_add_to_slotinfo (struct link_map *l, bool do_add)
+extern bool _dl_add_to_slotinfo (struct link_map *l, bool do_add)
   attribute_hidden;
 
 /* Update slot information data for at least the generation of the
@@ -1254,6 +1269,20 @@ extern struct link_map *_dl_update_slotinfo (unsigned long int req_modid,
 					     size_t gen)
      attribute_hidden;
 
+/* The last TLS module ID that is initially loaded, plus 1.  TLS
+   addresses for modules with IDs lower than that can be obtained from
+   the DTV even if its generation is outdated.  */
+extern size_t _dl_tls_initial_modid_limit attribute_hidden attribute_relro;
+
+/* Compute _dl_tls_initial_modid_limit.  To be called after initial
+   relocation.  */
+void _dl_tls_initial_modid_limit_setup (void) attribute_hidden;
+
+/* Number of threads currently in a TLS update.  This is used to
+   detect reentrant __tls_get_addr calls without a per-thread
+   flag.  */
+extern unsigned int _dl_tls_threads_in_update attribute_hidden;
+
 /* Look up the module's TLS block as for __tls_get_addr,
    but never touch anything.  Return null if it's not allocated yet.  */
 extern void *_dl_tls_get_addr_soft (struct link_map *l) attribute_hidden;
diff --git a/sysdeps/generic/libc-tsd.h b/sysdeps/generic/libc-tsd.h
deleted file mode 100644
index ac0e99e14b..0000000000
--- a/sysdeps/generic/libc-tsd.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/* libc-internal interface for thread-specific data.  Stub or TLS version.
-   Copyright (C) 1998-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#ifndef _GENERIC_LIBC_TSD_H
-#define _GENERIC_LIBC_TSD_H 1
-
-/* This file defines the following macros for accessing a small fixed
-   set of thread-specific `void *' data used only internally by libc.
-
-   __libc_tsd_define(CLASS, TYPE, KEY)	-- Define or declare a datum with TYPE
-					   for KEY.  CLASS can be `static' for
-					   keys used in only one source file,
-					   empty for global definitions, or
-					   `extern' for global declarations.
-   __libc_tsd_address(TYPE, KEY)	-- Return the `TYPE *' pointing to
-					   the current thread's datum for KEY.
-   __libc_tsd_get(TYPE, KEY)		-- Return the `TYPE' datum for KEY.
-   __libc_tsd_set(TYPE, KEY, VALUE)	-- Set the datum for KEY to VALUE.
-
-   The set of available KEY's will usually be provided as an enum,
-   and contains (at least):
-		_LIBC_TSD_KEY_MALLOC
-		_LIBC_TSD_KEY_DL_ERROR
-		_LIBC_TSD_KEY_RPC_VARS
-   All uses must be the literal _LIBC_TSD_* name in the __libc_tsd_* macros.
-   Some implementations may not provide any enum at all and instead
-   using string pasting in the macros.  */
-
-#include <tls.h>
-
-/* When full support for __thread variables is available, this interface is
-   just a trivial wrapper for it.  Without TLS, this is the generic/stub
-   implementation for wholly single-threaded systems.
-
-   We don't define an enum for the possible key values, because the KEYs
-   translate directly into variables by macro magic.  */
-
-#define __libc_tsd_define(CLASS, TYPE, KEY)	\
-  CLASS __thread TYPE __libc_tsd_##KEY attribute_tls_model_ie;
-
-#define __libc_tsd_address(TYPE, KEY)		(&__libc_tsd_##KEY)
-#define __libc_tsd_get(TYPE, KEY)		(__libc_tsd_##KEY)
-#define __libc_tsd_set(TYPE, KEY, VALUE)	(__libc_tsd_##KEY = (VALUE))
-
-#endif	/* libc-tsd.h */
diff --git a/sysdeps/generic/mremap-failure.h b/sysdeps/generic/mremap-failure.h
new file mode 100644
index 0000000000..bc0d476368
--- /dev/null
+++ b/sysdeps/generic/mremap-failure.h
@@ -0,0 +1,25 @@
+/* mremap failure handling.  Generic version.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* Return exit value on mremap failure with errno ERR.  */
+
+static int
+mremap_failure_exit (int err)
+{
+  return EXIT_FAILURE;
+}
diff --git a/sysdeps/generic/utmp-size.h b/sysdeps/generic/utmp-size.h
new file mode 100644
index 0000000000..89dbe878b0
--- /dev/null
+++ b/sysdeps/generic/utmp-size.h
@@ -0,0 +1,23 @@
+/* Expected sizes of utmp-related structures stored in files.  64-bit version.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* Expected size, in bytes, of struct utmp and struct utmpx.  */
+#define UTMP_SIZE 400
+
+/* Expected size, in bytes, of struct lastlog.  */
+#define LASTLOG_SIZE 296
diff --git a/sysdeps/hppa/utmp-size.h b/sysdeps/hppa/utmp-size.h
new file mode 100644
index 0000000000..8f21ebe1b6
--- /dev/null
+++ b/sysdeps/hppa/utmp-size.h
@@ -0,0 +1,2 @@
+#define UTMP_SIZE 384
+#define LASTLOG_SIZE 292
diff --git a/sysdeps/i386/Makefile b/sysdeps/i386/Makefile
index a2e8c0b128..c0c017b899 100644
--- a/sysdeps/i386/Makefile
+++ b/sysdeps/i386/Makefile
@@ -30,7 +30,9 @@ stack-align-test-flags += -malign-double
 endif
 
 ifeq ($(subdir),elf)
-sysdep-dl-routines += tlsdesc dl-tlsdesc
+sysdep-dl-routines += \
+  dl-tls-get-addr \
+# sysdep-dl-routines
 
 tests += tst-audit3
 modules-names += tst-auditmod3a tst-auditmod3b
@@ -58,6 +60,15 @@ $(objpfx)tst-ld-sse-use.out: ../sysdeps/i386/tst-ld-sse-use.sh $(objpfx)ld.so
 	@echo "Checking ld.so for SSE register use.  This will take a few seconds..."
 	$(BASH) $< $(objpfx) '$(NM)' '$(OBJDUMP)' '$(READELF)' > $@; \
 	$(evaluate-test)
+
+tests-special += $(objpfx)check-gnu-tls.out
+
+$(objpfx)check-gnu-tls.out: $(common-objpfx)libc.so
+	LC_ALL=C $(READELF) -V -W $< \
+		| sed -ne '/.gnu.version_d/, /.gnu.version_r/ p' \
+		| grep GLIBC_ABI_GNU_TLS > $@; \
+	$(evaluate-test)
+generated += check-gnu-tls.out
 else
 CFLAGS-.os += $(if $(filter rtld-%.os,$(@F)), $(rtld-CFLAGS))
 endif
diff --git a/sysdeps/i386/Versions b/sysdeps/i386/Versions
index 36e23b466a..9c84c8ef04 100644
--- a/sysdeps/i386/Versions
+++ b/sysdeps/i386/Versions
@@ -28,6 +28,11 @@ libc {
   GLIBC_2.13 {
     __fentry__;
   }
+  GLIBC_ABI_GNU_TLS {
+    # This symbol is used only for empty version map and will be removed
+    # by scripts/versions.awk.
+    __placeholder_only_for_empty_version_map;
+  }
 }
 libm {
   GLIBC_2.1 {
diff --git a/sysdeps/i386/dl-machine.h b/sysdeps/i386/dl-machine.h
index fc1ef96587..50d74fe6e9 100644
--- a/sysdeps/i386/dl-machine.h
+++ b/sysdeps/i386/dl-machine.h
@@ -347,7 +347,7 @@ and creates an unsatisfiable circular dependency.\n",
 		  {
 		    td->arg = _dl_make_tlsdesc_dynamic
 		      (sym_map, sym->st_value + (ElfW(Word))td->arg);
-		    td->entry = _dl_tlsdesc_dynamic;
+		    td->entry = GLRO(dl_x86_tlsdesc_dynamic);
 		  }
 		else
 #  endif
diff --git a/sysdeps/i386/dl-tls-get-addr.c b/sysdeps/i386/dl-tls-get-addr.c
new file mode 100644
index 0000000000..c97e5c57be
--- /dev/null
+++ b/sysdeps/i386/dl-tls-get-addr.c
@@ -0,0 +1,68 @@
+/* Ifunc selector for ___tls_get_addr.
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifdef SHARED
+# define ___tls_get_addr __redirect____tls_get_addr
+# include <dl-tls.h>
+# undef ___tls_get_addr
+# undef __tls_get_addr
+
+# define SYMBOL_NAME ___tls_get_addr
+# include <init-arch.h>
+
+extern __typeof (REDIRECT_NAME) OPTIMIZE (fnsave) attribute_hidden;
+extern __typeof (REDIRECT_NAME) OPTIMIZE (fxsave) attribute_hidden;
+extern __typeof (REDIRECT_NAME) OPTIMIZE (xsave) attribute_hidden;
+extern __typeof (REDIRECT_NAME) OPTIMIZE (xsavec) attribute_hidden;
+
+static inline void *
+IFUNC_SELECTOR (void)
+{
+  const struct cpu_features* cpu_features = __get_cpu_features ();
+
+  if (cpu_features->xsave_state_size != 0)
+    {
+      if (CPU_FEATURE_USABLE_P (cpu_features, XSAVEC))
+	return OPTIMIZE (xsavec);
+      else
+	return OPTIMIZE (xsave);
+    }
+  else if (CPU_FEATURE_USABLE_P (cpu_features, FXSR))
+    return OPTIMIZE (fxsave);
+  return OPTIMIZE (fnsave);
+}
+
+libc_ifunc_redirected (__redirect____tls_get_addr, ___tls_get_addr,
+		       IFUNC_SELECTOR ());
+
+/* The special thing about the x86 TLS ABI is that we have two
+   variants of the __tls_get_addr function with different calling
+   conventions.  The GNU version, which we are mostly concerned here,
+   takes the parameter in a register.  The name is changed by adding
+   an additional underscore at the beginning.  The Sun version uses
+   the normal calling convention.  */
+
+rtld_hidden_proto (___tls_get_addr)
+rtld_hidden_def (___tls_get_addr)
+
+void *
+__tls_get_addr (tls_index *ti)
+{
+  return ___tls_get_addr (ti);
+}
+#endif
diff --git a/sysdeps/i386/dl-tls.h b/sysdeps/i386/dl-tls.h
index f17286703d..2380ec1bd4 100644
--- a/sysdeps/i386/dl-tls.h
+++ b/sysdeps/i386/dl-tls.h
@@ -29,33 +29,13 @@ typedef struct dl_tls_index
 /* This is the prototype for the GNU version.  */
 extern void *___tls_get_addr (tls_index *ti)
      __attribute__ ((__regparm__ (1)));
-extern void *___tls_get_addr_internal (tls_index *ti)
-     __attribute__ ((__regparm__ (1))) attribute_hidden;
-
 # if IS_IN (rtld)
-/* The special thing about the x86 TLS ABI is that we have two
-   variants of the __tls_get_addr function with different calling
-   conventions.  The GNU version, which we are mostly concerned here,
-   takes the parameter in a register.  The name is changed by adding
-   an additional underscore at the beginning.  The Sun version uses
-   the normal calling convention.  */
-void *
-__tls_get_addr (tls_index *ti)
-{
-  return ___tls_get_addr_internal (ti);
-}
-
-
 /* Prepare using the definition of __tls_get_addr in the generic
    version of this file.  */
-# define __tls_get_addr __attribute__ ((__regparm__ (1))) ___tls_get_addr
-strong_alias (___tls_get_addr, ___tls_get_addr_internal)
-rtld_hidden_proto (___tls_get_addr)
-rtld_hidden_def (___tls_get_addr)
-#else
-
+# define __tls_get_addr \
+    __attribute__ ((__regparm__ (1))) ___tls_get_addr_internal
+# else
 /* Users should get the better interface.  */
-# define __tls_get_addr ___tls_get_addr
-
+#  define __tls_get_addr ___tls_get_addr
 # endif
 #endif
diff --git a/sysdeps/i386/dl-tlsdesc-dynamic.h b/sysdeps/i386/dl-tlsdesc-dynamic.h
new file mode 100644
index 0000000000..8a5952421e
--- /dev/null
+++ b/sysdeps/i386/dl-tlsdesc-dynamic.h
@@ -0,0 +1,84 @@
+/* Thread-local storage handling in the ELF dynamic linker.  i386 version.
+   Copyright (C) 2004-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+	.hidden _dl_tlsdesc_dynamic
+	.global	_dl_tlsdesc_dynamic
+	.type	_dl_tlsdesc_dynamic,@function
+
+     /* This function is used for symbols that need dynamic TLS.
+
+	%eax points to the TLS descriptor, such that 0(%eax) points to
+	_dl_tlsdesc_dynamic itself, and 4(%eax) points to a struct
+	tlsdesc_dynamic_arg object.  It must return in %eax the offset
+	between the thread pointer and the object denoted by the
+	argument, without clobbering any registers.
+
+	The assembly code that follows is a rendition of the following
+	C code, hand-optimized a little bit.
+
+ptrdiff_t
+__attribute__ ((__regparm__ (1)))
+_dl_tlsdesc_dynamic (struct tlsdesc *tdp)
+{
+  struct tlsdesc_dynamic_arg *td = tdp->arg;
+  dtv_t *dtv = *(dtv_t **)((char *)__thread_pointer + DTV_OFFSET);
+  if (__builtin_expect (td->gen_count <= dtv[0].counter
+			&& (dtv[td->tlsinfo.ti_module].pointer.val
+			    != TLS_DTV_UNALLOCATED),
+			1))
+    return dtv[td->tlsinfo.ti_module].pointer.val + td->tlsinfo.ti_offset
+      - __thread_pointer;
+
+  return ___tls_get_addr (&td->tlsinfo) - __thread_pointer;
+}
+*/
+	cfi_startproc
+	.align 16
+_dl_tlsdesc_dynamic:
+	/* Like all TLS resolvers, preserve call-clobbered registers.
+	   We need two scratch regs anyway.  */
+	subl	$32, %esp
+	cfi_adjust_cfa_offset (32)
+	movl	%ecx, 20(%esp)
+	movl	%edx, 24(%esp)
+	movl	TLSDESC_ARG(%eax), %eax
+	movl	%gs:DTV_OFFSET, %edx
+	movl	TLSDESC_GEN_COUNT(%eax), %ecx
+	cmpl	(%edx), %ecx
+	ja	2f
+	movl	TLSDESC_MODID(%eax), %ecx
+	movl	(%edx,%ecx,8), %edx
+	cmpl	$-1, %edx
+	je	2f
+	movl	TLSDESC_MODOFF(%eax), %eax
+	addl	%edx, %eax
+1:
+	movl	20(%esp), %ecx
+	subl	%gs:0, %eax
+	movl	24(%esp), %edx
+	addl	$32, %esp
+	cfi_adjust_cfa_offset (-32)
+	ret
+	.p2align 4,,7
+2:
+#include "tls-get-addr-wrapper.h"
+	jmp	1b
+	cfi_endproc
+	.size	_dl_tlsdesc_dynamic, .-_dl_tlsdesc_dynamic
+
+#undef STATE_SAVE_ALIGNMENT
diff --git a/sysdeps/i386/dl-tlsdesc.S b/sysdeps/i386/dl-tlsdesc.S
index 90d93caa0c..dec7049911 100644
--- a/sysdeps/i386/dl-tlsdesc.S
+++ b/sysdeps/i386/dl-tlsdesc.S
@@ -18,6 +18,8 @@
 
 #include <sysdep.h>
 #include <tls.h>
+#include <cpu-features-offsets.h>
+#include <features-offsets.h>
 #include "tlsdesc.h"
 
 	.text
@@ -65,69 +67,35 @@ _dl_tlsdesc_undefweak:
 	.size	_dl_tlsdesc_undefweak, .-_dl_tlsdesc_undefweak
 
 #ifdef SHARED
-	.hidden _dl_tlsdesc_dynamic
-	.global	_dl_tlsdesc_dynamic
-	.type	_dl_tlsdesc_dynamic,@function
-
-     /* This function is used for symbols that need dynamic TLS.
-
-	%eax points to the TLS descriptor, such that 0(%eax) points to
-	_dl_tlsdesc_dynamic itself, and 4(%eax) points to a struct
-	tlsdesc_dynamic_arg object.  It must return in %eax the offset
-	between the thread pointer and the object denoted by the
-	argument, without clobbering any registers.
-
-	The assembly code that follows is a rendition of the following
-	C code, hand-optimized a little bit.
-
-ptrdiff_t
-__attribute__ ((__regparm__ (1)))
-_dl_tlsdesc_dynamic (struct tlsdesc *tdp)
-{
-  struct tlsdesc_dynamic_arg *td = tdp->arg;
-  dtv_t *dtv = *(dtv_t **)((char *)__thread_pointer + DTV_OFFSET);
-  if (__builtin_expect (td->gen_count <= dtv[0].counter
-			&& (dtv[td->tlsinfo.ti_module].pointer.val
-			    != TLS_DTV_UNALLOCATED),
-			1))
-    return dtv[td->tlsinfo.ti_module].pointer.val + td->tlsinfo.ti_offset
-      - __thread_pointer;
-
-  return ___tls_get_addr (&td->tlsinfo) - __thread_pointer;
-}
-*/
-	cfi_startproc
-	.align 16
-_dl_tlsdesc_dynamic:
-	/* Like all TLS resolvers, preserve call-clobbered registers.
-	   We need two scratch regs anyway.  */
-	subl	$28, %esp
-	cfi_adjust_cfa_offset (28)
-	movl	%ecx, 20(%esp)
-	movl	%edx, 24(%esp)
-	movl	TLSDESC_ARG(%eax), %eax
-	movl	%gs:DTV_OFFSET, %edx
-	movl	TLSDESC_GEN_COUNT(%eax), %ecx
-	cmpl	(%edx), %ecx
-	ja	.Lslow
-	movl	TLSDESC_MODID(%eax), %ecx
-	movl	(%edx,%ecx,8), %edx
-	cmpl	$-1, %edx
-	je	.Lslow
-	movl	TLSDESC_MODOFF(%eax), %eax
-	addl	%edx, %eax
-.Lret:
-	movl	20(%esp), %ecx
-	subl	%gs:0, %eax
-	movl	24(%esp), %edx
-	addl	$28, %esp
-	cfi_adjust_cfa_offset (-28)
-	ret
-	.p2align 4,,7
-.Lslow:
-	cfi_adjust_cfa_offset (28)
-	call	HIDDEN_JUMPTARGET (___tls_get_addr)
-	jmp	.Lret
-	cfi_endproc
-	.size	_dl_tlsdesc_dynamic, .-_dl_tlsdesc_dynamic
+# define USE_FNSAVE
+# define MINIMUM_ALIGNMENT	4
+# define STATE_SAVE_ALIGNMENT	4
+# define _dl_tlsdesc_dynamic	_dl_tlsdesc_dynamic_fnsave
+# include "dl-tlsdesc-dynamic.h"
+# undef _dl_tlsdesc_dynamic
+# undef MINIMUM_ALIGNMENT
+# undef USE_FNSAVE
+
+# define MINIMUM_ALIGNMENT	16
+
+# define USE_FXSAVE
+# define STATE_SAVE_ALIGNMENT	16
+# define _dl_tlsdesc_dynamic	_dl_tlsdesc_dynamic_fxsave
+# include "dl-tlsdesc-dynamic.h"
+# undef _dl_tlsdesc_dynamic
+# undef USE_FXSAVE
+
+# define USE_XSAVE
+# define STATE_SAVE_ALIGNMENT	64
+# define _dl_tlsdesc_dynamic	_dl_tlsdesc_dynamic_xsave
+# include "dl-tlsdesc-dynamic.h"
+# undef _dl_tlsdesc_dynamic
+# undef USE_XSAVE
+
+# define USE_XSAVEC
+# define STATE_SAVE_ALIGNMENT	64
+# define _dl_tlsdesc_dynamic	_dl_tlsdesc_dynamic_xsavec
+# include "dl-tlsdesc-dynamic.h"
+# undef _dl_tlsdesc_dynamic
+# undef USE_XSAVEC
 #endif /* SHARED */
diff --git a/sysdeps/i386/fpu/libm-test-ulps b/sysdeps/i386/fpu/libm-test-ulps
index 84e6686eba..f2139fc172 100644
--- a/sysdeps/i386/fpu/libm-test-ulps
+++ b/sysdeps/i386/fpu/libm-test-ulps
@@ -1232,6 +1232,7 @@ ldouble: 6
 
 Function: "hypot":
 double: 1
+float: 1
 float128: 1
 ldouble: 1
 
diff --git a/sysdeps/i386/fpu/w_exp10_compat.c b/sysdeps/i386/fpu/w_exp10_compat.c
index b53455386e..49a0e03385 100644
--- a/sysdeps/i386/fpu/w_exp10_compat.c
+++ b/sysdeps/i386/fpu/w_exp10_compat.c
@@ -1,3 +1,8 @@
 /* i386 provides an optimized __ieee754_exp10.  */
-#define NO_COMPAT_NEEDED 1
-#include <math/w_exp10_compat.c>
+#ifdef SHARED
+# define NO_COMPAT_NEEDED 1
+# include <math/w_exp10_compat.c>
+#else
+# include <math-type-macros-double.h>
+# include <w_exp10_template.c>
+#endif
diff --git a/sysdeps/i386/fpu/w_fmod_compat.c b/sysdeps/i386/fpu/w_fmod_compat.c
index 5ac9995ffd..528bfc2a13 100644
--- a/sysdeps/i386/fpu/w_fmod_compat.c
+++ b/sysdeps/i386/fpu/w_fmod_compat.c
@@ -7,8 +7,9 @@
 # define LIBM_SVID_COMPAT 1
 # undef compat_symbol
 # define compat_symbol(a, b, c, d)
-#endif
-#include <math/w_fmod_compat.c>
-#ifdef SHARED
+# include <math/w_fmod_compat.c>
 libm_alias_double (__fmod_compat, fmod)
+#else
+#include <math-type-macros-double.h>
+#include <w_fmod_template.c>
 #endif
diff --git a/sysdeps/i386/fpu/w_fmodf_compat.c b/sysdeps/i386/fpu/w_fmodf_compat.c
index cc417e07d3..5a61693e51 100644
--- a/sysdeps/i386/fpu/w_fmodf_compat.c
+++ b/sysdeps/i386/fpu/w_fmodf_compat.c
@@ -7,8 +7,9 @@
 # define LIBM_SVID_COMPAT 1
 # undef compat_symbol
 # define compat_symbol(a, b, c, d)
-#endif
-#include <math/w_fmodf_compat.c>
-#ifdef SHARED
+# include <math/w_fmodf_compat.c>
 libm_alias_float (__fmod_compat, fmod)
+#else
+#include <math-type-macros-float.h>
+#include <w_fmod_template.c>
 #endif
diff --git a/sysdeps/i386/i586/memcpy.S b/sysdeps/i386/i586/memcpy.S
index 3e26f112d6..79856d498a 100644
--- a/sysdeps/i386/i586/memcpy.S
+++ b/sysdeps/i386/i586/memcpy.S
@@ -26,7 +26,7 @@
 #define LEN	SRC+4
 
         .text
-#if defined PIC && IS_IN (libc)
+#if defined SHARED && IS_IN (libc)
 ENTRY (__memcpy_chk)
 	movl	12(%esp), %eax
 	cmpl	%eax, 16(%esp)
diff --git a/sysdeps/i386/i686/memmove.S b/sysdeps/i386/i686/memmove.S
index f230359ad6..effd958120 100644
--- a/sysdeps/i386/i686/memmove.S
+++ b/sysdeps/i386/i686/memmove.S
@@ -29,7 +29,7 @@
 #define SRC	DEST+4
 #define LEN	SRC+4
 
-#if defined PIC && IS_IN (libc)
+#if defined SHARED && IS_IN (libc)
 ENTRY_CHK (__memmove_chk)
 	movl	12(%esp), %eax
 	cmpl	%eax, 16(%esp)
diff --git a/sysdeps/i386/i686/memset.S b/sysdeps/i386/i686/memset.S
index f02f5a6df7..ab06771ea0 100644
--- a/sysdeps/i386/i686/memset.S
+++ b/sysdeps/i386/i686/memset.S
@@ -27,7 +27,7 @@
 #define LEN	CHR+4
 
         .text
-#if defined PIC && IS_IN (libc)
+#if defined SHARED && IS_IN (libc)
 ENTRY_CHK (__memset_chk)
 	movl	12(%esp), %eax
 	cmpl	%eax, 16(%esp)
diff --git a/sysdeps/i386/i686/multiarch/memrchr-c.c b/sysdeps/i386/i686/multiarch/memrchr-c.c
index ef7bbbe792..20bfdf3af3 100644
--- a/sysdeps/i386/i686/multiarch/memrchr-c.c
+++ b/sysdeps/i386/i686/multiarch/memrchr-c.c
@@ -5,3 +5,4 @@ extern void *__memrchr_ia32 (const void *, int, size_t);
 #endif
 
 #include "string/memrchr.c"
+strong_alias (__memrchr_ia32, __GI___memrchr)
diff --git a/sysdeps/i386/i686/multiarch/memrchr-sse2.S b/sysdeps/i386/i686/multiarch/memrchr-sse2.S
index d9dae04171..e123f87435 100644
--- a/sysdeps/i386/i686/multiarch/memrchr-sse2.S
+++ b/sysdeps/i386/i686/multiarch/memrchr-sse2.S
@@ -720,5 +720,4 @@ L(ret_null):
 	ret
 
 END (__memrchr_sse2)
-strong_alias (__memrchr_sse2, __GI___memrchr)
 #endif
diff --git a/sysdeps/i386/tls-get-addr-wrapper.h b/sysdeps/i386/tls-get-addr-wrapper.h
new file mode 100644
index 0000000000..0708e5ad1d
--- /dev/null
+++ b/sysdeps/i386/tls-get-addr-wrapper.h
@@ -0,0 +1,127 @@
+/* Wrapper of i386 ___tls_get_addr to save and restore vector registers.
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#undef REGISTER_SAVE_AREA
+
+#if !defined USE_FNSAVE && (STATE_SAVE_ALIGNMENT % 16) != 0
+# error STATE_SAVE_ALIGNMENT must be multiple of 16
+#endif
+
+#if DL_RUNTIME_RESOLVE_REALIGN_STACK
+# ifdef USE_FNSAVE
+#  error USE_FNSAVE shouldn't be defined
+# endif
+# ifdef USE_FXSAVE
+/* Use fxsave to save all registers.  */
+#  define REGISTER_SAVE_AREA	512
+# endif
+#else
+# ifdef USE_FNSAVE
+/* Use fnsave to save x87 FPU stack registers.  */
+#  define REGISTER_SAVE_AREA	108
+# else
+#  ifndef USE_FXSAVE
+#   error USE_FXSAVE must be defined
+#  endif
+/* Use fxsave to save all registers.  Add 12 bytes to align the stack
+   to 16 bytes.  */
+#  define REGISTER_SAVE_AREA	(512 + 12)
+# endif
+#endif
+
+#if DL_RUNTIME_RESOLVE_REALIGN_STACK
+	movl	%ebx, 28(%esp)
+	movl	%esp, %ebx
+	cfi_def_cfa_register(%ebx)
+	and	$-STATE_SAVE_ALIGNMENT, %esp
+#endif
+#ifdef REGISTER_SAVE_AREA
+	subl	$REGISTER_SAVE_AREA, %esp
+# if !DL_RUNTIME_RESOLVE_REALIGN_STACK
+	cfi_adjust_cfa_offset(REGISTER_SAVE_AREA)
+# endif
+#else
+# if !DL_RUNTIME_RESOLVE_REALIGN_STACK
+#  error DL_RUNTIME_RESOLVE_REALIGN_STACK must be true
+# endif
+	/* Allocate stack space of the required size to save the state.  */
+	LOAD_PIC_REG (cx)
+	subl	RTLD_GLOBAL_RO_DL_X86_CPU_FEATURES_OFFSET \
+		+XSAVE_STATE_SIZE_OFFSET+_rtld_local_ro@GOTOFF(%ecx), %esp
+#endif
+#ifdef USE_FNSAVE
+	fnsave	(%esp)
+#elif defined USE_FXSAVE
+	fxsave	(%esp)
+#else
+	/* Save the argument for ___tls_get_addr in EAX.  */
+	movl	%eax, %ecx
+	movl	$TLSDESC_CALL_STATE_SAVE_MASK, %eax
+	xorl	%edx, %edx
+	/* Clear the XSAVE Header.  */
+# ifdef USE_XSAVE
+	movl	%edx, (512)(%esp)
+	movl	%edx, (512 + 4 * 1)(%esp)
+	movl	%edx, (512 + 4 * 2)(%esp)
+	movl	%edx, (512 + 4 * 3)(%esp)
+# endif
+	movl	%edx, (512 + 4 * 4)(%esp)
+	movl	%edx, (512 + 4 * 5)(%esp)
+	movl	%edx, (512 + 4 * 6)(%esp)
+	movl	%edx, (512 + 4 * 7)(%esp)
+	movl	%edx, (512 + 4 * 8)(%esp)
+	movl	%edx, (512 + 4 * 9)(%esp)
+	movl	%edx, (512 + 4 * 10)(%esp)
+	movl	%edx, (512 + 4 * 11)(%esp)
+	movl	%edx, (512 + 4 * 12)(%esp)
+	movl	%edx, (512 + 4 * 13)(%esp)
+	movl	%edx, (512 + 4 * 14)(%esp)
+	movl	%edx, (512 + 4 * 15)(%esp)
+# ifdef USE_XSAVE
+	xsave	(%esp)
+# else
+	xsavec	(%esp)
+# endif
+	/* Restore the argument for ___tls_get_addr in EAX.  */
+	movl	%ecx, %eax
+#endif
+	call	___tls_get_addr_internal
+	/* Get register content back.  */
+#ifdef USE_FNSAVE
+	frstor	(%esp)
+#elif defined USE_FXSAVE
+	fxrstor	(%esp)
+#else
+	/* Save and retore ___tls_get_addr return value stored in EAX.  */
+	movl	%eax, %ecx
+	movl	$TLSDESC_CALL_STATE_SAVE_MASK, %eax
+	xorl	%edx, %edx
+	xrstor	(%esp)
+	movl	%ecx, %eax
+#endif
+#if DL_RUNTIME_RESOLVE_REALIGN_STACK
+	mov	%ebx, %esp
+	cfi_def_cfa_register(%esp)
+	movl	28(%esp), %ebx
+	cfi_restore(%ebx)
+#else
+	addl	$REGISTER_SAVE_AREA, %esp
+	cfi_adjust_cfa_offset(-REGISTER_SAVE_AREA)
+#endif
+
+#undef STATE_SAVE_ALIGNMENT
diff --git a/sysdeps/i386/tls_get_addr.S b/sysdeps/i386/tls_get_addr.S
new file mode 100644
index 0000000000..7d143d8a23
--- /dev/null
+++ b/sysdeps/i386/tls_get_addr.S
@@ -0,0 +1,57 @@
+/* Thread-local storage handling in the ELF dynamic linker.  i386 version.
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <tls.h>
+#include <cpu-features-offsets.h>
+#include <features-offsets.h>
+
+	.text
+#ifdef SHARED
+# define USE_FNSAVE
+# define MINIMUM_ALIGNMENT	4
+# define STATE_SAVE_ALIGNMENT	4
+# define ___tls_get_addr	_____tls_get_addr_fnsave
+# include "tls_get_addr.h"
+# undef ___tls_get_addr
+# undef MINIMUM_ALIGNMENT
+# undef USE_FNSAVE
+
+# define MINIMUM_ALIGNMENT	16
+
+# define USE_FXSAVE
+# define STATE_SAVE_ALIGNMENT	16
+# define ___tls_get_addr	_____tls_get_addr_fxsave
+# include "tls_get_addr.h"
+# undef ___tls_get_addr
+# undef USE_FXSAVE
+
+# define USE_XSAVE
+# define STATE_SAVE_ALIGNMENT	64
+# define ___tls_get_addr	_____tls_get_addr_xsave
+# include "tls_get_addr.h"
+# undef ___tls_get_addr
+# undef USE_XSAVE
+
+# define USE_XSAVEC
+# define STATE_SAVE_ALIGNMENT	64
+# define ___tls_get_addr	_____tls_get_addr_xsavec
+# include "tls_get_addr.h"
+# undef ___tls_get_addr
+# undef USE_XSAVEC
+#endif /* SHARED */
diff --git a/sysdeps/i386/tls_get_addr.h b/sysdeps/i386/tls_get_addr.h
new file mode 100644
index 0000000000..1825798724
--- /dev/null
+++ b/sysdeps/i386/tls_get_addr.h
@@ -0,0 +1,42 @@
+/* Thread-local storage handling in the ELF dynamic linker.  i386 version.
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+	.hidden ___tls_get_addr
+	.global	___tls_get_addr
+	.type	___tls_get_addr,@function
+
+	/* This function is a wrapper of ___tls_get_addr_internal to
+	   preserve caller-saved vector registers.  */
+
+	cfi_startproc
+	.align 16
+___tls_get_addr:
+	/* Like all TLS resolvers, preserve call-clobbered registers.
+	   We need two scratch regs anyway.  */
+	subl	$32, %esp
+	cfi_adjust_cfa_offset (32)
+	movl	%ecx, 20(%esp)
+	movl	%edx, 24(%esp)
+#include "tls-get-addr-wrapper.h"
+	movl	20(%esp), %ecx
+	movl	24(%esp), %edx
+	addl	$32, %esp
+	cfi_adjust_cfa_offset (-32)
+	ret
+	cfi_endproc
+	.size	___tls_get_addr, .-___tls_get_addr
diff --git a/sysdeps/ieee754/dbl-64/e_atanh.c b/sysdeps/ieee754/dbl-64/e_atanh.c
index 11a2a45799..05ac0a1b30 100644
--- a/sysdeps/ieee754/dbl-64/e_atanh.c
+++ b/sysdeps/ieee754/dbl-64/e_atanh.c
@@ -44,6 +44,11 @@
 
 static const double huge = 1e300;
 
+#ifndef SECTION
+# define SECTION
+#endif
+
+SECTION
 double
 __ieee754_atanh (double x)
 {
@@ -73,4 +78,7 @@ __ieee754_atanh (double x)
 
   return copysign (t, x);
 }
+
+#ifndef __ieee754_atanh
 libm_alias_finite (__ieee754_atanh, __atanh)
+#endif
diff --git a/sysdeps/ieee754/dbl-64/e_sinh.c b/sysdeps/ieee754/dbl-64/e_sinh.c
index b4b5857ddd..3f787967f9 100644
--- a/sysdeps/ieee754/dbl-64/e_sinh.c
+++ b/sysdeps/ieee754/dbl-64/e_sinh.c
@@ -41,6 +41,11 @@ static char rcsid[] = "$NetBSD: e_sinh.c,v 1.7 1995/05/10 20:46:13 jtc Exp $";
 
 static const double one = 1.0, shuge = 1.0e307;
 
+#ifndef SECTION
+# define SECTION
+#endif
+
+SECTION
 double
 __ieee754_sinh (double x)
 {
@@ -90,4 +95,7 @@ __ieee754_sinh (double x)
   /* |x| > overflowthresold, sinh(x) overflow */
   return math_narrow_eval (x * shuge);
 }
+
+#ifndef __ieee754_sinh
 libm_alias_finite (__ieee754_sinh, __sinh)
+#endif
diff --git a/sysdeps/ieee754/dbl-64/math_config.h b/sysdeps/ieee754/dbl-64/math_config.h
index ef87cfa6be..05515fd95a 100644
--- a/sysdeps/ieee754/dbl-64/math_config.h
+++ b/sysdeps/ieee754/dbl-64/math_config.h
@@ -195,16 +195,18 @@ check_uflow (double x)
 extern const struct exp_data
 {
   double invln2N;
-  double shift;
   double negln2hiN;
   double negln2loN;
   double poly[4]; /* Last four coefficients.  */
+  double shift;
+
   double exp2_shift;
   double exp2_poly[EXP2_POLY_ORDER];
-  double invlog10_2N;
+
   double neglog10_2hiN;
   double neglog10_2loN;
   double exp10_poly[5];
+  double invlog10_2N;
   uint64_t tab[2*(1 << EXP_TABLE_BITS)];
 } __exp_data attribute_hidden;
 
diff --git a/sysdeps/ieee754/dbl-64/s_tanh.c b/sysdeps/ieee754/dbl-64/s_tanh.c
index 673a97102d..13063db04e 100644
--- a/sysdeps/ieee754/dbl-64/s_tanh.c
+++ b/sysdeps/ieee754/dbl-64/s_tanh.c
@@ -46,6 +46,11 @@ static char rcsid[] = "$NetBSD: s_tanh.c,v 1.7 1995/05/10 20:48:22 jtc Exp $";
 
 static const double one = 1.0, two = 2.0, tiny = 1.0e-300;
 
+#ifndef SECTION
+# define SECTION
+#endif
+
+SECTION
 double
 __tanh (double x)
 {
diff --git a/sysdeps/ieee754/float128/s_isnanf128.c b/sysdeps/ieee754/float128/s_isnanf128.c
index 59f71533ce..b73a4e80d7 100644
--- a/sysdeps/ieee754/float128/s_isnanf128.c
+++ b/sysdeps/ieee754/float128/s_isnanf128.c
@@ -11,7 +11,11 @@
 #include "../ldbl-128/s_isnanl.c"
 #if !IS_IN (libm)
 #include <float128-abi.h>
+#ifdef SHARED
 hidden_ver (__isnanf128_impl, __isnanf128)
+#else
+strong_alias (__isnanf128_impl, __isnanf128)
+#endif
 _weak_alias (__isnanf128_impl, isnanl)
 versioned_symbol (libc, __isnanf128_impl, __isnanf128, GLIBC_2_34);
 #if (SHLIB_COMPAT (libc, FLOAT128_VERSION_M, GLIBC_2_34))
diff --git a/sysdeps/ieee754/flt-32/math_config.h b/sysdeps/ieee754/flt-32/math_config.h
index 729f22cd4f..dc07ebd459 100644
--- a/sysdeps/ieee754/flt-32/math_config.h
+++ b/sysdeps/ieee754/flt-32/math_config.h
@@ -166,9 +166,9 @@ extern const struct exp2f_data
   uint64_t tab[1 << EXP2F_TABLE_BITS];
   double shift_scaled;
   double poly[EXP2F_POLY_ORDER];
-  double shift;
   double invln2_scaled;
   double poly_scaled[EXP2F_POLY_ORDER];
+  double shift;
 } __exp2f_data attribute_hidden;
 
 #define LOGF_TABLE_BITS 4
diff --git a/sysdeps/ieee754/ldbl-64-128/s_copysignl.c b/sysdeps/ieee754/ldbl-64-128/s_copysignl.c
index 11b42d04ba..80137847d3 100644
--- a/sysdeps/ieee754/ldbl-64-128/s_copysignl.c
+++ b/sysdeps/ieee754/ldbl-64-128/s_copysignl.c
@@ -1,10 +1,10 @@
 #include <math_ldbl_opt.h>
 #include <libm-alias-ldouble.h>
-#if IS_IN (libc)
+#if IS_IN (libc) && defined SHARED
 # undef libm_alias_ldouble
 # define libm_alias_ldouble(from, to)
 #endif
 #include <sysdeps/ieee754/ldbl-128/s_copysignl.c>
-#if IS_IN (libc)
+#if IS_IN (libc) && defined SHARED
 long_double_symbol (libc, __copysignl, copysignl);
 #endif
diff --git a/sysdeps/ieee754/ldbl-64-128/s_frexpl.c b/sysdeps/ieee754/ldbl-64-128/s_frexpl.c
index 73ac41e40c..f5f7d349f7 100644
--- a/sysdeps/ieee754/ldbl-64-128/s_frexpl.c
+++ b/sysdeps/ieee754/ldbl-64-128/s_frexpl.c
@@ -1,10 +1,10 @@
 #include <math_ldbl_opt.h>
 #include <libm-alias-ldouble.h>
-#if IS_IN (libc)
+#if IS_IN (libc) && defined SHARED
 # undef libm_alias_ldouble
 # define libm_alias_ldouble(from, to)
 #endif
 #include <sysdeps/ieee754/ldbl-128/s_frexpl.c>
-#if IS_IN (libc)
+#if IS_IN (libc) && defined SHARED
 long_double_symbol (libc, __frexpl, frexpl);
 #endif
diff --git a/sysdeps/ieee754/ldbl-64-128/s_modfl.c b/sysdeps/ieee754/ldbl-64-128/s_modfl.c
index 7d7aeae111..ba3d31334a 100644
--- a/sysdeps/ieee754/ldbl-64-128/s_modfl.c
+++ b/sysdeps/ieee754/ldbl-64-128/s_modfl.c
@@ -1,10 +1,10 @@
 #include <math_ldbl_opt.h>
 #include <libm-alias-ldouble.h>
-#if IS_IN (libc)
+#if IS_IN (libc) && defined SHARED
 # undef libm_alias_ldouble
 # define libm_alias_ldouble(from, to)
 #endif
 #include <sysdeps/ieee754/ldbl-128/s_modfl.c>
-#if IS_IN (libc)
+#if IS_IN (libc) && defined SHARED
 long_double_symbol (libc, __modfl, modfl);
 #endif
diff --git a/sysdeps/ieee754/ldbl-opt/s_ldexpl.c b/sysdeps/ieee754/ldbl-opt/s_ldexpl.c
index 1afbe7d8ad..932cc4341c 100644
--- a/sysdeps/ieee754/ldbl-opt/s_ldexpl.c
+++ b/sysdeps/ieee754/ldbl-opt/s_ldexpl.c
@@ -17,13 +17,13 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#if IS_IN (libc)
+#if IS_IN (libc) && defined SHARED
 # define declare_mgen_alias(f,t)
 #endif
 #include <math-type-macros-ldouble.h>
 #include <s_ldexp_template.c>
 
-#if IS_IN (libc)
+#if IS_IN (libc) && defined SHARED
 long_double_symbol (libc, __ldexpl, ldexpl);
 long_double_symbol (libc, __wrap_scalbnl, scalbnl);
 #endif
diff --git a/sysdeps/loongarch/fpu/e_scalbf.c b/sysdeps/loongarch/fpu/e_scalbf.c
index 9f05485236..7c0395fbb5 100644
--- a/sysdeps/loongarch/fpu/e_scalbf.c
+++ b/sysdeps/loongarch/fpu/e_scalbf.c
@@ -57,4 +57,4 @@ __ieee754_scalbf (float x, float fn)
 
   return x;
 }
-libm_alias_finite (__ieee754_scalb, __scalb)
+libm_alias_finite (__ieee754_scalbf, __scalbf)
diff --git a/sysdeps/loongarch/lp64/multiarch/Makefile b/sysdeps/loongarch/lp64/multiarch/Makefile
index fe863e1ba4..01762ef526 100644
--- a/sysdeps/loongarch/lp64/multiarch/Makefile
+++ b/sysdeps/loongarch/lp64/multiarch/Makefile
@@ -1,52 +1,52 @@
 ifeq ($(subdir),string)
 sysdep_routines += \
-  strlen-aligned \
-  strlen-lsx \
-  strlen-lasx \
-  strnlen-aligned \
-  strnlen-lsx \
-  strnlen-lasx \
+  memchr-aligned \
+  memchr-lasx \
+  memchr-lsx \
+  memcmp-aligned \
+  memcmp-lasx \
+  memcmp-lsx \
+  memcpy-aligned \
+  memcpy-unaligned \
+  memmove-lasx \
+  memmove-lsx \
+  memmove-unaligned \
+  memrchr-generic \
+  memrchr-lasx \
+  memrchr-lsx \
+  memset-aligned \
+  memset-lasx \
+  memset-lsx \
+  memset-unaligned \
+  rawmemchr-aligned \
+  rawmemchr-lasx \
+  rawmemchr-lsx \
+  stpcpy-aligned \
+  stpcpy-lasx \
+  stpcpy-lsx \
+  stpcpy-unaligned \
   strchr-aligned \
-  strchr-lsx \
   strchr-lasx \
-  strrchr-aligned \
-  strrchr-lsx \
-  strrchr-lasx \
+  strchr-lsx \
   strchrnul-aligned \
-  strchrnul-lsx \
   strchrnul-lasx \
+  strchrnul-lsx \
   strcmp-aligned \
   strcmp-lsx \
-  strncmp-aligned \
-  strncmp-lsx \
   strcpy-aligned \
-  strcpy-unaligned \
-  strcpy-lsx \
   strcpy-lasx \
-  stpcpy-aligned \
-  stpcpy-unaligned \
-  stpcpy-lsx \
-  stpcpy-lasx \
-  memcpy-aligned \
-  memcpy-unaligned \
-  memmove-unaligned \
-  memmove-lsx \
-  memmove-lasx \
-  rawmemchr-aligned \
-  rawmemchr-lsx \
-  rawmemchr-lasx \
-  memchr-aligned \
-  memchr-lsx \
-  memchr-lasx \
-  memrchr-generic \
-  memrchr-lsx \
-  memrchr-lasx \
-  memset-aligned \
-  memset-unaligned \
-  memset-lsx \
-  memset-lasx \
-  memcmp-aligned \
-  memcmp-lsx \
-  memcmp-lasx \
+  strcpy-lsx \
+  strcpy-unaligned \
+  strlen-aligned \
+  strlen-lasx \
+  strlen-lsx \
+  strncmp-aligned \
+  strncmp-lsx \
+  strnlen-aligned \
+  strnlen-lasx \
+  strnlen-lsx \
+  strrchr-aligned \
+  strrchr-lasx \
+  strrchr-lsx \
 # sysdep_routines
 endif
diff --git a/sysdeps/loongarch/lp64/multiarch/dl-symbol-redir-ifunc.h b/sysdeps/loongarch/lp64/multiarch/dl-symbol-redir-ifunc.h
index cb640d77b7..a73390b12f 100644
--- a/sysdeps/loongarch/lp64/multiarch/dl-symbol-redir-ifunc.h
+++ b/sysdeps/loongarch/lp64/multiarch/dl-symbol-redir-ifunc.h
@@ -19,6 +19,9 @@
 #ifndef _DL_IFUNC_GENERIC_H
 #define _DL_IFUNC_GENERIC_H
 
+#ifndef SHARED
 asm ("memset = __memset_aligned");
+asm ("memcmp = __memcmp_aligned");
+#endif
 
 #endif
diff --git a/sysdeps/loongarch/preconfigure b/sysdeps/loongarch/preconfigure
index dfc7ecfd9e..6b015ae5dc 100644
--- a/sysdeps/loongarch/preconfigure
+++ b/sysdeps/loongarch/preconfigure
@@ -43,6 +43,7 @@ loongarch*)
 
 
     base_machine=loongarch
+    mtls_traditional=trad
     ;;
 esac
 
diff --git a/sysdeps/loongarch/preconfigure.ac b/sysdeps/loongarch/preconfigure.ac
index 67e4357013..31e9579e63 100644
--- a/sysdeps/loongarch/preconfigure.ac
+++ b/sysdeps/loongarch/preconfigure.ac
@@ -41,6 +41,7 @@ loongarch*)
     AC_DEFINE_UNQUOTED([LOONGARCH_ABI_FRLEN], [$abi_flen])
 
     base_machine=loongarch
+    mtls_traditional=trad
     ;;
 esac
 
diff --git a/sysdeps/m68k/bits/wordsize.h b/sysdeps/m68k/bits/wordsize.h
new file mode 100644
index 0000000000..6ecbfe7c86
--- /dev/null
+++ b/sysdeps/m68k/bits/wordsize.h
@@ -0,0 +1,21 @@
+/* Copyright (C) 1999-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define __WORDSIZE			32
+#define __WORDSIZE_TIME64_COMPAT32	1
+#define __WORDSIZE32_SIZE_ULONG		0
+#define __WORDSIZE32_PTRDIFF_LONG	0
diff --git a/sysdeps/m68k/m680x0/fpu/w_exp10_compat.c b/sysdeps/m68k/m680x0/fpu/w_exp10_compat.c
index 0d3e718626..350f2e4b4d 100644
--- a/sysdeps/m68k/m680x0/fpu/w_exp10_compat.c
+++ b/sysdeps/m68k/m680x0/fpu/w_exp10_compat.c
@@ -1,3 +1,8 @@
 /* m68k provides an optimized __ieee754_exp10.  */
-#define NO_COMPAT_NEEDED 1
-#include <math/w_exp10_compat.c>
+#ifdef SHARED
+# define NO_COMPAT_NEEDED 1
+# include <math/w_exp10_compat.c>
+#else
+# include <math-type-macros-double.h>
+# include <w_exp10_template.c>
+#endif
diff --git a/sysdeps/m68k/m680x0/fpu/w_fmod_compat.c b/sysdeps/m68k/m680x0/fpu/w_fmod_compat.c
index 527d4fbed2..57f38091e6 100644
--- a/sysdeps/m68k/m680x0/fpu/w_fmod_compat.c
+++ b/sysdeps/m68k/m680x0/fpu/w_fmod_compat.c
@@ -7,8 +7,9 @@
 # define LIBM_SVID_COMPAT 1
 # undef compat_symbol
 # define compat_symbol(a, b, c, d)
-#endif
 #include <math/w_fmod_compat.c>
-#ifdef SHARED
 libm_alias_double (__fmod_compat, fmod)
+#else
+#include <math-type-macros-double.h>
+#include <w_fmod_template.c>
 #endif
diff --git a/sysdeps/m68k/m680x0/fpu/w_fmodf_compat.c b/sysdeps/m68k/m680x0/fpu/w_fmodf_compat.c
index 5043586b91..88db07f443 100644
--- a/sysdeps/m68k/m680x0/fpu/w_fmodf_compat.c
+++ b/sysdeps/m68k/m680x0/fpu/w_fmodf_compat.c
@@ -7,8 +7,9 @@
 # define LIBM_SVID_COMPAT 1
 # undef compat_symbol
 # define compat_symbol(a, b, c, d)
-#endif
-#include <math/w_fmodf_compat.c>
-#ifdef SHARED
+# include <math/w_fmodf_compat.c>
 libm_alias_float (__fmod_compat, fmod)
+#else
+#include <math-type-macros-float.h>
+#include <w_fmod_template.c>
 #endif
diff --git a/sysdeps/m68k/utmp-size.h b/sysdeps/m68k/utmp-size.h
new file mode 100644
index 0000000000..5946685819
--- /dev/null
+++ b/sysdeps/m68k/utmp-size.h
@@ -0,0 +1,3 @@
+/* m68k has 2-byte alignment.  */
+#define UTMP_SIZE 382
+#define LASTLOG_SIZE 292
diff --git a/sysdeps/mach/hurd/bits/socket.h b/sysdeps/mach/hurd/bits/socket.h
index 3e72f9fa93..b5eeac3731 100644
--- a/sysdeps/mach/hurd/bits/socket.h
+++ b/sysdeps/mach/hurd/bits/socket.h
@@ -153,7 +153,7 @@ enum __socket_type
 #include <bits/sockaddr.h>
 
 /* Structure describing a generic socket address.  */
-struct sockaddr
+struct __attribute_struct_may_alias__ sockaddr
   {
     __SOCKADDR_COMMON (sa_);	/* Common data: address family and length.  */
     char sa_data[14];		/* Address data.  */
@@ -170,7 +170,7 @@ struct sockaddr
 #define _SS_PADSIZE \
   (_SS_SIZE - __SOCKADDR_COMMON_SIZE - sizeof (__ss_aligntype))
 
-struct sockaddr_storage
+struct __attribute_struct_may_alias__ sockaddr_storage
   {
     __SOCKADDR_COMMON (ss_);	/* Address family, etc.  */
     char __ss_padding[_SS_PADSIZE];
diff --git a/sysdeps/microblaze/bits/wordsize.h b/sysdeps/microblaze/bits/wordsize.h
new file mode 100644
index 0000000000..6ecbfe7c86
--- /dev/null
+++ b/sysdeps/microblaze/bits/wordsize.h
@@ -0,0 +1,21 @@
+/* Copyright (C) 1999-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define __WORDSIZE			32
+#define __WORDSIZE_TIME64_COMPAT32	1
+#define __WORDSIZE32_SIZE_ULONG		0
+#define __WORDSIZE32_PTRDIFF_LONG	0
diff --git a/sysdeps/microblaze/utmp-size.h b/sysdeps/microblaze/utmp-size.h
new file mode 100644
index 0000000000..8f21ebe1b6
--- /dev/null
+++ b/sysdeps/microblaze/utmp-size.h
@@ -0,0 +1,2 @@
+#define UTMP_SIZE 384
+#define LASTLOG_SIZE 292
diff --git a/sysdeps/mips/bits/wordsize.h b/sysdeps/mips/bits/wordsize.h
index 57f0f2a22f..30dd3fd85d 100644
--- a/sysdeps/mips/bits/wordsize.h
+++ b/sysdeps/mips/bits/wordsize.h
@@ -19,11 +19,7 @@
 
 #define __WORDSIZE			_MIPS_SZPTR
 
-#if _MIPS_SIM == _ABI64
-# define __WORDSIZE_TIME64_COMPAT32	1
-#else
-# define __WORDSIZE_TIME64_COMPAT32	0
-#endif
+#define __WORDSIZE_TIME64_COMPAT32	1
 
 #if __WORDSIZE == 32
 #define __WORDSIZE32_SIZE_ULONG		0
diff --git a/sysdeps/mips/mips64/libm-test-ulps b/sysdeps/mips/mips64/libm-test-ulps
index 78969745b2..933aba4735 100644
--- a/sysdeps/mips/mips64/libm-test-ulps
+++ b/sysdeps/mips/mips64/libm-test-ulps
@@ -1066,17 +1066,17 @@ double: 1
 ldouble: 1
 
 Function: "j0":
-double: 2
+double: 3
 float: 9
 ldouble: 2
 
 Function: "j0_downward":
-double: 5
+double: 6
 float: 9
 ldouble: 9
 
 Function: "j0_towardzero":
-double: 6
+double: 7
 float: 9
 ldouble: 9
 
@@ -1146,6 +1146,7 @@ float: 6
 ldouble: 8
 
 Function: "log":
+double: 1
 float: 1
 ldouble: 1
 
diff --git a/sysdeps/mips/utmp-size.h b/sysdeps/mips/utmp-size.h
new file mode 100644
index 0000000000..8f21ebe1b6
--- /dev/null
+++ b/sysdeps/mips/utmp-size.h
@@ -0,0 +1,2 @@
+#define UTMP_SIZE 384
+#define LASTLOG_SIZE 292
diff --git a/sysdeps/nios2/bits/wordsize.h b/sysdeps/nios2/bits/wordsize.h
new file mode 100644
index 0000000000..6ecbfe7c86
--- /dev/null
+++ b/sysdeps/nios2/bits/wordsize.h
@@ -0,0 +1,21 @@
+/* Copyright (C) 1999-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define __WORDSIZE			32
+#define __WORDSIZE_TIME64_COMPAT32	1
+#define __WORDSIZE32_SIZE_ULONG		0
+#define __WORDSIZE32_PTRDIFF_LONG	0
diff --git a/sysdeps/nios2/utmp-size.h b/sysdeps/nios2/utmp-size.h
new file mode 100644
index 0000000000..8f21ebe1b6
--- /dev/null
+++ b/sysdeps/nios2/utmp-size.h
@@ -0,0 +1,2 @@
+#define UTMP_SIZE 384
+#define LASTLOG_SIZE 292
diff --git a/sysdeps/nptl/bits/thread-shared-types.h b/sysdeps/nptl/bits/thread-shared-types.h
index df54eef6f7..bccc2003ec 100644
--- a/sysdeps/nptl/bits/thread-shared-types.h
+++ b/sysdeps/nptl/bits/thread-shared-types.h
@@ -95,11 +95,12 @@ struct __pthread_cond_s
 {
   __atomic_wide_counter __wseq;
   __atomic_wide_counter __g1_start;
-  unsigned int __g_refs[2] __LOCK_ALIGNMENT;
-  unsigned int __g_size[2];
+  unsigned int __g_size[2] __LOCK_ALIGNMENT;
   unsigned int __g1_orig_size;
   unsigned int __wrefs;
   unsigned int __g_signals[2];
+  unsigned int __unused_initialized_1;
+  unsigned int __unused_initialized_2;
 };
 
 typedef unsigned int __tss_t;
diff --git a/sysdeps/nptl/dl-tls_init_tp.c b/sysdeps/nptl/dl-tls_init_tp.c
index 092c274f36..ed10185e37 100644
--- a/sysdeps/nptl/dl-tls_init_tp.c
+++ b/sysdeps/nptl/dl-tls_init_tp.c
@@ -23,6 +23,7 @@
 #include <tls.h>
 #include <rseq-internal.h>
 #include <thread_pointer.h>
+#include <dl-symbol-redir-ifunc.h>
 
 #define TUNABLE_NAMESPACE pthread
 #include <dl-tunables.h>
@@ -45,8 +46,6 @@ rtld_mutex_dummy (pthread_mutex_t *lock)
 #endif
 
 const unsigned int __rseq_flags;
-const unsigned int __rseq_size attribute_relro;
-const ptrdiff_t __rseq_offset attribute_relro;
 
 void
 __tls_pre_init_tp (void)
@@ -104,12 +103,7 @@ __tls_init_tp (void)
     bool do_rseq = true;
     do_rseq = TUNABLE_GET (rseq, int, NULL);
     if (rseq_register_current_thread (pd, do_rseq))
-      {
-        /* We need a writable view of the variables.  They are in
-           .data.relro and are not yet write-protected.  */
-        extern unsigned int size __asm__ ("__rseq_size");
-        size = sizeof (pd->rseq_area);
-      }
+      _rseq_size = RSEQ_AREA_SIZE_INITIAL_USED;
 
 #ifdef RSEQ_SIG
     /* This should be a compile-time constant, but the current
@@ -117,8 +111,7 @@ __tls_init_tp (void)
        all targets support __thread_pointer, so set __rseq_offset only
        if the rseq registration may have happened because RSEQ_SIG is
        defined.  */
-    extern ptrdiff_t offset __asm__ ("__rseq_offset");
-    offset = (char *) &pd->rseq_area - (char *) __thread_pointer ();
+    _rseq_offset = (char *) &pd->rseq_area - (char *) __thread_pointer ();
 #endif
   }
 
diff --git a/sysdeps/nptl/pthread.h b/sysdeps/nptl/pthread.h
index 1607fdf29a..e0f24418fe 100644
--- a/sysdeps/nptl/pthread.h
+++ b/sysdeps/nptl/pthread.h
@@ -152,7 +152,7 @@ enum
 
 
 /* Conditional variable handling.  */
-#define PTHREAD_COND_INITIALIZER { { {0}, {0}, {0, 0}, {0, 0}, 0, 0, {0, 0} } }
+#define PTHREAD_COND_INITIALIZER { { {0}, {0}, {0, 0}, 0, 0, {0, 0}, 0, 0 } }
 
 
 /* Cleanup buffers */
@@ -223,7 +223,7 @@ extern int pthread_join (pthread_t __th, void **__thread_return);
    the thread in *THREAD_RETURN, if THREAD_RETURN is not NULL.  */
 extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) __THROW;
 
-# ifndef __USE_TIME_BITS64
+# ifndef __USE_TIME64_REDIRECTS
 /* Make calling thread wait for termination of the thread TH, but only
    until TIMEOUT.  The exit status of the thread is stored in
    *THREAD_RETURN, if THREAD_RETURN is not NULL.
@@ -796,7 +796,7 @@ extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
 
 #ifdef __USE_XOPEN2K
 /* Wait until lock becomes available, or specified time passes. */
-# ifndef __USE_TIME_BITS64
+# ifndef __USE_TIME64_REDIRECTS
 extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
 				    const struct timespec *__restrict
 				    __abstime) __THROWNL __nonnull ((1, 2));
@@ -813,7 +813,7 @@ extern int __REDIRECT_NTHNL (pthread_mutex_timedlock,
 #endif
 
 #ifdef __USE_GNU
-# ifndef __USE_TIME_BITS64
+# ifndef __USE_TIME64_REDIRECTS
 extern int pthread_mutex_clocklock (pthread_mutex_t *__restrict __mutex,
 				    clockid_t __clockid,
 				    const struct timespec *__restrict
@@ -982,7 +982,7 @@ extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
 
 # ifdef __USE_XOPEN2K
 /* Try to acquire read lock for RWLOCK or return after specified time.  */
-#  ifndef __USE_TIME_BITS64
+#  ifndef __USE_TIME64_REDIRECTS
 extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
 				       const struct timespec *__restrict
 				       __abstime) __THROWNL __nonnull ((1, 2));
@@ -1000,7 +1000,7 @@ extern int __REDIRECT_NTHNL (pthread_rwlock_timedrdlock,
 # endif
 
 # ifdef __USE_GNU
-#  ifndef __USE_TIME_BITS64
+#  ifndef __USE_TIME64_REDIRECTS
 extern int pthread_rwlock_clockrdlock (pthread_rwlock_t *__restrict __rwlock,
 				       clockid_t __clockid,
 				       const struct timespec *__restrict
@@ -1029,7 +1029,7 @@ extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
 
 # ifdef __USE_XOPEN2K
 /* Try to acquire write lock for RWLOCK or return after specified time.  */
-#  ifndef __USE_TIME_BITS64
+#  ifndef __USE_TIME64_REDIRECTS
 extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
 				       const struct timespec *__restrict
 				       __abstime) __THROWNL __nonnull ((1, 2));
@@ -1047,7 +1047,7 @@ extern int __REDIRECT_NTHNL (pthread_rwlock_timedwrlock,
 # endif
 
 # ifdef __USE_GNU
-#  ifndef __USE_TIME_BITS64
+#  ifndef __USE_TIME64_REDIRECTS
 extern int pthread_rwlock_clockwrlock (pthread_rwlock_t *__restrict __rwlock,
 				       clockid_t __clockid,
 				       const struct timespec *__restrict
@@ -1141,7 +1141,7 @@ extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
 
    This function is a cancellation point and therefore not marked with
    __THROW.  */
-# ifndef __USE_TIME_BITS64
+# ifndef __USE_TIME64_REDIRECTS
 extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
 				   pthread_mutex_t *__restrict __mutex,
 				   const struct timespec *__restrict __abstime)
@@ -1167,7 +1167,7 @@ extern int __REDIRECT (pthread_cond_timedwait,
 
    This function is a cancellation point and therefore not marked with
    __THROW. */
-#  ifndef __USE_TIME_BITS64
+#  ifndef __USE_TIME64_REDIRECTS
 extern int pthread_cond_clockwait (pthread_cond_t *__restrict __cond,
 				   pthread_mutex_t *__restrict __mutex,
 				   __clockid_t __clock_id,
diff --git a/sysdeps/or1k/utmp-size.h b/sysdeps/or1k/utmp-size.h
new file mode 100644
index 0000000000..6b3653aa4d
--- /dev/null
+++ b/sysdeps/or1k/utmp-size.h
@@ -0,0 +1,3 @@
+/* or1k has less padding than other architectures with 64-bit time_t.  */
+#define UTMP_SIZE 392
+#define LASTLOG_SIZE 296
diff --git a/sysdeps/posix/libc_fatal.c b/sysdeps/posix/libc_fatal.c
index f9e3425e04..089c47b04b 100644
--- a/sysdeps/posix/libc_fatal.c
+++ b/sysdeps/posix/libc_fatal.c
@@ -20,6 +20,7 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <ldsodefs.h>
+#include <libc-pointer-arith.h>
 #include <paths.h>
 #include <stdarg.h>
 #include <stdbool.h>
@@ -105,7 +106,8 @@ __libc_message_impl (const char *fmt, ...)
     {
       WRITEV_FOR_FATAL (fd, iov, iovcnt, total);
 
-      total = (total + 1 + GLRO(dl_pagesize) - 1) & ~(GLRO(dl_pagesize) - 1);
+      total = ALIGN_UP (total + sizeof (struct abort_msg_s) + 1,
+			GLRO(dl_pagesize));
       struct abort_msg_s *buf = __mmap (NULL, total,
 					PROT_READ | PROT_WRITE,
 					MAP_ANON | MAP_PRIVATE, -1, 0);
diff --git a/sysdeps/powerpc/Makefile b/sysdeps/powerpc/Makefile
index 5e6cb07ce6..5cdb64f29b 100644
--- a/sysdeps/powerpc/Makefile
+++ b/sysdeps/powerpc/Makefile
@@ -28,6 +28,11 @@ tst-cache-ppc-static-dlopen-ENV = LD_LIBRARY_PATH=$(objpfx):$(common-objpfx):$(c
 $(objpfx)tst-cache-ppc-static-dlopen.out: $(objpfx)mod-cache-ppc.so
 
 $(objpfx)tst-cache-ppc: $(objpfx)mod-cache-ppc.so
+
+# The test checks if the __tls_get_addr does not clobber caller-saved
+# register, so disable the powerpc specific optimization to force a
+# __tls_get_addr call.
+LDFLAGS-tst-tls23-mod.so = -Wl,--no-tls-get-addr-optimize
 endif
 
 ifneq (no,$(multi-arch))
diff --git a/sysdeps/powerpc/dl-procinfo.c b/sysdeps/powerpc/dl-procinfo.c
index a76bb6e5b0..8cf00aa7e3 100644
--- a/sysdeps/powerpc/dl-procinfo.c
+++ b/sysdeps/powerpc/dl-procinfo.c
@@ -38,6 +38,10 @@
        needed.
   */
 
+/* The total number of available bits (including those prior to
+   _DL_HWCAP_FIRST).  Some of these bits might not be used.  */
+#define _DL_HWCAP_COUNT         128
+
 #ifndef PROCINFO_CLASS
 # define PROCINFO_CLASS
 #endif
@@ -61,7 +65,7 @@ PROCINFO_CLASS struct cpu_features _dl_powerpc_cpu_features
 #if !defined PROCINFO_DECL && defined SHARED
   ._dl_powerpc_cap_flags
 #else
-PROCINFO_CLASS const char _dl_powerpc_cap_flags[64][15]
+PROCINFO_CLASS const char _dl_powerpc_cap_flags[_DL_HWCAP_COUNT][15]
 #endif
 #ifndef PROCINFO_DECL
 = {
diff --git a/sysdeps/powerpc/dl-procinfo.h b/sysdeps/powerpc/dl-procinfo.h
index 68f4241095..b36697ba44 100644
--- a/sysdeps/powerpc/dl-procinfo.h
+++ b/sysdeps/powerpc/dl-procinfo.h
@@ -22,22 +22,23 @@
 #include <ldsodefs.h>
 #include <sysdep.h>	/* This defines the PPC_FEATURE[2]_* macros.  */
 
-/* The total number of available bits (including those prior to
-   _DL_HWCAP_FIRST).  Some of these bits might not be used.  */
-#define _DL_HWCAP_COUNT		64
+/* Feature masks are all 32-bits in size.  */
+#define _DL_HWCAP_SIZE		32
 
-/* Features started at bit 31 and decremented as new features were added.  */
-#define _DL_HWCAP_LAST		31
+/* AT_HWCAP2 feature strings follow the AT_HWCAP feature strings.  */
+#define _DL_HWCAP2_OFFSET	_DL_HWCAP_SIZE
 
-/* AT_HWCAP2 features started at bit 31 and decremented as new features were
-   added.  HWCAP2 feature bits start at bit 0.  */
-#define _DL_HWCAP2_LAST		31
+/* AT_HWCAP3 feature strings follow the AT_HWCAP2 feature strings.  */
+#define _DL_HWCAP3_OFFSET	(_DL_HWCAP2_OFFSET + _DL_HWCAP_SIZE)
+
+/* AT_HWCAP4 feature strings follow the AT_HWCAP3 feature strings.  */
+#define _DL_HWCAP4_OFFSET	(_DL_HWCAP3_OFFSET + _DL_HWCAP_SIZE)
 
 /* These bits influence library search.  */
 #define HWCAP_IMPORTANT		(PPC_FEATURE_HAS_ALTIVEC \
 				+ PPC_FEATURE_HAS_DFP)
 
-#define _DL_PLATFORMS_COUNT	16
+#define _DL_PLATFORMS_COUNT	17
 
 #define _DL_FIRST_PLATFORM	32
 /* Mask to filter out platforms.  */
@@ -61,6 +62,7 @@
 #define PPC_PLATFORM_POWER8		13
 #define PPC_PLATFORM_POWER9		14
 #define PPC_PLATFORM_POWER10		15
+#define PPC_PLATFORM_POWER11		16
 
 static inline const char *
 __attribute__ ((unused))
@@ -88,6 +90,11 @@ _dl_string_platform (const char *str)
 	      ret = _DL_FIRST_PLATFORM + PPC_PLATFORM_POWER10;
 	      str++;
 	    }
+	  else if (str[1] == '1')
+	    {
+	      ret = _DL_FIRST_PLATFORM + PPC_PLATFORM_POWER11;
+	      str++;
+	    }
 	  else
 	    return -1;
 	  break;
@@ -187,21 +194,42 @@ _dl_procinfo (unsigned int type, unsigned long int word)
     case AT_HWCAP:
       _dl_printf ("AT_HWCAP:            ");
 
-      for (int i = 0; i <= _DL_HWCAP_LAST; ++i)
+      for (int i = 0; i < _DL_HWCAP_SIZE; ++i)
        if (word & (1 << i))
          _dl_printf (" %s", _dl_hwcap_string (i));
       break;
     case AT_HWCAP2:
       {
-       unsigned int offset = _DL_HWCAP_LAST + 1;
 
        _dl_printf ("AT_HWCAP2:           ");
 
-        /* We have to go through them all because the kernel added the
-          AT_HWCAP2 features starting with the high bits.  */
-       for (int i = 0; i <= _DL_HWCAP2_LAST; ++i)
-         if (word & (1 << i))
-           _dl_printf (" %s", _dl_hwcap_string (offset + i));
+       /* We have to go through them all because the kernel added the
+	  AT_HWCAP2 features starting with the high bits.  */
+       for (int i = 0; i < _DL_HWCAP_SIZE; ++i)
+	 if (word & (1 << i))
+	   _dl_printf (" %s", _dl_hwcap_string (_DL_HWCAP2_OFFSET + i));
+       break;
+      }
+    case AT_HWCAP3:
+      {
+       _dl_printf ("AT_HWCAP3:           ");
+
+       /* We have to go through them all because the kernel added the
+	  AT_HWCAP3 features starting with the high bits.  */
+       for (int i = 0; i < _DL_HWCAP_SIZE; ++i)
+	 if (word & (1 << i))
+	   _dl_printf (" %s", _dl_hwcap_string (_DL_HWCAP3_OFFSET + i));
+       break;
+      }
+    case AT_HWCAP4:
+      {
+       _dl_printf ("AT_HWCAP4:           ");
+
+       /* We have to go through them all because the kernel added the
+	  AT_HWCAP4 features starting with the high bits.  */
+       for (int i = 0; i <= _DL_HWCAP_SIZE; ++i)
+	 if (word & (1 << i))
+	   _dl_printf (" %s", _dl_hwcap_string (_DL_HWCAP4_OFFSET + i));
        break;
       }
     case AT_L1I_CACHEGEOMETRY:
diff --git a/sysdeps/powerpc/hwcapinfo.c b/sysdeps/powerpc/hwcapinfo.c
index 76344f285a..f6fede15a7 100644
--- a/sysdeps/powerpc/hwcapinfo.c
+++ b/sysdeps/powerpc/hwcapinfo.c
@@ -31,7 +31,7 @@ void
 __tcb_parse_hwcap_and_convert_at_platform (void)
 {
 
-  uint64_t h1, h2;
+  uint64_t h1, h2, h3, h4;
 
   /* Read AT_PLATFORM string from auxv and convert it to a number.  */
   __tcb.at_platform = _dl_string_platform (GLRO (dl_platform));
@@ -39,6 +39,8 @@ __tcb_parse_hwcap_and_convert_at_platform (void)
   /* Read HWCAP and HWCAP2 from auxv.  */
   h1 = GLRO (dl_hwcap);
   h2 = GLRO (dl_hwcap2);
+  h3 = GLRO (dl_hwcap3);
+  h4 = GLRO (dl_hwcap4);
 
   /* hwcap contains only the latest supported ISA, the code checks which is
      and fills the previous supported ones.  */
@@ -64,13 +66,16 @@ __tcb_parse_hwcap_and_convert_at_platform (void)
   else if (h1 & PPC_FEATURE_POWER5)
     h1 |= PPC_FEATURE_POWER4;
 
-  uint64_t array_hwcaps[] = { h1, h2 };
+  uint64_t array_hwcaps[] = { h1, h2, h3, h4 };
   init_cpu_features (&GLRO(dl_powerpc_cpu_features), array_hwcaps);
 
   /* Consolidate both HWCAP and HWCAP2 into a single doubleword so that
      we can read both in a single load later.  */
   __tcb.hwcap = (h1 << 32) | (h2 & 0xffffffff);
-  __tcb.hwcap_extn = 0x0;
+
+  /* Consolidate both HWCAP3 and HWCAP4 into a single doubleword so that
+     we can read both in a single load later.  */
+  __tcb.hwcap_extn = (h3 << 32) | (h4 & 0xffffffff);
 
 }
 #if IS_IN (rtld)
diff --git a/sysdeps/powerpc/powerpc32/bits/wordsize.h b/sysdeps/powerpc/powerpc32/bits/wordsize.h
index 04ca9debf0..6993fb6b29 100644
--- a/sysdeps/powerpc/powerpc32/bits/wordsize.h
+++ b/sysdeps/powerpc/powerpc32/bits/wordsize.h
@@ -2,10 +2,9 @@
 
 #if defined __powerpc64__
 # define __WORDSIZE	64
-# define __WORDSIZE_TIME64_COMPAT32	1
 #else
 # define __WORDSIZE	32
-# define __WORDSIZE_TIME64_COMPAT32	0
 # define __WORDSIZE32_SIZE_ULONG	0
 # define __WORDSIZE32_PTRDIFF_LONG	0
 #endif
+#define __WORDSIZE_TIME64_COMPAT32	1
diff --git a/sysdeps/powerpc/powerpc32/power11/Implies b/sysdeps/powerpc/powerpc32/power11/Implies
new file mode 100644
index 0000000000..051cbe0f79
--- /dev/null
+++ b/sysdeps/powerpc/powerpc32/power11/Implies
@@ -0,0 +1,2 @@
+powerpc/powerpc32/power10/fpu
+powerpc/powerpc32/power10
diff --git a/sysdeps/powerpc/powerpc32/power11/fpu/multiarch/Implies b/sysdeps/powerpc/powerpc32/power11/fpu/multiarch/Implies
new file mode 100644
index 0000000000..58edb2861d
--- /dev/null
+++ b/sysdeps/powerpc/powerpc32/power11/fpu/multiarch/Implies
@@ -0,0 +1 @@
+powerpc/powerpc32/power10/fpu/multiarch
diff --git a/sysdeps/powerpc/powerpc32/power11/multiarch/Implies b/sysdeps/powerpc/powerpc32/power11/multiarch/Implies
new file mode 100644
index 0000000000..c70f0428ba
--- /dev/null
+++ b/sysdeps/powerpc/powerpc32/power11/multiarch/Implies
@@ -0,0 +1 @@
+powerpc/powerpc32/power10/multiarch
diff --git a/sysdeps/powerpc/powerpc64/be/power11/Implies b/sysdeps/powerpc/powerpc64/be/power11/Implies
new file mode 100644
index 0000000000..de481d1c13
--- /dev/null
+++ b/sysdeps/powerpc/powerpc64/be/power11/Implies
@@ -0,0 +1,2 @@
+powerpc/powerpc64/be/power10/fpu
+powerpc/powerpc64/be/power10
diff --git a/sysdeps/powerpc/powerpc64/be/power11/fpu/Implies b/sysdeps/powerpc/powerpc64/be/power11/fpu/Implies
new file mode 100644
index 0000000000..dff0e13064
--- /dev/null
+++ b/sysdeps/powerpc/powerpc64/be/power11/fpu/Implies
@@ -0,0 +1 @@
+powerpc/powerpc64/be/power10/fpu
diff --git a/sysdeps/powerpc/powerpc64/be/power11/fpu/multiarch/Implies b/sysdeps/powerpc/powerpc64/be/power11/fpu/multiarch/Implies
new file mode 100644
index 0000000000..c3f259e009
--- /dev/null
+++ b/sysdeps/powerpc/powerpc64/be/power11/fpu/multiarch/Implies
@@ -0,0 +1 @@
+powerpc/powerpc64/be/power10/fpu/multiarch
diff --git a/sysdeps/powerpc/powerpc64/be/power11/multiarch/Implies b/sysdeps/powerpc/powerpc64/be/power11/multiarch/Implies
new file mode 100644
index 0000000000..9491a394c9
--- /dev/null
+++ b/sysdeps/powerpc/powerpc64/be/power11/multiarch/Implies
@@ -0,0 +1 @@
+powerpc/powerpc64/be/power10/multiarch
diff --git a/sysdeps/powerpc/powerpc64/bits/wordsize.h b/sysdeps/powerpc/powerpc64/bits/wordsize.h
index 04ca9debf0..6993fb6b29 100644
--- a/sysdeps/powerpc/powerpc64/bits/wordsize.h
+++ b/sysdeps/powerpc/powerpc64/bits/wordsize.h
@@ -2,10 +2,9 @@
 
 #if defined __powerpc64__
 # define __WORDSIZE	64
-# define __WORDSIZE_TIME64_COMPAT32	1
 #else
 # define __WORDSIZE	32
-# define __WORDSIZE_TIME64_COMPAT32	0
 # define __WORDSIZE32_SIZE_ULONG	0
 # define __WORDSIZE32_PTRDIFF_LONG	0
 #endif
+#define __WORDSIZE_TIME64_COMPAT32	1
diff --git a/sysdeps/powerpc/powerpc64/dl-machine.h b/sysdeps/powerpc/powerpc64/dl-machine.h
index c6682f3445..2b6f5d2b08 100644
--- a/sysdeps/powerpc/powerpc64/dl-machine.h
+++ b/sysdeps/powerpc/powerpc64/dl-machine.h
@@ -78,6 +78,7 @@ elf_host_tolerates_class (const Elf64_Ehdr *ehdr)
 static inline Elf64_Addr
 elf_machine_load_address (void) __attribute__ ((const));
 
+#ifndef __PCREL__
 static inline Elf64_Addr
 elf_machine_load_address (void)
 {
@@ -105,6 +106,24 @@ elf_machine_dynamic (void)
   /* Then subtract off the load address offset.  */
   return runtime_dynamic - elf_machine_load_address() ;
 }
+#else /* __PCREL__ */
+/* In PCREL mode, r2 may have been clobbered.  Rely on relative
+   relocations instead.  */
+
+static inline ElfW(Addr)
+elf_machine_load_address (void)
+{
+  extern const ElfW(Ehdr) __ehdr_start attribute_hidden;
+  return (ElfW(Addr)) &__ehdr_start;
+}
+
+static inline ElfW(Addr)
+elf_machine_dynamic (void)
+{
+  extern ElfW(Dyn) _DYNAMIC[] attribute_hidden;
+  return (ElfW(Addr)) _DYNAMIC - elf_machine_load_address ();
+}
+#endif /* __PCREL__ */
 
 /* The PLT uses Elf64_Rela relocs.  */
 #define elf_machine_relplt elf_machine_rela
diff --git a/sysdeps/powerpc/powerpc64/le/Makefile b/sysdeps/powerpc/powerpc64/le/Makefile
index 5214eb40ad..ca5e395f8d 100644
--- a/sysdeps/powerpc/powerpc64/le/Makefile
+++ b/sysdeps/powerpc/powerpc64/le/Makefile
@@ -129,6 +129,10 @@ CFLAGS-tst-strtod-round.c += $(type-float128-CFLAGS)
 CFLAGS-tst-wcstod-round.c += $(type-float128-CFLAGS)
 CFLAGS-tst-strtod-nan-locale.c += $(type-float128-CFLAGS)
 CFLAGS-tst-wcstod-nan-locale.c += $(type-float128-CFLAGS)
+CFLAGS-tst-strtod1i.c += $(type-float128-CFLAGS)
+CFLAGS-tst-strtod3.c += $(type-float128-CFLAGS)
+CFLAGS-tst-strtod4.c += $(type-float128-CFLAGS)
+CFLAGS-tst-strtod5i.c += $(type-float128-CFLAGS)
 CFLAGS-tst-strtod6.c += $(type-float128-CFLAGS)
 CFLAGS-tst-strfrom.c += $(type-float128-CFLAGS)
 CFLAGS-tst-strfrom-locale.c += $(type-float128-CFLAGS)
diff --git a/sysdeps/powerpc/powerpc64/le/power10/memchr.S b/sysdeps/powerpc/powerpc64/le/power10/memchr.S
deleted file mode 100644
index 53e5716d72..0000000000
--- a/sysdeps/powerpc/powerpc64/le/power10/memchr.S
+++ /dev/null
@@ -1,315 +0,0 @@
-/* Optimized memchr implementation for POWER10 LE.
-   Copyright (C) 2021-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-
-# ifndef MEMCHR
-#  define MEMCHR __memchr
-# endif
-# define M_VREG_ZERO v20
-# define M_OFF_START_LOOP 256
-# define MEMCHR_SUBTRACT_VECTORS \
-	vsububm   v4,v4,v18;	    \
-	vsububm   v5,v5,v18;	    \
-	vsububm   v6,v6,v18;	    \
-	vsububm   v7,v7,v18;
-# define M_TAIL(vreg,increment)	   \
-	vctzlsbb  r4,vreg;	   \
-	cmpld     r5,r4;	   \
-	ble       L(null);	   \
-	addi	  r4,r4,increment; \
-	add	  r3,r6,r4;	   \
-	blr
-
-/* TODO: Replace macros by the actual instructions when minimum binutils becomes
-   >= 2.35.  This is used to keep compatibility with older versions.  */
-#define M_VEXTRACTBM(rt,vrb)	 \
-	.long(((4)<<(32-6))	 \
-	      | ((rt)<<(32-11))	 \
-	      | ((8)<<(32-16))	 \
-	      | ((vrb)<<(32-21)) \
-	      | 1602)
-
-#define M_LXVP(xtp,dq,ra)		   \
-	.long(((6)<<(32-6))		   \
-	      | ((((xtp)-32)>>1)<<(32-10)) \
-	      | ((1)<<(32-11))		   \
-	      | ((ra)<<(32-16))		   \
-	      | dq)
-
-#define CHECK16B(vreg,offset,addr,label) \
-	lxv	  vreg+32,offset(addr);	\
-	vcmpequb. vreg,vreg,v18;	\
-	bne	  cr6,L(label);		\
-	cmpldi	  r5,16;		\
-	ble	  L(null);		\
-	addi	  r5,r5,-16;
-
-/* Load 4 quadwords, merge into one VR for speed and check for NULLs.  r6 has #
-   of bytes already checked.  */
-#define CHECK64B(offset,addr,label)	    \
-	M_LXVP(v4+32,offset,addr);	    \
-	M_LXVP(v6+32,offset+32,addr);	    \
-	MEMCHR_SUBTRACT_VECTORS;	    \
-	vminub	  v14,v4,v5;		    \
-	vminub	  v15,v6,v7;		    \
-	vminub	  v16,v14,v15;		    \
-	vcmpequb. v0,v16,M_VREG_ZERO;	    \
-	beq	  cr6,$+12;		    \
-	li	  r7,offset;		    \
-	b     	  L(label);          	    \
-	cmpldi	  r5,64;		    \
-	ble	  L(null);		    \
-	addi	  r5,r5,-64
-
-/* Implements the function
-   void *[r3] memchr (const void *s [r3], int c [r4], size_t n [r5]).  */
-
-	.machine power9
-
-ENTRY_TOCLESS (MEMCHR)
-	CALL_MCOUNT 3
-
-	cmpldi	r5,0
-	beq	L(null)
-	mr	r0,r5
-	xori	r6,r4,0xff
-
-	mtvsrd	v18+32,r4	/* matching char in v18  */
-	mtvsrd	v19+32,r6	/* non matching char in v19  */
-
-	vspltb	v18,v18,7	/* replicate  */
-	vspltb	v19,v19,7	/* replicate  */
-	vspltisb  M_VREG_ZERO,0
-
-	/* Next 16B-aligned address. Prepare address for L(aligned).  */
-	addi	  r6,r3,16
-	clrrdi	  r6,r6,4
-
-	/* Align data and fill bytes not loaded with non matching char.	 */
-	lvx	  v0,0,r3
-	lvsr	  v1,0,r3
-	vperm	  v0,v19,v0,v1
-
-	vcmpequb. v6,v0,v18
-	bne	  cr6,L(found)
-	sub	  r4,r6,r3
-	cmpld	  r5,r4
-	ble	  L(null)
-	sub	  r5,r5,r4
-
-	/* Test up to OFF_START_LOOP-16 bytes in 16B chunks.  The main loop is
-	   optimized for longer strings, so checking the first bytes in 16B
-	   chunks benefits a lot small strings.  */
-	.p2align 5
-L(aligned):
-	cmpldi	r5,0
-	beq     L(null)
-
-	CHECK16B(v0,0,r6,tail1)
-	CHECK16B(v1,16,r6,tail2)
-	CHECK16B(v2,32,r6,tail3)
-	CHECK16B(v3,48,r6,tail4)
-	CHECK16B(v4,64,r6,tail5)
-	CHECK16B(v5,80,r6,tail6)
-	CHECK16B(v6,96,r6,tail7)
-	CHECK16B(v7,112,r6,tail8)
-	CHECK16B(v8,128,r6,tail9)
-	CHECK16B(v9,144,r6,tail10)
-	CHECK16B(v10,160,r6,tail11)
-	CHECK16B(v0,176,r6,tail12)
-	CHECK16B(v1,192,r6,tail13)
-	CHECK16B(v2,208,r6,tail14)
-	CHECK16B(v3,224,r6,tail15)
-
-	cmpdi	cr5,r4,0	/* Check if c == 0.  This will be useful to
-				   choose how we will perform the main loop.  */
-
-	/* Prepare address for the loop.  */
-	addi	  r4,r3,M_OFF_START_LOOP
-	clrrdi	  r4,r4,6
-	sub	  r6,r4,r3
-	sub	  r5,r0,r6
-	addi	  r6,r4,128
-
-	/* If c == 0, use the loop without the vsububm.  */
-	beq	cr5,L(loop)
-
-	/* This is very similar to the block after L(loop), the difference is
-	   that here MEMCHR_SUBTRACT_VECTORS is not empty, and we subtract
-	   each byte loaded by the char we are looking for, this way we can keep
-	   using vminub to merge the results and checking for nulls.  */
-	.p2align 5
-L(memchr_loop):
-	CHECK64B(0,r4,pre_tail_64b)
-	CHECK64B(64,r4,pre_tail_64b)
-	addi	r4,r4,256
-
-	CHECK64B(0,r6,tail_64b)
-	CHECK64B(64,r6,tail_64b)
-	addi	r6,r6,256
-
-	CHECK64B(0,r4,pre_tail_64b)
-	CHECK64B(64,r4,pre_tail_64b)
-	addi	r4,r4,256
-
-	CHECK64B(0,r6,tail_64b)
-	CHECK64B(64,r6,tail_64b)
-	addi	r6,r6,256
-
-	b	L(memchr_loop)
-	/* Switch to a more aggressive approach checking 64B each time.  Use 2
-	   pointers 128B apart and unroll the loop once to make the pointer
-	   updates and usages separated enough to avoid stalls waiting for
-	   address calculation.  */
-	.p2align 5
-L(loop):
-#undef MEMCHR_SUBTRACT_VECTORS
-#define MEMCHR_SUBTRACT_VECTORS /* nothing */
-	CHECK64B(0,r4,pre_tail_64b)
-	CHECK64B(64,r4,pre_tail_64b)
-	addi	  r4,r4,256
-
-	CHECK64B(0,r6,tail_64b)
-	CHECK64B(64,r6,tail_64b)
-	addi	  r6,r6,256
-
-	CHECK64B(0,r4,pre_tail_64b)
-	CHECK64B(64,r4,pre_tail_64b)
-	addi      r4,r4,256
-
-	CHECK64B(0,r6,tail_64b)
-	CHECK64B(64,r6,tail_64b)
-	addi      r6,r6,256
-
-	b	  L(loop)
-
-	.p2align  5
-L(pre_tail_64b):
-	mr	r6,r4
-L(tail_64b):
-	/* OK, we found a null byte.  Let's look for it in the current 64-byte
-	   block and mark it in its corresponding VR.  lxvp vx,0(ry) puts the
-	   low 16B bytes into vx+1, and the high into vx, so the order here is
-	   v5, v4, v7, v6.  */
-	vcmpequb  v1,v5,M_VREG_ZERO
-	vcmpequb  v2,v4,M_VREG_ZERO
-	vcmpequb  v3,v7,M_VREG_ZERO
-	vcmpequb  v4,v6,M_VREG_ZERO
-
-	/* Take into account the other 64B blocks we had already checked.  */
-	add	r6,r6,r7
-	/* Extract first bit of each byte.  */
-	M_VEXTRACTBM(r8,v1)
-	M_VEXTRACTBM(r9,v2)
-	M_VEXTRACTBM(r10,v3)
-	M_VEXTRACTBM(r11,v4)
-
-	/* Shift each value into their corresponding position.  */
-	sldi	  r9,r9,16
-	sldi	  r10,r10,32
-	sldi	  r11,r11,48
-
-	/* Merge the results.  */
-	or	  r8,r8,r9
-	or	  r9,r10,r11
-	or	  r11,r9,r8
-
-	cnttzd	  r0,r11	  /* Count trailing zeros before the match.  */
-	cmpld     r5,r0
-	ble	  L(null)
-	add	  r3,r6,r0	  /* Compute final address.  */
-	blr
-
-	.p2align  5
-L(tail1):
-	M_TAIL(v0,0)
-
-	.p2align  5
-L(tail2):
-	M_TAIL(v1,16)
-
-	.p2align  5
-L(tail3):
-	M_TAIL(v2,32)
-
-	.p2align  5
-L(tail4):
-	M_TAIL(v3,48)
-
-	.p2align  5
-L(tail5):
-	M_TAIL(v4,64)
-
-	.p2align  5
-L(tail6):
-	M_TAIL(v5,80)
-
-	.p2align  5
-L(tail7):
-	M_TAIL(v6,96)
-
-	.p2align  5
-L(tail8):
-	M_TAIL(v7,112)
-
-	.p2align  5
-L(tail9):
-	M_TAIL(v8,128)
-
-	.p2align  5
-L(tail10):
-	M_TAIL(v9,144)
-
-	.p2align  5
-L(tail11):
-	M_TAIL(v10,160)
-
-	.p2align  5
-L(tail12):
-	M_TAIL(v0,176)
-
-	.p2align  5
-L(tail13):
-	M_TAIL(v1,192)
-
-	.p2align  5
-L(tail14):
-	M_TAIL(v2,208)
-
-	.p2align  5
-L(tail15):
-	M_TAIL(v3,224)
-
-	.p2align  5
-L(found):
-	vctzlsbb  r7,v6
-	cmpld     r5,r7
-	ble       L(null)
-	add       r3,r3,r7
-	blr
-
-	.p2align  5
-L(null):
-	li	r3,0
-	blr
-
-END (MEMCHR)
-
-weak_alias (__memchr, memchr)
-libc_hidden_builtin_def (memchr)
diff --git a/sysdeps/powerpc/powerpc64/le/power10/strcmp.S b/sysdeps/powerpc/powerpc64/le/power10/strcmp.S
index f0d6732a25..0d4a53317c 100644
--- a/sysdeps/powerpc/powerpc64/le/power10/strcmp.S
+++ b/sysdeps/powerpc/powerpc64/le/power10/strcmp.S
@@ -1,5 +1,5 @@
 /* Optimized strcmp implementation for PowerPC64/POWER10.
-   Copyright (C) 2021-2024 Free Software Foundation, Inc.
+   Copyright (C) 2025 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -24,16 +24,6 @@
 /* Implements the function
    int [r3] strcmp (const char *s1 [r3], const char *s2 [r4]).  */
 
-/* TODO: Change this to actual instructions when minimum binutils is upgraded
-   to 2.27.  Macros are defined below for these newer instructions in order
-   to maintain compatibility.  */
-
-#define LXVP(xtp,dq,ra)		     \
-	.long(((6)<<(32-6))	     \
-	| ((((xtp)-32)>>1)<<(32-10)) \
-	| ((1)<<(32-11))	     \
-	| ((ra)<<(32-16))	     \
-	| dq)
 
 #define COMPARE_16(vreg1,vreg2,offset)  \
 	lxv       vreg1+32,offset(r3);  \
@@ -42,8 +32,8 @@
 	bne       cr6,L(different);     \
 
 #define COMPARE_32(vreg1,vreg2,offset,label1,label2) \
-	LXVP(vreg1+32,offset,r3);                    \
-	LXVP(vreg2+32,offset,r4);                    \
+	lxvp	  vreg1+32,offset(r3);               \
+	lxvp	  vreg2+32,offset(r4);               \
 	vcmpnezb. v7,vreg1+1,vreg2+1;                \
 	bne	  cr6,L(label1);                     \
 	vcmpnezb. v7,vreg1,vreg2;                    \
@@ -62,120 +52,77 @@
 	lxvl	  32+v5,reg2,r0;         \
 	add	  reg1,reg1,len_reg;     \
 	add	  reg2,reg2,len_reg;     \
-	vcmpnezb  v7,v4,v5;              \
+	vcmpnezb. v7,v4,v5;              \
 	vctzlsbb  r6,v7;                 \
 	cmpld	  cr7,r6,len_reg;        \
 	blt	  cr7,L(different);      \
 
-	/* TODO: change this to .machine power10 when the minimum required
-	binutils allows it.  */
 
-	.machine  power9
+	.machine  power10
 ENTRY_TOCLESS (STRCMP, 4)
-	andi.	r7,r3,4095
-	andi.	r8,r4,4095
-	cmpldi	cr0,r7,4096-16
-	cmpldi	cr1,r8,4096-16
-	bgt	cr0,L(crosses)
-	bgt	cr1,L(crosses)
-	COMPARE_16(v4,v5,0)
-
-L(crosses):
-	andi.	r7,r3,15
-	subfic	r7,r7,16	/* r7(nalign1) = 16 - (str1 & 15).  */
-	andi.	r9,r4,15
-	subfic	r5,r9,16	/* r5(nalign2) = 16 - (str2 & 15).  */
-	cmpld	cr7,r7,r5
-	beq	cr7,L(same_aligned)
-	blt	cr7,L(nalign1_min)
+	li	 r11,16
+	/* eq bit of cr1 used as swap status flag to indicate if
+	source pointers were swapped.  */
+	crclr	 4*cr1+eq
+	andi.	 r7,r3,15
+	sub	 r7,r11,r7	/* r7(nalign1) = 16 - (str1 & 15).  */
+	andi.	 r9,r4,15
+	sub	 r5,r11,r9	/* r5(nalign2) = 16 - (str2 & 15).  */
+	cmpld	 cr7,r7,r5
+	beq	 cr7,L(same_aligned)
+	blt	 cr7,L(nalign1_min)
+	/* Swap r3 and r4, and r7 and r5 such that r3 and r7 hold the
+	pointer which is closer to the next 16B boundary so that only
+	one CHECK_N_BYTES is needed before entering the loop below.  */
+	mr	 r8,r4
+	mr	 r4,r3
+	mr	 r3,r8
+	mr	 r12,r7
+	mr	 r7,r5
+	mr	 r5,r12
+	crset	 4*cr1+eq	/* Set bit on swapping source pointers.  */
 
-	/* nalign2 is minimum and s2 pointer is aligned.  */
-	CHECK_N_BYTES(r3,r4,r5)
-	/* Are we on the 64B hunk which crosses a page?  */
-	andi.	r10,r3,63	/* Determine offset into 64B hunk.  */
-	andi.	r8,r3,15        /* The offset into the 16B hunk.  */
-	neg	r7,r3
-	andi.	r9,r7,15	/* Number of bytes after a 16B cross.  */
-	rlwinm.	r7,r7,26,0x3F	/* ((r3-4096))>>6&63.  */
-	beq	L(compare_64_pagecross)
-	mtctr	r7
-	b	L(compare_64B_unaligned)
-
-	/* nalign1 is minimum and s1 pointer is aligned.  */
+	.p2align 5
 L(nalign1_min):
 	CHECK_N_BYTES(r3,r4,r7)
-	/* Are we on the 64B hunk which crosses a page?  */
-	andi.	r10,r4,63	/* Determine offset into 64B hunk.  */
-	andi.	r8,r4,15	/* The offset into the 16B hunk.  */
-	neg	r7,r4
-	andi.	r9,r7,15	/* Number of bytes after a 16B cross.  */
-	rlwinm. r7,r7,26,0x3F	/* ((r4-4096))>>6&63.  */
-	beq	L(compare_64_pagecross)
-	mtctr	r7
 
 	.p2align 5
-L(compare_64B_unaligned):
-	COMPARE_16(v4,v5,0)
-	COMPARE_16(v4,v5,16)
-	COMPARE_16(v4,v5,32)
-	COMPARE_16(v4,v5,48)
-	addi	r3,r3,64
-	addi	r4,r4,64
-	bdnz	L(compare_64B_unaligned)
+L(s1_aligned):
+	/* r9 and r5 is number of bytes to be read after and before
+	 page boundary correspondingly.  */
+	sub 	r5,r5,r7
+	subfic	r9,r5,16
+	/* Now let r7 hold the count of quadwords which can be
+	checked without crossing a page boundary. quadword offset is
+	(str2>>4)&0xFF.  */
+	rlwinm	r7,r4,28,0xFF
+	/* Below check is required only for first iteration. For second
+	iteration and beyond, the new loop counter is always 255.  */
+	cmpldi	r7,255
+	beq	L(L3)
+	/* Get the initial loop count by 255-((str2>>4)&0xFF).  */
+	subfic  r11,r7,255
 
-	/* Cross the page boundary of s2, carefully. Only for first
-	iteration we have to get the count of 64B blocks to be checked.
-	From second iteration and beyond, loop counter is always 63.  */
-L(compare_64_pagecross):
-	li	r11, 63
+	.p2align 5
+L(L1):
 	mtctr	r11
-	cmpldi	r10,16
-	ble	L(cross_4)
-	cmpldi	r10,32
-	ble	L(cross_3)
-	cmpldi	r10,48
-	ble	L(cross_2)
-L(cross_1):
-	CHECK_N_BYTES(r3,r4,r9)
-	CHECK_N_BYTES(r3,r4,r8)
-	COMPARE_16(v4,v5,0)
-	COMPARE_16(v4,v5,16)
-	COMPARE_16(v4,v5,32)
-	addi	r3,r3,48
-	addi	r4,r4,48
-	b	L(compare_64B_unaligned)
-L(cross_2):
-	COMPARE_16(v4,v5,0)
-	addi	r3,r3,16
-	addi	r4,r4,16
-	CHECK_N_BYTES(r3,r4,r9)
-	CHECK_N_BYTES(r3,r4,r8)
-	COMPARE_16(v4,v5,0)
-	COMPARE_16(v4,v5,16)
-	addi	r3,r3,32
-	addi	r4,r4,32
-	b	L(compare_64B_unaligned)
-L(cross_3):
-	COMPARE_16(v4,v5,0)
-	COMPARE_16(v4,v5,16)
-	addi	r3,r3,32
-	addi	r4,r4,32
-	CHECK_N_BYTES(r3,r4,r9)
-	CHECK_N_BYTES(r3,r4,r8)
-	COMPARE_16(v4,v5,0)
+
+	.p2align 5
+L(L2):
+	COMPARE_16(v4,v5,0)	/* Load 16B blocks using lxv.  */
 	addi	r3,r3,16
 	addi	r4,r4,16
-	b	L(compare_64B_unaligned)
-L(cross_4):
-	COMPARE_16(v4,v5,0)
-	COMPARE_16(v4,v5,16)
-	COMPARE_16(v4,v5,32)
-	addi	r3,r3,48
-	addi	r4,r4,48
+	bdnz	L(L2)
+	/* Cross the page boundary of s2, carefully.  */
+
+	.p2align 5
+L(L3):
+	CHECK_N_BYTES(r3,r4,r5)
 	CHECK_N_BYTES(r3,r4,r9)
-	CHECK_N_BYTES(r3,r4,r8)
-	b	L(compare_64B_unaligned)
+	li 	r11,255		/* Load the new loop counter.  */
+	b	L(L1)
 
+	.p2align 5
 L(same_aligned):
 	CHECK_N_BYTES(r3,r4,r7)
         /* Align s1 to 32B and adjust s2 address.
@@ -208,26 +155,31 @@ L(16B_aligned_loop):
 
 	/* Calculate and return the difference.  */
 L(different):
-	TAIL(v4,v5)
+	vctzlsbb r6,v7
+	vextubrx r5,r6,v4
+	vextubrx r4,r6,v5
+	bt  	 4*cr1+eq,L(swapped)
+	subf	 r3,r4,r5
+	blr
+
+	/* If src pointers were swapped, then swap the
+	indices and calculate the return value.  */
+L(swapped):
+	subf     r3,r5,r4
+	blr
 
 	.p2align 5
 L(32B_aligned_loop):
 	COMPARE_32(v14,v16,0,tail1,tail2)
-	COMPARE_32(v18,v20,32,tail3,tail4)
-	COMPARE_32(v22,v24,64,tail5,tail6)
-	COMPARE_32(v26,v28,96,tail7,tail8)
+	COMPARE_32(v14,v16,32,tail1,tail2)
+	COMPARE_32(v14,v16,64,tail1,tail2)
+	COMPARE_32(v14,v16,96,tail1,tail2)
 	addi	r3,r3,128
 	addi	r4,r4,128
 	b	L(32B_aligned_loop)
 
 L(tail1): TAIL(v15,v17)
 L(tail2): TAIL(v14,v16)
-L(tail3): TAIL(v19,v21)
-L(tail4): TAIL(v18,v20)
-L(tail5): TAIL(v23,v25)
-L(tail6): TAIL(v22,v24)
-L(tail7): TAIL(v27,v29)
-L(tail8): TAIL(v26,v28)
 
 END (STRCMP)
 libc_hidden_builtin_def (strcmp)
diff --git a/sysdeps/powerpc/powerpc64/le/power10/strlen.S b/sysdeps/powerpc/powerpc64/le/power10/strlen.S
index 0bd794540f..574a24b586 100644
--- a/sysdeps/powerpc/powerpc64/le/power10/strlen.S
+++ b/sysdeps/powerpc/powerpc64/le/power10/strlen.S
@@ -31,7 +31,7 @@
 #  define FUNCNAME RAWMEMCHR
 # endif
 # define MCOUNT_NARGS 2
-# define VREG_ZERO v20
+# define VREG_ZERO v17
 # define OFF_START_LOOP 256
 # define RAWMEMCHR_SUBTRACT_VECTORS \
 	vsububm   v4,v4,v18;	    \
diff --git a/sysdeps/powerpc/powerpc64/le/power10/strncmp.S b/sysdeps/powerpc/powerpc64/le/power10/strncmp.S
new file mode 100644
index 0000000000..6e09fcb7f2
--- /dev/null
+++ b/sysdeps/powerpc/powerpc64/le/power10/strncmp.S
@@ -0,0 +1,252 @@
+/* Optimized strncmp implementation for PowerPC64/POWER10.
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+/* Implements the function
+
+   int [r3] strncmp (const char *s1 [r3], const char *s2 [r4], size_t [r5] n)
+
+   The implementation uses unaligned doubleword access to avoid specialized
+   code paths depending of data alignment for first 32 bytes and uses
+   vectorised loops after that.  */
+
+#ifndef STRNCMP
+# define STRNCMP strncmp
+#endif
+
+#define COMPARE_16(vreg1,vreg2,offset) \
+	lxv	  vreg1+32,offset(r3); \
+	lxv	  vreg2+32,offset(r4); \
+	vcmpnezb. v7,vreg1,vreg2;      \
+	bne	  cr6,L(different);    \
+	cmpldi	  cr7,r5,16;           \
+	ble	  cr7,L(ret0);         \
+	addi	  r5,r5,-16;
+
+#define COMPARE_32(vreg1,vreg2,offset,label1,label2) \
+	lxvp	  vreg1+32,offset(r3);               \
+	lxvp	  vreg2+32,offset(r4);               \
+	vcmpnezb. v7,vreg1+1,vreg2+1;                \
+	bne	  cr6,L(label1);                     \
+	vcmpnezb. v7,vreg1,vreg2;                    \
+	bne	  cr6,L(label2);                     \
+	cmpldi	  cr7,r5,32;                         \
+	ble	  cr7,L(ret0);                       \
+	addi	  r5,r5,-32;
+
+#define TAIL_FIRST_16B(vreg1,vreg2) \
+	vctzlsbb r6,v7;             \
+	cmpld	 cr7,r5,r6;         \
+	ble	 cr7,L(ret0);       \
+	vextubrx r5,r6,vreg1;       \
+	vextubrx r4,r6,vreg2;       \
+	subf	 r3,r4,r5;          \
+	blr;
+
+#define TAIL_SECOND_16B(vreg1,vreg2) \
+	vctzlsbb r6,v7;              \
+	addi	 r0,r6,16;           \
+	cmpld	 cr7,r5,r0;          \
+	ble	 cr7,L(ret0);        \
+	vextubrx r5,r6,vreg1;        \
+	vextubrx r4,r6,vreg2;        \
+	subf	 r3,r4,r5;           \
+	blr;
+
+#define CHECK_N_BYTES(reg1,reg2,len_reg) \
+	sldi	  r6,len_reg,56;	 \
+	lxvl	  32+v4,reg1,r6;	 \
+	lxvl	  32+v5,reg2,r6;	 \
+	add	  reg1,reg1,len_reg;	 \
+	add	  reg2,reg2,len_reg;	 \
+	vcmpnezb  v7,v4,v5;		 \
+	vctzlsbb  r6,v7;		 \
+	cmpld	  cr7,r6,len_reg;	 \
+	blt	  cr7,L(different);	 \
+	cmpld	  cr7,r5,len_reg;	 \
+	ble	  cr7,L(ret0);		 \
+	sub	  r5,r5,len_reg;	 \
+
+	.machine  power10
+ENTRY_TOCLESS (STRNCMP, 4)
+	/* Check if size is 0.  */
+	cmpdi	 cr0,r5,0
+	beq	 cr0,L(ret0)
+	andi.   r7,r3,4095
+	andi.   r8,r4,4095
+	cmpldi  cr0,r7,4096-16
+	cmpldi  cr1,r8,4096-16
+	bgt     cr0,L(crosses)
+	bgt     cr1,L(crosses)
+	COMPARE_16(v4,v5,0)
+	addi	r3,r3,16
+	addi	r4,r4,16
+
+L(crosses):
+	andi.	 r7,r3,15
+	subfic	 r7,r7,16	/* r7(nalign1) = 16 - (str1 & 15).  */
+	andi.	 r9,r4,15
+	subfic	 r8,r9,16	/* r8(nalign2) = 16 - (str2 & 15).  */
+	cmpld	 cr7,r7,r8
+	beq	 cr7,L(same_aligned)
+	blt	 cr7,L(nalign1_min)
+
+	/* nalign2 is minimum and s2 pointer is aligned.  */
+	CHECK_N_BYTES(r3,r4,r8)
+	/* Are we on the 64B hunk which crosses a page?  */
+	andi.   r10,r3,63       /* Determine offset into 64B hunk.  */
+	andi.   r8,r3,15        /* The offset into the 16B hunk.  */
+	neg     r7,r3
+	andi.   r9,r7,15        /* Number of bytes after a 16B cross.  */
+	rlwinm. r7,r7,26,0x3F   /* ((r4-4096))>>6&63.  */
+	beq     L(compare_64_pagecross)
+	mtctr   r7
+	b       L(compare_64B_unaligned)
+
+	/* nalign1 is minimum and s1 pointer is aligned.  */
+L(nalign1_min):
+	CHECK_N_BYTES(r3,r4,r7)
+	/* Are we on the 64B hunk which crosses a page?  */
+	andi.   r10,r4,63       /* Determine offset into 64B hunk.  */
+	andi.   r8,r4,15        /* The offset into the 16B hunk.  */
+	neg     r7,r4
+	andi.   r9,r7,15        /* Number of bytes after a 16B cross.  */
+	rlwinm. r7,r7,26,0x3F   /* ((r4-4096))>>6&63.  */
+	beq     L(compare_64_pagecross)
+	mtctr   r7
+
+	.p2align 5
+L(compare_64B_unaligned):
+	COMPARE_16(v4,v5,0)
+	COMPARE_16(v4,v5,16)
+	COMPARE_16(v4,v5,32)
+	COMPARE_16(v4,v5,48)
+	addi    r3,r3,64
+	addi    r4,r4,64
+	bdnz    L(compare_64B_unaligned)
+
+	/* Cross the page boundary of s2, carefully. Only for first
+	iteration we have to get the count of 64B blocks to be checked.
+	From second iteration and beyond, loop counter is always 63.  */
+L(compare_64_pagecross):
+	li      r11, 63
+	mtctr   r11
+	cmpldi  r10,16
+	ble     L(cross_4)
+	cmpldi  r10,32
+	ble     L(cross_3)
+	cmpldi  r10,48
+	ble     L(cross_2)
+L(cross_1):
+	CHECK_N_BYTES(r3,r4,r9)
+	CHECK_N_BYTES(r3,r4,r8)
+	COMPARE_16(v4,v5,0)
+	COMPARE_16(v4,v5,16)
+	COMPARE_16(v4,v5,32)
+	addi    r3,r3,48
+	addi    r4,r4,48
+	b       L(compare_64B_unaligned)
+L(cross_2):
+	COMPARE_16(v4,v5,0)
+	addi    r3,r3,16
+	addi    r4,r4,16
+	CHECK_N_BYTES(r3,r4,r9)
+	CHECK_N_BYTES(r3,r4,r8)
+	COMPARE_16(v4,v5,0)
+	COMPARE_16(v4,v5,16)
+	addi    r3,r3,32
+	addi    r4,r4,32
+	b       L(compare_64B_unaligned)
+L(cross_3):
+	COMPARE_16(v4,v5,0)
+	COMPARE_16(v4,v5,16)
+	addi    r3,r3,32
+	addi    r4,r4,32
+	CHECK_N_BYTES(r3,r4,r9)
+	CHECK_N_BYTES(r3,r4,r8)
+	COMPARE_16(v4,v5,0)
+	addi    r3,r3,16
+	addi    r4,r4,16
+	b       L(compare_64B_unaligned)
+L(cross_4):
+	COMPARE_16(v4,v5,0)
+	COMPARE_16(v4,v5,16)
+	COMPARE_16(v4,v5,32)
+	addi    r3,r3,48
+	addi    r4,r4,48
+	CHECK_N_BYTES(r3,r4,r9)
+	CHECK_N_BYTES(r3,r4,r8)
+	b       L(compare_64B_unaligned)
+
+L(same_aligned):
+	CHECK_N_BYTES(r3,r4,r7)
+	/* Align s1 to 32B and adjust s2 address.
+	   Use lxvp only if both s1 and s2 are 32B aligned.  */
+	COMPARE_16(v4,v5,0)
+	COMPARE_16(v4,v5,16)
+	COMPARE_16(v4,v5,32)
+	COMPARE_16(v4,v5,48)
+	addi	r3,r3,64
+	addi	r4,r4,64
+	COMPARE_16(v4,v5,0)
+	COMPARE_16(v4,v5,16)
+	addi	r5,r5,32
+
+	clrldi  r6,r3,59
+	subfic	r7,r6,32
+	add	r3,r3,r7
+	add	r4,r4,r7
+	subf	r5,r7,r5
+	andi.	r7,r4,0x1F
+	beq	cr0,L(32B_aligned_loop)
+
+	.p2align 5
+L(16B_aligned_loop):
+	COMPARE_16(v4,v5,0)
+	COMPARE_16(v4,v5,16)
+	COMPARE_16(v4,v5,32)
+	COMPARE_16(v4,v5,48)
+	addi	r3,r3,64
+	addi	r4,r4,64
+	b	L(16B_aligned_loop)
+
+	/* Calculate and return the difference.  */
+L(different):
+	TAIL_FIRST_16B(v4,v5)
+
+	.p2align 5
+L(32B_aligned_loop):
+	COMPARE_32(v14,v16,0,tail1,tail2)
+	COMPARE_32(v14,v16,32,tail1,tail2)
+	COMPARE_32(v14,v16,64,tail1,tail2)
+	COMPARE_32(v14,v16,96,tail1,tail2)
+	addi	r3,r3,128
+	addi	r4,r4,128
+	b	L(32B_aligned_loop)
+
+L(tail1): TAIL_FIRST_16B(v15,v17)
+L(tail2): TAIL_SECOND_16B(v14,v16)
+
+	.p2align 5
+L(ret0):
+	li	r3,0
+	blr
+
+END(STRNCMP)
+libc_hidden_builtin_def(strncmp)
diff --git a/sysdeps/powerpc/powerpc64/le/power11/Implies b/sysdeps/powerpc/powerpc64/le/power11/Implies
new file mode 100644
index 0000000000..e18182dcc1
--- /dev/null
+++ b/sysdeps/powerpc/powerpc64/le/power11/Implies
@@ -0,0 +1,2 @@
+powerpc/powerpc64/le/power10/fpu
+powerpc/powerpc64/le/power10
diff --git a/sysdeps/powerpc/powerpc64/le/power11/fpu/Implies b/sysdeps/powerpc/powerpc64/le/power11/fpu/Implies
new file mode 100644
index 0000000000..e41bd55684
--- /dev/null
+++ b/sysdeps/powerpc/powerpc64/le/power11/fpu/Implies
@@ -0,0 +1 @@
+powerpc/powerpc64/le/power10/fpu
diff --git a/sysdeps/powerpc/powerpc64/le/power11/fpu/multiarch/Implies b/sysdeps/powerpc/powerpc64/le/power11/fpu/multiarch/Implies
new file mode 100644
index 0000000000..c838d50931
--- /dev/null
+++ b/sysdeps/powerpc/powerpc64/le/power11/fpu/multiarch/Implies
@@ -0,0 +1 @@
+powerpc/powerpc64/le/power10/fpu/multiarch
diff --git a/sysdeps/powerpc/powerpc64/le/power11/multiarch/Implies b/sysdeps/powerpc/powerpc64/le/power11/multiarch/Implies
new file mode 100644
index 0000000000..687248c3c2
--- /dev/null
+++ b/sysdeps/powerpc/powerpc64/le/power11/multiarch/Implies
@@ -0,0 +1 @@
+powerpc/powerpc64/le/power10/multiarch
diff --git a/sysdeps/powerpc/powerpc64/le/tst-glibc-hwcaps.c b/sysdeps/powerpc/powerpc64/le/tst-glibc-hwcaps.c
index 77465d9133..65d3e69303 100644
--- a/sysdeps/powerpc/powerpc64/le/tst-glibc-hwcaps.c
+++ b/sysdeps/powerpc/powerpc64/le/tst-glibc-hwcaps.c
@@ -36,9 +36,11 @@ compute_level (void)
     return 9;
   if (strcmp (platform, "power10") == 0)
     return 10;
+  if (strcmp (platform, "power11") == 0)
+    return 11;
   printf ("warning: unrecognized AT_PLATFORM value: %s\n", platform);
-  /* Assume that the new platform supports POWER10.  */
-  return 10;
+  /* Assume that the new platform supports POWER11.  */
+  return 11;
 }
 
 static int
diff --git a/sysdeps/powerpc/powerpc64/multiarch/Makefile b/sysdeps/powerpc/powerpc64/multiarch/Makefile
index 594fbb8058..f6d93f2551 100644
--- a/sysdeps/powerpc/powerpc64/multiarch/Makefile
+++ b/sysdeps/powerpc/powerpc64/multiarch/Makefile
@@ -31,10 +31,10 @@ sysdep_routines += memcpy-power8-cached memcpy-power7 memcpy-a2 memcpy-power6 \
 		   strncase-power8
 
 ifneq (,$(filter %le,$(config-machine)))
-sysdep_routines += memchr-power10 memcmp-power10 memcpy-power10 \
-		   memmove-power10 memset-power10 rawmemchr-power9 \
-		   rawmemchr-power10 strcmp-power9 strcmp-power10 \
-		   strncmp-power9 strcpy-power9 stpcpy-power9 \
+sysdep_routines += memcmp-power10 memcpy-power10 memmove-power10 memset-power10 \
+		   rawmemchr-power9 rawmemchr-power10 \
+		   strcmp-power9 strcmp-power10 strncmp-power9 strncmp-power10 \
+		   strcpy-power9 stpcpy-power9 \
 		   strlen-power9 strncpy-power9 stpncpy-power9 strlen-power10
 endif
 CFLAGS-strncase-power7.c += -mcpu=power7 -funroll-loops
diff --git a/sysdeps/powerpc/powerpc64/multiarch/ifunc-impl-list.c b/sysdeps/powerpc/powerpc64/multiarch/ifunc-impl-list.c
index 5b2d6a90ab..99d24ed1ff 100644
--- a/sysdeps/powerpc/powerpc64/multiarch/ifunc-impl-list.c
+++ b/sysdeps/powerpc/powerpc64/multiarch/ifunc-impl-list.c
@@ -164,6 +164,9 @@ __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
   /* Support sysdeps/powerpc/powerpc64/multiarch/strncmp.c.  */
   IFUNC_IMPL (i, name, strncmp,
 #ifdef __LITTLE_ENDIAN__
+	      IFUNC_IMPL_ADD (array, i, strncmp, hwcap2 & PPC_FEATURE2_ARCH_3_1
+			      && hwcap & PPC_FEATURE_HAS_VSX,
+			      __strncmp_power10)
 	      IFUNC_IMPL_ADD (array, i, strncmp, hwcap2 & PPC_FEATURE2_ARCH_3_00
 			      && hwcap & PPC_FEATURE_HAS_ALTIVEC,
 			      __strncmp_power9)
@@ -226,12 +229,6 @@ __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
 
   /* Support sysdeps/powerpc/powerpc64/multiarch/memchr.c.  */
   IFUNC_IMPL (i, name, memchr,
-#ifdef __LITTLE_ENDIAN__
-	      IFUNC_IMPL_ADD (array, i, memchr,
-		              hwcap2 & PPC_FEATURE2_ARCH_3_1
-			      && hwcap & PPC_FEATURE_HAS_VSX,
-			      __memchr_power10)
-#endif
 	      IFUNC_IMPL_ADD (array, i, memchr,
 			      hwcap2 & PPC_FEATURE2_ARCH_2_07
 			      && hwcap & PPC_FEATURE_HAS_ALTIVEC,
diff --git a/sysdeps/powerpc/powerpc64/multiarch/memchr.c b/sysdeps/powerpc/powerpc64/multiarch/memchr.c
index 57d23e7b18..b4655dfcaa 100644
--- a/sysdeps/powerpc/powerpc64/multiarch/memchr.c
+++ b/sysdeps/powerpc/powerpc64/multiarch/memchr.c
@@ -25,23 +25,15 @@ extern __typeof (__memchr) __memchr_ppc attribute_hidden;
 extern __typeof (__memchr) __memchr_power7 attribute_hidden;
 extern __typeof (__memchr) __memchr_power8 attribute_hidden;
 
-# ifdef __LITTLE_ENDIAN__
-extern __typeof (__memchr) __memchr_power10 attribute_hidden;
-# endif
 /* Avoid DWARF definition DIE on ifunc symbol so that GDB can handle
    ifunc symbol properly.  */
 libc_ifunc (__memchr,
-# ifdef __LITTLE_ENDIAN__
-	    (hwcap2 & PPC_FEATURE2_ARCH_3_1
-	     && hwcap & PPC_FEATURE_HAS_VSX)
-	    ? __memchr_power10 :
-# endif
-	      (hwcap2 & PPC_FEATURE2_ARCH_2_07
-	      && hwcap & PPC_FEATURE_HAS_ALTIVEC)
-	      ? __memchr_power8 :
-	        (hwcap & PPC_FEATURE_ARCH_2_06)
-	        ? __memchr_power7
-	        : __memchr_ppc);
+	    (hwcap2 & PPC_FEATURE2_ARCH_2_07
+	     && hwcap & PPC_FEATURE_HAS_ALTIVEC)
+	    ? __memchr_power8 :
+	    (hwcap & PPC_FEATURE_ARCH_2_06)
+            ? __memchr_power7
+            : __memchr_ppc);
 
 weak_alias (__memchr, memchr)
 libc_hidden_builtin_def (memchr)
diff --git a/sysdeps/powerpc/powerpc64/multiarch/strcmp-power10.S b/sysdeps/powerpc/powerpc64/multiarch/strcmp-power10.S
index 1a9f6069f5..a4ee7fb53c 100644
--- a/sysdeps/powerpc/powerpc64/multiarch/strcmp-power10.S
+++ b/sysdeps/powerpc/powerpc64/multiarch/strcmp-power10.S
@@ -1,5 +1,5 @@
 /* Optimized strcmp implementation for POWER10/PPC64.
-   Copyright (C) 2021-2024 Free Software Foundation, Inc.
+   Copyright (C) 2025 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
diff --git a/sysdeps/powerpc/powerpc64/multiarch/memchr-power10.S b/sysdeps/powerpc/powerpc64/multiarch/strncmp-power10.S
similarity index 77%
rename from sysdeps/powerpc/powerpc64/multiarch/memchr-power10.S
rename to sysdeps/powerpc/powerpc64/multiarch/strncmp-power10.S
index 7d35ef28a9..bb25bc75b8 100644
--- a/sysdeps/powerpc/powerpc64/multiarch/memchr-power10.S
+++ b/sysdeps/powerpc/powerpc64/multiarch/strncmp-power10.S
@@ -1,5 +1,4 @@
-/* Optimized memchr implementation for POWER10/PPC64.
-   Copyright (C) 2016-2024 Free Software Foundation, Inc.
+/* Copyright (C) 2025 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -17,12 +16,10 @@
    <https://www.gnu.org/licenses/>.  */
 
 #if defined __LITTLE_ENDIAN__ && IS_IN (libc)
-#define MEMCHR __memchr_power10
+#define STRNCMP __strncmp_power10
 
 #undef libc_hidden_builtin_def
 #define libc_hidden_builtin_def(name)
-#undef weak_alias
-#define weak_alias(name,alias)
 
-#include <sysdeps/powerpc/powerpc64/le/power10/memchr.S>
+#include <sysdeps/powerpc/powerpc64/le/power10/strncmp.S>
 #endif
diff --git a/sysdeps/powerpc/powerpc64/multiarch/strncmp.c b/sysdeps/powerpc/powerpc64/multiarch/strncmp.c
index 6178f4a432..a5ed67f766 100644
--- a/sysdeps/powerpc/powerpc64/multiarch/strncmp.c
+++ b/sysdeps/powerpc/powerpc64/multiarch/strncmp.c
@@ -29,6 +29,7 @@ extern __typeof (strncmp) __strncmp_ppc attribute_hidden;
 extern __typeof (strncmp) __strncmp_power8 attribute_hidden;
 # ifdef __LITTLE_ENDIAN__
 extern __typeof (strncmp) __strncmp_power9 attribute_hidden;
+extern __typeof (strncmp) __strncmp_power10 attribute_hidden;
 # endif
 # undef strncmp
 
@@ -36,6 +37,9 @@ extern __typeof (strncmp) __strncmp_power9 attribute_hidden;
    ifunc symbol properly.  */
 libc_ifunc_redirected (__redirect_strncmp, strncmp,
 # ifdef __LITTLE_ENDIAN__
+			(hwcap2 & PPC_FEATURE2_ARCH_3_1
+			 && hwcap & PPC_FEATURE_HAS_VSX)
+			? __strncmp_power10 :
 			(hwcap2 & PPC_FEATURE2_ARCH_3_00
 			 && hwcap & PPC_FEATURE_HAS_ALTIVEC)
 			? __strncmp_power9 :
diff --git a/sysdeps/powerpc/preconfigure b/sysdeps/powerpc/preconfigure
index 4de94089a3..9e5a07ab6d 100644
--- a/sysdeps/powerpc/preconfigure
+++ b/sysdeps/powerpc/preconfigure
@@ -58,7 +58,7 @@ fi
 
     ;;
 
-  a2|970|power[4-9]|power5x|power6+|power10)
+  a2|970|power[4-9]|power5x|power6+|power10|power11)
     submachine=${archcpu}
     if test ${libc_cv_cc_submachine+y}
 then :
diff --git a/sysdeps/powerpc/preconfigure.ac b/sysdeps/powerpc/preconfigure.ac
index 6c63bd8257..14b6dafd4a 100644
--- a/sysdeps/powerpc/preconfigure.ac
+++ b/sysdeps/powerpc/preconfigure.ac
@@ -46,7 +46,7 @@ case "${machine}:${submachine}" in
     AC_CACHE_VAL(libc_cv_cc_submachine,libc_cv_cc_submachine="")
     ;;
 
-  a2|970|power[[4-9]]|power5x|power6+|power10)
+  a2|970|power[[4-9]]|power5x|power6+|power10|power11)
     submachine=${archcpu}
     AC_CACHE_VAL(libc_cv_cc_submachine,libc_cv_cc_submachine="")
     ;;
diff --git a/sysdeps/powerpc/utmp-size.h b/sysdeps/powerpc/utmp-size.h
new file mode 100644
index 0000000000..8f21ebe1b6
--- /dev/null
+++ b/sysdeps/powerpc/utmp-size.h
@@ -0,0 +1,2 @@
+#define UTMP_SIZE 384
+#define LASTLOG_SIZE 292
diff --git a/sysdeps/pthread/Makefile b/sysdeps/pthread/Makefile
index f9efb50764..830d9cb878 100644
--- a/sysdeps/pthread/Makefile
+++ b/sysdeps/pthread/Makefile
@@ -254,6 +254,7 @@ tests += \
   tst-sem14 \
   tst-sem15 \
   tst-sem16 \
+  tst-sem18 \
   tst-setuid3 \
   tst-signal1 \
   tst-signal2 \
@@ -282,6 +283,10 @@ tests += \
   tst-vfork2x \
   # tests
 
+tests-2.0 += \
+  tst-pthread_kill-exited
+  # tests-2.0
+
 tests-time64 += \
   tst-abstime-time64 \
   tst-cnd-timedwait-time64 \
diff --git a/sysdeps/pthread/sem_open.c b/sysdeps/pthread/sem_open.c
index e41236157a..dab734191a 100644
--- a/sysdeps/pthread/sem_open.c
+++ b/sysdeps/pthread/sem_open.c
@@ -76,6 +76,7 @@ __sem_open (const char *name, int oflag, ...)
 	    goto try_create;
 
 	  /* Return.  errno is already set.  */
+	  result = SEM_FAILED;
 	}
       else
 	/* Check whether we already have this semaphore mapped and
diff --git a/sysdeps/pthread/semaphore.h b/sysdeps/pthread/semaphore.h
index c75ca4ce6d..8a09633699 100644
--- a/sysdeps/pthread/semaphore.h
+++ b/sysdeps/pthread/semaphore.h
@@ -59,7 +59,7 @@ extern int sem_wait (sem_t *__sem) __nonnull ((1));
 
    This function is a cancellation point and therefore not marked with
    __THROW.  */
-# ifndef __USE_TIME_BITS64
+# ifndef __USE_TIME64_REDIRECTS
 extern int sem_timedwait (sem_t *__restrict __sem,
 			  const struct timespec *__restrict __abstime)
   __nonnull ((1, 2));
@@ -77,7 +77,7 @@ extern int __REDIRECT (sem_timedwait,
 #endif
 
 #ifdef __USE_GNU
-# ifndef __USE_TIME_BITS64
+# ifndef __USE_TIME64_REDIRECTS
 extern int sem_clockwait (sem_t *__restrict __sem,
 			  clockid_t clock,
 			  const struct timespec *__restrict __abstime)
diff --git a/sysdeps/pthread/threads.h b/sysdeps/pthread/threads.h
index c5410b5c3a..7cade24e1f 100644
--- a/sysdeps/pthread/threads.h
+++ b/sysdeps/pthread/threads.h
@@ -90,7 +90,7 @@ extern thrd_t thrd_current (void);
    __TIME_POINT.  The current thread may resume if receives a signal.  In
    that case, if __REMAINING is not NULL, the remaining time is stored in
    the object pointed by it.  */
-#ifndef __USE_TIME_BITS64
+#ifndef __USE_TIME64_REDIRECTS
 extern int thrd_sleep (const struct timespec *__time_point,
 		       struct timespec *__remaining);
 #else
@@ -143,7 +143,7 @@ extern int mtx_lock (mtx_t *__mutex);
 /* Block the current thread until the mutex pointed by __MUTEX is unlocked
    or time pointed by __TIME_POINT is reached.  In case the mutex is unlock,
    the current thread will not be blocked.  */
-#ifndef __USE_TIME_BITS64
+#ifndef __USE_TIME64_REDIRECTS
 extern int mtx_timedlock (mtx_t *__restrict __mutex,
 			  const struct timespec *__restrict __time_point);
 #else
@@ -194,7 +194,7 @@ extern int cnd_wait (cnd_t *__cond, mtx_t *__mutex);
 /* Block current thread on the condition variable until condition variable
    pointed by __COND is signaled or time pointed by __TIME_POINT is
    reached.  */
-#ifndef __USE_TIME_BITS64
+#ifndef __USE_TIME64_REDIRECTS
 extern int cnd_timedwait (cnd_t *__restrict __cond,
 			  mtx_t *__restrict __mutex,
 			  const struct timespec *__restrict __time_point);
diff --git a/sysdeps/pthread/tst-cancel30.c b/sysdeps/pthread/tst-cancel30.c
index 3030660e5f..94ad6281bc 100644
--- a/sysdeps/pthread/tst-cancel30.c
+++ b/sysdeps/pthread/tst-cancel30.c
@@ -18,6 +18,7 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
+#include <errno.h>
 #include <support/check.h>
 #include <support/xstdio.h>
 #include <support/xthread.h>
@@ -46,13 +47,19 @@ tf (void *arg)
 
   /* Wait indefinitely for cancellation, which only works if asynchronous
      cancellation is enabled.  */
-#if defined SYS_ppoll || defined SYS_ppoll_time64
-# ifndef SYS_ppoll_time64
-#  define SYS_ppoll_time64 SYS_ppoll
+#ifdef SYS_ppoll_time64
+  long int ret = syscall (SYS_ppoll_time64, NULL, 0, NULL, NULL);
+  (void) ret;
+# ifdef SYS_ppoll
+  if (ret == -1 && errno == ENOSYS)
+    syscall (SYS_ppoll, NULL, 0, NULL, NULL);
 # endif
-  syscall (SYS_ppoll_time64, NULL, 0, NULL, NULL);
 #else
+# ifdef SYS_ppoll
+  syscall (SYS_ppoll, NULL, 0, NULL, NULL);
+# else
   for (;;);
+# endif
 #endif
 
   return 0;
diff --git a/sysdeps/pthread/tst-sem18.c b/sysdeps/pthread/tst-sem18.c
new file mode 100644
index 0000000000..1be207bcbe
--- /dev/null
+++ b/sysdeps/pthread/tst-sem18.c
@@ -0,0 +1,35 @@
+/* Test sem_open with missing file.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <semaphore.h>
+
+#include <support/check.h>
+
+int
+do_test (void)
+{
+  sem_unlink ("/glibc-tst-sem18");
+  errno = 0;
+  sem_t *s = sem_open ("/glibc-tst-sem18", 0);
+  TEST_VERIFY (s == SEM_FAILED);
+  TEST_COMPARE (errno, ENOENT);
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/sysdeps/pthread/tst-setuid3.c b/sysdeps/pthread/tst-setuid3.c
index 83f42a0ae5..3845ab03d3 100644
--- a/sysdeps/pthread/tst-setuid3.c
+++ b/sysdeps/pthread/tst-setuid3.c
@@ -15,24 +15,19 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <stdio.h>
 #include <errno.h>
 #include <pthread.h>
 #include <stdbool.h>
 #include <unistd.h>
 
+#include <support/check.h>
+
 /* The test must run under a non-privileged user ID.  */
 static const uid_t test_uid = 1;
 
 static pthread_barrier_t barrier1;
 static pthread_barrier_t barrier2;
 
-#define FAIL(fmt, ...) \
-  do { printf ("FAIL: " fmt "\n", __VA_ARGS__); _exit (1); } while (0)
-
-#define FAIL_ERR(fmt, ...) \
-  do { printf ("FAIL: " fmt ": %m\n", __VA_ARGS__); _exit (1); } while (0)
-
 /* True if x is not a successful return code from pthread_barrier_wait.  */
 static inline bool
 is_invalid_barrier_ret (int x)
@@ -45,10 +40,10 @@ thread_func (void *ctx __attribute__ ((unused)))
 {
   int ret = pthread_barrier_wait (&barrier1);
   if (is_invalid_barrier_ret (ret))
-    FAIL ("pthread_barrier_wait (barrier1) (on thread): %d", ret);
+    FAIL_EXIT1 ("pthread_barrier_wait (barrier1) (on thread): %d", ret);
   ret = pthread_barrier_wait (&barrier2);
   if (is_invalid_barrier_ret (ret))
-    FAIL ("pthread_barrier_wait (barrier2) (on thread): %d", ret);
+    FAIL_EXIT1 ("pthread_barrier_wait (barrier2) (on thread): %d", ret);
   return NULL;
 }
 
@@ -59,13 +54,13 @@ setuid_failure (int phase)
   switch (ret)
     {
     case 0:
-      FAIL ("setuid succeeded unexpectedly in phase %d", phase);
+      FAIL_EXIT1 ("setuid succeeded unexpectedly in phase %d", phase);
     case -1:
       if (errno != EPERM)
-	FAIL_ERR ("setuid phase %d", phase);
+	FAIL_EXIT1 ("setuid phase %d: %m", phase);
       break;
     default:
-      FAIL ("invalid setuid return value in phase %d: %d", phase, ret);
+      FAIL_EXIT1 ("invalid setuid return value in phase %d: %d", phase, ret);
     }
 }
 
@@ -74,42 +69,42 @@ do_test (void)
 {
   if (getuid () == 0)
     if (setuid (test_uid) != 0)
-      FAIL_ERR ("setuid (%u)", (unsigned) test_uid);
+      FAIL_EXIT1 ("setuid (%u): %m", (unsigned) test_uid);
   if (setuid (getuid ()))
-    FAIL_ERR ("setuid (%s)", "getuid ()");
+    FAIL_EXIT1 ("setuid (%s): %m", "getuid ()");
   setuid_failure (1);
 
   int ret = pthread_barrier_init (&barrier1, NULL, 2);
   if (ret != 0)
-    FAIL ("pthread_barrier_init (barrier1): %d", ret);
+    FAIL_EXIT1 ("pthread_barrier_init (barrier1): %d", ret);
   ret = pthread_barrier_init (&barrier2, NULL, 2);
   if (ret != 0)
-    FAIL ("pthread_barrier_init (barrier2): %d", ret);
+    FAIL_EXIT1 ("pthread_barrier_init (barrier2): %d", ret);
 
   pthread_t thread;
   ret = pthread_create (&thread, NULL, thread_func, NULL);
   if (ret != 0)
-    FAIL ("pthread_create: %d", ret);
+    FAIL_EXIT1 ("pthread_create: %d", ret);
 
   /* Ensure that the thread is running properly.  */
   ret = pthread_barrier_wait (&barrier1);
   if (is_invalid_barrier_ret (ret))
-    FAIL ("pthread_barrier_wait (barrier1): %d", ret);
+    FAIL_EXIT1 ("pthread_barrier_wait (barrier1): %d", ret);
 
   setuid_failure (2);
 
   /* Check success case. */
   if (setuid (getuid ()) != 0)
-    FAIL_ERR ("setuid (%s)", "getuid ()");
+    FAIL_EXIT1 ("setuid (%s): %m", "getuid ()");
 
   /* Shutdown.  */
   ret = pthread_barrier_wait (&barrier2);
   if (is_invalid_barrier_ret (ret))
-    FAIL ("pthread_barrier_wait (barrier2): %d", ret);
+    FAIL_EXIT1 ("pthread_barrier_wait (barrier2): %d", ret);
 
   ret = pthread_join (thread, NULL);
   if (ret != 0)
-    FAIL ("pthread_join: %d", ret);
+    FAIL_EXIT1 ("pthread_join: %d", ret);
 
   return 0;
 }
diff --git a/sysdeps/riscv/utmp-size.h b/sysdeps/riscv/utmp-size.h
new file mode 100644
index 0000000000..8f21ebe1b6
--- /dev/null
+++ b/sysdeps/riscv/utmp-size.h
@@ -0,0 +1,2 @@
+#define UTMP_SIZE 384
+#define LASTLOG_SIZE 292
diff --git a/sysdeps/s390/wcsncmp-vx.S b/sysdeps/s390/wcsncmp-vx.S
index bf6dfa6bc2..8b081567a2 100644
--- a/sysdeps/s390/wcsncmp-vx.S
+++ b/sysdeps/s390/wcsncmp-vx.S
@@ -59,14 +59,7 @@ ENTRY(WCSNCMP_Z13)
 	sllg	%r4,%r4,2	/* Convert character-count to byte-count.  */
 	locgrne	%r4,%r1		/* Use max byte-count, if bit 0/1 was one.  */
 
-	/* Check first character without vector load.  */
-	lghi	%r5,4		/* current_len = 4 bytes.  */
-	/* Check s1/2[0].  */
-	lt	%r0,0(%r2)
-	l	%r1,0(%r3)
-	je	.Lend_cmp_one_char
-	crjne	%r0,%r1,.Lend_cmp_one_char
-
+	lghi	%r5,0		/* current_len = 0 bytes.  */
 .Lloop:
 	vlbb	%v17,0(%r5,%r3),6 /* Load s2 to block boundary.  */
 	vlbb	%v16,0(%r5,%r2),6 /* Load s1 to block boundary.  */
@@ -167,7 +160,6 @@ ENTRY(WCSNCMP_Z13)
 	srl	%r4,2		/* And convert it to character-index.  */
 	vlgvf	%r0,%v16,0(%r4)	/* Load character-values.  */
 	vlgvf	%r1,%v17,0(%r4)
-.Lend_cmp_one_char:
 	cr	%r0,%r1
 	je	.Lend_equal
 	lghi	%r2,1
diff --git a/sysdeps/sh/bits/wordsize.h b/sysdeps/sh/bits/wordsize.h
new file mode 100644
index 0000000000..6ecbfe7c86
--- /dev/null
+++ b/sysdeps/sh/bits/wordsize.h
@@ -0,0 +1,21 @@
+/* Copyright (C) 1999-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define __WORDSIZE			32
+#define __WORDSIZE_TIME64_COMPAT32	1
+#define __WORDSIZE32_SIZE_ULONG		0
+#define __WORDSIZE32_PTRDIFF_LONG	0
diff --git a/sysdeps/sh/utmp-size.h b/sysdeps/sh/utmp-size.h
new file mode 100644
index 0000000000..8f21ebe1b6
--- /dev/null
+++ b/sysdeps/sh/utmp-size.h
@@ -0,0 +1,2 @@
+#define UTMP_SIZE 384
+#define LASTLOG_SIZE 292
diff --git a/sysdeps/sparc/sparc32/bits/wordsize.h b/sysdeps/sparc/sparc32/bits/wordsize.h
index 4bbd2e63b4..a2e79e0fa9 100644
--- a/sysdeps/sparc/sparc32/bits/wordsize.h
+++ b/sysdeps/sparc/sparc32/bits/wordsize.h
@@ -1,6 +1,6 @@
 /* Determine the wordsize from the preprocessor defines.  */
 
 #define __WORDSIZE	32
-#define __WORDSIZE_TIME64_COMPAT32	0
+#define __WORDSIZE_TIME64_COMPAT32	1
 #define __WORDSIZE32_SIZE_ULONG	0
 #define __WORDSIZE32_PTRDIFF_LONG	0
diff --git a/sysdeps/sparc/sparc64/bits/wordsize.h b/sysdeps/sparc/sparc64/bits/wordsize.h
index 2f66f10d72..ea103e5970 100644
--- a/sysdeps/sparc/sparc64/bits/wordsize.h
+++ b/sysdeps/sparc/sparc64/bits/wordsize.h
@@ -2,10 +2,9 @@
 
 #if defined __arch64__ || defined __sparcv9
 # define __WORDSIZE	64
-# define __WORDSIZE_TIME64_COMPAT32	1
 #else
 # define __WORDSIZE	32
-# define __WORDSIZE_TIME64_COMPAT32	0
 # define __WORDSIZE32_SIZE_ULONG	0
 # define __WORDSIZE32_PTRDIFF_LONG	0
 #endif
+#define __WORDSIZE_TIME64_COMPAT32	1
diff --git a/sysdeps/sparc/sparc64/rtld-memset.c b/sysdeps/sparc/sparc64/rtld-memset.c
index 55f3835790..a19202a620 100644
--- a/sysdeps/sparc/sparc64/rtld-memset.c
+++ b/sysdeps/sparc/sparc64/rtld-memset.c
@@ -1 +1,4 @@
 #include <string/memset.c>
+#if IS_IN(rtld)
+strong_alias (memset, __memset_ultra1)
+#endif
diff --git a/sysdeps/sparc/utmp-size.h b/sysdeps/sparc/utmp-size.h
new file mode 100644
index 0000000000..8f21ebe1b6
--- /dev/null
+++ b/sysdeps/sparc/utmp-size.h
@@ -0,0 +1,2 @@
+#define UTMP_SIZE 384
+#define LASTLOG_SIZE 292
diff --git a/sysdeps/unix/sysv/linux/Makefile b/sysdeps/unix/sysv/linux/Makefile
index 415aa1f14d..a7938a86ac 100644
--- a/sysdeps/unix/sysv/linux/Makefile
+++ b/sysdeps/unix/sysv/linux/Makefile
@@ -205,6 +205,7 @@ tests += \
   tst-getauxval \
   tst-gettid \
   tst-gettid-kill \
+  tst-linux-mremap1 \
   tst-memfd_create \
   tst-misalign-clone \
   tst-mlock2 \
@@ -615,6 +616,10 @@ tests += \
 endif
 
 ifeq ($(subdir),elf)
+dl-routines += \
+  dl-rseq-symbols \
+  # dl-routines
+
 sysdep-rtld-routines += \
   dl-brk \
   dl-getcwd \
@@ -632,7 +637,15 @@ install-bin += \
   # install-bin
 
 $(objpfx)pldd: $(objpfx)xmalloc.o
+
+test-internal-extras += tst-nolink-libc
+ifeq ($(run-built-tests),yes)
+tests-special += \
+  $(objpfx)tst-nolink-libc-1.out \
+  $(objpfx)tst-nolink-libc-2.out \
+  # tests-special
 endif
+endif # $(subdir) == elf
 
 ifeq ($(subdir),rt)
 CFLAGS-mq_send.c += -fexceptions
diff --git a/sysdeps/unix/sysv/linux/____longjmp_chk.c b/sysdeps/unix/sysv/linux/____longjmp_chk.c
index 0896dc5755..3c66a4638e 100644
--- a/sysdeps/unix/sysv/linux/____longjmp_chk.c
+++ b/sysdeps/unix/sysv/linux/____longjmp_chk.c
@@ -23,7 +23,7 @@
 #include <stdio.h>
 #include <stackinfo.h>
 
-#ifdef _STACK_GROWS_DOWN
+#if _STACK_GROWS_DOWN
 #define called_from(this, saved) ((this) < (saved))
 #else
 #define called_from(this, saved) ((this) > (saved))
diff --git a/sysdeps/unix/sysv/linux/aarch64/clone.S b/sysdeps/unix/sysv/linux/aarch64/clone.S
index 0e7ee24e68..4fb9f02792 100644
--- a/sysdeps/unix/sysv/linux/aarch64/clone.S
+++ b/sysdeps/unix/sysv/linux/aarch64/clone.S
@@ -51,6 +51,9 @@ ENTRY(__clone)
 	and	x1, x1, -16
 	cbz	x1, .Lsyscall_error
 
+	/* Clear ZA state of SME.  */
+	CALL_LIBC_ARM_ZA_DISABLE
+
 	/* Do the system call.  */
 	/* X0:flags, x1:newsp, x2:parenttidptr, x3:newtls, x4:childtid.  */
 	mov	x0, x2                  /* flags  */
diff --git a/sysdeps/unix/sysv/linux/aarch64/clone3.S b/sysdeps/unix/sysv/linux/aarch64/clone3.S
index 92d69a5430..1acefd2ded 100644
--- a/sysdeps/unix/sysv/linux/aarch64/clone3.S
+++ b/sysdeps/unix/sysv/linux/aarch64/clone3.S
@@ -50,6 +50,9 @@ ENTRY(__clone3)
 	cbz	x10, .Lsyscall_error	/* No NULL cl_args pointer.  */
 	cbz	x2, .Lsyscall_error	/* No NULL function pointer.  */
 
+    /* Clear ZA state of SME.  */
+	CALL_LIBC_ARM_ZA_DISABLE
+
 	/* Do the system call, the kernel expects:
 	   x8: system call number
 	   x0: cl_args
diff --git a/sysdeps/unix/sysv/linux/aarch64/cpu-features.c b/sysdeps/unix/sysv/linux/aarch64/cpu-features.c
index b1a3f673f0..0ad55a0c7f 100644
--- a/sysdeps/unix/sysv/linux/aarch64/cpu-features.c
+++ b/sysdeps/unix/sysv/linux/aarch64/cpu-features.c
@@ -21,7 +21,9 @@
 #include <sys/auxv.h>
 #include <elf/dl-hwcaps.h>
 #include <sys/prctl.h>
+#include <sys/utsname.h>
 #include <dl-tunables-parse.h>
+#include <dl-symbol-redir-ifunc.h>
 
 #define DCZID_DZP_MASK (1 << 4)
 #define DCZID_BS_MASK (0xf)
@@ -62,6 +64,46 @@ get_midr_from_mcpu (const struct tunable_str_t *mcpu)
   return UINT64_MAX;
 }
 
+#if __LINUX_KERNEL_VERSION < 0x060200
+
+/* Return true if we prefer using SVE in string ifuncs.  Old kernels disable
+   SVE after every system call which results in unnecessary traps if memcpy
+   uses SVE.  This is true for kernels between 4.15.0 and before 6.2.0, except
+   for 5.14.0 which was patched.  For these versions return false to avoid using
+   SVE ifuncs.
+   Parse the kernel version into a 24-bit kernel.major.minor value without
+   calling any library functions.  If uname() is not supported or if the version
+   format is not recognized, assume the kernel is modern and return true.  */
+
+static inline bool
+prefer_sve_ifuncs (void)
+{
+  struct utsname buf;
+  const char *p = &buf.release[0];
+  int kernel = 0;
+  int val;
+
+  if (__uname (&buf) < 0)
+    return true;
+
+  for (int shift = 16; shift >= 0; shift -= 8)
+    {
+      for (val = 0; *p >= '0' && *p <= '9'; p++)
+	val = val * 10 + *p - '0';
+      kernel |= (val & 255) << shift;
+      if (*p++ != '.')
+	break;
+    }
+
+  if (kernel >= 0x060200 || kernel == 0x050e00)
+    return true;
+  if (kernel >= 0x040f00)
+    return false;
+  return true;
+}
+
+#endif
+
 static inline void
 init_cpu_features (struct cpu_features *cpu_features)
 {
@@ -126,6 +168,13 @@ init_cpu_features (struct cpu_features *cpu_features)
   /* Check if SVE is supported.  */
   cpu_features->sve = GLRO (dl_hwcap) & HWCAP_SVE;
 
+  cpu_features->prefer_sve_ifuncs = cpu_features->sve;
+
+#if __LINUX_KERNEL_VERSION < 0x060200
+  if (cpu_features->sve)
+    cpu_features->prefer_sve_ifuncs = prefer_sve_ifuncs ();
+#endif
+
   /* Check if MOPS is supported.  */
   cpu_features->mops = GLRO (dl_hwcap2) & HWCAP2_MOPS;
 }
diff --git a/sysdeps/unix/sysv/linux/aarch64/setcontext.S b/sysdeps/unix/sysv/linux/aarch64/setcontext.S
index ba659438c5..1be9be2c27 100644
--- a/sysdeps/unix/sysv/linux/aarch64/setcontext.S
+++ b/sysdeps/unix/sysv/linux/aarch64/setcontext.S
@@ -49,25 +49,8 @@ ENTRY (__setcontext)
 	cbz	x0, 1f
 	b	C_SYMBOL_NAME (__syscall_error)
 1:
-	/* Disable ZA of SME.  */
-#if HAVE_AARCH64_PAC_RET
-	PACIASP
-	cfi_window_save
-#endif
-	stp	x29, x30, [sp, -16]!
-	cfi_adjust_cfa_offset (16)
-	cfi_rel_offset (x29, 0)
-	cfi_rel_offset (x30, 8)
-	mov	x29, sp
-	bl	__libc_arm_za_disable
-	ldp	x29, x30, [sp], 16
-	cfi_adjust_cfa_offset (-16)
-	cfi_restore (x29)
-	cfi_restore (x30)
-#if HAVE_AARCH64_PAC_RET
-	AUTIASP
-	cfi_window_save
-#endif
+	/* Clear ZA state of SME.  */
+	CALL_LIBC_ARM_ZA_DISABLE
 	/* Restore the general purpose registers.  */
 	mov	x0, x9
 	cfi_def_cfa (x0, 0)
diff --git a/sysdeps/unix/sysv/linux/aarch64/sysdep.h b/sysdeps/unix/sysv/linux/aarch64/sysdep.h
index bbbe35723c..dd98242dad 100644
--- a/sysdeps/unix/sysv/linux/aarch64/sysdep.h
+++ b/sysdeps/unix/sysv/linux/aarch64/sysdep.h
@@ -150,6 +150,19 @@
     mov x8, SYS_ify (syscall_name);		\
     svc 0
 
+/* Clear ZA state of SME (ASM version).  */
+/* The __libc_arm_za_disable function has special calling convention
+   that allows to call it without stack manipulation and preserving
+   most of the registers.  */
+	.macro CALL_LIBC_ARM_ZA_DISABLE
+	cfi_remember_state
+	mov		x13, x30
+	cfi_register(x30, x13)
+	bl		__libc_arm_za_disable
+	mov		x30, x13
+	cfi_restore_state
+	.endm
+
 #else /* not __ASSEMBLER__ */
 
 # ifdef __LP64__
@@ -234,6 +247,32 @@
 #undef HAVE_INTERNAL_BRK_ADDR_SYMBOL
 #define HAVE_INTERNAL_BRK_ADDR_SYMBOL 1
 
+/* Clear ZA state of SME (C version).  */
+/* The __libc_arm_za_disable function has special calling convention
+   that allows to call it without stack manipulation and preserving
+   most of the registers.  */
+#define CALL_LIBC_ARM_ZA_DISABLE()			\
+({							\
+  unsigned long int __tmp;				\
+  asm volatile (					\
+  "	.cfi_remember_state\n"			\
+  "	mov		%0, x30\n"			\
+  "	.cfi_register x30, %0\n"      \
+  "	bl		__libc_arm_za_disable\n"	\
+  "	mov		x30, %0\n"			\
+  "	.cfi_restore_state\n"			\
+  : "=r" (__tmp)					\
+  :							\
+  : "x14", "x15", "x16", "x17", "x18", "memory" );	\
+})
+
+/* Do clear ZA state of SME before making normal clone syscall.  */
+#define INLINE_CLONE_SYSCALL(a0, a1, a2, a3, a4)	\
+({							\
+  CALL_LIBC_ARM_ZA_DISABLE ();				\
+  INLINE_SYSCALL_CALL (clone, a0, a1, a2, a3, a4);	\
+})
+
 #endif	/* __ASSEMBLER__ */
 
 #endif /* linux/aarch64/sysdep.h */
diff --git a/sysdeps/unix/sysv/linux/aarch64/vfork.S b/sysdeps/unix/sysv/linux/aarch64/vfork.S
index e71e492da3..65fa85ae89 100644
--- a/sysdeps/unix/sysv/linux/aarch64/vfork.S
+++ b/sysdeps/unix/sysv/linux/aarch64/vfork.S
@@ -27,6 +27,9 @@
 
 ENTRY (__vfork)
 
+	/* Clear ZA state of SME.  */
+	CALL_LIBC_ARM_ZA_DISABLE
+
 	mov	x0, #0x4111	/* CLONE_VM | CLONE_VFORK | SIGCHLD */
 	mov	x1, sp
 	DO_CALL (clone, 2)
diff --git a/sysdeps/unix/sysv/linux/arm/Makefile b/sysdeps/unix/sysv/linux/arm/Makefile
index a73c897f43..e73ce4f811 100644
--- a/sysdeps/unix/sysv/linux/arm/Makefile
+++ b/sysdeps/unix/sysv/linux/arm/Makefile
@@ -1,5 +1,8 @@
 ifeq ($(subdir),elf)
 sysdep-rtld-routines += aeabi_read_tp libc-do-syscall
+# The test uses INTERNAL_SYSCALL_CALL.  In thumb mode, this uses
+# an undefined reference to __libc_do_syscall.
+CFLAGS-tst-nolink-libc.c += -marm
 endif
 
 ifeq ($(subdir),misc)
diff --git a/sysdeps/unix/sysv/linux/arm/bits/struct_stat.h b/sysdeps/unix/sysv/linux/arm/bits/struct_stat.h
index 255feaa8cb..89534fea85 100644
--- a/sysdeps/unix/sysv/linux/arm/bits/struct_stat.h
+++ b/sysdeps/unix/sysv/linux/arm/bits/struct_stat.h
@@ -28,7 +28,7 @@
 
 struct stat
   {
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # include <bits/struct_stat_time64_helper.h>
 #else
     __dev_t st_dev;			/* Device.  */
@@ -83,13 +83,13 @@ struct stat
 # else
     __ino64_t st_ino;			/* File serial number.	*/
 # endif
-#endif /* __USE_TIME_BITS64  */
+#endif /* __USE_TIME64_REDIRECTS  */
   };
 
 #ifdef __USE_LARGEFILE64
 struct stat64
   {
-# ifdef __USE_TIME_BITS64
+# ifdef __USE_TIME64_REDIRECTS
 #  include <bits/struct_stat_time64_helper.h>
 # else
     __dev_t st_dev;			/* Device.  */
@@ -125,7 +125,7 @@ struct stat64
     unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
 #  endif
     __ino64_t st_ino;			/* File serial number.		*/
-# endif /* __USE_TIME_BITS64  */
+# endif /* __USE_TIME64_REDIRECTS  */
   };
 #endif
 
diff --git a/sysdeps/unix/sysv/linux/bits/socket-constants.h b/sysdeps/unix/sysv/linux/bits/socket-constants.h
index d997dbf594..b2102d3abf 100644
--- a/sysdeps/unix/sysv/linux/bits/socket-constants.h
+++ b/sysdeps/unix/sysv/linux/bits/socket-constants.h
@@ -64,7 +64,7 @@
 #  define SO_TIMESTAMPNS_NEW 64
 #  define SO_TIMESTAMPING_NEW 65
 
-#  ifdef __USE_TIME_BITS64
+#  ifdef __USE_TIME64_REDIRECTS
 #   define SO_RCVTIMEO SO_RCVTIMEO_NEW
 #   define SO_SNDTIMEO SO_SNDTIMEO_NEW
 #   define SO_TIMESTAMP SO_TIMESTAMP_NEW
diff --git a/sysdeps/unix/sysv/linux/bits/socket.h b/sysdeps/unix/sysv/linux/bits/socket.h
index 0d86feb4ca..6dab283a2e 100644
--- a/sysdeps/unix/sysv/linux/bits/socket.h
+++ b/sysdeps/unix/sysv/linux/bits/socket.h
@@ -180,7 +180,7 @@ typedef __socklen_t socklen_t;
 #include <bits/sockaddr.h>
 
 /* Structure describing a generic socket address.  */
-struct sockaddr
+struct __attribute_struct_may_alias__ sockaddr
   {
     __SOCKADDR_COMMON (sa_);	/* Common data: address family and length.  */
     char sa_data[14];		/* Address data.  */
@@ -193,7 +193,7 @@ struct sockaddr
 #define _SS_PADSIZE \
   (_SS_SIZE - __SOCKADDR_COMMON_SIZE - sizeof (__ss_aligntype))
 
-struct sockaddr_storage
+struct __attribute_struct_may_alias__ sockaddr_storage
   {
     __SOCKADDR_COMMON (ss_);	/* Address family, etc.  */
     char __ss_padding[_SS_PADSIZE];
diff --git a/sysdeps/unix/sysv/linux/bits/time.h b/sysdeps/unix/sysv/linux/bits/time.h
index b70ba58a7d..cab4057971 100644
--- a/sysdeps/unix/sysv/linux/bits/time.h
+++ b/sysdeps/unix/sysv/linux/bits/time.h
@@ -77,7 +77,7 @@ __BEGIN_DECLS
 /* Tune a POSIX clock.  */
 extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) __THROW __nonnull((2));
 
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # if defined(__REDIRECT_NTH)
 extern int __REDIRECT_NTH (clock_adjtime, (__clockid_t __clock_id,
                                            struct timex *__utx),
diff --git a/sysdeps/unix/sysv/linux/bits/timex.h b/sysdeps/unix/sysv/linux/bits/timex.h
index 398d8094f2..03ccde6d0a 100644
--- a/sysdeps/unix/sysv/linux/bits/timex.h
+++ b/sysdeps/unix/sysv/linux/bits/timex.h
@@ -25,7 +25,7 @@
 
 struct timex
 {
-# if defined __USE_TIME_BITS64 || (__TIMESIZE == 64 && __WORDSIZE == 32)
+# if defined __USE_TIME64_REDIRECTS || (__TIMESIZE == 64 && __WORDSIZE == 32)
   unsigned int modes;          /* mode selector */
   int :32;                     /* pad */
   long long offset;            /* time offset (usec) */
diff --git a/sysdeps/unix/sysv/linux/bits/types/struct_msqid_ds.h b/sysdeps/unix/sysv/linux/bits/types/struct_msqid_ds.h
index fae50281c7..86296ca922 100644
--- a/sysdeps/unix/sysv/linux/bits/types/struct_msqid_ds.h
+++ b/sysdeps/unix/sysv/linux/bits/types/struct_msqid_ds.h
@@ -26,7 +26,7 @@
    The type `struct msg' is opaque.  */
 struct msqid_ds
 {
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # include <bits/types/struct_msqid64_ds_helper.h>
 #else
   struct ipc_perm msg_perm;	/* structure describing operation permission */
diff --git a/sysdeps/unix/sysv/linux/bits/types/struct_semid_ds.h b/sysdeps/unix/sysv/linux/bits/types/struct_semid_ds.h
index 3c277ed1d8..2ac89b3ce4 100644
--- a/sysdeps/unix/sysv/linux/bits/types/struct_semid_ds.h
+++ b/sysdeps/unix/sysv/linux/bits/types/struct_semid_ds.h
@@ -23,7 +23,7 @@
 /* Data structure describing a set of semaphores.  */
 struct semid_ds
 {
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # include <bits/types/struct_semid64_ds_helper.h>
 #else
   struct ipc_perm sem_perm;        /* operation permission struct */
diff --git a/sysdeps/unix/sysv/linux/bits/types/struct_shmid_ds.h b/sysdeps/unix/sysv/linux/bits/types/struct_shmid_ds.h
index 09de0b4e3a..1012ed0317 100644
--- a/sysdeps/unix/sysv/linux/bits/types/struct_shmid_ds.h
+++ b/sysdeps/unix/sysv/linux/bits/types/struct_shmid_ds.h
@@ -23,7 +23,7 @@
 /* Data structure describing a shared memory segment.  */
 struct shmid_ds
   {
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # include <bits/types/struct_shmid64_ds_helper.h>
 #else
     struct ipc_perm shm_perm;		/* operation permission struct */
diff --git a/sysdeps/unix/sysv/linux/bits/uio-ext.h b/sysdeps/unix/sysv/linux/bits/uio-ext.h
index 7854cccef3..ead7a09156 100644
--- a/sysdeps/unix/sysv/linux/bits/uio-ext.h
+++ b/sysdeps/unix/sysv/linux/bits/uio-ext.h
@@ -47,6 +47,7 @@ extern ssize_t process_vm_writev (pid_t __pid, const struct iovec *__lvec,
 #define RWF_SYNC	0x00000004 /* per-IO O_SYNC.  */
 #define RWF_NOWAIT	0x00000008 /* per-IO nonblocking mode.  */
 #define RWF_APPEND	0x00000010 /* per-IO O_APPEND.  */
+#define RWF_NOAPPEND	0x00000020 /* per-IO negation of O_APPEND */
 
 __END_DECLS
 
diff --git a/sysdeps/unix/sysv/linux/csky/bits/struct_stat.h b/sysdeps/unix/sysv/linux/csky/bits/struct_stat.h
index 4b4822d6d0..47a9f0aaff 100644
--- a/sysdeps/unix/sysv/linux/csky/bits/struct_stat.h
+++ b/sysdeps/unix/sysv/linux/csky/bits/struct_stat.h
@@ -43,7 +43,7 @@
 
 struct stat
   {
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # include <bits/struct_stat_time64_helper.h>
 #else
     __dev_t st_dev;		/* Device.  */
@@ -88,7 +88,7 @@ struct stat
 #ifdef __USE_LARGEFILE64
 struct stat64
   {
-# ifdef __USE_TIME_BITS64
+# ifdef __USE_TIME64_REDIRECTS
 #  include <bits/struct_stat_time64_helper.h>
 # else
     __dev_t st_dev;		/* Device.  */
diff --git a/sysdeps/unix/sysv/linux/dl-parse_auxv.h b/sysdeps/unix/sysv/linux/dl-parse_auxv.h
index e3d758b163..ea2a58ecb1 100644
--- a/sysdeps/unix/sysv/linux/dl-parse_auxv.h
+++ b/sysdeps/unix/sysv/linux/dl-parse_auxv.h
@@ -47,6 +47,8 @@ void _dl_parse_auxv (ElfW(auxv_t) *av, dl_parse_auxv_t auxv_values)
   GLRO(dl_platform) = (void *) auxv_values[AT_PLATFORM];
   GLRO(dl_hwcap) = auxv_values[AT_HWCAP];
   GLRO(dl_hwcap2) = auxv_values[AT_HWCAP2];
+  GLRO(dl_hwcap3) = auxv_values[AT_HWCAP3];
+  GLRO(dl_hwcap4) = auxv_values[AT_HWCAP4];
   GLRO(dl_clktck) = auxv_values[AT_CLKTCK];
   GLRO(dl_fpu_control) = auxv_values[AT_FPUCW];
   _dl_random = (void *) auxv_values[AT_RANDOM];
diff --git a/sysdeps/unix/sysv/linux/dl-rseq-symbols.S b/sysdeps/unix/sysv/linux/dl-rseq-symbols.S
new file mode 100644
index 0000000000..b4bba06a99
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/dl-rseq-symbols.S
@@ -0,0 +1,64 @@
+/* Define symbols used by rseq.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+#if __WORDSIZE == 64
+#define RSEQ_OFFSET_SIZE	8
+#else
+#define RSEQ_OFFSET_SIZE	4
+#endif
+
+/* Some targets define a macro to denote the zero register.  */
+#undef zero
+
+/* Define 2 symbols: '__rseq_size' is public const and '_rseq_size' (an
+   alias of '__rseq_size') is hidden and writable for internal use by the
+   dynamic linker which will initialize the value both symbols point to
+   before copy relocations take place. */
+
+	.globl	__rseq_size
+	.type	__rseq_size, %object
+	.size	__rseq_size, 4
+	.hidden _rseq_size
+	.globl	_rseq_size
+	.type	_rseq_size, %object
+	.size	_rseq_size, 4
+	.section .data.rel.ro
+	.balign 4
+__rseq_size:
+_rseq_size:
+	.zero	4
+
+/* Define 2 symbols: '__rseq_offset' is public const and '_rseq_offset' (an
+   alias of '__rseq_offset') is hidden and writable for internal use by the
+   dynamic linker which will initialize the value both symbols point to
+   before copy relocations take place. */
+
+	.globl	__rseq_offset
+	.type	__rseq_offset, %object
+	.size	__rseq_offset, RSEQ_OFFSET_SIZE
+	.hidden _rseq_offset
+	.globl	_rseq_offset
+	.type	_rseq_offset, %object
+	.size	_rseq_offset, RSEQ_OFFSET_SIZE
+	.section .data.rel.ro
+	.balign RSEQ_OFFSET_SIZE
+__rseq_offset:
+_rseq_offset:
+	.zero	RSEQ_OFFSET_SIZE
diff --git a/sysdeps/unix/sysv/linux/dl-sysdep.c b/sysdeps/unix/sysv/linux/dl-sysdep.c
index ad3692d738..a8ec2d7c18 100644
--- a/sysdeps/unix/sysv/linux/dl-sysdep.c
+++ b/sysdeps/unix/sysv/linux/dl-sysdep.c
@@ -40,6 +40,7 @@
 #include <sys/utsname.h>
 #include <tls.h>
 #include <unistd.h>
+#include <dl-symbol-redir-ifunc.h>
 
 #include <dl-machine.h>
 #include <dl-hwcap-check.h>
@@ -197,6 +198,8 @@ _dl_show_auxv (void)
 	  [AT_SYSINFO_EHDR - 2] =	{ "SYSINFO_EHDR:      0x", hex },
 	  [AT_RANDOM - 2] =		{ "RANDOM:            0x", hex },
 	  [AT_HWCAP2 - 2] =		{ "HWCAP2:            0x", hex },
+	  [AT_HWCAP3 - 2] =		{ "HWCAP3:            0x", hex },
+	  [AT_HWCAP4 - 2] =		{ "HWCAP4:            0x", hex },
 	  [AT_MINSIGSTKSZ - 2] =	{ "MINSIGSTKSZ:       ", dec },
 	  [AT_L1I_CACHESIZE - 2] =	{ "L1I_CACHESIZE:     ", dec },
 	  [AT_L1I_CACHEGEOMETRY - 2] =	{ "L1I_CACHEGEOMETRY: 0x", hex },
diff --git a/sysdeps/unix/sysv/linux/features-time64.h b/sysdeps/unix/sysv/linux/features-time64.h
index dd3442c2ea..8d573cd23e 100644
--- a/sysdeps/unix/sysv/linux/features-time64.h
+++ b/sysdeps/unix/sysv/linux/features-time64.h
@@ -24,9 +24,8 @@
 # if _TIME_BITS == 64
 #  if ! defined (_FILE_OFFSET_BITS) || _FILE_OFFSET_BITS != 64
 #   error "_TIME_BITS=64 is allowed only with _FILE_OFFSET_BITS=64"
-#  elif __TIMESIZE == 32
-#   define __USE_TIME_BITS64	1
 #  endif
+#  define __USE_TIME_BITS64	1
 # elif _TIME_BITS == 32
 #  if __TIMESIZE > 32
 #   error "_TIME_BITS=32 is not compatible with __TIMESIZE > 32"
@@ -34,4 +33,10 @@
 # else
 #  error Invalid _TIME_BITS value (can only be 32 or 64-bit)
 # endif
+#elif __TIMESIZE == 64
+# define __USE_TIME_BITS64      1
+#endif
+
+#if defined __USE_TIME_BITS64 && __TIMESIZE == 32
+# define __USE_TIME64_REDIRECTS 1
 #endif
diff --git a/sysdeps/unix/sysv/linux/hppa/bits/socket-constants.h b/sysdeps/unix/sysv/linux/hppa/bits/socket-constants.h
index 58b523d03a..80a76a17dc 100644
--- a/sysdeps/unix/sysv/linux/hppa/bits/socket-constants.h
+++ b/sysdeps/unix/sysv/linux/hppa/bits/socket-constants.h
@@ -54,7 +54,7 @@
 # define SO_TIMESTAMPNS_NEW 0x4039
 # define SO_TIMESTAMPING_NEW 0x403A
 
-# ifdef __USE_TIME_BITS64
+# ifdef __USE_TIME64_REDIRECTS
 #  define SO_RCVTIMEO SO_RCVTIMEO_NEW
 #  define SO_SNDTIMEO SO_SNDTIMEO_NEW
 #  define SO_TIMESTAMP SO_TIMESTAMP_NEW
diff --git a/sysdeps/unix/sysv/linux/hppa/bits/struct_stat.h b/sysdeps/unix/sysv/linux/hppa/bits/struct_stat.h
index 069efdbc55..09ea40054b 100644
--- a/sysdeps/unix/sysv/linux/hppa/bits/struct_stat.h
+++ b/sysdeps/unix/sysv/linux/hppa/bits/struct_stat.h
@@ -28,7 +28,7 @@
 
 struct stat
   {
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # include <bits/struct_stat_time64_helper.h>
 #else
     __dev_t st_dev;			/* Device.  */
@@ -83,13 +83,13 @@ struct stat
 # else
     __ino64_t st_ino;			/* File serial number.	*/
 # endif
-#endif /* __USE_TIME_BITS64  */
+#endif /* __USE_TIME64_REDIRECTS  */
   };
 
 #ifdef __USE_LARGEFILE64
 struct stat64
   {
-# ifdef __USE_TIME_BITS64
+# ifdef __USE_TIME64_REDIRECTS
 #  include <bits/struct_stat_time64_helper.h>
 # else
     __dev_t st_dev;			/* Device.  */
@@ -125,7 +125,7 @@ struct stat64
     unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
 #  endif
     __ino64_t st_ino;			/* File serial number.		*/
-# endif /* __USE_TIME_BITS64  */
+# endif /* __USE_TIME64_REDIRECTS  */
   };
 #endif
 
diff --git a/sysdeps/unix/sysv/linux/hppa/bits/types/struct_msqid_ds.h b/sysdeps/unix/sysv/linux/hppa/bits/types/struct_msqid_ds.h
index 2bc7cac06d..4995e0a4a5 100644
--- a/sysdeps/unix/sysv/linux/hppa/bits/types/struct_msqid_ds.h
+++ b/sysdeps/unix/sysv/linux/hppa/bits/types/struct_msqid_ds.h
@@ -26,7 +26,7 @@
    The type `struct msg' is opaque.  */
 struct msqid_ds
 {
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # include <bits/types/struct_msqid64_ds_helper.h>
 #else
   struct ipc_perm msg_perm;	/* structure describing operation permission */
diff --git a/sysdeps/unix/sysv/linux/hppa/bits/types/struct_semid_ds.h b/sysdeps/unix/sysv/linux/hppa/bits/types/struct_semid_ds.h
index dd8fbebcf4..df88949dc2 100644
--- a/sysdeps/unix/sysv/linux/hppa/bits/types/struct_semid_ds.h
+++ b/sysdeps/unix/sysv/linux/hppa/bits/types/struct_semid_ds.h
@@ -23,7 +23,7 @@
 /* Data structure describing a set of semaphores.  */
 struct semid_ds
 {
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # include <bits/types/struct_semid64_ds_helper.h>
 #else
   struct ipc_perm sem_perm;   /* operation permission struct */
diff --git a/sysdeps/unix/sysv/linux/hppa/bits/types/struct_shmid_ds.h b/sysdeps/unix/sysv/linux/hppa/bits/types/struct_shmid_ds.h
index 58ac572b6e..cb3b0303aa 100644
--- a/sysdeps/unix/sysv/linux/hppa/bits/types/struct_shmid_ds.h
+++ b/sysdeps/unix/sysv/linux/hppa/bits/types/struct_shmid_ds.h
@@ -23,7 +23,7 @@
 /* Data structure describing a shared memory segment.  */
 struct shmid_ds
   {
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # include <bits/types/struct_shmid64_ds_helper.h>
 #else
     struct ipc_perm shm_perm;		/* operation permission struct */
diff --git a/sysdeps/unix/sysv/linux/hppa/bits/wordsize.h b/sysdeps/unix/sysv/linux/hppa/bits/wordsize.h
new file mode 100644
index 0000000000..6ecbfe7c86
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/hppa/bits/wordsize.h
@@ -0,0 +1,21 @@
+/* Copyright (C) 1999-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define __WORDSIZE			32
+#define __WORDSIZE_TIME64_COMPAT32	1
+#define __WORDSIZE32_SIZE_ULONG		0
+#define __WORDSIZE32_PTRDIFF_LONG	0
diff --git a/sysdeps/unix/sysv/linux/m68k/bits/struct_stat.h b/sysdeps/unix/sysv/linux/m68k/bits/struct_stat.h
index 3b1db157bc..b7f20189b1 100644
--- a/sysdeps/unix/sysv/linux/m68k/bits/struct_stat.h
+++ b/sysdeps/unix/sysv/linux/m68k/bits/struct_stat.h
@@ -25,7 +25,7 @@
 
 struct stat
   {
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # include <bits/struct_stat_time64_helper.h>
 #else
     __dev_t st_dev;			/* Device.  */
@@ -80,13 +80,13 @@ struct stat
 # else
     __ino64_t st_ino;			/* File serial number.	*/
 # endif
-#endif /* __USE_TIME_BITS64  */
+#endif /* __USE_TIME64_REDIRECTS  */
   };
 
 #ifdef __USE_LARGEFILE64
 struct stat64
   {
-# ifdef __USE_TIME_BITS64
+# ifdef __USE_TIME64_REDIRECTS
 #  include <bits/struct_stat_time64_helper.h>
 # else
     __dev_t st_dev;			/* Device.  */
@@ -122,7 +122,7 @@ struct stat64
     unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
 #  endif
     __ino64_t st_ino;			/* File serial number.		*/
-# endif /* __USE_TIME_BITS64 */
+# endif /* __USE_TIME64_REDIRECTS */
   };
 #endif
 
diff --git a/sysdeps/unix/sysv/linux/microblaze/bits/struct_stat.h b/sysdeps/unix/sysv/linux/microblaze/bits/struct_stat.h
index 0f4693fb1f..ff1e269f14 100644
--- a/sysdeps/unix/sysv/linux/microblaze/bits/struct_stat.h
+++ b/sysdeps/unix/sysv/linux/microblaze/bits/struct_stat.h
@@ -26,7 +26,7 @@
 #ifndef __USE_FILE_OFFSET64
 struct stat
 {
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # include <bits/struct_stat_time64_helper.h>
 #else
         __dev_t         st_dev;     /* Device.  */
@@ -64,7 +64,7 @@ struct stat
 # endif
         unsigned int            __glibc_reserved4;
         unsigned int            __glibc_reserved5;
-#endif /* __USE_TIME_BITS64  */
+#endif /* __USE_TIME64_REDIRECTS  */
 };
 #else /* __USE_FILE_OFFSET64 */
 /* MS: If __USE_FILE_OFFSET64 is setup then struct stat should match stat64
@@ -74,7 +74,7 @@ struct stat
  * create one ifdef to separate stats structures.  */
 struct stat
 {
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # include <bits/struct_stat_time64_helper.h>
 #else
         unsigned long long      st_dev;     /* Device.  */
@@ -112,14 +112,14 @@ struct stat
 # endif
         unsigned int            __glibc_reserved4;
         unsigned int            __glibc_reserved5;
-# endif /* __USE_TIME_BITS64 */
+# endif /* __USE_TIME64_REDIRECTS */
 };
 #endif /* __USE_FILE_OFFSET64 */
 
 #ifdef __USE_LARGEFILE64
 struct stat64
 {
-# ifdef __USE_TIME_BITS64
+# ifdef __USE_TIME64_REDIRECTS
 #  include <bits/struct_stat_time64_helper.h>
 # else
         unsigned long long      st_dev;     /* Device.  */
@@ -157,7 +157,7 @@ struct stat64
 #  endif
         unsigned int            __glibc_reserved4;
         unsigned int            __glibc_reserved5;
-# endif /* __USE_TIME_BITS64 */
+# endif /* __USE_TIME64_REDIRECTS */
 };
 #endif
 
diff --git a/sysdeps/unix/sysv/linux/mips/bits/socket-constants.h b/sysdeps/unix/sysv/linux/mips/bits/socket-constants.h
index c6908a2793..77ffc8b890 100644
--- a/sysdeps/unix/sysv/linux/mips/bits/socket-constants.h
+++ b/sysdeps/unix/sysv/linux/mips/bits/socket-constants.h
@@ -54,7 +54,7 @@
 # define SO_TIMESTAMPNS_NEW 64
 # define SO_TIMESTAMPING_NEW 65
 
-# ifdef __USE_TIME_BITS64
+# ifdef __USE_TIME64_REDIRECTS
 #  define SO_RCVTIMEO SO_RCVTIMEO_NEW
 #  define SO_SNDTIMEO SO_SNDTIMEO_NEW
 #  define SO_TIMESTAMP SO_TIMESTAMP_NEW
diff --git a/sysdeps/unix/sysv/linux/mips/bits/struct_stat.h b/sysdeps/unix/sysv/linux/mips/bits/struct_stat.h
index 277ebad9b6..50a4b367f6 100644
--- a/sysdeps/unix/sysv/linux/mips/bits/struct_stat.h
+++ b/sysdeps/unix/sysv/linux/mips/bits/struct_stat.h
@@ -29,7 +29,7 @@
 /* Structure describing file characteristics.  */
 struct stat
   {
-# ifdef __USE_TIME_BITS64
+# ifdef __USE_TIME64_REDIRECTS
 #  include <bits/struct_stat_time64_helper.h>
 # else
     unsigned long int st_dev;
@@ -82,13 +82,13 @@ struct stat
     __blkcnt64_t st_blocks;	/* Number of 512-byte blocks allocated.  */
 #  endif
     long int st_pad5[14];
-# endif /* __USE_TIME_BITS64  */
+# endif /* __USE_TIME64_REDIRECTS  */
   };
 
 # ifdef __USE_LARGEFILE64
 struct stat64
   {
-#  ifdef __USE_TIME_BITS64
+#  ifdef __USE_TIME64_REDIRECTS
 #   include <bits/struct_stat_time64_helper.h>
 #  else
     unsigned long int st_dev;
@@ -123,7 +123,7 @@ struct stat64
     long int st_pad3;
     __blkcnt64_t st_blocks;	/* Number of 512-byte blocks allocated.  */
     long int st_pad4[14];
-#  endif /* __USE_TIME_BITS64  */
+#  endif /* __USE_TIME64_REDIRECTS  */
   };
 # endif /* __USE_LARGEFILE64  */
 
@@ -131,7 +131,7 @@ struct stat64
 
 struct stat
   {
-# ifdef __USE_TIME_BITS64
+# ifdef __USE_TIME64_REDIRECTS
 #  include <bits/struct_stat_time64_helper.h>
 # else
     __dev_t st_dev;
@@ -189,7 +189,7 @@ struct stat
 #ifdef __USE_LARGEFILE64
 struct stat64
   {
-# ifdef __USE_TIME_BITS64
+# ifdef __USE_TIME64_REDIRECTS
 #  include <bits/struct_stat_time64_helper.h>
 # else
     __dev_t st_dev;
@@ -224,7 +224,7 @@ struct stat64
     unsigned int st_pad3;
     __blkcnt64_t st_blocks;
     int st_pad4[14];
-# endif /* __USE_TIME_BITS64  */
+# endif /* __USE_TIME64_REDIRECTS  */
 };
 #endif
 
diff --git a/sysdeps/unix/sysv/linux/mips/bits/types/struct_msqid_ds.h b/sysdeps/unix/sysv/linux/mips/bits/types/struct_msqid_ds.h
index 4e8bd51b0a..09c53648b7 100644
--- a/sysdeps/unix/sysv/linux/mips/bits/types/struct_msqid_ds.h
+++ b/sysdeps/unix/sysv/linux/mips/bits/types/struct_msqid_ds.h
@@ -26,7 +26,7 @@
    The type `struct msg' is opaque.  */
 struct msqid_ds
 {
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # include <bits/types/struct_msqid64_ds_helper.h>
 #else
   struct ipc_perm msg_perm;	/* structure describing operation permission */
diff --git a/sysdeps/unix/sysv/linux/mips/bits/types/struct_semid_ds.h b/sysdeps/unix/sysv/linux/mips/bits/types/struct_semid_ds.h
index d1a30e3164..0746684a7d 100644
--- a/sysdeps/unix/sysv/linux/mips/bits/types/struct_semid_ds.h
+++ b/sysdeps/unix/sysv/linux/mips/bits/types/struct_semid_ds.h
@@ -23,7 +23,7 @@
 /* Data structure describing a set of semaphores.  */
 struct semid_ds
 {
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # include <bits/types/struct_semid64_ds_helper.h>
 #else
   struct ipc_perm sem_perm;		/* operation permission struct */
diff --git a/sysdeps/unix/sysv/linux/mips/bits/types/struct_shmid_ds.h b/sysdeps/unix/sysv/linux/mips/bits/types/struct_shmid_ds.h
index 8771164b57..c665af1874 100644
--- a/sysdeps/unix/sysv/linux/mips/bits/types/struct_shmid_ds.h
+++ b/sysdeps/unix/sysv/linux/mips/bits/types/struct_shmid_ds.h
@@ -23,7 +23,7 @@
 /* Data structure describing a shared memory segment.  */
 struct shmid_ds
   {
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # include <bits/types/struct_shmid64_ds_helper.h>
 #else
     struct ipc_perm shm_perm;		/* operation permission struct */
diff --git a/sysdeps/unix/sysv/linux/mips/clone3.S b/sysdeps/unix/sysv/linux/mips/clone3.S
index e9fec2fa47..481b8ae963 100644
--- a/sysdeps/unix/sysv/linux/mips/clone3.S
+++ b/sysdeps/unix/sysv/linux/mips/clone3.S
@@ -37,11 +37,6 @@
 
 	.text
 	.set		nomips16
-#if _MIPS_SIM == _ABIO32
-# define EXTRA_LOCALS 1
-#else
-# define EXTRA_LOCALS 0
-#endif
 #define FRAMESZ ((NARGSAVE*SZREG)+ALSZ)&ALMASK
 GPOFF= FRAMESZ-(1*SZREG)
 NESTED(__clone3, SZREG, sp)
@@ -68,8 +63,31 @@ NESTED(__clone3, SZREG, sp)
 	beqz	a0, L(error)	/* No NULL cl_args pointer.  */
 	beqz	a2, L(error)	/* No NULL function pointer.  */
 
+#if _MIPS_SIM == _ABIO32
+	/* Both stack and stack_size on clone_args are defined as uint64_t, and
+	   there is no need to handle values larger than to 32 bits for o32.  */
+# if __BYTE_ORDER == __BIG_ENDIAN
+#  define CL_STACKPOINTER_OFFSET  44
+#  define CL_STACKSIZE_OFFSET     52
+# else
+#  define CL_STACKPOINTER_OFFSET  40
+#  define CL_STACKSIZE_OFFSET     48
+# endif
+
+	/* For o32 we need to setup a minimal stack frame to allow cprestore
+	   on __thread_start_clone3.  Also there is no guarantee by kABI that
+	   $8 will be preserved after syscall execution (so we need to save it
+	   on the provided stack).  */
+	lw	t0, CL_STACKPOINTER_OFFSET(a0)	/* Load the stack pointer.  */
+	lw	t1, CL_STACKSIZE_OFFSET(a0)	/* Load the stack_size.  */
+	addiu	t1, -32				/* Update the stack size.  */
+	addu	t2, t1, t0			/* Calculate the thread stack.  */
+	sw	a3, 0(t2)			/* Save argument pointer.  */
+	sw	t1, CL_STACKSIZE_OFFSET(a0)	/* Save the new stack size.  */
+#else
 	move	$8, a3		/* a3 is set to 0/1 for syscall success/error
 				   while a4/$8 is returned unmodified.  */
+#endif
 
 	/* Do the system call, the kernel expects:
 	   v0: system call number
@@ -125,7 +143,11 @@ L(thread_start_clone3):
 
 	/* Restore the arg for user's function.  */
 	move		t9, a2		/* Function pointer.  */
+#if _MIPS_SIM == _ABIO32
+	PTR_L		a0, 0(sp)
+#else
 	move		a0, $8		/* Argument pointer.  */
+#endif
 
 	/* Call the user's function.  */
 	jal		t9
diff --git a/sysdeps/unix/sysv/linux/mremap-failure.h b/sysdeps/unix/sysv/linux/mremap-failure.h
new file mode 100644
index 0000000000..c99ab30ca9
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/mremap-failure.h
@@ -0,0 +1,30 @@
+/* mremap failure handling.  Linux version.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <support/check.h>
+
+/* Return exit value on mremap failure with errno ERR.  */
+
+static int
+mremap_failure_exit (int err)
+{
+  if (err != EINVAL)
+    return EXIT_FAILURE;
+
+  return EXIT_UNSUPPORTED;
+}
diff --git a/sysdeps/unix/sysv/linux/mremap.c b/sysdeps/unix/sysv/linux/mremap.c
index 4f770799c4..1ada5c1f40 100644
--- a/sysdeps/unix/sysv/linux/mremap.c
+++ b/sysdeps/unix/sysv/linux/mremap.c
@@ -20,6 +20,12 @@
 #include <sysdep.h>
 #include <stdarg.h>
 #include <stddef.h>
+#include <errno.h>
+
+#define MREMAP_KNOWN_BITS \
+  (MREMAP_MAYMOVE \
+   | MREMAP_FIXED \
+   | MREMAP_DONTUNMAP)
 
 void *
 __mremap (void *addr, size_t old_len, size_t new_len, int flags, ...)
@@ -27,7 +33,13 @@ __mremap (void *addr, size_t old_len, size_t new_len, int flags, ...)
   va_list va;
   void *new_addr = NULL;
 
-  if (flags & MREMAP_FIXED)
+  if (flags & ~(MREMAP_KNOWN_BITS))
+    {
+      __set_errno (EINVAL);
+      return MAP_FAILED;
+    }
+
+  if (flags & (MREMAP_FIXED | MREMAP_DONTUNMAP))
     {
       va_start (va, flags);
       new_addr = va_arg (va, void *);
diff --git a/sysdeps/unix/sysv/linux/net/if_packet.h b/sysdeps/unix/sysv/linux/net/if_packet.h
index 9ffb69b508..c17e1c23c5 100644
--- a/sysdeps/unix/sysv/linux/net/if_packet.h
+++ b/sysdeps/unix/sysv/linux/net/if_packet.h
@@ -26,7 +26,7 @@
    From Linux 2.1 the AF_PACKET interface is preferred and you should
    consider using it in place of this one.  */
 
-struct sockaddr_pkt
+struct __attribute_struct_may_alias__ sockaddr_pkt
   {
     __SOCKADDR_COMMON (spkt_);
     unsigned char spkt_device[14];
diff --git a/sysdeps/unix/sysv/linux/netash/ash.h b/sysdeps/unix/sysv/linux/netash/ash.h
index 7d885d17cc..7a6ff50b17 100644
--- a/sysdeps/unix/sysv/linux/netash/ash.h
+++ b/sysdeps/unix/sysv/linux/netash/ash.h
@@ -22,7 +22,7 @@
 #include <features.h>
 #include <bits/sockaddr.h>
 
-struct sockaddr_ash
+struct __attribute_struct_may_alias__ sockaddr_ash
   {
     __SOCKADDR_COMMON (sash_);		/* Common data: address family etc.  */
     int sash_ifindex;			/* Interface to use.  */
diff --git a/sysdeps/unix/sysv/linux/neteconet/ec.h b/sysdeps/unix/sysv/linux/neteconet/ec.h
index b07a107961..f3132f06ff 100644
--- a/sysdeps/unix/sysv/linux/neteconet/ec.h
+++ b/sysdeps/unix/sysv/linux/neteconet/ec.h
@@ -28,7 +28,7 @@ struct ec_addr
     unsigned char net;			/* Network number.  */
   };
 
-struct sockaddr_ec
+struct __attribute_struct_may_alias__ sockaddr_ec
   {
     __SOCKADDR_COMMON (sec_);
     unsigned char port;			/* Port number.  */
diff --git a/sysdeps/unix/sysv/linux/netiucv/iucv.h b/sysdeps/unix/sysv/linux/netiucv/iucv.h
index f5fad81751..27151e8bbe 100644
--- a/sysdeps/unix/sysv/linux/netiucv/iucv.h
+++ b/sysdeps/unix/sysv/linux/netiucv/iucv.h
@@ -23,7 +23,7 @@
 
 __BEGIN_DECLS
 
-struct sockaddr_iucv
+struct __attribute_struct_may_alias__ sockaddr_iucv
   {
     __SOCKADDR_COMMON (siucv_);
     unsigned short	siucv_port;		/* Reserved */
diff --git a/sysdeps/unix/sysv/linux/nios2/bits/struct_stat.h b/sysdeps/unix/sysv/linux/nios2/bits/struct_stat.h
index 672c7c6bb8..dab466d881 100644
--- a/sysdeps/unix/sysv/linux/nios2/bits/struct_stat.h
+++ b/sysdeps/unix/sysv/linux/nios2/bits/struct_stat.h
@@ -43,7 +43,7 @@
 
 struct stat
   {
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # include <bits/struct_stat_time64_helper.h>
 #else
     __dev_t st_dev;		/* Device.  */
@@ -88,7 +88,7 @@ struct stat
 #ifdef __USE_LARGEFILE64
 struct stat64
   {
-# ifdef __USE_TIME_BITS64
+# ifdef __USE_TIME64_REDIRECTS
 #  include <bits/struct_stat_time64_helper.h>
 # else
     __dev_t st_dev;		/* Device.  */
diff --git a/sysdeps/unix/sysv/linux/pidfd_getpid.c b/sysdeps/unix/sysv/linux/pidfd_getpid.c
index 8567b413dd..30025e5863 100644
--- a/sysdeps/unix/sysv/linux/pidfd_getpid.c
+++ b/sysdeps/unix/sysv/linux/pidfd_getpid.c
@@ -74,8 +74,10 @@ parse_fdinfo (const char *l, void *arg)
 
       /* Ignore invalid large values.  */
       if (INT_MULTIPLY_WRAPV (10, n, &n)
-          || INT_ADD_WRAPV (n, *l++ - '0', &n))
+          || INT_ADD_WRAPV (n, *l - '0', &n))
         return -1;
+
+      l++;
     }
 
   /* -1 indicates that the process is terminated.  */
diff --git a/sysdeps/unix/sysv/linux/powerpc/bits/socket-constants.h b/sysdeps/unix/sysv/linux/powerpc/bits/socket-constants.h
index 6be5055e65..0d3e095c5d 100644
--- a/sysdeps/unix/sysv/linux/powerpc/bits/socket-constants.h
+++ b/sysdeps/unix/sysv/linux/powerpc/bits/socket-constants.h
@@ -54,7 +54,7 @@
 # define SO_TIMESTAMPNS_NEW 64
 # define SO_TIMESTAMPING_NEW 65
 
-# ifdef __USE_TIME_BITS64
+# ifdef __USE_TIME64_REDIRECTS
 #  define SO_RCVTIMEO SO_RCVTIMEO_NEW
 #  define SO_SNDTIMEO SO_SNDTIMEO_NEW
 #  define SO_TIMESTAMP SO_TIMESTAMP_NEW
diff --git a/sysdeps/unix/sysv/linux/powerpc/bits/struct_stat.h b/sysdeps/unix/sysv/linux/powerpc/bits/struct_stat.h
index f6328399cd..2cf331544a 100644
--- a/sysdeps/unix/sysv/linux/powerpc/bits/struct_stat.h
+++ b/sysdeps/unix/sysv/linux/powerpc/bits/struct_stat.h
@@ -28,7 +28,7 @@
 #if __WORDSIZE == 32
 struct stat
   {
-# ifdef __USE_TIME_BITS64
+# ifdef __USE_TIME64_REDIRECTS
 #  include <bits/struct_stat_time64_helper.h>
 # else
     __dev_t st_dev;			/* Device.  */
@@ -79,13 +79,13 @@ struct stat
 #  endif
     unsigned long int __glibc_reserved4;
     unsigned long int __glibc_reserved5;
-# endif /* __USE_TIME_BITS64 */
+# endif /* __USE_TIME64_REDIRECTS */
   };
 
 # ifdef __USE_LARGEFILE64
 struct stat64
   {
-#  ifdef __USE_TIME_BITS64
+#  ifdef __USE_TIME64_REDIRECTS
 #   include <bits/struct_stat_time64_helper.h>
 #  else
     __dev_t st_dev;			/* Device.  */
@@ -122,7 +122,7 @@ struct stat64
 #   endif
     unsigned long int __glibc_reserved4;
     unsigned long int __glibc_reserved5;
-#  endif /* __USE_TIME_BITS64 */
+#  endif /* __USE_TIME64_REDIRECTS */
   };
 # endif /* __USE_LARGEFILE64 */
 
diff --git a/sysdeps/unix/sysv/linux/powerpc/bits/types/struct_msqid_ds.h b/sysdeps/unix/sysv/linux/powerpc/bits/types/struct_msqid_ds.h
index 830629cd37..44ae08265d 100644
--- a/sysdeps/unix/sysv/linux/powerpc/bits/types/struct_msqid_ds.h
+++ b/sysdeps/unix/sysv/linux/powerpc/bits/types/struct_msqid_ds.h
@@ -26,7 +26,7 @@
    The type `struct msg' is opaque.  */
 struct msqid_ds
 {
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # include <bits/types/struct_msqid64_ds_helper.h>
 #else
   struct ipc_perm msg_perm;	/* structure describing operation permission */
diff --git a/sysdeps/unix/sysv/linux/powerpc/bits/types/struct_semid_ds.h b/sysdeps/unix/sysv/linux/powerpc/bits/types/struct_semid_ds.h
index 4370257557..ccee57c28b 100644
--- a/sysdeps/unix/sysv/linux/powerpc/bits/types/struct_semid_ds.h
+++ b/sysdeps/unix/sysv/linux/powerpc/bits/types/struct_semid_ds.h
@@ -23,7 +23,7 @@
 /* Data structure describing a set of semaphores.  */
 struct semid_ds
 {
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # include <bits/types/struct_semid64_ds_helper.h>
 #else
   struct ipc_perm sem_perm;   /* operation permission struct */
diff --git a/sysdeps/unix/sysv/linux/powerpc/bits/types/struct_shmid_ds.h b/sysdeps/unix/sysv/linux/powerpc/bits/types/struct_shmid_ds.h
index da1b4b3c56..58145d0a5d 100644
--- a/sysdeps/unix/sysv/linux/powerpc/bits/types/struct_shmid_ds.h
+++ b/sysdeps/unix/sysv/linux/powerpc/bits/types/struct_shmid_ds.h
@@ -23,7 +23,7 @@
 /* Data structure describing a shared memory segment.  */
 struct shmid_ds
   {
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # include <bits/types/struct_shmid64_ds_helper.h>
 #else
     struct ipc_perm shm_perm;		/* operation permission struct */
diff --git a/sysdeps/unix/sysv/linux/powerpc/bits/wordsize.h b/sysdeps/unix/sysv/linux/powerpc/bits/wordsize.h
index 04ca9debf0..6993fb6b29 100644
--- a/sysdeps/unix/sysv/linux/powerpc/bits/wordsize.h
+++ b/sysdeps/unix/sysv/linux/powerpc/bits/wordsize.h
@@ -2,10 +2,9 @@
 
 #if defined __powerpc64__
 # define __WORDSIZE	64
-# define __WORDSIZE_TIME64_COMPAT32	1
 #else
 # define __WORDSIZE	32
-# define __WORDSIZE_TIME64_COMPAT32	0
 # define __WORDSIZE32_SIZE_ULONG	0
 # define __WORDSIZE32_PTRDIFF_LONG	0
 #endif
+#define __WORDSIZE_TIME64_COMPAT32	1
diff --git a/sysdeps/unix/sysv/linux/powerpc/cpu-features.c b/sysdeps/unix/sysv/linux/powerpc/cpu-features.c
index 8e8a5ec2ea..a947d62db6 100644
--- a/sysdeps/unix/sysv/linux/powerpc/cpu-features.c
+++ b/sysdeps/unix/sysv/linux/powerpc/cpu-features.c
@@ -94,6 +94,8 @@ init_cpu_features (struct cpu_features *cpu_features, uint64_t hwcaps[])
      which are set by __tcb_parse_hwcap_and_convert_at_platform.  */
   cpu_features->hwcap = hwcaps[0];
   cpu_features->hwcap2 = hwcaps[1];
+  cpu_features->hwcap3 = hwcaps[2];
+  cpu_features->hwcap4 = hwcaps[3];
   /* Default is to use aligned memory access on optimized function unless
      tunables is enable, since for this case user can explicit disable
      unaligned optimizations.  */
diff --git a/sysdeps/unix/sysv/linux/powerpc/cpu-features.h b/sysdeps/unix/sysv/linux/powerpc/cpu-features.h
index 1294f0b601..e9eb6a13c8 100644
--- a/sysdeps/unix/sysv/linux/powerpc/cpu-features.h
+++ b/sysdeps/unix/sysv/linux/powerpc/cpu-features.h
@@ -26,6 +26,8 @@ struct cpu_features
   bool use_cached_memopt;
   unsigned long int hwcap;
   unsigned long int hwcap2;
+  unsigned long int hwcap3;
+  unsigned long int hwcap4;
 };
 
 static const char hwcap_names[] = {
diff --git a/sysdeps/unix/sysv/linux/powerpc/libc-start.c b/sysdeps/unix/sysv/linux/powerpc/libc-start.c
index a4705daf1c..6a00cd88cd 100644
--- a/sysdeps/unix/sysv/linux/powerpc/libc-start.c
+++ b/sysdeps/unix/sysv/linux/powerpc/libc-start.c
@@ -87,6 +87,12 @@ __libc_start_main_impl (int argc, char **argv,
       case AT_HWCAP2:
 	_dl_hwcap2 = (unsigned long int) av->a_un.a_val;
 	break;
+      case AT_HWCAP3:
+	_dl_hwcap3 = (unsigned long int) av->a_un.a_val;
+	break;
+      case AT_HWCAP4:
+	_dl_hwcap4 = (unsigned long int) av->a_un.a_val;
+	break;
       case AT_PLATFORM:
 	_dl_platform = (void *) av->a_un.a_val;
 	break;
diff --git a/sysdeps/unix/sysv/linux/rseq-internal.h b/sysdeps/unix/sysv/linux/rseq-internal.h
index 48eebc1e16..76de2b7ff0 100644
--- a/sysdeps/unix/sysv/linux/rseq-internal.h
+++ b/sysdeps/unix/sysv/linux/rseq-internal.h
@@ -25,18 +25,47 @@
 #include <stdio.h>
 #include <sys/rseq.h>
 
+/* 32 is the initially required value for the area size.  The
+   actually used rseq size may be less (20 bytes initially).  */
+#define RSEQ_AREA_SIZE_INITIAL 32
+#define RSEQ_AREA_SIZE_INITIAL_USED 20
+
+/* The variables are in .data.relro but are not yet write-protected.  */
+extern unsigned int _rseq_size attribute_hidden;
+extern ptrdiff_t _rseq_offset attribute_hidden;
+
 #ifdef RSEQ_SIG
 static inline bool
 rseq_register_current_thread (struct pthread *self, bool do_rseq)
 {
   if (do_rseq)
     {
+      unsigned int size;
+#if IS_IN (rtld)
+      /* Use the hidden symbol in ld.so.  */
+      size = _rseq_size;
+#else
+      size = __rseq_size;
+#endif
+      if (size < RSEQ_AREA_SIZE_INITIAL)
+        /* The initial implementation used only 20 bytes out of 32,
+           but still expected size 32.  */
+        size = RSEQ_AREA_SIZE_INITIAL;
+
+      /* Initialize the whole rseq area to zero prior to registration.  */
+      memset (&self->rseq_area, 0, size);
+
+      /* Set the cpu_id field to RSEQ_CPU_ID_UNINITIALIZED, this is checked by
+         the kernel at registration when CONFIG_DEBUG_RSEQ is enabled.  */
+      THREAD_SETMEM (self, rseq_area.cpu_id, RSEQ_CPU_ID_UNINITIALIZED);
+
       int ret = INTERNAL_SYSCALL_CALL (rseq, &self->rseq_area,
-                                       sizeof (self->rseq_area),
-                                       0, RSEQ_SIG);
+                                       size, 0, RSEQ_SIG);
       if (!INTERNAL_SYSCALL_ERROR_P (ret))
         return true;
     }
+  /* When rseq is disabled by tunables or the registration fails, inform
+     userspace by setting 'cpu_id' to RSEQ_CPU_ID_REGISTRATION_FAILED.  */
   THREAD_SETMEM (self, rseq_area.cpu_id, RSEQ_CPU_ID_REGISTRATION_FAILED);
   return false;
 }
diff --git a/sysdeps/unix/sysv/linux/s390/bits/struct_stat.h b/sysdeps/unix/sysv/linux/s390/bits/struct_stat.h
index 9911c47bb2..e5c9024fb2 100644
--- a/sysdeps/unix/sysv/linux/s390/bits/struct_stat.h
+++ b/sysdeps/unix/sysv/linux/s390/bits/struct_stat.h
@@ -65,7 +65,7 @@ struct stat
 #else
 struct stat
   {
-# ifdef __USE_TIME_BITS64
+# ifdef __USE_TIME64_REDIRECTS
 #  include <bits/struct_stat_time64_helper.h>
 # else
     __dev_t st_dev;			/* Device.  */
@@ -166,7 +166,7 @@ struct stat64
 # else
 struct stat64
   {
-#  ifdef __USE_TIME_BITS64
+#  ifdef __USE_TIME64_REDIRECTS
 #   include <bits/struct_stat_time64_helper.h>
 #  else
     __dev_t st_dev;			/* Device.  */
diff --git a/sysdeps/unix/sysv/linux/s390/s390-32/clone.S b/sysdeps/unix/sysv/linux/s390/s390-32/clone.S
index 4c882ef2ee..a7a863242c 100644
--- a/sysdeps/unix/sysv/linux/s390/s390-32/clone.S
+++ b/sysdeps/unix/sysv/linux/s390/s390-32/clone.S
@@ -53,6 +53,7 @@ ENTRY(__clone)
 	br	%r14
 error:
 	lhi	%r2,-EINVAL
+	lm	%r6,%r7,24(%r15)	/* Load registers.  */
 	j	SYSCALL_ERROR_LABEL
 PSEUDO_END (__clone)
 
diff --git a/sysdeps/unix/sysv/linux/s390/s390-64/clone.S b/sysdeps/unix/sysv/linux/s390/s390-64/clone.S
index 4eb104be71..c552a6b8de 100644
--- a/sysdeps/unix/sysv/linux/s390/s390-64/clone.S
+++ b/sysdeps/unix/sysv/linux/s390/s390-64/clone.S
@@ -54,6 +54,7 @@ ENTRY(__clone)
 	br	%r14
 error:
 	lghi	%r2,-EINVAL
+	lmg	%r6,%r7,48(%r15)	/* Restore registers.  */
 	jg	SYSCALL_ERROR_LABEL
 PSEUDO_END (__clone)
 
diff --git a/sysdeps/unix/sysv/linux/sched_getcpu.c b/sysdeps/unix/sysv/linux/sched_getcpu.c
index dfb884568d..72a3360550 100644
--- a/sysdeps/unix/sysv/linux/sched_getcpu.c
+++ b/sysdeps/unix/sysv/linux/sched_getcpu.c
@@ -33,17 +33,9 @@ vsyscall_sched_getcpu (void)
   return r == -1 ? r : cpu;
 }
 
-#ifdef RSEQ_SIG
 int
 sched_getcpu (void)
 {
   int cpu_id = THREAD_GETMEM_VOLATILE (THREAD_SELF, rseq_area.cpu_id);
   return __glibc_likely (cpu_id >= 0) ? cpu_id : vsyscall_sched_getcpu ();
 }
-#else /* RSEQ_SIG */
-int
-sched_getcpu (void)
-{
-  return vsyscall_sched_getcpu ();
-}
-#endif /* RSEQ_SIG */
diff --git a/sysdeps/unix/sysv/linux/sh/bits/struct_stat.h b/sysdeps/unix/sysv/linux/sh/bits/struct_stat.h
index cbd4bc0f31..d47cd7be1e 100644
--- a/sysdeps/unix/sysv/linux/sh/bits/struct_stat.h
+++ b/sysdeps/unix/sysv/linux/sh/bits/struct_stat.h
@@ -28,7 +28,7 @@
 
 struct stat
   {
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # include <bits/struct_stat_time64_helper.h>
 #else
     __dev_t st_dev;			/* Device.  */
@@ -83,13 +83,13 @@ struct stat
 # else
     __ino64_t st_ino;			/* File serial number.	*/
 # endif
-#endif /* __USE_TIME_BITS64  */
+#endif /* __USE_TIME64_REDIRECTS  */
   };
 
 #ifdef __USE_LARGEFILE64
 struct stat64
   {
-# ifdef __USE_TIME_BITS64
+# ifdef __USE_TIME64_REDIRECTS
 #  include <bits/struct_stat_time64_helper.h>
 # else
     __dev_t st_dev;			/* Device.  */
@@ -125,7 +125,7 @@ struct stat64
     unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
 #  endif
     __ino64_t st_ino;			/* File serial number.		*/
-# endif /* __USE_TIME_BITS64  */
+# endif /* __USE_TIME64_REDIRECTS  */
   };
 #endif
 
diff --git a/sysdeps/unix/sysv/linux/sparc/bits/socket-constants.h b/sysdeps/unix/sysv/linux/sparc/bits/socket-constants.h
index 59958611c4..e7a6b684cc 100644
--- a/sysdeps/unix/sysv/linux/sparc/bits/socket-constants.h
+++ b/sysdeps/unix/sysv/linux/sparc/bits/socket-constants.h
@@ -54,7 +54,7 @@
 # define SO_TIMESTAMPNS_NEW 0x0042
 # define SO_TIMESTAMPING_NEW 0x0043
 
-# ifdef __USE_TIME_BITS64
+# ifdef __USE_TIME64_REDIRECTS
 #  define SO_RCVTIMEO SO_RCVTIMEO_NEW
 #  define SO_SNDTIMEO SO_SNDTIMEO_NEW
 #  define SO_TIMESTAMP SO_TIMESTAMP_NEW
diff --git a/sysdeps/unix/sysv/linux/sparc/bits/struct_stat.h b/sysdeps/unix/sysv/linux/sparc/bits/struct_stat.h
index 4e48634edc..fcab5f4804 100644
--- a/sysdeps/unix/sysv/linux/sparc/bits/struct_stat.h
+++ b/sysdeps/unix/sysv/linux/sparc/bits/struct_stat.h
@@ -28,7 +28,7 @@
 
 struct stat
   {
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # include <bits/struct_stat_time64_helper.h>
 #else
     __dev_t st_dev;			/* Device.  */
@@ -79,13 +79,13 @@ struct stat
 # endif
     unsigned long int __glibc_reserved4;
     unsigned long int __glibc_reserved5;
-#endif /* __USE_TIME_BITS64  */
+#endif /* __USE_TIME64_REDIRECTS  */
   };
 
 #ifdef __USE_LARGEFILE64
 struct stat64
   {
-# ifdef __USE_TIME_BITS64
+# ifdef __USE_TIME64_REDIRECTS
 #  include <bits/struct_stat_time64_helper.h>
 # else
     __dev_t st_dev;			/* Device.  */
@@ -126,7 +126,7 @@ struct stat64
 #  endif
     unsigned long int __glibc_reserved4;
     unsigned long int __glibc_reserved5;
-# endif /* __USE_TIME_BITS64  */
+# endif /* __USE_TIME64_REDIRECTS  */
   };
 #endif
 
diff --git a/sysdeps/unix/sysv/linux/sparc/bits/types/struct_msqid_ds.h b/sysdeps/unix/sysv/linux/sparc/bits/types/struct_msqid_ds.h
index db783c28d4..ed8d47c9b6 100644
--- a/sysdeps/unix/sysv/linux/sparc/bits/types/struct_msqid_ds.h
+++ b/sysdeps/unix/sysv/linux/sparc/bits/types/struct_msqid_ds.h
@@ -26,7 +26,7 @@
    The type `struct msg' is opaque.  */
 struct msqid_ds
 {
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # include <bits/types/struct_msqid64_ds_helper.h>
 #else
   struct ipc_perm msg_perm;	/* structure describing operation permission */
diff --git a/sysdeps/unix/sysv/linux/sparc/bits/types/struct_semid_ds.h b/sysdeps/unix/sysv/linux/sparc/bits/types/struct_semid_ds.h
index 1c8a3693db..b9e729b8b4 100644
--- a/sysdeps/unix/sysv/linux/sparc/bits/types/struct_semid_ds.h
+++ b/sysdeps/unix/sysv/linux/sparc/bits/types/struct_semid_ds.h
@@ -23,7 +23,7 @@
 /* Data structure describing a set of semaphores.  */
 struct semid_ds
 {
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # include <bits/types/struct_semid64_ds_helper.h>
 #else
   struct ipc_perm sem_perm;   /* operation permission struct */
diff --git a/sysdeps/unix/sysv/linux/sparc/bits/types/struct_shmid_ds.h b/sysdeps/unix/sysv/linux/sparc/bits/types/struct_shmid_ds.h
index 35a0cc36ab..7885d2ab25 100644
--- a/sysdeps/unix/sysv/linux/sparc/bits/types/struct_shmid_ds.h
+++ b/sysdeps/unix/sysv/linux/sparc/bits/types/struct_shmid_ds.h
@@ -23,7 +23,7 @@
 /* Data structure describing a shared memory segment.  */
 struct shmid_ds
   {
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # include <bits/types/struct_shmid64_ds_helper.h>
 #else
     struct ipc_perm shm_perm;		/* operation permission struct */
diff --git a/sysdeps/unix/sysv/linux/sparc/bits/wordsize.h b/sysdeps/unix/sysv/linux/sparc/bits/wordsize.h
index 7562875ee2..ea103e5970 100644
--- a/sysdeps/unix/sysv/linux/sparc/bits/wordsize.h
+++ b/sysdeps/unix/sysv/linux/sparc/bits/wordsize.h
@@ -2,10 +2,9 @@
 
 #if defined __arch64__ || defined __sparcv9
 # define __WORDSIZE	64
-# define __WORDSIZE_TIME64_COMPAT32	1
 #else
 # define __WORDSIZE	32
 # define __WORDSIZE32_SIZE_ULONG	0
 # define __WORDSIZE32_PTRDIFF_LONG	0
-# define __WORDSIZE_TIME64_COMPAT32	0
 #endif
+#define __WORDSIZE_TIME64_COMPAT32	1
diff --git a/sysdeps/unix/sysv/linux/spawni.c b/sysdeps/unix/sysv/linux/spawni.c
index e8ed2babb9..f57e92815e 100644
--- a/sysdeps/unix/sysv/linux/spawni.c
+++ b/sysdeps/unix/sysv/linux/spawni.c
@@ -449,13 +449,22 @@ __spawnix (int *pid, const char *file,
 	 caller to actually collect it.  */
       ec = args.err;
       if (ec > 0)
-	/* There still an unlikely case where the child is cancelled after
-	   setting args.err, due to a positive error value.  Also there is
-	   possible pid reuse race (where the kernel allocated the same pid
-	   to an unrelated process).  Unfortunately due synchronization
-	   issues where the kernel might not have the process collected
-	   the waitpid below can not use WNOHANG.  */
-	__waitpid (new_pid, NULL, 0);
+	{
+	  /* There still an unlikely case where the child is cancelled after
+	     setting args.err, due to a positive error value.  Also there is
+	     possible pid reuse race (where the kernel allocated the same pid
+	     to an unrelated process).  Unfortunately due synchronization
+	     issues where the kernel might not have the process collected
+	     the waitpid below can not use WNOHANG.  */
+	  __waitid (use_pidfd ? P_PIDFD : P_PID,
+		    use_pidfd ? args.pidfd : new_pid,
+		    NULL,
+		    WEXITED);
+	  /* For pidfd we need to also close the file descriptor for the case
+	     where execve fails.  */
+	  if (use_pidfd)
+	    __close_nocancel_nostatus (args.pidfd);
+	}
     }
   else
     ec = errno;
diff --git a/sysdeps/unix/sysv/linux/sys/epoll.h b/sysdeps/unix/sysv/linux/sys/epoll.h
index 9b51e3bd14..fc8dce45c8 100644
--- a/sysdeps/unix/sysv/linux/sys/epoll.h
+++ b/sysdeps/unix/sysv/linux/sys/epoll.h
@@ -140,7 +140,7 @@ extern int epoll_pwait (int __epfd, struct epoll_event *__events,
 
    This function is a cancellation point and therefore not marked with
    __THROW.  */
-#ifndef __USE_TIME_BITS64
+#ifndef __USE_TIME64_REDIRECTS
 extern int epoll_pwait2 (int __epfd, struct epoll_event *__events,
 			 int __maxevents, const struct timespec *__timeout,
 			 const __sigset_t *__ss)
diff --git a/sysdeps/unix/sysv/linux/sys/prctl.h b/sysdeps/unix/sysv/linux/sys/prctl.h
index b13b846261..79a9b31273 100644
--- a/sysdeps/unix/sysv/linux/sys/prctl.h
+++ b/sysdeps/unix/sysv/linux/sys/prctl.h
@@ -38,7 +38,7 @@
 __BEGIN_DECLS
 
 /* Control process execution.  */
-#ifndef __USE_TIME_BITS64
+#ifndef __USE_TIME64_REDIRECTS
 extern int prctl (int __option, ...) __THROW;
 #else
 # ifdef __REDIRECT
diff --git a/sysdeps/unix/sysv/linux/sys/timerfd.h b/sysdeps/unix/sysv/linux/sys/timerfd.h
index 19d0cbfae0..f66ece306a 100644
--- a/sysdeps/unix/sysv/linux/sys/timerfd.h
+++ b/sysdeps/unix/sysv/linux/sys/timerfd.h
@@ -47,7 +47,7 @@ extern int timerfd_settime (int __ufd, int __flags,
 			    const struct itimerspec *__utmr,
 			    struct itimerspec *__otmr) __THROW;
 
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # if defined(__REDIRECT_NTH)
 extern int __REDIRECT_NTH (timerfd_settime,
                            (int __ufd, int __flags,
@@ -62,7 +62,7 @@ extern int __REDIRECT_NTH (timerfd_settime,
 /* Return the next expiration time of UFD.  */
 extern int timerfd_gettime (int __ufd, struct itimerspec *__otmr) __THROW;
 
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # if defined(__REDIRECT_NTH)
 extern int __REDIRECT_NTH (timerfd_gettime, (int __ufd,
                                              struct itimerspec *__otmr),
diff --git a/sysdeps/unix/sysv/linux/sys/timex.h b/sysdeps/unix/sysv/linux/sys/timex.h
index 28ce022253..568748d767 100644
--- a/sysdeps/unix/sysv/linux/sys/timex.h
+++ b/sysdeps/unix/sysv/linux/sys/timex.h
@@ -54,7 +54,7 @@ struct ntptimeval
 
 __BEGIN_DECLS
 
-#ifndef __USE_TIME_BITS64
+#ifndef __USE_TIME64_REDIRECTS
 extern int adjtimex (struct timex *__ntx) __THROW __nonnull ((1));
 extern int ntp_gettimex (struct ntptimeval *__ntv) __THROW __nonnull ((1));
 
diff --git a/sysdeps/unix/sysv/linux/syscalls.list b/sysdeps/unix/sysv/linux/syscalls.list
index 73e941ef89..9ac42c3436 100644
--- a/sysdeps/unix/sysv/linux/syscalls.list
+++ b/sysdeps/unix/sysv/linux/syscalls.list
@@ -46,6 +46,7 @@ open_tree	EXTRA	open_tree	i:isU	open_tree
 pipe2		-	pipe2		i:fi	__pipe2		pipe2
 pidfd_open	EXTRA	pidfd_open	i:iU	pidfd_open
 pidfd_getfd	EXTRA	pidfd_getfd	i:iiU	pidfd_getfd
+prctl		EXTRA	prctl		i:iiiii	__prctl		prctl __prctl_time64
 pivot_root	EXTRA	pivot_root	i:ss	pivot_root
 pidfd_send_signal	EXTRA	pidfd_send_signal	i:iiPU	pidfd_send_signal
 process_madvise EXTRA   process_madvise i:iPniU process_madvise
diff --git a/sysdeps/unix/sysv/linux/timespec_get.c b/sysdeps/unix/sysv/linux/timespec_get.c
index c6e5e66289..778d1e3354 100644
--- a/sysdeps/unix/sysv/linux/timespec_get.c
+++ b/sysdeps/unix/sysv/linux/timespec_get.c
@@ -5,7 +5,7 @@
    The GNU C Library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
-   version 2.1 of the License.
+   version 2.1 of the License, or (at your option) any later version.
 
    The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
diff --git a/sysdeps/unix/sysv/linux/timespec_getres.c b/sysdeps/unix/sysv/linux/timespec_getres.c
index 5acebe2a2c..2eef9e512c 100644
--- a/sysdeps/unix/sysv/linux/timespec_getres.c
+++ b/sysdeps/unix/sysv/linux/timespec_getres.c
@@ -5,7 +5,7 @@
    The GNU C Library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
-   version 2.1 of the License.
+   version 2.1 of the License, or (at your option) any later version.
 
    The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
diff --git a/sysdeps/unix/sysv/linux/tst-clone.c b/sysdeps/unix/sysv/linux/tst-clone.c
index 470676ab2b..2bc7124983 100644
--- a/sysdeps/unix/sysv/linux/tst-clone.c
+++ b/sysdeps/unix/sysv/linux/tst-clone.c
@@ -16,12 +16,16 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-/* BZ #2386 */
+/* BZ #2386, BZ #31402 */
 #include <errno.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
 #include <sched.h>
+#include <stackinfo.h>  /* For _STACK_GROWS_{UP,DOWN}.  */
+#include <support/check.h>
+
+volatile unsigned v = 0xdeadbeef;
 
 int child_fn(void *arg)
 {
@@ -30,22 +34,67 @@ int child_fn(void *arg)
 }
 
 static int
-do_test (void)
+__attribute__((noinline))
+do_clone (int (*fn)(void *), void *stack)
 {
   int result;
+  unsigned int a = v;
+  unsigned int b = v;
+  unsigned int c = v;
+  unsigned int d = v;
+  unsigned int e = v;
+  unsigned int f = v;
+  unsigned int g = v;
+  unsigned int h = v;
+  unsigned int i = v;
+  unsigned int j = v;
+  unsigned int k = v;
+  unsigned int l = v;
+  unsigned int m = v;
+  unsigned int n = v;
+  unsigned int o = v;
+
+  result = clone (fn, stack, 0, NULL);
+
+  /* Check that clone does not clobber call-saved registers.  */
+  TEST_VERIFY (a == v && b == v && c == v && d == v && e == v && f == v
+	       && g == v && h == v && i == v && j == v && k == v && l == v
+	       && m == v && n == v && o == v);
+
+  return result;
+}
+
+static void
+__attribute__((noinline))
+do_test_single (int (*fn)(void *), void *stack)
+{
+  printf ("%s (fn=%p, stack=%p)\n", __FUNCTION__, fn, stack);
+  errno = 0;
+
+  int result = do_clone (fn, stack);
+
+  TEST_COMPARE (errno, EINVAL);
+  TEST_COMPARE (result, -1);
+}
 
-  result = clone (child_fn, NULL, 0, NULL);
+static int
+do_test (void)
+{
+  char st[128 * 1024] __attribute__ ((aligned));
+  void *stack = NULL;
+#if _STACK_GROWS_DOWN
+  stack = st + sizeof (st);
+#elif _STACK_GROWS_UP
+  stack = st;
+#else
+# error "Define either _STACK_GROWS_DOWN or _STACK_GROWS_UP"
+#endif
 
-  if (errno != EINVAL || result != -1)
-    {
-      printf ("FAIL: clone()=%d (wanted -1) errno=%d (wanted %d)\n",
-              result, errno, EINVAL);
-      return 1;
-    }
+  do_test_single (child_fn, NULL);
+  do_test_single (NULL, stack);
+  do_test_single (NULL, NULL);
 
-  puts ("All OK");
   return 0;
 }
 
-#define TEST_FUNCTION do_test ()
-#include "../test-skeleton.c"
+#include <support/test-driver.c>
diff --git a/sysdeps/unix/sysv/linux/tst-linux-mremap1.c b/sysdeps/unix/sysv/linux/tst-linux-mremap1.c
new file mode 100644
index 0000000000..408e8af2ab
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/tst-linux-mremap1.c
@@ -0,0 +1,63 @@
+/* Test mremap with MREMAP_DONTUNMAP.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <sys/mman.h>
+#include <support/xstdlib.h>
+#include <support/xunistd.h>
+#include <support/check.h>
+#include <support/test-driver.h>
+#include <mremap-failure.h>
+
+static int
+do_test (void)
+{
+  size_t old_size = getpagesize ();
+  size_t new_size = old_size;
+  char *old_addr = xmmap (NULL, old_size, PROT_READ | PROT_WRITE,
+			  MAP_PRIVATE | MAP_ANONYMOUS, -1);
+  old_addr[0] = 1;
+  old_addr[old_size - 1] = 2;
+
+  /* Create an available 64-page mmap region.  */
+  size_t fixed_size = old_size * 64;
+  char *fixed_addr = xmmap (NULL, fixed_size, PROT_READ | PROT_WRITE,
+			    MAP_PRIVATE | MAP_ANONYMOUS, -1);
+  xmunmap (fixed_addr, fixed_size);
+
+  /* Add 3 * pagesize.  */
+  fixed_size += 3 * old_size;
+
+  /* Test MREMAP_DONTUNMAP.  It should return FIXED_ADDR created above.  */
+  char *new_addr = mremap (old_addr, old_size, new_size,
+			   MREMAP_DONTUNMAP | MREMAP_MAYMOVE,
+			   fixed_addr);
+  if (new_addr == MAP_FAILED)
+    return mremap_failure_exit (errno);
+  TEST_VERIFY_EXIT (fixed_addr == new_addr);
+  old_addr[0] = 3;
+  old_addr[old_size - 1] = 4;
+  new_addr[0] = 1;
+  new_addr[new_size - 1] = 2;
+  xmunmap (new_addr, new_size);
+  xmunmap (old_addr, old_size);
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/sysdeps/unix/sysv/linux/tst-nolink-libc.c b/sysdeps/unix/sysv/linux/tst-nolink-libc.c
new file mode 100644
index 0000000000..817f37784b
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/tst-nolink-libc.c
@@ -0,0 +1,25 @@
+/* Test program not linked against libc.so and not using any glibc functions.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+void
+_start (void)
+{
+  INTERNAL_SYSCALL_CALL (exit_group, 0);
+}
diff --git a/sysdeps/unix/sysv/linux/tst-pkey.c b/sysdeps/unix/sysv/linux/tst-pkey.c
index d9083daab9..46f55666da 100644
--- a/sysdeps/unix/sysv/linux/tst-pkey.c
+++ b/sysdeps/unix/sysv/linux/tst-pkey.c
@@ -205,7 +205,13 @@ do_test (void)
            " protection keys");
       FAIL_EXIT1 ("pkey_alloc: %m");
     }
-  TEST_COMPARE (pkey_get (keys[0]), 0);
+  if (pkey_get (keys[0]) < 0)
+    {
+      if (errno == ENOSYS)
+	FAIL_UNSUPPORTED
+	  ("glibc does not support memory protection keys");
+      FAIL_EXIT1 ("pkey_alloc: %m");
+    }
   for (int i = 1; i < key_count; ++i)
     {
       keys[i] = pkey_alloc (0, i);
diff --git a/sysdeps/unix/sysv/linux/tst-rseq.c b/sysdeps/unix/sysv/linux/tst-rseq.c
index 2c90409ba0..08a9533130 100644
--- a/sysdeps/unix/sysv/linux/tst-rseq.c
+++ b/sysdeps/unix/sysv/linux/tst-rseq.c
@@ -29,6 +29,7 @@
 # include <stdlib.h>
 # include <string.h>
 # include <syscall.h>
+# include <sys/auxv.h>
 # include <thread_pointer.h>
 # include <tls.h>
 # include "tst-rseq.h"
@@ -42,7 +43,8 @@ do_rseq_main_test (void)
   TEST_COMPARE (__rseq_flags, 0);
   TEST_VERIFY ((char *) __thread_pointer () + __rseq_offset
                == (char *) &pd->rseq_area);
-  TEST_COMPARE (__rseq_size, sizeof (pd->rseq_area));
+  /* The current implementation only supports the initial size.  */
+  TEST_COMPARE (__rseq_size, 20);
 }
 
 static void
@@ -52,6 +54,12 @@ do_rseq_test (void)
     {
       FAIL_UNSUPPORTED ("kernel does not support rseq, skipping test");
     }
+  printf ("info: __rseq_size: %u\n", __rseq_size);
+  printf ("info: __rseq_offset: %td\n", __rseq_offset);
+  printf ("info: __rseq_flags: %u\n", __rseq_flags);
+  printf ("info: getauxval (AT_RSEQ_FEATURE_SIZE): %ld\n",
+          getauxval (AT_RSEQ_FEATURE_SIZE));
+  printf ("info: getauxval (AT_RSEQ_ALIGN): %ld\n", getauxval (AT_RSEQ_ALIGN));
   do_rseq_main_test ();
 }
 #else /* RSEQ_SIG */
diff --git a/sysdeps/unix/sysv/linux/x86/bits/struct_stat.h b/sysdeps/unix/sysv/linux/x86/bits/struct_stat.h
index 21aa315d8d..810d6566f0 100644
--- a/sysdeps/unix/sysv/linux/x86/bits/struct_stat.h
+++ b/sysdeps/unix/sysv/linux/x86/bits/struct_stat.h
@@ -25,7 +25,7 @@
 
 struct stat
   {
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # include <bits/struct_stat_time64_helper.h>
 #else
     __dev_t st_dev;		/* Device.  */
@@ -95,14 +95,14 @@ struct stat
     __ino64_t st_ino;			/* File serial number.	*/
 #  endif
 # endif
-#endif /* __USE_TIME_BITS64  */
+#endif /* __USE_TIME64_REDIRECTS  */
   };
 
 #ifdef __USE_LARGEFILE64
 /* Note stat64 has the same shape as stat for x86-64.  */
 struct stat64
   {
-# ifdef __USE_TIME_BITS64
+# ifdef __USE_TIME64_REDIRECTS
 #  include <bits/struct_stat_time64_helper.h>
 # else
     __dev_t st_dev;		/* Device.  */
@@ -152,7 +152,7 @@ struct stat64
 #  else
     __ino64_t st_ino;			/* File serial number.		*/
 #  endif
-# endif /* __USE_TIME_BITS64  */
+# endif /* __USE_TIME64_REDIRECTS  */
   };
 #endif
 
diff --git a/sysdeps/unix/sysv/linux/x86/bits/types/struct_semid_ds.h b/sysdeps/unix/sysv/linux/x86/bits/types/struct_semid_ds.h
index 9f3d170b65..81867c0316 100644
--- a/sysdeps/unix/sysv/linux/x86/bits/types/struct_semid_ds.h
+++ b/sysdeps/unix/sysv/linux/x86/bits/types/struct_semid_ds.h
@@ -23,7 +23,7 @@
 /* Data structure describing a set of semaphores.  */
 struct semid_ds
 {
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 # include <bits/types/struct_semid64_ds_helper.h>
 #else
   struct ipc_perm sem_perm;   /* operation permission struct */
diff --git a/sysdeps/unix/sysv/linux/x86_64/Makefile b/sysdeps/unix/sysv/linux/x86_64/Makefile
index 4223feb95f..fcbffd81cb 100644
--- a/sysdeps/unix/sysv/linux/x86_64/Makefile
+++ b/sysdeps/unix/sysv/linux/x86_64/Makefile
@@ -17,18 +17,21 @@ endif
 ifeq ($(subdir),elf)
 ifeq (yes,$(enable-x86-isa-level))
 tests += \
-  tst-glibc-hwcaps-2
+  tst-glibc-hwcaps-2 \
+# tests
 ifeq (no,$(build-hardcoded-path-in-tests))
 # This is an ld.so.cache test, and RPATH/RUNPATH in the executable
 # interferes with its test objectives.
 tests-container += \
-  tst-glibc-hwcaps-2-cache
+  tst-glibc-hwcaps-2-cache \
+# tests-container
 endif
 modules-names += \
   libx86-64-isa-level-1 \
   libx86-64-isa-level-2 \
   libx86-64-isa-level-3 \
-  libx86-64-isa-level-4
+  libx86-64-isa-level-4 \
+# modules-names
 
 $(objpfx)tst-glibc-hwcaps-2: $(objpfx)libx86-64-isa-level.so
 
@@ -63,6 +66,33 @@ $(objpfx)libx86-64-isa-level%.os: $(..)/sysdeps/unix/sysv/linux/x86_64/x86-64-is
 $(objpfx)libx86-64-isa-level.so: $(objpfx)libx86-64-isa-level-1.so
 	cp $< $@
 endif
+
+ifeq (yes,$(have-mamx-tile))
+tests += \
+  tst-gnu2-tls2-amx \
+# tests
+
+modules-names += \
+  tst-gnu2-tls2-amx-mod0 \
+  tst-gnu2-tls2-amx-mod1 \
+  tst-gnu2-tls2-amx-mod2 \
+# modules-names
+
+$(objpfx)tst-gnu2-tls2-amx: $(shared-thread-library)
+$(objpfx)tst-gnu2-tls2-amx.out: \
+  $(objpfx)tst-gnu2-tls2-amx-mod0.so \
+  $(objpfx)tst-gnu2-tls2-amx-mod1.so \
+  $(objpfx)tst-gnu2-tls2-amx-mod2.so
+$(objpfx)tst-gnu2-tls2-amx-mod0.so: $(libsupport)
+$(objpfx)tst-gnu2-tls2-amx-mod1.so: $(libsupport)
+$(objpfx)tst-gnu2-tls2-amx-mod2.so: $(libsupport)
+
+CFLAGS-tst-gnu2-tls2-amx.c += -mamx-tile
+CFLAGS-tst-gnu2-tls2-amx-mod0.c += -mamx-tile -mtls-dialect=gnu2
+CFLAGS-tst-gnu2-tls2-amx-mod1.c += -mamx-tile -mtls-dialect=gnu2
+CFLAGS-tst-gnu2-tls2-amx-mod2.c += -mamx-tile -mtls-dialect=gnu2
+endif
+
 endif # $(subdir) == elf
 
 ifneq ($(enable-cet),no)
diff --git a/sysdeps/unix/sysv/linux/x86_64/dl-cet.h b/sysdeps/unix/sysv/linux/x86_64/dl-cet.h
index 1fe3133406..b4f7e6c9cd 100644
--- a/sysdeps/unix/sysv/linux/x86_64/dl-cet.h
+++ b/sysdeps/unix/sysv/linux/x86_64/dl-cet.h
@@ -92,9 +92,9 @@ dl_cet_ibt_enabled (void)
 	# Pass GL(dl_x86_feature_1) to _dl_cet_setup_features.\n\
 	movl %edx, %edi\n\
 	# Align stack for the _dl_cet_setup_features call.\n\
-	andq $-16, %rsp\n\
+	and $-16, %" RSP_LP "\n\
 	call _dl_cet_setup_features\n\
 	# Restore %rax and %rsp from %r12 and %r13.\n\
-	movq %r12, %rax\n\
-	movq %r13, %rsp\n\
+	mov %" R12_LP ", %" RAX_LP "\n\
+	mov %" R13_LP ", %" RSP_LP "\n\
 "
diff --git a/sysdeps/unix/sysv/linux/x86_64/include/asm/prctl.h b/sysdeps/unix/sysv/linux/x86_64/include/asm/prctl.h
index 2f511321ad..ef4631bf4b 100644
--- a/sysdeps/unix/sysv/linux/x86_64/include/asm/prctl.h
+++ b/sysdeps/unix/sysv/linux/x86_64/include/asm/prctl.h
@@ -20,3 +20,8 @@
 # define ARCH_SHSTK_SHSTK		0x1
 # define ARCH_SHSTK_WRSS		0x2
 #endif
+
+#ifndef ARCH_GET_XCOMP_PERM
+# define ARCH_GET_XCOMP_PERM		0x1022
+# define ARCH_REQ_XCOMP_PERM		0x1023
+#endif
diff --git a/sysdeps/unix/sysv/linux/x86_64/tst-gnu2-tls2-amx-mod0.c b/sysdeps/unix/sysv/linux/x86_64/tst-gnu2-tls2-amx-mod0.c
new file mode 100644
index 0000000000..2e0c7b91b7
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/tst-gnu2-tls2-amx-mod0.c
@@ -0,0 +1,2 @@
+#include "tst-gnu2-tls2-amx.h"
+#include <tst-gnu2-tls2mod0.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/tst-gnu2-tls2-amx-mod1.c b/sysdeps/unix/sysv/linux/x86_64/tst-gnu2-tls2-amx-mod1.c
new file mode 100644
index 0000000000..b8a8ccf1c1
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/tst-gnu2-tls2-amx-mod1.c
@@ -0,0 +1,2 @@
+#include "tst-gnu2-tls2-amx.h"
+#include <tst-gnu2-tls2mod1.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/tst-gnu2-tls2-amx-mod2.c b/sysdeps/unix/sysv/linux/x86_64/tst-gnu2-tls2-amx-mod2.c
new file mode 100644
index 0000000000..cdf4a8f363
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/tst-gnu2-tls2-amx-mod2.c
@@ -0,0 +1,2 @@
+#include "tst-gnu2-tls2-amx.h"
+#include <tst-gnu2-tls2mod2.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/tst-gnu2-tls2-amx.c b/sysdeps/unix/sysv/linux/x86_64/tst-gnu2-tls2-amx.c
new file mode 100644
index 0000000000..ae4dd82556
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/tst-gnu2-tls2-amx.c
@@ -0,0 +1,83 @@
+/* Test TLSDESC relocation with AMX.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <stdbool.h>
+#include <asm/prctl.h>
+#include <support/check.h>
+#include "tst-gnu2-tls2-amx.h"
+
+extern int arch_prctl (int, ...);
+
+#define X86_XSTATE_TILECFG_ID	17
+#define X86_XSTATE_TILEDATA_ID	18
+
+/* Initialize tile config.  */
+__attribute__ ((noinline, noclone))
+static void
+init_tile_config (__tilecfg *tileinfo)
+{
+  int i;
+  tileinfo->palette_id = 1;
+  tileinfo->start_row = 0;
+
+  tileinfo->colsb[0] = MAX_ROWS;
+  tileinfo->rows[0] = MAX_ROWS;
+
+  for (i = 1; i < 4; ++i)
+  {
+    tileinfo->colsb[i] = MAX_COLS;
+    tileinfo->rows[i] = MAX_ROWS;
+  }
+
+  _tile_loadconfig (tileinfo);
+}
+
+static bool
+enable_amx (void)
+{
+  uint64_t bitmask;
+  if (arch_prctl (ARCH_GET_XCOMP_PERM, &bitmask) != 0)
+    return false;
+
+  if ((bitmask & (1 << X86_XSTATE_TILECFG_ID)) == 0)
+    return false;
+
+  if (arch_prctl (ARCH_REQ_XCOMP_PERM, X86_XSTATE_TILEDATA_ID) != 0)
+    return false;
+
+  /* Load tile configuration.  */
+  __tilecfg tile_data = { 0 };
+  init_tile_config (&tile_data);
+
+  return true;
+}
+
+/* An architecture can define it to clobber caller-saved registers in
+   malloc below to verify that the implicit TLSDESC call won't change
+   caller-saved registers.  */
+static void
+clear_tile_register (void)
+{
+  _tile_zero (2);
+}
+
+#define MOD(i) "tst-gnu2-tls2-amx-mod" #i ".so"
+#define IS_SUPPORTED()	enable_amx ()
+#define PREPARE_MALLOC() clear_tile_register ()
+
+#include <elf/tst-gnu2-tls2.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/tst-gnu2-tls2-amx.h b/sysdeps/unix/sysv/linux/x86_64/tst-gnu2-tls2-amx.h
new file mode 100644
index 0000000000..1845a3caba
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/tst-gnu2-tls2-amx.h
@@ -0,0 +1,63 @@
+/* Test TLSDESC relocation with AMX.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <stdint.h>
+#include <string.h>
+#include <x86intrin.h>
+#include <support/check.h>
+
+#define MAX_ROWS 16
+#define MAX_COLS 64
+#define MAX 1024
+#define STRIDE 64
+
+typedef struct __tile_config
+{
+  uint8_t palette_id;
+  uint8_t start_row;
+  uint8_t reserved_0[14];
+  uint16_t colsb[16];
+  uint8_t rows[16];
+} __tilecfg __attribute__ ((aligned (64)));
+
+/* Initialize int8_t buffer */
+static inline void
+init_buffer (int8_t *buf, int8_t value)
+{
+  int rows, colsb, i, j;
+  rows  = MAX_ROWS;
+  colsb = MAX_COLS;
+
+  for (i = 0; i < rows; i++)
+    for (j = 0; j < colsb; j++)
+      buf[i * colsb + j] = value;
+}
+
+#define BEFORE_TLSDESC_CALL()					\
+  int8_t src[MAX];						\
+  int8_t res[MAX];						\
+  /* Initialize src with data  */				\
+  init_buffer (src, 2);						\
+  /* Load tile rows from memory.  */				\
+  _tile_loadd (2, src, STRIDE);
+
+#define AFTER_TLSDESC_CALL()					\
+  /* Store the tile data to memory.  */				\
+  _tile_stored (2, res, STRIDE);				\
+  _tile_release ();						\
+  TEST_VERIFY_EXIT (memcmp (src, res, sizeof (res)) == 0);
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/arch-syscall.h b/sysdeps/unix/sysv/linux/x86_64/x32/arch-syscall.h
index b9db8bc5be..645e85802f 100644
--- a/sysdeps/unix/sysv/linux/x86_64/x32/arch-syscall.h
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/arch-syscall.h
@@ -151,6 +151,7 @@
 #define __NR_lsetxattr 1073742013
 #define __NR_lstat 1073741830
 #define __NR_madvise 1073741852
+#define __NR_map_shadow_stack 1073742277
 #define __NR_mbind 1073742061
 #define __NR_membarrier 1073742148
 #define __NR_memfd_create 1073742143
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/fixup-asm-unistd.h b/sysdeps/unix/sysv/linux/x86_64/x32/fixup-asm-unistd.h
index 98124169e6..47fa8af4ce 100644
--- a/sysdeps/unix/sysv/linux/x86_64/x32/fixup-asm-unistd.h
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/fixup-asm-unistd.h
@@ -15,6 +15,10 @@
    License along with the GNU C Library; if not, see
    <http://www.gnu.org/licenses/>.  */
 
+#ifndef __NR_map_shadow_stack
+# define __NR_map_shadow_stack 1073742277
+#endif
+
 /* X32 uses the same 64-bit syscall interface for set_thread_area.   */
 #ifndef __NR_set_thread_area
 # define __NR_set_thread_area 1073742029
diff --git a/sysdeps/unix/sysv/linux/prctl.c b/sysdeps/unix/sysv/linux/x86_64/x32/prctl.c
similarity index 93%
rename from sysdeps/unix/sysv/linux/prctl.c
rename to sysdeps/unix/sysv/linux/x86_64/x32/prctl.c
index 52d234ea0d..4bf1b479a0 100644
--- a/sysdeps/unix/sysv/linux/prctl.c
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/prctl.c
@@ -1,4 +1,4 @@
-/* prctl - Linux specific syscall.
+/* prctl - Linux specific syscall.  x86-64 x32 version.
    Copyright (C) 2020-2024 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -40,6 +40,3 @@ __prctl (int option, ...)
 
 libc_hidden_def (__prctl)
 weak_alias (__prctl, prctl)
-#if __TIMESIZE != 64
-weak_alias (__prctl, __prctl_time64)
-#endif
diff --git a/sysdeps/x86/Makefile b/sysdeps/x86/Makefile
index 4d50b327b5..c814060e08 100644
--- a/sysdeps/x86/Makefile
+++ b/sysdeps/x86/Makefile
@@ -1,10 +1,16 @@
 ifeq ($(subdir),csu)
-gen-as-const-headers += cpu-features-offsets.sym
+gen-as-const-headers += cpu-features-offsets.sym features-offsets.sym
 endif
 
 ifeq ($(subdir),elf)
 sysdep_routines += get-cpuid-feature-leaf
-sysdep-dl-routines += dl-get-cpu-features
+sysdep-dl-routines += \
+  dl-get-cpu-features \
+  dl-tlsdesc \
+  tls_get_addr \
+  tlsdesc \
+# sysdep-dl-routines
+
 sysdep_headers += \
   bits/platform/features.h \
   bits/platform/x86.h \
@@ -15,18 +21,21 @@ CFLAGS-dl-get-cpu-features.os += $(rtld-early-cflags)
 CFLAGS-get-cpuid-feature-leaf.o += $(no-stack-protector)
 
 tests += \
-  tst-get-cpu-features \
-  tst-get-cpu-features-static \
   tst-cpu-features-cpuinfo \
   tst-cpu-features-cpuinfo-static \
   tst-cpu-features-supports \
   tst-cpu-features-supports-static \
+  tst-get-cpu-features \
+  tst-get-cpu-features-static \
+  tst-gnu2-tls2-x86-noxsave \
+  tst-gnu2-tls2-x86-noxsavec \
+  tst-gnu2-tls2-x86-noxsavexsavec \
   tst-hwcap-tunables \
 # tests
 tests-static += \
-  tst-get-cpu-features-static \
   tst-cpu-features-cpuinfo-static \
   tst-cpu-features-supports-static \
+  tst-get-cpu-features-static \
 # tests-static
 ifeq (yes,$(have-ifunc))
 ifeq (yes,$(have-gcc-ifunc))
@@ -86,6 +95,47 @@ endif
 tst-ifunc-isa-2-ENV = GLIBC_TUNABLES=glibc.cpu.hwcaps=-SSE4_2,-AVX,-AVX2,-AVX512F
 tst-ifunc-isa-2-static-ENV = $(tst-ifunc-isa-2-ENV)
 tst-hwcap-tunables-ARGS = -- $(host-test-program-cmd)
+
+CFLAGS-tst-gnu2-tls2.c += -msse
+CFLAGS-tst-gnu2-tls2mod0.c += -msse2 -mtune=haswell
+CFLAGS-tst-gnu2-tls2mod1.c += -msse2 -mtune=haswell
+CFLAGS-tst-gnu2-tls2mod2.c += -msse2 -mtune=haswell
+
+LDFLAGS-tst-gnu2-tls2-x86-noxsave += -Wl,-z,lazy
+LDFLAGS-tst-gnu2-tls2-x86-noxsavec += -Wl,-z,lazy
+LDFLAGS-tst-gnu2-tls2-x86-noxsavexsavec += -Wl,-z,lazy
+
+# Test for bug 32810: incorrect XSAVE state size if XSAVEC is disabled
+# via tunable.
+tst-gnu2-tls2-x86-noxsave-ENV = GLIBC_TUNABLES=glibc.cpu.hwcaps=-XSAVE
+tst-gnu2-tls2-x86-noxsavec-ENV = GLIBC_TUNABLES=glibc.cpu.hwcaps=-XSAVEC
+tst-gnu2-tls2-x86-noxsavexsavec-ENV = GLIBC_TUNABLES=glibc.cpu.hwcaps=-XSAVE,-XSAVEC
+$(objpfx)tst-gnu2-tls2-x86-noxsave: $(shared-thread-library)
+$(objpfx)tst-gnu2-tls2-x86-noxsavec: $(shared-thread-library)
+$(objpfx)tst-gnu2-tls2-x86-noxsavexsavec: $(shared-thread-library)
+$(objpfx)tst-gnu2-tls2-x86-noxsave.out \
+$(objpfx)tst-gnu2-tls2-x86-noxsavec.out \
+$(objpfx)tst-gnu2-tls2-x86-noxsavexsavec.out: \
+  $(objpfx)tst-gnu2-tls2mod0.so \
+  $(objpfx)tst-gnu2-tls2mod1.so \
+  $(objpfx)tst-gnu2-tls2mod2.so
+
+CFLAGS-tst-tls23.c += -msse2
+CFLAGS-tst-tls23-mod.c += -msse2 -mtune=haswell
+
+LDFLAGS-tst-tls23 += -rdynamic
+tst-tls23-mod.so-no-z-defs = yes
+
+$(objpfx)tst-tls23-mod.so: $(libsupport)
+
+tests-special += $(objpfx)check-gnu2-tls.out
+
+$(objpfx)check-gnu2-tls.out: $(common-objpfx)libc.so
+	LC_ALL=C $(READELF) -V -W $< \
+		| sed -ne '/.gnu.version_d/, /.gnu.version_r/ p' \
+		| grep GLIBC_ABI_GNU2_TLS > $@; \
+	$(evaluate-test)
+generated += check-gnu2-tls.out
 endif
 
 ifeq ($(subdir),math)
diff --git a/sysdeps/x86/Versions b/sysdeps/x86/Versions
index 4b10c4b5d7..e8dcfccbe4 100644
--- a/sysdeps/x86/Versions
+++ b/sysdeps/x86/Versions
@@ -7,4 +7,9 @@ libc {
   GLIBC_2.33 {
     __x86_get_cpuid_feature_leaf;
   }
+  GLIBC_ABI_GNU2_TLS {
+    # This symbol is used only for empty version map and will be removed
+    # by scripts/versions.awk.
+    __placeholder_only_for_empty_version_map;
+  }
 }
diff --git a/sysdeps/x86/bits/wordsize.h b/sysdeps/x86/bits/wordsize.h
index 70f652bca1..3f40aa76f9 100644
--- a/sysdeps/x86/bits/wordsize.h
+++ b/sysdeps/x86/bits/wordsize.h
@@ -8,10 +8,9 @@
 #define __WORDSIZE32_PTRDIFF_LONG	0
 #endif
 
+#define __WORDSIZE_TIME64_COMPAT32 1
+
 #ifdef __x86_64__
-# define __WORDSIZE_TIME64_COMPAT32	1
 /* Both x86-64 and x32 use the 64-bit system call interface.  */
 # define __SYSCALL_WORDSIZE		64
-#else
-# define __WORDSIZE_TIME64_COMPAT32	0
 #endif
diff --git a/sysdeps/x86/cacheinfo.h b/sysdeps/x86/cacheinfo.h
index ab73556772..83491607c7 100644
--- a/sysdeps/x86/cacheinfo.h
+++ b/sysdeps/x86/cacheinfo.h
@@ -35,9 +35,12 @@ long int __x86_data_cache_size attribute_hidden = 32 * 1024;
 long int __x86_shared_cache_size_half attribute_hidden = 1024 * 1024 / 2;
 long int __x86_shared_cache_size attribute_hidden = 1024 * 1024;
 
-/* Threshold to use non temporal store.  */
+/* Threshold to use non temporal store in memmove.  */
 long int __x86_shared_non_temporal_threshold attribute_hidden;
 
+/* Threshold to use non temporal store in memset.  */
+long int __x86_memset_non_temporal_threshold attribute_hidden;
+
 /* Threshold to use Enhanced REP MOVSB.  */
 long int __x86_rep_movsb_threshold attribute_hidden = 2048;
 
@@ -77,6 +80,9 @@ init_cacheinfo (void)
   __x86_shared_non_temporal_threshold
     = cpu_features->non_temporal_threshold;
 
+  __x86_memset_non_temporal_threshold
+      = cpu_features->memset_non_temporal_threshold;
+
   __x86_rep_movsb_threshold = cpu_features->rep_movsb_threshold;
   __x86_rep_stosb_threshold = cpu_features->rep_stosb_threshold;
   __x86_rep_movsb_stop_threshold =  cpu_features->rep_movsb_stop_threshold;
diff --git a/sysdeps/x86/configure b/sysdeps/x86/configure
index 1f4c2d67fd..04c6ba3e6c 100644
--- a/sysdeps/x86/configure
+++ b/sysdeps/x86/configure
@@ -98,6 +98,7 @@ printf "%s\n" "$libc_cv_have_x86_lahf_sahf" >&6; }
   if test $libc_cv_have_x86_lahf_sahf = yes; then
     printf "%s\n" "#define HAVE_X86_LAHF_SAHF 1" >>confdefs.h
 
+    ISAFLAG="-DHAVE_X86_LAHF_SAHF"
   fi
   { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for MOVBE instruction support" >&5
 printf %s "checking for MOVBE instruction support... " >&6; }
@@ -120,8 +121,53 @@ printf "%s\n" "$libc_cv_have_x86_movbe" >&6; }
   if test $libc_cv_have_x86_movbe = yes; then
     printf "%s\n" "#define HAVE_X86_MOVBE 1" >>confdefs.h
 
+    ISAFLAG="$ISAFLAG -DHAVE_X86_MOVBE"
   fi
+
+  # Check for ISA level support.
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for ISA level support" >&5
+printf %s "checking for ISA level support... " >&6; }
+if test ${libc_cv_have_x86_isa_level+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  cat > conftest.c <<EOF
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL >= 4
+libc_cv_have_x86_isa_level=4
+#elif MINIMUM_X86_ISA_LEVEL == 3
+libc_cv_have_x86_isa_level=3
+#elif MINIMUM_X86_ISA_LEVEL == 2
+libc_cv_have_x86_isa_level=2
+#elif defined __x86_64__
+libc_cv_have_x86_isa_level=baseline
+#elif MINIMUM_X86_ISA_LEVEL == 1
+libc_cv_have_x86_isa_level=1
+#else
+libc_cv_have_x86_isa_level=0
+#endif
+EOF
+		 eval `${CC-cc} $CFLAGS $CPPFLAGS $ISAFLAG -I$srcdir -E conftest.c | grep libc_cv_have_x86_isa_level`
+		 rm -rf conftest*
 fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $libc_cv_have_x86_isa_level" >&5
+printf "%s\n" "$libc_cv_have_x86_isa_level" >&6; }
+elif test $base_machine = x86_64; then
+  libc_cv_have_x86_isa_level=baseline
+else
+  libc_cv_have_x86_isa_level=0
+fi
+if test $libc_cv_have_x86_isa_level = baseline; then
+  printf "%s\n" "#define MINIMUM_X86_ISA_LEVEL 1" >>confdefs.h
+
+else
+  printf "%s\n" "#define MINIMUM_X86_ISA_LEVEL $libc_cv_have_x86_isa_level" >>confdefs.h
+
+fi
+config_vars="$config_vars
+have-x86-isa-level = $libc_cv_have_x86_isa_level"
+config_vars="$config_vars
+x86-isa-level-3-or-above = 3 4"
 config_vars="$config_vars
 enable-x86-isa-level = $libc_cv_include_x86_isa_level"
 
diff --git a/sysdeps/x86/configure.ac b/sysdeps/x86/configure.ac
index 437a50623b..8a259d3971 100644
--- a/sysdeps/x86/configure.ac
+++ b/sysdeps/x86/configure.ac
@@ -72,6 +72,7 @@ if test $libc_cv_include_x86_isa_level = yes; then
     fi])
   if test $libc_cv_have_x86_lahf_sahf = yes; then
     AC_DEFINE(HAVE_X86_LAHF_SAHF)
+    ISAFLAG="-DHAVE_X86_LAHF_SAHF"
   fi
   AC_CACHE_CHECK([for MOVBE instruction support],
 		 libc_cv_have_x86_movbe, [dnl
@@ -81,8 +82,42 @@ if test $libc_cv_include_x86_isa_level = yes; then
     fi])
   if test $libc_cv_have_x86_movbe = yes; then
     AC_DEFINE(HAVE_X86_MOVBE)
+    ISAFLAG="$ISAFLAG -DHAVE_X86_MOVBE"
   fi
+
+  # Check for ISA level support.
+  AC_CACHE_CHECK([for ISA level support],
+		 libc_cv_have_x86_isa_level, [dnl
+cat > conftest.c <<EOF
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL >= 4
+libc_cv_have_x86_isa_level=4
+#elif MINIMUM_X86_ISA_LEVEL == 3
+libc_cv_have_x86_isa_level=3
+#elif MINIMUM_X86_ISA_LEVEL == 2
+libc_cv_have_x86_isa_level=2
+#elif defined __x86_64__
+libc_cv_have_x86_isa_level=baseline
+#elif MINIMUM_X86_ISA_LEVEL == 1
+libc_cv_have_x86_isa_level=1
+#else
+libc_cv_have_x86_isa_level=0
+#endif
+EOF
+		 eval `${CC-cc} $CFLAGS $CPPFLAGS $ISAFLAG -I$srcdir -E conftest.c | grep libc_cv_have_x86_isa_level`
+		 rm -rf conftest*])
+elif test $base_machine = x86_64; then
+  libc_cv_have_x86_isa_level=baseline
+else
+  libc_cv_have_x86_isa_level=0
+fi
+if test $libc_cv_have_x86_isa_level = baseline; then
+  AC_DEFINE_UNQUOTED(MINIMUM_X86_ISA_LEVEL, 1)
+else
+  AC_DEFINE_UNQUOTED(MINIMUM_X86_ISA_LEVEL, $libc_cv_have_x86_isa_level)
 fi
+LIBC_CONFIG_VAR([have-x86-isa-level], [$libc_cv_have_x86_isa_level])
+LIBC_CONFIG_VAR([x86-isa-level-3-or-above], [3 4])
 LIBC_CONFIG_VAR([enable-x86-isa-level], [$libc_cv_include_x86_isa_level])
 
 dnl Static PIE is supported.
diff --git a/sysdeps/x86/cpu-features-offsets.sym b/sysdeps/x86/cpu-features-offsets.sym
index 6a8fd29813..21fc88d651 100644
--- a/sysdeps/x86/cpu-features-offsets.sym
+++ b/sysdeps/x86/cpu-features-offsets.sym
@@ -3,3 +3,4 @@
 #include <ldsodefs.h>
 
 XSAVE_STATE_SIZE_OFFSET	offsetof (struct cpu_features, xsave_state_size)
+XSAVE_STATE_FULL_SIZE_OFFSET offsetof (struct cpu_features, xsave_state_full_size)
diff --git a/sysdeps/x86/cpu-features.c b/sysdeps/x86/cpu-features.c
index 25e6622a79..6e520b16fa 100644
--- a/sysdeps/x86/cpu-features.c
+++ b/sysdeps/x86/cpu-features.c
@@ -18,17 +18,24 @@
 
 #include <dl-hwcap.h>
 #include <libc-pointer-arith.h>
+#include <isa-level.h>
 #include <get-isa-level.h>
 #include <cacheinfo.h>
 #include <dl-cacheinfo.h>
 #include <dl-minsigstacksize.h>
 #include <dl-hwcap2.h>
+#include <gcc-macros.h>
 
 extern void TUNABLE_CALLBACK (set_hwcaps) (tunable_val_t *)
   attribute_hidden;
 
-#if defined SHARED && defined __x86_64__
-# include <dl-plt-rewrite.h>
+#if defined SHARED
+extern void _dl_tlsdesc_dynamic_fxsave (void) attribute_hidden;
+extern void _dl_tlsdesc_dynamic_xsave (void) attribute_hidden;
+extern void _dl_tlsdesc_dynamic_xsavec (void) attribute_hidden;
+
+# ifdef __x86_64__
+#  include <dl-plt-rewrite.h>
 
 static void
 TUNABLE_CALLBACK (set_plt_rewrite) (tunable_val_t *valp)
@@ -47,6 +54,15 @@ TUNABLE_CALLBACK (set_plt_rewrite) (tunable_val_t *valp)
 		 : plt_rewrite_jmp);
     }
 }
+# else
+extern void _dl_tlsdesc_dynamic_fnsave (void) attribute_hidden;
+# endif
+#endif
+
+#ifdef __x86_64__
+extern void _dl_runtime_resolve_fxsave (void) attribute_hidden;
+extern void _dl_runtime_resolve_xsave (void) attribute_hidden;
+extern void _dl_runtime_resolve_xsavec (void) attribute_hidden;
 #endif
 
 #ifdef __LP64__
@@ -68,6 +84,8 @@ extern void TUNABLE_CALLBACK (set_x86_shstk) (tunable_val_t *)
 # include <dl-cet.h>
 #endif
 
+unsigned long int _dl_x86_features_tlsdesc_state_size;
+
 static void
 update_active (struct cpu_features *cpu_features)
 {
@@ -293,19 +311,22 @@ update_active (struct cpu_features *cpu_features)
 	  __cpuid_count (0xd, 0, eax, ebx, ecx, edx);
 	  if (ebx != 0)
 	    {
+	      /* NB: On AMX capable processors, ebx always includes AMX
+		 states.  */
 	      unsigned int xsave_state_full_size
-		= ALIGN_UP (ebx + STATE_SAVE_OFFSET, 64);
+		= ALIGN_UP (ebx + TLSDESC_CALL_REGISTER_SAVE_AREA, 64);
 
 	      cpu_features->xsave_state_size
 		= xsave_state_full_size;
 	      cpu_features->xsave_state_full_size
 		= xsave_state_full_size;
+	      _dl_x86_features_tlsdesc_state_size = xsave_state_full_size;
 
 	      /* Check if XSAVEC is available.  */
 	      if (CPU_FEATURES_CPU_P (cpu_features, XSAVEC))
 		{
-		  unsigned int xstate_comp_offsets[32];
-		  unsigned int xstate_comp_sizes[32];
+		  unsigned int xstate_comp_offsets[X86_XSTATE_MAX_ID + 1];
+		  unsigned int xstate_comp_sizes[X86_XSTATE_MAX_ID + 1];
 		  unsigned int i;
 
 		  xstate_comp_offsets[0] = 0;
@@ -314,9 +335,9 @@ update_active (struct cpu_features *cpu_features)
 		  xstate_comp_sizes[0] = 160;
 		  xstate_comp_sizes[1] = 256;
 
-		  for (i = 2; i < 32; i++)
+		  for (i = 2; i <= X86_XSTATE_MAX_ID; i++)
 		    {
-		      if ((STATE_SAVE_MASK & (1 << i)) != 0)
+		      if ((FULL_STATE_SAVE_MASK & (1 << i)) != 0)
 			{
 			  __cpuid_count (0xd, i, eax, ebx, ecx, edx);
 			  xstate_comp_sizes[i] = eax;
@@ -331,7 +352,7 @@ update_active (struct cpu_features *cpu_features)
 			{
 			  xstate_comp_offsets[i]
 			    = (xstate_comp_offsets[i - 1]
-			       + xstate_comp_sizes[i -1]);
+			       + xstate_comp_sizes[i - 1]);
 			  if ((ecx & (1 << 1)) != 0)
 			    xstate_comp_offsets[i]
 			      = ALIGN_UP (xstate_comp_offsets[i], 64);
@@ -340,11 +361,23 @@ update_active (struct cpu_features *cpu_features)
 
 		  /* Use XSAVEC.  */
 		  unsigned int size
-		    = xstate_comp_offsets[31] + xstate_comp_sizes[31];
+		    = (xstate_comp_offsets[X86_XSTATE_MAX_ID]
+		       + xstate_comp_sizes[X86_XSTATE_MAX_ID]);
 		  if (size)
 		    {
-		      cpu_features->xsave_state_size
-			= ALIGN_UP (size + STATE_SAVE_OFFSET, 64);
+		      size = ALIGN_UP (size + TLSDESC_CALL_REGISTER_SAVE_AREA,
+				       64);
+#ifdef __x86_64__
+		      _dl_x86_features_tlsdesc_state_size = size;
+		      /* Exclude the AMX space from the start of TILECFG
+			 space to the end of TILEDATA space.  If CPU
+			 doesn't support AMX, TILECFG offset is the same
+			 as TILEDATA + 1 offset.  Otherwise, they are
+			 multiples of 64.  */
+		      size -= (xstate_comp_offsets[X86_XSTATE_TILEDATA_ID + 1]
+			       - xstate_comp_offsets[X86_XSTATE_TILECFG_ID]);
+#endif
+		      cpu_features->xsave_state_size = size;
 		      CPU_FEATURE_SET (cpu_features, XSAVEC);
 		    }
 		}
@@ -469,8 +502,8 @@ _Static_assert (((index_arch_Fast_Unaligned_Load
 		"Incorrect index_arch_Fast_Unaligned_Load");
 
 
-/* Intel Family-6 microarch list.  */
-enum
+/* Intel microarch list.  */
+enum intel_microarch
 {
   /* Atom processors.  */
   INTEL_ATOM_BONNELL,
@@ -479,6 +512,7 @@ enum
   INTEL_ATOM_GOLDMONT,
   INTEL_ATOM_GOLDMONT_PLUS,
   INTEL_ATOM_SIERRAFOREST,
+  INTEL_ATOM_CLEARWATERFOREST,
   INTEL_ATOM_GRANDRIDGE,
   INTEL_ATOM_TREMONT,
 
@@ -506,7 +540,11 @@ enum
   INTEL_BIGCORE_METEORLAKE,
   INTEL_BIGCORE_LUNARLAKE,
   INTEL_BIGCORE_ARROWLAKE,
+  INTEL_BIGCORE_PANTHERLAKE,
   INTEL_BIGCORE_GRANITERAPIDS,
+  INTEL_BIGCORE_DIAMONDRAPIDS,
+  INTEL_BIGCORE_WILDCATLAKE,
+  INTEL_BIGCORE_NOVALAKE,
 
   /* Mixed (bigcore + atom SOC).  */
   INTEL_MIXED_LAKEFIELD,
@@ -520,7 +558,7 @@ enum
   INTEL_UNKNOWN,
 };
 
-static unsigned int
+static enum intel_microarch
 intel_get_fam6_microarch (unsigned int model,
 			  __attribute__ ((unused)) unsigned int stepping)
 {
@@ -551,6 +589,8 @@ intel_get_fam6_microarch (unsigned int model,
       return INTEL_ATOM_GOLDMONT_PLUS;
     case 0xAF:
       return INTEL_ATOM_SIERRAFOREST;
+    case 0xDD:
+      return INTEL_ATOM_CLEARWATERFOREST;
     case 0xB6:
       return INTEL_ATOM_GRANDRIDGE;
     case 0x86:
@@ -658,8 +698,14 @@ intel_get_fam6_microarch (unsigned int model,
       return INTEL_BIGCORE_METEORLAKE;
     case 0xbd:
       return INTEL_BIGCORE_LUNARLAKE;
+    case 0xb5:
+    case 0xc5:
     case 0xc6:
       return INTEL_BIGCORE_ARROWLAKE;
+    case 0xCC:
+      return INTEL_BIGCORE_PANTHERLAKE;
+    case 0xD5:
+      return INTEL_BIGCORE_WILDCATLAKE;
     case 0xAD:
     case 0xAE:
       return INTEL_BIGCORE_GRANITERAPIDS;
@@ -687,6 +733,12 @@ init_cpu_features (struct cpu_features *cpu_features)
   unsigned int stepping = 0;
   enum cpu_features_kind kind;
 
+  /* Default is avoid non-temporal memset for non Intel/AMD hardware. This is,
+     as of writing this, we only have benchmarks indicatings it profitability
+     on Intel/AMD.  */
+  cpu_features->preferred[index_arch_Avoid_Non_Temporal_Memset]
+      |= bit_arch_Avoid_Non_Temporal_Memset;
+
   cpu_features->cachesize_non_temporal_divisor = 4;
 #if !HAS_CPUID
   if (__get_cpuid_max (0, 0) == 0)
@@ -712,125 +764,25 @@ init_cpu_features (struct cpu_features *cpu_features)
 
       update_active (cpu_features);
 
+      /* Benchmarks indicate non-temporal memset can be profitable on Intel
+	hardware.  */
+      cpu_features->preferred[index_arch_Avoid_Non_Temporal_Memset]
+	  &= ~bit_arch_Avoid_Non_Temporal_Memset;
+
+      enum intel_microarch microarch = INTEL_UNKNOWN;
       if (family == 0x06)
 	{
 	  model += extended_model;
-	  unsigned int microarch
-	      = intel_get_fam6_microarch (model, stepping);
+	  microarch = intel_get_fam6_microarch (model, stepping);
 
+	  /* Disable TSX on some processors to avoid TSX on kernels that
+	     weren't updated with the latest microcode package (which
+	     disables broken feature by default).  */
 	  switch (microarch)
 	    {
-	      /* Atom / KNL tuning.  */
-	    case INTEL_ATOM_BONNELL:
-	      /* BSF is slow on Bonnell.  */
-	      cpu_features->preferred[index_arch_Slow_BSF]
-		  |= bit_arch_Slow_BSF;
-	      break;
-
-	      /* Unaligned load versions are faster than SSSE3
-		     on Airmont, Silvermont, Goldmont, and Goldmont Plus.  */
-	    case INTEL_ATOM_AIRMONT:
-	    case INTEL_ATOM_SILVERMONT:
-	    case INTEL_ATOM_GOLDMONT:
-	    case INTEL_ATOM_GOLDMONT_PLUS:
-
-          /* Knights Landing.  Enable Silvermont optimizations.  */
-	    case INTEL_KNIGHTS_LANDING:
-
-	      cpu_features->preferred[index_arch_Fast_Unaligned_Load]
-		  |= (bit_arch_Fast_Unaligned_Load
-		      | bit_arch_Fast_Unaligned_Copy
-		      | bit_arch_Prefer_PMINUB_for_stringop
-		      | bit_arch_Slow_SSE4_2);
-	      break;
-
-	    case INTEL_ATOM_TREMONT:
-	      /* Enable rep string instructions, unaligned load, unaligned
-		 copy, pminub and avoid SSE 4.2 on Tremont.  */
-	      cpu_features->preferred[index_arch_Fast_Rep_String]
-		  |= (bit_arch_Fast_Rep_String
-		      | bit_arch_Fast_Unaligned_Load
-		      | bit_arch_Fast_Unaligned_Copy
-		      | bit_arch_Prefer_PMINUB_for_stringop
-		      | bit_arch_Slow_SSE4_2);
-	      break;
-
-	   /*
-	    Default tuned Knights microarch.
-	    case INTEL_KNIGHTS_MILL:
-        */
-
-	   /*
-	    Default tuned atom microarch.
-	    case INTEL_ATOM_SIERRAFOREST:
-	    case INTEL_ATOM_GRANDRIDGE:
-	   */
-
-	      /* Bigcore/Default Tuning.  */
 	    default:
-	    default_tuning:
-	      /* Unknown family 0x06 processors.  Assuming this is one
-		 of Core i3/i5/i7 processors if AVX is available.  */
-	      if (!CPU_FEATURES_CPU_P (cpu_features, AVX))
-		break;
-
-	    enable_modern_features:
-	      /* Rep string instructions, unaligned load, unaligned copy,
-		 and pminub are fast on Intel Core i3, i5 and i7.  */
-	      cpu_features->preferred[index_arch_Fast_Rep_String]
-		  |= (bit_arch_Fast_Rep_String
-		      | bit_arch_Fast_Unaligned_Load
-		      | bit_arch_Fast_Unaligned_Copy
-		      | bit_arch_Prefer_PMINUB_for_stringop);
 	      break;
 
-	    case INTEL_BIGCORE_NEHALEM:
-	    case INTEL_BIGCORE_WESTMERE:
-	      /* Older CPUs prefer non-temporal stores at lower threshold.  */
-	      cpu_features->cachesize_non_temporal_divisor = 8;
-	      goto enable_modern_features;
-
-	      /* Older Bigcore microarch (smaller non-temporal store
-		 threshold).  */
-	    case INTEL_BIGCORE_SANDYBRIDGE:
-	    case INTEL_BIGCORE_IVYBRIDGE:
-	    case INTEL_BIGCORE_HASWELL:
-	    case INTEL_BIGCORE_BROADWELL:
-	      cpu_features->cachesize_non_temporal_divisor = 8;
-	      goto default_tuning;
-
-	      /* Newer Bigcore microarch (larger non-temporal store
-		 threshold).  */
-	    case INTEL_BIGCORE_SKYLAKE:
-	    case INTEL_BIGCORE_KABYLAKE:
-	    case INTEL_BIGCORE_COMETLAKE:
-	    case INTEL_BIGCORE_SKYLAKE_AVX512:
-	    case INTEL_BIGCORE_CANNONLAKE:
-	    case INTEL_BIGCORE_ICELAKE:
-	    case INTEL_BIGCORE_TIGERLAKE:
-	    case INTEL_BIGCORE_ROCKETLAKE:
-	    case INTEL_BIGCORE_RAPTORLAKE:
-	    case INTEL_BIGCORE_METEORLAKE:
-	    case INTEL_BIGCORE_LUNARLAKE:
-	    case INTEL_BIGCORE_ARROWLAKE:
-	    case INTEL_BIGCORE_SAPPHIRERAPIDS:
-	    case INTEL_BIGCORE_EMERALDRAPIDS:
-	    case INTEL_BIGCORE_GRANITERAPIDS:
-	      cpu_features->cachesize_non_temporal_divisor = 2;
-	      goto default_tuning;
-
-	      /* Default tuned Mixed (bigcore + atom SOC). */
-	    case INTEL_MIXED_LAKEFIELD:
-	    case INTEL_MIXED_ALDERLAKE:
-	      cpu_features->cachesize_non_temporal_divisor = 2;
-	      goto default_tuning;
-	    }
-
-	      /* Disable TSX on some processors to avoid TSX on kernels that
-		 weren't updated with the latest microcode package (which
-		 disables broken feature by default).  */
-	  switch (microarch)
-	    {
 	    case INTEL_BIGCORE_SKYLAKE_AVX512:
 	      /* 0x55 (Skylake-avx512) && stepping <= 5 disable TSX. */
 	      if (stepping <= 5)
@@ -839,38 +791,176 @@ init_cpu_features (struct cpu_features *cpu_features)
 
 	    case INTEL_BIGCORE_KABYLAKE:
 	      /* NB: Although the errata documents that for model == 0x8e
-		     (kabylake skylake client), only 0xb stepping or lower are
-		     impacted, the intention of the errata was to disable TSX on
-		     all client processors on all steppings.  Include 0xc
-		     stepping which is an Intel Core i7-8665U, a client mobile
-		     processor.  */
+		 (kabylake skylake client), only 0xb stepping or lower are
+		 impacted, the intention of the errata was to disable TSX on
+		 all client processors on all steppings.  Include 0xc
+		 stepping which is an Intel Core i7-8665U, a client mobile
+		 processor.  */
 	      if (stepping > 0xc)
 		break;
 	      /* Fall through.  */
 	    case INTEL_BIGCORE_SKYLAKE:
-		/* Disable Intel TSX and enable RTM_ALWAYS_ABORT for
-		   processors listed in:
-
-https://www.intel.com/content/www/us/en/support/articles/000059422/processors.html
-		 */
-	    disable_tsx:
-		CPU_FEATURE_UNSET (cpu_features, HLE);
-		CPU_FEATURE_UNSET (cpu_features, RTM);
-		CPU_FEATURE_SET (cpu_features, RTM_ALWAYS_ABORT);
-		break;
+	      /* Disable Intel TSX and enable RTM_ALWAYS_ABORT for
+		 processors listed in:
+
+		 https://www.intel.com/content/www/us/en/support/articles/000059422/processors.html
+	       */
+disable_tsx:
+	      CPU_FEATURE_UNSET (cpu_features, HLE);
+	      CPU_FEATURE_UNSET (cpu_features, RTM);
+	      CPU_FEATURE_SET (cpu_features, RTM_ALWAYS_ABORT);
+	      break;
 
 	    case INTEL_BIGCORE_HASWELL:
-		/* Xeon E7 v3 (model == 0x3f) with stepping >= 4 has working
-		   TSX.  Haswell also include other model numbers that have
-		   working TSX.  */
-		if (model == 0x3f && stepping >= 4)
+	      /* Xeon E7 v3 (model == 0x3f) with stepping >= 4 has working
+		 TSX.  Haswell also includes other model numbers that have
+		 working TSX.  */
+	      if (model == 0x3f && stepping >= 4)
 		break;
 
-		CPU_FEATURE_UNSET (cpu_features, RTM);
-		break;
+	      CPU_FEATURE_UNSET (cpu_features, RTM);
+	      break;
 	    }
 	}
+      else if (family == 18)
+	switch (model)
+	  {
+	  case 0x01:
+	  case 0x03:
+	    microarch = INTEL_BIGCORE_NOVALAKE;
+	    break;
 
+	  default:
+	    break;
+	  }
+      else if (family == 19)
+	switch (model)
+	  {
+	  case 0x01:
+	    microarch = INTEL_BIGCORE_DIAMONDRAPIDS;
+	    break;
+
+	  default:
+	    break;
+	  }
+
+      switch (microarch)
+	{
+	  /* Atom / KNL tuning.  */
+	case INTEL_ATOM_BONNELL:
+	  /* BSF is slow on Bonnell.  */
+	  cpu_features->preferred[index_arch_Slow_BSF]
+	    |= bit_arch_Slow_BSF;
+	  break;
+
+	  /* Unaligned load versions are faster than SSSE3
+	     on Airmont, Silvermont, Goldmont, and Goldmont Plus.  */
+	case INTEL_ATOM_AIRMONT:
+	case INTEL_ATOM_SILVERMONT:
+	case INTEL_ATOM_GOLDMONT:
+	case INTEL_ATOM_GOLDMONT_PLUS:
+
+	  /* Knights Landing.  Enable Silvermont optimizations.  */
+	case INTEL_KNIGHTS_LANDING:
+
+	  cpu_features->preferred[index_arch_Fast_Unaligned_Load]
+	    |= (bit_arch_Fast_Unaligned_Load
+		| bit_arch_Fast_Unaligned_Copy
+		| bit_arch_Prefer_PMINUB_for_stringop
+		| bit_arch_Slow_SSE4_2);
+	  break;
+
+	case INTEL_ATOM_TREMONT:
+	  /* Enable rep string instructions, unaligned load, unaligned
+	     copy, pminub and avoid SSE 4.2 on Tremont.  */
+	  cpu_features->preferred[index_arch_Fast_Rep_String]
+	    |= (bit_arch_Fast_Rep_String
+		| bit_arch_Fast_Unaligned_Load
+		| bit_arch_Fast_Unaligned_Copy
+		| bit_arch_Prefer_PMINUB_for_stringop
+		| bit_arch_Slow_SSE4_2);
+	  break;
+
+	  /*
+	     Default tuned Knights microarch.
+	     case INTEL_KNIGHTS_MILL:
+	     */
+
+	  /*
+	     Default tuned atom microarch.
+	     case INTEL_ATOM_SIERRAFOREST:
+	     case INTEL_ATOM_GRANDRIDGE:
+	     case INTEL_ATOM_CLEARWATERFOREST:
+	     */
+
+	  /* Bigcore/Default Tuning.  */
+	default:
+	default_tuning:
+	  /* Unknown Intel processors.  Assuming this is one of Core
+	     i3/i5/i7 processors if AVX is available.  */
+	  if (!CPU_FEATURES_CPU_P (cpu_features, AVX))
+	    break;
+
+	enable_modern_features:
+	  /* Rep string instructions, unaligned load, unaligned copy,
+	     and pminub are fast on Intel Core i3, i5 and i7.  */
+	  cpu_features->preferred[index_arch_Fast_Rep_String]
+	    |= (bit_arch_Fast_Rep_String
+		| bit_arch_Fast_Unaligned_Load
+		| bit_arch_Fast_Unaligned_Copy
+		| bit_arch_Prefer_PMINUB_for_stringop);
+	  break;
+
+	case INTEL_BIGCORE_NEHALEM:
+	case INTEL_BIGCORE_WESTMERE:
+	  /* Older CPUs prefer non-temporal stores at lower threshold.  */
+	  cpu_features->cachesize_non_temporal_divisor = 8;
+	  goto enable_modern_features;
+
+	  /* Older Bigcore microarch (smaller non-temporal store
+	     threshold).  */
+	case INTEL_BIGCORE_SANDYBRIDGE:
+	case INTEL_BIGCORE_IVYBRIDGE:
+	case INTEL_BIGCORE_HASWELL:
+	case INTEL_BIGCORE_BROADWELL:
+	  cpu_features->cachesize_non_temporal_divisor = 8;
+	  goto default_tuning;
+
+	  /* Newer Bigcore microarch (larger non-temporal store
+	     threshold).  */
+	case INTEL_BIGCORE_SKYLAKE_AVX512:
+	case INTEL_BIGCORE_CANNONLAKE:
+	  /* Benchmarks indicate non-temporal memset is not
+	     necessarily profitable on SKX (and in some cases much
+	     worse). This is likely unique to SKX due to its unique
+	     mesh interconnect (not present on ICX or BWD). Disable
+	     non-temporal on all Skylake servers. */
+	  cpu_features->preferred[index_arch_Avoid_Non_Temporal_Memset]
+	    |= bit_arch_Avoid_Non_Temporal_Memset;
+	  /* fallthrough */
+	case INTEL_BIGCORE_COMETLAKE:
+	case INTEL_BIGCORE_SKYLAKE:
+	case INTEL_BIGCORE_KABYLAKE:
+	case INTEL_BIGCORE_ICELAKE:
+	case INTEL_BIGCORE_TIGERLAKE:
+	case INTEL_BIGCORE_ROCKETLAKE:
+	case INTEL_BIGCORE_RAPTORLAKE:
+	case INTEL_BIGCORE_METEORLAKE:
+	case INTEL_BIGCORE_LUNARLAKE:
+	case INTEL_BIGCORE_ARROWLAKE:
+	case INTEL_BIGCORE_PANTHERLAKE:
+	case INTEL_BIGCORE_WILDCATLAKE:
+	case INTEL_BIGCORE_NOVALAKE:
+	case INTEL_BIGCORE_SAPPHIRERAPIDS:
+	case INTEL_BIGCORE_EMERALDRAPIDS:
+	case INTEL_BIGCORE_GRANITERAPIDS:
+	case INTEL_BIGCORE_DIAMONDRAPIDS:
+	  /* Default tuned Mixed (bigcore + atom SOC). */
+	case INTEL_MIXED_LAKEFIELD:
+	case INTEL_MIXED_ALDERLAKE:
+	  cpu_features->cachesize_non_temporal_divisor = 2;
+	  goto default_tuning;
+	}
 
       /* Since AVX512ER is unique to Xeon Phi, set Prefer_No_VZEROUPPER
          if AVX512ER is available.  Don't use AVX512 to avoid lower CPU
@@ -915,6 +1005,11 @@ https://www.intel.com/content/www/us/en/support/articles/000059422/processors.ht
 
       ecx = cpu_features->features[CPUID_INDEX_1].cpuid.ecx;
 
+      /* Benchmarks indicate non-temporal memset can be profitable on AMD
+	hardware.  */
+      cpu_features->preferred[index_arch_Avoid_Non_Temporal_Memset]
+	  &= ~bit_arch_Avoid_Non_Temporal_Memset;
+
       if (CPU_FEATURE_USABLE_P (cpu_features, AVX))
 	{
 	  /* Since the FMA4 bit is in CPUID_INDEX_80000001 and
@@ -1023,6 +1118,9 @@ no_cpuid:
 	       TUNABLE_CALLBACK (set_prefer_map_32bit_exec));
 #endif
 
+  /* Do not add the logic to disable XSAVE/XSAVEC if this glibc build
+     requires AVX and therefore XSAVE or XSAVEC support.  */
+#ifndef GCCMACRO__AVX__
   bool disable_xsave_features = false;
 
   if (!CPU_FEATURE_USABLE_P (cpu_features, OSXSAVE))
@@ -1076,6 +1174,7 @@ no_cpuid:
 
       CPU_FEATURE_UNSET (cpu_features, FMA4);
     }
+#endif
 
 #ifdef __x86_64__
   GLRO(dl_hwcap) = HWCAP_X86_64;
@@ -1130,6 +1229,45 @@ no_cpuid:
 	       TUNABLE_CALLBACK (set_x86_shstk));
 #endif
 
+  if (MINIMUM_X86_ISA_LEVEL >= AVX_X86_ISA_LEVEL
+      || (GLRO(dl_x86_cpu_features).xsave_state_size != 0))
+    {
+      if (CPU_FEATURE_USABLE_P (cpu_features, XSAVEC))
+	{
+#ifdef __x86_64__
+	  GLRO(dl_x86_64_runtime_resolve) = _dl_runtime_resolve_xsavec;
+#endif
+#ifdef SHARED
+	  GLRO(dl_x86_tlsdesc_dynamic) = _dl_tlsdesc_dynamic_xsavec;
+#endif
+	}
+      else
+	{
+#ifdef __x86_64__
+	  GLRO(dl_x86_64_runtime_resolve) = _dl_runtime_resolve_xsave;
+#endif
+#ifdef SHARED
+	  GLRO(dl_x86_tlsdesc_dynamic) = _dl_tlsdesc_dynamic_xsave;
+#endif
+	}
+    }
+  else
+    {
+#ifdef __x86_64__
+      GLRO(dl_x86_64_runtime_resolve) = _dl_runtime_resolve_fxsave;
+# ifdef SHARED
+      GLRO(dl_x86_tlsdesc_dynamic) = _dl_tlsdesc_dynamic_fxsave;
+# endif
+#else
+# ifdef SHARED
+      if (CPU_FEATURE_USABLE_P (cpu_features, FXSR))
+	GLRO(dl_x86_tlsdesc_dynamic) = _dl_tlsdesc_dynamic_fxsave;
+      else
+	GLRO(dl_x86_tlsdesc_dynamic) = _dl_tlsdesc_dynamic_fnsave;
+# endif
+#endif
+    }
+
 #ifdef SHARED
 # ifdef __x86_64__
   TUNABLE_GET (plt_rewrite, tunable_val_t *,
diff --git a/sysdeps/x86/cpu-tunables.c b/sysdeps/x86/cpu-tunables.c
index 89da7a03da..a0b31d80f6 100644
--- a/sysdeps/x86/cpu-tunables.c
+++ b/sysdeps/x86/cpu-tunables.c
@@ -164,6 +164,8 @@ TUNABLE_CALLBACK (set_hwcaps) (tunable_val_t *valp)
 		  /* Update xsave_state_size to XSAVE state size.  */
 		  cpu_features->xsave_state_size
 		    = cpu_features->xsave_state_full_size;
+		  _dl_x86_features_tlsdesc_state_size
+		    = cpu_features->xsave_state_full_size;
 		  CPU_FEATURE_UNSET (cpu_features, XSAVEC);
 		}
 	    }
@@ -243,6 +245,12 @@ TUNABLE_CALLBACK (set_hwcaps) (tunable_val_t *valp)
 		(n, cpu_features, MathVec_Prefer_No_AVX512, AVX512F, 24);
 	    }
 	  break;
+	case 25:
+	  {
+	    CHECK_GLIBC_IFUNC_PREFERRED_BOTH (n, cpu_features,
+					      Avoid_Non_Temporal_Memset, 25);
+	  }
+	  break;
 	case 26:
 	    {
 	      CHECK_GLIBC_IFUNC_PREFERRED_NEED_BOTH
diff --git a/sysdeps/x86/dl-cacheinfo.h b/sysdeps/x86/dl-cacheinfo.h
index d5101615e3..10ad18061a 100644
--- a/sysdeps/x86/dl-cacheinfo.h
+++ b/sysdeps/x86/dl-cacheinfo.h
@@ -791,7 +791,6 @@ dl_init_cacheinfo (struct cpu_features *cpu_features)
   long int data = -1;
   long int shared = -1;
   long int shared_per_thread = -1;
-  long int core = -1;
   unsigned int threads = 0;
   unsigned long int level1_icache_size = -1;
   unsigned long int level1_icache_linesize = -1;
@@ -809,7 +808,6 @@ dl_init_cacheinfo (struct cpu_features *cpu_features)
   if (cpu_features->basic.kind == arch_kind_intel)
     {
       data = handle_intel (_SC_LEVEL1_DCACHE_SIZE, cpu_features);
-      core = handle_intel (_SC_LEVEL2_CACHE_SIZE, cpu_features);
       shared = handle_intel (_SC_LEVEL3_CACHE_SIZE, cpu_features);
       shared_per_thread = shared;
 
@@ -822,7 +820,8 @@ dl_init_cacheinfo (struct cpu_features *cpu_features)
 	= handle_intel (_SC_LEVEL1_DCACHE_ASSOC, cpu_features);
       level1_dcache_linesize
 	= handle_intel (_SC_LEVEL1_DCACHE_LINESIZE, cpu_features);
-      level2_cache_size = core;
+      level2_cache_size
+	= handle_intel (_SC_LEVEL2_CACHE_SIZE, cpu_features);
       level2_cache_assoc
 	= handle_intel (_SC_LEVEL2_CACHE_ASSOC, cpu_features);
       level2_cache_linesize
@@ -835,12 +834,12 @@ dl_init_cacheinfo (struct cpu_features *cpu_features)
       level4_cache_size
 	= handle_intel (_SC_LEVEL4_CACHE_SIZE, cpu_features);
 
-      get_common_cache_info (&shared, &shared_per_thread, &threads, core);
+      get_common_cache_info (&shared, &shared_per_thread, &threads,
+			     level2_cache_size);
     }
   else if (cpu_features->basic.kind == arch_kind_zhaoxin)
     {
       data = handle_zhaoxin (_SC_LEVEL1_DCACHE_SIZE);
-      core = handle_zhaoxin (_SC_LEVEL2_CACHE_SIZE);
       shared = handle_zhaoxin (_SC_LEVEL3_CACHE_SIZE);
       shared_per_thread = shared;
 
@@ -849,19 +848,19 @@ dl_init_cacheinfo (struct cpu_features *cpu_features)
       level1_dcache_size = data;
       level1_dcache_assoc = handle_zhaoxin (_SC_LEVEL1_DCACHE_ASSOC);
       level1_dcache_linesize = handle_zhaoxin (_SC_LEVEL1_DCACHE_LINESIZE);
-      level2_cache_size = core;
+      level2_cache_size = handle_zhaoxin (_SC_LEVEL2_CACHE_SIZE);
       level2_cache_assoc = handle_zhaoxin (_SC_LEVEL2_CACHE_ASSOC);
       level2_cache_linesize = handle_zhaoxin (_SC_LEVEL2_CACHE_LINESIZE);
       level3_cache_size = shared;
       level3_cache_assoc = handle_zhaoxin (_SC_LEVEL3_CACHE_ASSOC);
       level3_cache_linesize = handle_zhaoxin (_SC_LEVEL3_CACHE_LINESIZE);
 
-      get_common_cache_info (&shared, &shared_per_thread, &threads, core);
+      get_common_cache_info (&shared, &shared_per_thread, &threads,
+			     level2_cache_size);
     }
   else if (cpu_features->basic.kind == arch_kind_amd)
     {
       data = handle_amd (_SC_LEVEL1_DCACHE_SIZE);
-      core = handle_amd (_SC_LEVEL2_CACHE_SIZE);
       shared = handle_amd (_SC_LEVEL3_CACHE_SIZE);
 
       level1_icache_size = handle_amd (_SC_LEVEL1_ICACHE_SIZE);
@@ -869,7 +868,7 @@ dl_init_cacheinfo (struct cpu_features *cpu_features)
       level1_dcache_size = data;
       level1_dcache_assoc = handle_amd (_SC_LEVEL1_DCACHE_ASSOC);
       level1_dcache_linesize = handle_amd (_SC_LEVEL1_DCACHE_LINESIZE);
-      level2_cache_size = core;
+      level2_cache_size = handle_amd (_SC_LEVEL2_CACHE_SIZE);;
       level2_cache_assoc = handle_amd (_SC_LEVEL2_CACHE_ASSOC);
       level2_cache_linesize = handle_amd (_SC_LEVEL2_CACHE_LINESIZE);
       level3_cache_size = shared;
@@ -880,12 +879,12 @@ dl_init_cacheinfo (struct cpu_features *cpu_features)
       if (shared <= 0)
         {
            /* No shared L3 cache.  All we have is the L2 cache.  */
-           shared = core;
+           shared = level2_cache_size;
         }
       else if (cpu_features->basic.family < 0x17)
         {
            /* Account for exclusive L2 and L3 caches.  */
-           shared += core;
+           shared += level2_cache_size;
         }
 
       shared_per_thread = shared;
@@ -960,11 +959,11 @@ dl_init_cacheinfo (struct cpu_features *cpu_features)
     non_temporal_threshold = maximum_non_temporal_threshold;
 
   /* NB: The REP MOVSB threshold must be greater than VEC_SIZE * 8.  */
-  unsigned int minimum_rep_movsb_threshold;
+  unsigned long int minimum_rep_movsb_threshold;
   /* NB: The default REP MOVSB threshold is 4096 * (VEC_SIZE / 16) for
      VEC_SIZE == 64 or 32.  For VEC_SIZE == 16, the default REP MOVSB
      threshold is 2048 * (VEC_SIZE / 16).  */
-  unsigned int rep_movsb_threshold;
+  unsigned long int rep_movsb_threshold;
   if (CPU_FEATURE_USABLE_P (cpu_features, AVX512F)
       && !CPU_FEATURE_PREFERRED_P (cpu_features, Prefer_No_AVX512))
     {
@@ -987,6 +986,12 @@ dl_init_cacheinfo (struct cpu_features *cpu_features)
   if (CPU_FEATURE_USABLE_P (cpu_features, FSRM))
     rep_movsb_threshold = 2112;
 
+  /* For AMD CPUs that support ERMS (Zen3+), REP MOVSB is in a lot of
+     cases slower than the vectorized path (and for some alignments,
+     it is really slow, check BZ #30994).  */
+  if (cpu_features->basic.kind == arch_kind_amd)
+    rep_movsb_threshold = non_temporal_threshold;
+
   /* The default threshold to use Enhanced REP STOSB.  */
   unsigned long int rep_stosb_threshold = 2048;
 
@@ -1002,11 +1007,23 @@ dl_init_cacheinfo (struct cpu_features *cpu_features)
   if (tunable_size != 0)
     shared = tunable_size;
 
+  /* Non-temporal stores are more performant on some hardware above
+     non_temporal_threshold. Currently Prefer_Non_Temporal is set for for both
+     Intel and AMD hardware. */
+  unsigned long int memset_non_temporal_threshold = SIZE_MAX;
+  if (!CPU_FEATURES_ARCH_P (cpu_features, Avoid_Non_Temporal_Memset))
+    memset_non_temporal_threshold = non_temporal_threshold;
+
   tunable_size = TUNABLE_GET (x86_non_temporal_threshold, long int, NULL);
   if (tunable_size > minimum_non_temporal_threshold
       && tunable_size <= maximum_non_temporal_threshold)
     non_temporal_threshold = tunable_size;
 
+  tunable_size = TUNABLE_GET (x86_memset_non_temporal_threshold, long int, NULL);
+  if (tunable_size > minimum_non_temporal_threshold
+      && tunable_size <= maximum_non_temporal_threshold)
+    memset_non_temporal_threshold = tunable_size;
+
   tunable_size = TUNABLE_GET (x86_rep_movsb_threshold, long int, NULL);
   if (tunable_size > minimum_rep_movsb_threshold)
     rep_movsb_threshold = tunable_size;
@@ -1016,32 +1033,34 @@ dl_init_cacheinfo (struct cpu_features *cpu_features)
      minimum value is fixed.  */
   rep_stosb_threshold = TUNABLE_GET (x86_rep_stosb_threshold,
 				     long int, NULL);
+  if (cpu_features->basic.kind == arch_kind_amd
+      && !TUNABLE_IS_INITIALIZED (x86_rep_stosb_threshold))
+    /* For AMD Zen3+ architecture, the performance of the vectorized loop is
+       slightly better than ERMS.  */
+    rep_stosb_threshold = SIZE_MAX;
 
   TUNABLE_SET_WITH_BOUNDS (x86_data_cache_size, data, 0, SIZE_MAX);
   TUNABLE_SET_WITH_BOUNDS (x86_shared_cache_size, shared, 0, SIZE_MAX);
   TUNABLE_SET_WITH_BOUNDS (x86_non_temporal_threshold, non_temporal_threshold,
 			   minimum_non_temporal_threshold,
 			   maximum_non_temporal_threshold);
+  TUNABLE_SET_WITH_BOUNDS (x86_memset_non_temporal_threshold,
+			   memset_non_temporal_threshold,
+			   minimum_non_temporal_threshold, SIZE_MAX);
   TUNABLE_SET_WITH_BOUNDS (x86_rep_movsb_threshold, rep_movsb_threshold,
 			   minimum_rep_movsb_threshold, SIZE_MAX);
   TUNABLE_SET_WITH_BOUNDS (x86_rep_stosb_threshold, rep_stosb_threshold, 1,
 			   SIZE_MAX);
 
   unsigned long int rep_movsb_stop_threshold;
-  /* ERMS feature is implemented from AMD Zen3 architecture and it is
-     performing poorly for data above L2 cache size. Henceforth, adding
-     an upper bound threshold parameter to limit the usage of Enhanced
-     REP MOVSB operations and setting its value to L2 cache size.  */
-  if (cpu_features->basic.kind == arch_kind_amd)
-    rep_movsb_stop_threshold = core;
   /* Setting the upper bound of ERMS to the computed value of
-     non-temporal threshold for architectures other than AMD.  */
-  else
-    rep_movsb_stop_threshold = non_temporal_threshold;
+     non-temporal threshold for all architectures.  */
+  rep_movsb_stop_threshold = non_temporal_threshold;
 
   cpu_features->data_cache_size = data;
   cpu_features->shared_cache_size = shared;
   cpu_features->non_temporal_threshold = non_temporal_threshold;
+  cpu_features->memset_non_temporal_threshold = memset_non_temporal_threshold;
   cpu_features->rep_movsb_threshold = rep_movsb_threshold;
   cpu_features->rep_stosb_threshold = rep_stosb_threshold;
   cpu_features->rep_movsb_stop_threshold = rep_movsb_stop_threshold;
diff --git a/sysdeps/x86/dl-diagnostics-cpu.c b/sysdeps/x86/dl-diagnostics-cpu.c
index c76ea3be16..8113a93883 100644
--- a/sysdeps/x86/dl-diagnostics-cpu.c
+++ b/sysdeps/x86/dl-diagnostics-cpu.c
@@ -78,11 +78,15 @@ _dl_diagnostics_cpu (void)
                             cpu_features->xsave_state_size);
   print_cpu_features_value ("xsave_state_full_size",
                             cpu_features->xsave_state_full_size);
+  print_cpu_features_value ("tlsdesc_state_full_size",
+                            _dl_x86_features_tlsdesc_state_size);
   print_cpu_features_value ("data_cache_size", cpu_features->data_cache_size);
   print_cpu_features_value ("shared_cache_size",
                             cpu_features->shared_cache_size);
   print_cpu_features_value ("non_temporal_threshold",
                             cpu_features->non_temporal_threshold);
+  print_cpu_features_value ("memset_non_temporal_threshold",
+                            cpu_features->memset_non_temporal_threshold);
   print_cpu_features_value ("rep_movsb_threshold",
                             cpu_features->rep_movsb_threshold);
   print_cpu_features_value ("rep_movsb_stop_threshold",
diff --git a/sysdeps/x86/dl-procinfo.c b/sysdeps/x86/dl-procinfo.c
index ee957b4d70..5920d4b320 100644
--- a/sysdeps/x86/dl-procinfo.c
+++ b/sysdeps/x86/dl-procinfo.c
@@ -86,3 +86,19 @@ PROCINFO_CLASS const char _dl_x86_platforms[4][9]
 #else
 ,
 #endif
+
+#if defined SHARED && !IS_IN (ldconfig)
+# if !defined PROCINFO_DECL
+  ._dl_x86_tlsdesc_dynamic
+# else
+PROCINFO_CLASS void * _dl_x86_tlsdesc_dynamic
+# endif
+# ifndef PROCINFO_DECL
+= NULL
+# endif
+# ifdef PROCINFO_DECL
+;
+# else
+,
+# endif
+#endif
diff --git a/sysdeps/x86/dl-tunables.list b/sysdeps/x86/dl-tunables.list
index 7d82da0dec..a0a1299592 100644
--- a/sysdeps/x86/dl-tunables.list
+++ b/sysdeps/x86/dl-tunables.list
@@ -30,6 +30,9 @@ glibc {
     x86_non_temporal_threshold {
       type: SIZE_T
     }
+    x86_memset_non_temporal_threshold {
+      type: SIZE_T
+    }
     x86_rep_movsb_threshold {
       type: SIZE_T
       # Since there is overhead to set up REP MOVSB operation, REP
diff --git a/sysdeps/x86_64/features-offsets.sym b/sysdeps/x86/features-offsets.sym
similarity index 89%
rename from sysdeps/x86_64/features-offsets.sym
rename to sysdeps/x86/features-offsets.sym
index 9e4be3393a..77e990c705 100644
--- a/sysdeps/x86_64/features-offsets.sym
+++ b/sysdeps/x86/features-offsets.sym
@@ -3,4 +3,6 @@
 #include <ldsodefs.h>
 
 RTLD_GLOBAL_RO_DL_X86_CPU_FEATURES_OFFSET offsetof (struct rtld_global_ro, _dl_x86_cpu_features)
+#ifdef __x86_64__
 RTLD_GLOBAL_DL_X86_FEATURE_1_OFFSET offsetof (struct rtld_global, _dl_x86_feature_1)
+#endif
diff --git a/sysdeps/x86/include/cpu-features-preferred_feature_index_1.def b/sysdeps/x86/include/cpu-features-preferred_feature_index_1.def
index 85e7f54ec8..61bbbc2e89 100644
--- a/sysdeps/x86/include/cpu-features-preferred_feature_index_1.def
+++ b/sysdeps/x86/include/cpu-features-preferred_feature_index_1.def
@@ -33,3 +33,4 @@ BIT (Prefer_No_AVX512)
 BIT (MathVec_Prefer_No_AVX512)
 BIT (Prefer_FSRM)
 BIT (Avoid_Short_Distance_REP_MOVSB)
+BIT (Avoid_Non_Temporal_Memset)
diff --git a/sysdeps/x86/include/cpu-features.h b/sysdeps/x86/include/cpu-features.h
index b9bf3115b6..03c71387dd 100644
--- a/sysdeps/x86/include/cpu-features.h
+++ b/sysdeps/x86/include/cpu-features.h
@@ -942,8 +942,10 @@ struct cpu_features
   /* Shared cache size for use in memory and string routines, typically
      L2 or L3 size.  */
   unsigned long int shared_cache_size;
-  /* Threshold to use non temporal store.  */
+  /* Threshold to use non temporal store in memmove.  */
   unsigned long int non_temporal_threshold;
+  /* Threshold to use non temporal store in memset.  */
+  unsigned long int memset_non_temporal_threshold;
   /* Threshold to use "rep movsb".  */
   unsigned long int rep_movsb_threshold;
   /* Threshold to stop using "rep movsb".  */
@@ -985,6 +987,13 @@ extern const struct cpu_features *_dl_x86_get_cpu_features (void)
 
 #define __get_cpu_features() _dl_x86_get_cpu_features()
 
+#if IS_IN (rtld) || IS_IN (libc)
+/* XSAVE/XSAVEC state size used by TLS descriptors.  Compared to
+   xsave_state_size from struct cpu_features, this includes additional
+   registers.  */
+extern unsigned long int _dl_x86_features_tlsdesc_state_size attribute_hidden;
+#endif
+
 #if defined (_LIBC) && !IS_IN (nonlib)
 /* Unused for x86.  */
 # define INIT_ARCH()
diff --git a/sysdeps/x86/isa-level.h b/sysdeps/x86/isa-level.h
index 11fe1ca90c..03c1fe2bf5 100644
--- a/sysdeps/x86/isa-level.h
+++ b/sysdeps/x86/isa-level.h
@@ -35,7 +35,17 @@
 # define __X86_ISA_V1 0
 #endif
 
-#if __X86_ISA_V1 && defined __GCC_HAVE_SYNC_COMPARE_AND_SWAP_16               \
+#ifdef __x86_64__
+# ifdef __GCC_HAVE_SYNC_COMPARE_AND_SWAP_16
+#  define __GCC_HAVE_SYNC_COMPARE_AND_SWAP
+# endif
+#else
+# ifdef __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8
+#  define __GCC_HAVE_SYNC_COMPARE_AND_SWAP
+# endif
+#endif
+
+#if __X86_ISA_V1 && defined __GCC_HAVE_SYNC_COMPARE_AND_SWAP		      \
     && defined HAVE_X86_LAHF_SAHF && defined __POPCNT__ && defined __SSE3__   \
     && defined __SSSE3__ && defined __SSE4_1__ && defined __SSE4_2__
 /* NB: ISAs in x86-64 ISA level v2 are used.  */
@@ -61,8 +71,10 @@
 # define __X86_ISA_V4 0
 #endif
 
-#define MINIMUM_X86_ISA_LEVEL                                                 \
+#ifndef MINIMUM_X86_ISA_LEVEL
+# define MINIMUM_X86_ISA_LEVEL                                                 \
   (__X86_ISA_V1 + __X86_ISA_V2 + __X86_ISA_V3 + __X86_ISA_V4)
+#endif
 
 /* Depending on the minimum ISA level, a feature check result can be a
    compile-time constant.. */
diff --git a/sysdeps/x86/sysdep.h b/sysdeps/x86/sysdep.h
index 85d0a8c943..d5f5ec0ecc 100644
--- a/sysdeps/x86/sysdep.h
+++ b/sysdeps/x86/sysdep.h
@@ -21,14 +21,124 @@
 
 #include <sysdeps/generic/sysdep.h>
 
+/* The extended state feature IDs in the state component bitmap.  */
+#define X86_XSTATE_X87_ID	0
+#define X86_XSTATE_SSE_ID	1
+#define X86_XSTATE_AVX_ID	2
+#define X86_XSTATE_BNDREGS_ID	3
+#define X86_XSTATE_BNDCFG_ID	4
+#define X86_XSTATE_K_ID		5
+#define X86_XSTATE_ZMM_H_ID	6
+#define X86_XSTATE_ZMM_ID	7
+#define X86_XSTATE_PKRU_ID	9
+#define X86_XSTATE_TILECFG_ID	17
+#define X86_XSTATE_TILEDATA_ID	18
+#define X86_XSTATE_APX_F_ID	19
+
+#ifdef __x86_64__
 /* Offset for fxsave/xsave area used by _dl_runtime_resolve.  Also need
    space to preserve RCX, RDX, RSI, RDI, R8, R9 and RAX.  It must be
-   aligned to 16 bytes for fxsave and 64 bytes for xsave.  */
-#define STATE_SAVE_OFFSET (8 * 7 + 8)
+   aligned to 16 bytes for fxsave and 64 bytes for xsave.  It is non-zero
+   because MOV, instead of PUSH, is used to save registers onto stack.
+
+   +==================+<- stack frame start aligned at 8 or 16 bytes
+   |                  |<- paddings for stack realignment of 64 bytes
+   |------------------|<- xsave buffer end aligned at 64 bytes
+   |                  |<-
+   |                  |<-
+   |                  |<-
+   |------------------|<- xsave buffer start at STATE_SAVE_OFFSET(%rsp)
+   |                  |<- 8-byte padding for 64-byte alignment
+   |                  |<- R9
+   |                  |<- R8
+   |                  |<- RDI
+   |                  |<- RSI
+   |                  |<- RDX
+   |                  |<- RCX
+   |                  |<- RAX
+   +==================+<- RSP aligned at 64 bytes
+
+ */
+# define STATE_SAVE_OFFSET (8 * 7 + 8)
+
+/* _dl_tlsdesc_dynamic preserves RDI, RSI and RBX before realigning
+   stack.  After realigning stack, it saves RCX, RDX, R8, R9, R10 and
+   R11.  Allocate space for RDI, RSI and RBX to avoid clobbering saved
+   RDI, RSI and RBX values on stack by xsave.
+
+   +==================+<- stack frame start aligned at 8 or 16 bytes
+   |                  |<- RDI saved in the red zone
+   |                  |<- RSI saved in the red zone
+   |                  |<- RBX saved in the red zone
+   |                  |<- paddings for stack realignment of 64 bytes
+   |------------------|<- xsave buffer end aligned at 64 bytes
+   |                  |<-
+   |                  |<-
+   |                  |<-
+   |------------------|<- xsave buffer start at STATE_SAVE_OFFSET(%rsp)
+   |                  |<- 8-byte padding for 64-byte alignment
+   |                  |<- 8-byte padding for 64-byte alignment
+   |                  |<- R11
+   |                  |<- R10
+   |                  |<- R9
+   |                  |<- R8
+   |                  |<- RDX
+   |                  |<- RCX
+   +==================+<- RSP aligned at 64 bytes
+
+   Define the total register save area size for all integer registers by
+   adding 24 to STATE_SAVE_OFFSET since RDI, RSI and RBX are saved onto
+   stack without adjusting stack pointer first, using the red-zone.  */
+# define TLSDESC_CALL_REGISTER_SAVE_AREA (STATE_SAVE_OFFSET + 24)
+
+/* Save SSE, AVX, AVX512, mask, bound and APX registers.  Bound and APX
+   registers are mutually exclusive.  */
+# define STATE_SAVE_MASK		\
+  ((1 << X86_XSTATE_SSE_ID)		\
+   | (1 << X86_XSTATE_AVX_ID)		\
+   | (1 << X86_XSTATE_BNDREGS_ID)	\
+   | (1 << X86_XSTATE_K_ID)		\
+   | (1 << X86_XSTATE_ZMM_H_ID) 	\
+   | (1 << X86_XSTATE_ZMM_ID)		\
+   | (1 << X86_XSTATE_APX_F_ID))
+
+/* The maximum supported xstate ID.  */
+# define X86_XSTATE_MAX_ID	X86_XSTATE_APX_F_ID
+
+/* AMX state mask.  */
+# define AMX_STATE_SAVE_MASK		\
+  ((1 << X86_XSTATE_TILECFG_ID) | (1 << X86_XSTATE_TILEDATA_ID))
+
+/* States to be included in xsave_state_full_size.  */
+# define FULL_STATE_SAVE_MASK		\
+  (STATE_SAVE_MASK | AMX_STATE_SAVE_MASK)
+#else
+/* Offset for fxsave/xsave area used by _dl_tlsdesc_dynamic.  Since i386
+   uses PUSH to save registers onto stack, use 0 here.  */
+# define STATE_SAVE_OFFSET 0
+# define TLSDESC_CALL_REGISTER_SAVE_AREA 0
+
+/* Save SSE, AVX, AXV512, mask and bound registers.   */
+# define STATE_SAVE_MASK		\
+  ((1 << X86_XSTATE_SSE_ID)		\
+   | (1 << X86_XSTATE_AVX_ID)		\
+   | (1 << X86_XSTATE_BNDREGS_ID)	\
+   | (1 << X86_XSTATE_K_ID)		\
+   | (1 << X86_XSTATE_ZMM_H_ID))
+
+/* The maximum supported xstate ID.  */
+# define X86_XSTATE_MAX_ID	X86_XSTATE_ZMM_H_ID
+
+/* States to be included in xsave_state_size.  */
+# define FULL_STATE_SAVE_MASK		STATE_SAVE_MASK
+#endif
 
-/* Save SSE, AVX, AVX512, mask and bound registers.  */
-#define STATE_SAVE_MASK \
-  ((1 << 1) | (1 << 2) | (1 << 3) | (1 << 5) | (1 << 6) | (1 << 7))
+/* States which should be saved for TLSDESC_CALL and TLS_DESC_CALL.
+   Compiler assumes that all registers, including AMX and x87 FPU
+   stack registers, are unchanged after CALL, except for EFLAGS and
+   RAX/EAX.  */
+#define TLSDESC_CALL_STATE_SAVE_MASK	\
+  (FULL_STATE_SAVE_MASK | (1 << X86_XSTATE_X87_ID))
 
 /* Constants for bits in __x86_string_control:  */
 
@@ -73,6 +183,29 @@
 
 #define atom_text_section .section ".text.atom", "ax"
 
+#ifndef DL_STACK_ALIGNMENT
+/* Due to GCC bug:
+
+   https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58066
+
+   __tls_get_addr may be called with 8-byte/4-byte stack alignment.
+   Although this bug has been fixed in GCC 4.9.4, 5.3 and 6, we can't
+   assume that stack will be always aligned at 16 bytes.  */
+# ifdef __x86_64__
+#  define DL_STACK_ALIGNMENT 8
+#  define MINIMUM_ALIGNMENT 16
+# else
+#  define DL_STACK_ALIGNMENT 4
+# endif
+#endif
+
+/* True if _dl_runtime_resolve/_dl_tlsdesc_dynamic should align stack for
+   STATE_SAVE or align stack to MINIMUM_ALIGNMENT bytes before calling
+   _dl_fixup/__tls_get_addr.  */
+#define DL_RUNTIME_RESOLVE_REALIGN_STACK \
+  (STATE_SAVE_ALIGNMENT > DL_STACK_ALIGNMENT \
+   || MINIMUM_ALIGNMENT > DL_STACK_ALIGNMENT)
+
 #endif	/* __ASSEMBLER__ */
 
 #endif	/* _X86_SYSDEP_H */
diff --git a/sysdeps/x86/tst-cpu-features-supports.c b/sysdeps/x86/tst-cpu-features-supports.c
index 93008dac70..0f43ef2b2d 100644
--- a/sysdeps/x86/tst-cpu-features-supports.c
+++ b/sysdeps/x86/tst-cpu-features-supports.c
@@ -65,7 +65,7 @@ do_test (int argc, char **argv)
 #endif
   fails += CHECK_FEATURE_ACTIVE (avx, AVX);
   fails += CHECK_FEATURE_ACTIVE (avx2, AVX2);
-#if __GNUC_PREREQ (7, 0)
+#if __GNUC_PREREQ (7, 0) && !__GNUC_PREREQ (15, 0)
   fails += CHECK_FEATURE_ACTIVE (avx5124fmaps, AVX512_4FMAPS);
   fails += CHECK_FEATURE_ACTIVE (avx5124vnniw, AVX512_4VNNIW);
 #endif
@@ -92,14 +92,18 @@ do_test (int argc, char **argv)
 #if __GNUC_PREREQ (6, 0)
   fails += CHECK_FEATURE_ACTIVE (avx512bw, AVX512BW);
   fails += CHECK_FEATURE_ACTIVE (avx512cd, AVX512CD);
+# if !__GNUC_PREREQ (15, 0)
   fails += CHECK_FEATURE_ACTIVE (avx512er, AVX512ER);
+# endif
   fails += CHECK_FEATURE_ACTIVE (avx512dq, AVX512DQ);
 #endif
 #if __GNUC_PREREQ (5, 0)
   fails += CHECK_FEATURE_ACTIVE (avx512f, AVX512F);
 #endif
 #if __GNUC_PREREQ (6, 0)
+# if !__GNUC_PREREQ (15, 0)
   fails += CHECK_FEATURE_ACTIVE (avx512pf, AVX512PF);
+# endif
   fails += CHECK_FEATURE_ACTIVE (avx512vl, AVX512VL);
 #endif
 #if __GNUC_PREREQ (5, 0)
@@ -148,7 +152,9 @@ do_test (int argc, char **argv)
 #endif
   fails += CHECK_FEATURE_ACTIVE (popcnt, POPCNT);
 #if __GNUC_PREREQ (11, 0)
+# if !__GNUC_PREREQ (15, 0)
   fails += CHECK_FEATURE_ACTIVE (prefetchwt1, PREFETCHWT1);
+# endif
   fails += CHECK_FEATURE_ACTIVE (ptwrite, PTWRITE);
   fails += CHECK_FEATURE_ACTIVE (rdpid, RDPID);
   fails += CHECK_FEATURE_ACTIVE (rdrnd, RDRAND);
diff --git a/sysdeps/x86/tst-gnu2-tls2-x86-noxsave.c b/sysdeps/x86/tst-gnu2-tls2-x86-noxsave.c
new file mode 100644
index 0000000000..f0024c143d
--- /dev/null
+++ b/sysdeps/x86/tst-gnu2-tls2-x86-noxsave.c
@@ -0,0 +1 @@
+#include <elf/tst-gnu2-tls2.c>
diff --git a/sysdeps/x86/tst-gnu2-tls2-x86-noxsavec.c b/sysdeps/x86/tst-gnu2-tls2-x86-noxsavec.c
new file mode 100644
index 0000000000..f0024c143d
--- /dev/null
+++ b/sysdeps/x86/tst-gnu2-tls2-x86-noxsavec.c
@@ -0,0 +1 @@
+#include <elf/tst-gnu2-tls2.c>
diff --git a/sysdeps/x86/tst-gnu2-tls2-x86-noxsavexsavec.c b/sysdeps/x86/tst-gnu2-tls2-x86-noxsavexsavec.c
new file mode 100644
index 0000000000..f0024c143d
--- /dev/null
+++ b/sysdeps/x86/tst-gnu2-tls2-x86-noxsavexsavec.c
@@ -0,0 +1 @@
+#include <elf/tst-gnu2-tls2.c>
diff --git a/sysdeps/x86/tst-gnu2-tls2.c b/sysdeps/x86/tst-gnu2-tls2.c
new file mode 100644
index 0000000000..de900a423b
--- /dev/null
+++ b/sysdeps/x86/tst-gnu2-tls2.c
@@ -0,0 +1,20 @@
+#ifndef __x86_64__
+#include <sys/platform/x86.h>
+
+#define IS_SUPPORTED() CPU_FEATURE_ACTIVE (SSE2)
+#endif
+
+/* Clear XMM0...XMM7  */
+#define PREPARE_MALLOC()				\
+{							\
+  asm volatile ("xorps %%xmm0, %%xmm0" : : : "xmm0" );	\
+  asm volatile ("xorps %%xmm1, %%xmm1" : : : "xmm1" );	\
+  asm volatile ("xorps %%xmm2, %%xmm2" : : : "xmm2" );	\
+  asm volatile ("xorps %%xmm3, %%xmm3" : : : "xmm3" );	\
+  asm volatile ("xorps %%xmm4, %%xmm4" : : : "xmm4" );	\
+  asm volatile ("xorps %%xmm5, %%xmm5" : : : "xmm5" );	\
+  asm volatile ("xorps %%xmm6, %%xmm6" : : : "xmm6" );	\
+  asm volatile ("xorps %%xmm7, %%xmm7" : : : "xmm7" );	\
+}
+
+#include <elf/tst-gnu2-tls2.c>
diff --git a/sysdeps/x86/tst-hwcap-tunables.c b/sysdeps/x86/tst-hwcap-tunables.c
index f6a65b88de..bc573c7435 100644
--- a/sysdeps/x86/tst-hwcap-tunables.c
+++ b/sysdeps/x86/tst-hwcap-tunables.c
@@ -60,7 +60,7 @@ static const struct test_t
     /* Disable everything.  */
     "-Prefer_ERMS,-Prefer_FSRM,-AVX,-AVX2,-AVX512F,-AVX512VL,"
     "-SSE4_1,-SSE4_2,-SSSE3,-Fast_Unaligned_Load,-ERMS,"
-    "-AVX_Fast_Unaligned_Load",
+    "-AVX_Fast_Unaligned_Load,-Avoid_Non_Temporal_Memset",
     test_1,
     array_length (test_1)
   },
@@ -68,7 +68,7 @@ static const struct test_t
     /* Same as before, but with some empty suboptions.  */
     ",-,-Prefer_ERMS,-Prefer_FSRM,-AVX,-AVX2,-AVX512F,-AVX512VL,"
     "-SSE4_1,-SSE4_2,-SSSE3,-Fast_Unaligned_Load,,-,"
-    "-ERMS,-AVX_Fast_Unaligned_Load,-,",
+    "-ERMS,-AVX_Fast_Unaligned_Load,-Avoid_Non_Temporal_Memset,-,",
     test_1,
     array_length (test_1)
   }
diff --git a/sysdeps/x86/tst-tls23.c b/sysdeps/x86/tst-tls23.c
new file mode 100644
index 0000000000..6130d91cf8
--- /dev/null
+++ b/sysdeps/x86/tst-tls23.c
@@ -0,0 +1,22 @@
+#ifndef __x86_64__
+#include <sys/platform/x86.h>
+
+#define IS_SUPPORTED() CPU_FEATURE_ACTIVE (SSE2)
+#endif
+
+/* Set XMM0...XMM7 to all 1s.  */
+#define PREPARE_MALLOC()					\
+{								\
+  asm volatile ("pcmpeqd %%xmm0, %%xmm0" : : : "xmm0" );	\
+  asm volatile ("pcmpeqd %%xmm1, %%xmm1" : : : "xmm1" );	\
+  asm volatile ("pcmpeqd %%xmm2, %%xmm2" : : : "xmm2" );	\
+  asm volatile ("pcmpeqd %%xmm3, %%xmm3" : : : "xmm3" );	\
+  asm volatile ("pcmpeqd %%xmm4, %%xmm4" : : : "xmm4" );	\
+  asm volatile ("pcmpeqd %%xmm5, %%xmm5" : : : "xmm5" );	\
+  asm volatile ("pcmpeqd %%xmm6, %%xmm6" : : : "xmm6" );	\
+  asm volatile ("pcmpeqd %%xmm7, %%xmm7" : : : "xmm7" );	\
+}
+
+#include <elf/tst-tls23.c>
+
+v2di v1, v2, v3;
diff --git a/sysdeps/x86/tst-tls23.h b/sysdeps/x86/tst-tls23.h
new file mode 100644
index 0000000000..21cee4ca07
--- /dev/null
+++ b/sysdeps/x86/tst-tls23.h
@@ -0,0 +1,35 @@
+/* Test that __tls_get_addr preserves XMM registers.
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <support/check.h>
+
+typedef long long v2di __attribute__((vector_size(16)));
+extern v2di v1, v2, v3;
+
+#define BEFORE_TLS_CALL()					\
+  v1 = __extension__(v2di){0, 0};				\
+  v2 = __extension__(v2di){0, 0};
+
+#define AFTER_TLS_CALL()					\
+  v3 = __extension__(v2di){0, 0};				\
+  asm volatile ("" : "+x" (v3));				\
+  union { v2di x; long long a[2]; } u;				\
+  u.x = v3;							\
+  TEST_VERIFY_EXIT (u.a[0] == 0 && u.a[1] == 0);
+
+#include <elf/tst-tls23.h>
diff --git a/sysdeps/x86/utmp-size.h b/sysdeps/x86/utmp-size.h
new file mode 100644
index 0000000000..8f21ebe1b6
--- /dev/null
+++ b/sysdeps/x86/utmp-size.h
@@ -0,0 +1,2 @@
+#define UTMP_SIZE 384
+#define LASTLOG_SIZE 292
diff --git a/sysdeps/x86_64/Makefile b/sysdeps/x86_64/Makefile
index 90f4ecfd26..c97b3ac13a 100644
--- a/sysdeps/x86_64/Makefile
+++ b/sysdeps/x86_64/Makefile
@@ -10,7 +10,7 @@ LDFLAGS-rtld += -Wl,-z,nomark-plt
 endif
 
 ifeq ($(subdir),csu)
-gen-as-const-headers += features-offsets.sym link-defines.sym
+gen-as-const-headers += link-defines.sym
 endif
 
 ifeq ($(subdir),gmon)
@@ -32,7 +32,8 @@ sysdep_routines += \
 # sysdep_routines
 gen-as-const-headers += locale-defines.sym
 tests += \
-  tst-rsi-strlen
+  tst-rsi-strlen \
+# tests
 endif
 
 ifeq ($(subdir),elf)
@@ -40,9 +41,6 @@ ifeq ($(subdir),elf)
 CFLAGS-.os += $(if $(filter $(@F),$(patsubst %,%.os,$(all-rtld-routines))),\
 		   -mno-mmx)
 
-sysdep-dl-routines += tlsdesc dl-tlsdesc tls_get_addr
-
-tests += ifuncmain8
 modules-names += ifuncmod8
 
 $(objpfx)ifuncmain8: $(objpfx)ifuncmod8.so
@@ -208,8 +206,19 @@ LDFLAGS-tst-plt-rewrite2 = -Wl,-z,now
 LDFLAGS-tst-plt-rewritemod2.so = -Wl,-z,now,-z,undefs
 tst-plt-rewrite2-ENV = GLIBC_TUNABLES=glibc.cpu.plt_rewrite=2
 $(objpfx)tst-plt-rewrite2: $(objpfx)tst-plt-rewritemod2.so
+
+tests-special += $(objpfx)check-dt-x86-64-plt.out
+
+$(objpfx)check-dt-x86-64-plt.out: $(common-objpfx)libc.so
+	LC_ALL=C $(READELF) -V -W $< \
+		| sed -ne '/.gnu.version_d/, /.gnu.version_r/ p' \
+		| grep GLIBC_ABI_DT_X86_64_PLT > $@; \
+	$(evaluate-test)
+generated += check-dt-x86-64-plt.out
 endif
 
+test-internal-extras += tst-gnu2-tls2mod1
+
 endif # $(subdir) == elf
 
 ifeq ($(subdir),csu)
@@ -230,7 +239,8 @@ sysdep_routines += \
 # sysdep_routines
 
 tests += \
-  tst-rsi-wcslen
+  tst-rsi-wcslen \
+# tests
 endif
 
 
@@ -250,6 +260,10 @@ sysdep-dl-routines += dl-cet
 
 tests += \
   tst-cet-legacy-1 \
+  tst-cet-legacy-10 \
+  tst-cet-legacy-10-static \
+  tst-cet-legacy-10a \
+  tst-cet-legacy-10a-static \
   tst-cet-legacy-1a \
   tst-cet-legacy-2 \
   tst-cet-legacy-2a \
@@ -261,15 +275,11 @@ tests += \
   tst-cet-legacy-8 \
   tst-cet-legacy-9 \
   tst-cet-legacy-9-static \
-  tst-cet-legacy-10 \
-  tst-cet-legacy-10-static \
-  tst-cet-legacy-10a \
-  tst-cet-legacy-10a-static \
 # tests
 tests-static += \
-  tst-cet-legacy-9-static \
   tst-cet-legacy-10-static \
   tst-cet-legacy-10a-static \
+  tst-cet-legacy-9-static \
 # tests-static
 tst-cet-legacy-1a-ARGS = -- $(host-test-program-cmd)
 
diff --git a/sysdeps/x86_64/Versions b/sysdeps/x86_64/Versions
index e94758b236..6a989ad3b3 100644
--- a/sysdeps/x86_64/Versions
+++ b/sysdeps/x86_64/Versions
@@ -5,6 +5,11 @@ libc {
   GLIBC_2.13 {
     __fentry__;
   }
+  GLIBC_ABI_DT_X86_64_PLT {
+    # This symbol is used only for empty version map and will be removed
+    # by scripts/versions.awk.
+    __placeholder_only_for_empty_version_map;
+  }
 }
 libm {
   GLIBC_2.1 {
diff --git a/sysdeps/x86_64/configure b/sysdeps/x86_64/configure
index 418cc4a9b8..07bdd40a37 100755
--- a/sysdeps/x86_64/configure
+++ b/sysdeps/x86_64/configure
@@ -134,6 +134,66 @@ fi
 config_vars="$config_vars
 enable-cet = $enable_cet"
 
+# Check if -mamx-tile works properly.
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether -mamx-tile works properly" >&5
+printf %s "checking whether -mamx-tile works properly... " >&6; }
+if test ${libc_cv_x86_have_amx_tile+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  cat > conftest.c <<EOF
+#include <x86intrin.h>
+EOF
+	       libc_cv_x86_have_amx_tile=no
+	       if { ac_try='${CC-cc} -E $CFLAGS -mamx-tile conftest.c > conftest.i'
+  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }; then
+		 if grep -q __builtin_ia32_ldtilecfg conftest.i; then
+		   libc_cv_x86_have_amx_tile=yes
+	         fi
+	       fi
+	       rm -rf conftest*
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $libc_cv_x86_have_amx_tile" >&5
+printf "%s\n" "$libc_cv_x86_have_amx_tile" >&6; }
+config_vars="$config_vars
+have-mamx-tile = $libc_cv_x86_have_amx_tile"
+
+# Check if -mapxf is enabled.
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether -mapxf is enabled" >&5
+printf %s "checking whether -mapxf is enabled... " >&6; }
+if test ${libc_cv_x86_have_apx+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  cat > conftest.c <<EOF
+#ifndef __APX_F__
+# error APX isn't enabled
+#endif
+EOF
+	       libc_cv_x86_have_apx=no
+	       if { ac_try='${CC-cc} -c $CFLAGS conftest.c -o conftest.o 1>&5'
+  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }; then
+		   libc_cv_x86_have_apx=yes
+	       fi
+	       rm -rf conftest*
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $libc_cv_x86_have_apx" >&5
+printf "%s\n" "$libc_cv_x86_have_apx" >&6; }
+if test $libc_cv_x86_have_apx = yes; then
+  printf "%s\n" "#define HAVE_X86_APX 1" >>confdefs.h
+
+fi
+config_vars="$config_vars
+have-x86-apx = $libc_cv_x86_have_apx"
+
 test -n "$critic_missing" && as_fn_error $? "
 *** $critic_missing" "$LINENO" 5
 
diff --git a/sysdeps/x86_64/configure.ac b/sysdeps/x86_64/configure.ac
index d1f803c02e..c7b68544a2 100644
--- a/sysdeps/x86_64/configure.ac
+++ b/sysdeps/x86_64/configure.ac
@@ -61,5 +61,38 @@ elif test $enable_cet = permissive; then
 fi
 LIBC_CONFIG_VAR([enable-cet], [$enable_cet])
 
+# Check if -mamx-tile works properly.
+AC_CACHE_CHECK(whether -mamx-tile works properly,
+	       libc_cv_x86_have_amx_tile, [dnl
+cat > conftest.c <<EOF
+#include <x86intrin.h>
+EOF
+	       libc_cv_x86_have_amx_tile=no
+	       if AC_TRY_COMMAND(${CC-cc} -E $CFLAGS -mamx-tile conftest.c > conftest.i); then
+		 if grep -q __builtin_ia32_ldtilecfg conftest.i; then
+		   libc_cv_x86_have_amx_tile=yes
+	         fi
+	       fi
+	       rm -rf conftest*])
+LIBC_CONFIG_VAR([have-mamx-tile], [$libc_cv_x86_have_amx_tile])
+
+# Check if -mapxf is enabled.
+AC_CACHE_CHECK(whether -mapxf is enabled,
+	       libc_cv_x86_have_apx, [dnl
+cat > conftest.c <<EOF
+#ifndef __APX_F__
+# error APX isn't enabled
+#endif
+EOF
+	       libc_cv_x86_have_apx=no
+	       if AC_TRY_COMMAND(${CC-cc} -c $CFLAGS conftest.c -o conftest.o 1>&AS_MESSAGE_LOG_FD); then
+		   libc_cv_x86_have_apx=yes
+	       fi
+	       rm -rf conftest*])
+if test $libc_cv_x86_have_apx = yes; then
+  AC_DEFINE(HAVE_X86_APX)
+fi
+LIBC_CONFIG_VAR([have-x86-apx], [$libc_cv_x86_have_apx])
+
 test -n "$critic_missing" && AC_MSG_ERROR([
 *** $critic_missing])
diff --git a/sysdeps/x86_64/dl-machine.h b/sysdeps/x86_64/dl-machine.h
index 6d605d0d32..899f56576f 100644
--- a/sysdeps/x86_64/dl-machine.h
+++ b/sysdeps/x86_64/dl-machine.h
@@ -71,9 +71,6 @@ elf_machine_runtime_setup (struct link_map *l, struct r_scope_elem *scope[],
 			   int lazy, int profile)
 {
   Elf64_Addr *got;
-  extern void _dl_runtime_resolve_fxsave (ElfW(Word)) attribute_hidden;
-  extern void _dl_runtime_resolve_xsave (ElfW(Word)) attribute_hidden;
-  extern void _dl_runtime_resolve_xsavec (ElfW(Word)) attribute_hidden;
   extern void _dl_runtime_profile_sse (ElfW(Word)) attribute_hidden;
   extern void _dl_runtime_profile_avx (ElfW(Word)) attribute_hidden;
   extern void _dl_runtime_profile_avx512 (ElfW(Word)) attribute_hidden;
@@ -96,8 +93,6 @@ elf_machine_runtime_setup (struct link_map *l, struct r_scope_elem *scope[],
       /* Identify this shared object.  */
       *(ElfW(Addr) *) (got + 1) = (ElfW(Addr)) l;
 
-      const struct cpu_features* cpu_features = __get_cpu_features ();
-
 #ifdef SHARED
       /* The got[2] entry contains the address of a function which gets
 	 called to get the address of a so far unresolved function and
@@ -107,6 +102,7 @@ elf_machine_runtime_setup (struct link_map *l, struct r_scope_elem *scope[],
 	 end in this function.  */
       if (__glibc_unlikely (profile))
 	{
+	  const struct cpu_features* cpu_features = __get_cpu_features ();
 	  if (X86_ISA_CPU_FEATURE_USABLE_P (cpu_features, AVX512F))
 	    *(ElfW(Addr) *) (got + 2) = (ElfW(Addr)) &_dl_runtime_profile_avx512;
 	  else if (X86_ISA_CPU_FEATURE_USABLE_P (cpu_features, AVX))
@@ -126,15 +122,8 @@ elf_machine_runtime_setup (struct link_map *l, struct r_scope_elem *scope[],
 	  /* This function will get called to fix up the GOT entry
 	     indicated by the offset on the stack, and then jump to
 	     the resolved address.  */
-	  if (MINIMUM_X86_ISA_LEVEL >= AVX_X86_ISA_LEVEL
-	      || GLRO(dl_x86_cpu_features).xsave_state_size != 0)
-	    *(ElfW(Addr) *) (got + 2)
-	      = (CPU_FEATURE_USABLE_P (cpu_features, XSAVEC)
-		 ? (ElfW(Addr)) &_dl_runtime_resolve_xsavec
-		 : (ElfW(Addr)) &_dl_runtime_resolve_xsave);
-	  else
-	    *(ElfW(Addr) *) (got + 2)
-	      = (ElfW(Addr)) &_dl_runtime_resolve_fxsave;
+	  *(ElfW(Addr) *) (got + 2)
+	    = (ElfW(Addr)) GLRO(dl_x86_64_runtime_resolve);
 	}
     }
 
@@ -150,37 +139,37 @@ elf_machine_runtime_setup (struct link_map *l, struct r_scope_elem *scope[],
 .globl _start\n\
 .globl _dl_start_user\n\
 _start:\n\
-	movq %rsp, %rdi\n\
+	mov %" RSP_LP ", %" RDI_LP "\n\
 	call _dl_start\n\
 _dl_start_user:\n\
 	# Save the user entry point address in %r12.\n\
-	movq %rax, %r12\n\
+	mov %" RAX_LP ", %" R12_LP "\n\
 	# Save %rsp value in %r13.\n\
-	movq %rsp, %r13\n\
+	mov %" RSP_LP ", % " R13_LP "\n\
 "\
 	RTLD_START_ENABLE_X86_FEATURES \
 "\
 	# Read the original argument count.\n\
-	movq (%rsp), %rdx\n\
+	mov (%rsp), %" RDX_LP "\n\
 	# Call _dl_init (struct link_map *main_map, int argc, char **argv, char **env)\n\
 	# argc -> rsi\n\
-	movq %rdx, %rsi\n\
+	mov %" RDX_LP ", %" RSI_LP "\n\
 	# And align stack for the _dl_init call. \n\
-	andq $-16, %rsp\n\
+	and $-16, %" RSP_LP "\n\
 	# _dl_loaded -> rdi\n\
-	movq _rtld_local(%rip), %rdi\n\
+	mov _rtld_local(%rip), %" RDI_LP "\n\
 	# env -> rcx\n\
-	leaq 16(%r13,%rdx,8), %rcx\n\
+	lea 2*" LP_SIZE "(%r13,%rdx," LP_SIZE "), %" RCX_LP "\n\
 	# argv -> rdx\n\
-	leaq 8(%r13), %rdx\n\
+	lea " LP_SIZE "(%r13), %" RDX_LP "\n\
 	# Clear %rbp to mark outermost frame obviously even for constructors.\n\
 	xorl %ebp, %ebp\n\
 	# Call the function to run the initializers.\n\
 	call _dl_init\n\
 	# Pass our finalizer function to the user in %rdx, as per ELF ABI.\n\
-	leaq _dl_fini(%rip), %rdx\n\
+	lea _dl_fini(%rip), %" RDX_LP "\n\
 	# And make sure %rsp points to argc stored on the stack.\n\
-	movq %r13, %rsp\n\
+	mov %" R13_LP ", %" RSP_LP "\n\
 	# Jump to the user's entry point.\n\
 	jmp *%r12\n\
 .previous\n\
@@ -245,8 +234,13 @@ elf_machine_plt_value (struct link_map *map, const ElfW(Rela) *reloc,
 
 
 /* Names of the architecture-specific auditing callback functions.  */
+#ifdef __LP64__
 #define ARCH_LA_PLTENTER x86_64_gnu_pltenter
 #define ARCH_LA_PLTEXIT x86_64_gnu_pltexit
+#else
+#define ARCH_LA_PLTENTER x32_gnu_pltenter
+#define ARCH_LA_PLTEXIT x32_gnu_pltexit
+#endif
 
 #endif /* !dl_machine_h */
 
@@ -383,7 +377,7 @@ and creates an unsatisfiable circular dependency.\n",
 		  {
 		    td->arg = _dl_make_tlsdesc_dynamic
 		      (sym_map, sym->st_value + reloc->r_addend);
-		    td->entry = _dl_tlsdesc_dynamic;
+		    td->entry = GLRO(dl_x86_tlsdesc_dynamic);
 		  }
 		else
 #  endif
diff --git a/sysdeps/x86_64/dl-procinfo.c b/sysdeps/x86_64/dl-procinfo.c
index 4d1d790fbb..06637a8154 100644
--- a/sysdeps/x86_64/dl-procinfo.c
+++ b/sysdeps/x86_64/dl-procinfo.c
@@ -41,5 +41,21 @@
 
 #include <sysdeps/x86/dl-procinfo.c>
 
+#if !IS_IN (ldconfig)
+# if !defined PROCINFO_DECL && defined SHARED
+  ._dl_x86_64_runtime_resolve
+# else
+PROCINFO_CLASS void * _dl_x86_64_runtime_resolve
+# endif
+# ifndef PROCINFO_DECL
+= NULL
+# endif
+# if !defined SHARED || defined PROCINFO_DECL
+;
+# else
+,
+# endif
+#endif
+
 #undef PROCINFO_DECL
 #undef PROCINFO_CLASS
diff --git a/sysdeps/x86_64/dl-tls.c b/sysdeps/x86_64/dl-tls.c
index 869023bbba..b3c1e4fcd7 100644
--- a/sysdeps/x86_64/dl-tls.c
+++ b/sysdeps/x86_64/dl-tls.c
@@ -41,7 +41,10 @@ __tls_get_addr_slow (GET_ADDR_ARGS)
   dtv_t *dtv = THREAD_DTV ();
 
   size_t gen = atomic_load_acquire (&GL(dl_tls_generation));
-  if (__glibc_unlikely (dtv[0].counter != gen))
+  if (__glibc_unlikely (dtv[0].counter != gen)
+      /* See comment in __tls_get_addr in elf/dl-tls.c.  */
+      && !(_dl_tls_allocate_active ()
+           && GET_ADDR_MODULE < _dl_tls_initial_modid_limit))
     return update_get_addr (GET_ADDR_PARAM, gen);
 
   return tls_get_addr_tail (GET_ADDR_PARAM, dtv, NULL);
diff --git a/sysdeps/x86_64/dl-tlsdesc-dynamic.h b/sysdeps/x86_64/dl-tlsdesc-dynamic.h
new file mode 100644
index 0000000000..44d948696f
--- /dev/null
+++ b/sysdeps/x86_64/dl-tlsdesc-dynamic.h
@@ -0,0 +1,166 @@
+/* Thread-local storage handling in the ELF dynamic linker.  x86_64 version.
+   Copyright (C) 2004-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef SECTION
+# define SECTION(p)	p
+#endif
+
+#undef REGISTER_SAVE_AREA
+#undef LOCAL_STORAGE_AREA
+#undef BASE
+
+#include "dl-trampoline-state.h"
+
+	.section SECTION(.text),"ax",@progbits
+
+	.hidden _dl_tlsdesc_dynamic
+	.global	_dl_tlsdesc_dynamic
+	.type	_dl_tlsdesc_dynamic,@function
+
+     /* %rax points to the TLS descriptor, such that 0(%rax) points to
+	_dl_tlsdesc_dynamic itself, and 8(%rax) points to a struct
+	tlsdesc_dynamic_arg object.  It must return in %rax the offset
+	between the thread pointer and the object denoted by the
+	argument, without clobbering any registers.
+
+	The assembly code that follows is a rendition of the following
+	C code, hand-optimized a little bit.
+
+ptrdiff_t
+_dl_tlsdesc_dynamic (register struct tlsdesc *tdp asm ("%rax"))
+{
+  struct tlsdesc_dynamic_arg *td = tdp->arg;
+  dtv_t *dtv = *(dtv_t **)((char *)__thread_pointer + DTV_OFFSET);
+  if (__builtin_expect (td->gen_count <= dtv[0].counter
+			&& (dtv[td->tlsinfo.ti_module].pointer.val
+			    != TLS_DTV_UNALLOCATED),
+			1))
+    return dtv[td->tlsinfo.ti_module].pointer.val + td->tlsinfo.ti_offset
+      - __thread_pointer;
+
+  return __tls_get_addr_internal (&td->tlsinfo) - __thread_pointer;
+}
+*/
+	cfi_startproc
+	.align 16
+_dl_tlsdesc_dynamic:
+	_CET_ENDBR
+	/* Preserve call-clobbered registers that we modify.
+	   We need two scratch regs anyway.  */
+	movq	%rsi, -16(%rsp)
+	mov	%fs:DTV_OFFSET, %RSI_LP
+	movq	%rdi, -8(%rsp)
+	movq	TLSDESC_ARG(%rax), %rdi
+	movq	(%rsi), %rax
+	cmpq	%rax, TLSDESC_GEN_COUNT(%rdi)
+	ja	2f
+	movq	TLSDESC_MODID(%rdi), %rax
+	salq	$4, %rax
+	movq	(%rax,%rsi), %rax
+	cmpq	$-1, %rax
+	je	2f
+	addq	TLSDESC_MODOFF(%rdi), %rax
+1:
+	movq	-16(%rsp), %rsi
+	sub	%fs:0, %RAX_LP
+	movq	-8(%rsp), %rdi
+	ret
+2:
+#if DL_RUNTIME_RESOLVE_REALIGN_STACK
+	movq	%rbx, -24(%rsp)
+	mov	%RSP_LP, %RBX_LP
+	cfi_def_cfa_register(%rbx)
+	and	$-STATE_SAVE_ALIGNMENT, %RSP_LP
+#endif
+#ifdef REGISTER_SAVE_AREA
+# if DL_RUNTIME_RESOLVE_REALIGN_STACK
+	/* STATE_SAVE_OFFSET has space for 8 integer registers.  But we
+	   need space for RCX, RDX, RSI, RDI, R8, R9, R10 and R11, plus
+	   RBX above.  */
+	sub	$(REGISTER_SAVE_AREA + STATE_SAVE_ALIGNMENT), %RSP_LP
+# else
+	sub	$REGISTER_SAVE_AREA, %RSP_LP
+	cfi_adjust_cfa_offset(REGISTER_SAVE_AREA)
+# endif
+#else
+	/* Allocate stack space of the required size to save the state.  */
+	sub	_dl_x86_features_tlsdesc_state_size(%rip), %RSP_LP
+#endif
+	/* Besides rdi and rsi, saved above, save rcx, rdx, r8, r9,
+	   r10 and r11.  */
+	movq	%rcx, REGISTER_SAVE_RCX(%rsp)
+	movq	%rdx, REGISTER_SAVE_RDX(%rsp)
+	movq	%r8, REGISTER_SAVE_R8(%rsp)
+	movq	%r9, REGISTER_SAVE_R9(%rsp)
+	movq	%r10, REGISTER_SAVE_R10(%rsp)
+	movq	%r11, REGISTER_SAVE_R11(%rsp)
+#ifdef USE_FXSAVE
+	fxsave	STATE_SAVE_OFFSET(%rsp)
+#else
+	movl	$TLSDESC_CALL_STATE_SAVE_MASK, %eax
+	xorl	%edx, %edx
+	/* Clear the XSAVE Header.  */
+# ifdef USE_XSAVE
+	movq	%rdx, (STATE_SAVE_OFFSET + 512)(%rsp)
+	movq	%rdx, (STATE_SAVE_OFFSET + 512 + 8)(%rsp)
+# endif
+	movq	%rdx, (STATE_SAVE_OFFSET + 512 + 8 * 2)(%rsp)
+	movq	%rdx, (STATE_SAVE_OFFSET + 512 + 8 * 3)(%rsp)
+	movq	%rdx, (STATE_SAVE_OFFSET + 512 + 8 * 4)(%rsp)
+	movq	%rdx, (STATE_SAVE_OFFSET + 512 + 8 * 5)(%rsp)
+	movq	%rdx, (STATE_SAVE_OFFSET + 512 + 8 * 6)(%rsp)
+	movq	%rdx, (STATE_SAVE_OFFSET + 512 + 8 * 7)(%rsp)
+# ifdef USE_XSAVE
+	xsave	STATE_SAVE_OFFSET(%rsp)
+# else
+	xsavec	STATE_SAVE_OFFSET(%rsp)
+# endif
+#endif
+	/* %rdi already points to the tlsinfo data structure.  */
+	call	HIDDEN_JUMPTARGET (__tls_get_addr)
+	# Get register content back.
+#ifdef USE_FXSAVE
+	fxrstor	STATE_SAVE_OFFSET(%rsp)
+#else
+	/* Save and retore __tls_get_addr return value stored in RAX.  */
+	mov	%RAX_LP, %RCX_LP
+	movl	$TLSDESC_CALL_STATE_SAVE_MASK, %eax
+	xorl	%edx, %edx
+	xrstor	STATE_SAVE_OFFSET(%rsp)
+	mov	%RCX_LP, %RAX_LP
+#endif
+	movq	REGISTER_SAVE_R11(%rsp), %r11
+	movq	REGISTER_SAVE_R10(%rsp), %r10
+	movq	REGISTER_SAVE_R9(%rsp), %r9
+	movq	REGISTER_SAVE_R8(%rsp), %r8
+	movq	REGISTER_SAVE_RDX(%rsp), %rdx
+	movq	REGISTER_SAVE_RCX(%rsp), %rcx
+#if DL_RUNTIME_RESOLVE_REALIGN_STACK
+	mov	%RBX_LP, %RSP_LP
+	cfi_def_cfa_register(%rsp)
+	movq	-24(%rsp), %rbx
+	cfi_restore(%rbx)
+#else
+	add	$REGISTER_SAVE_AREA, %RSP_LP
+	cfi_adjust_cfa_offset(-REGISTER_SAVE_AREA)
+#endif
+	jmp	1b
+	cfi_endproc
+	.size	_dl_tlsdesc_dynamic, .-_dl_tlsdesc_dynamic
+
+#undef STATE_SAVE_ALIGNMENT
diff --git a/sysdeps/x86_64/dl-tlsdesc.S b/sysdeps/x86_64/dl-tlsdesc.S
index f748af2ece..586079291a 100644
--- a/sysdeps/x86_64/dl-tlsdesc.S
+++ b/sysdeps/x86_64/dl-tlsdesc.S
@@ -18,8 +18,20 @@
 
 #include <sysdep.h>
 #include <tls.h>
+#include <cpu-features-offsets.h>
+#include <features-offsets.h>
+#include <isa-level.h>
 #include "tlsdesc.h"
 
+/* Area on stack to save and restore registers used for parameter
+   passing when calling _dl_tlsdesc_dynamic.  */
+#define REGISTER_SAVE_RCX	0
+#define REGISTER_SAVE_RDX	(REGISTER_SAVE_RCX + 8)
+#define REGISTER_SAVE_R8	(REGISTER_SAVE_RDX + 8)
+#define REGISTER_SAVE_R9	(REGISTER_SAVE_R8 + 8)
+#define REGISTER_SAVE_R10	(REGISTER_SAVE_R9 + 8)
+#define REGISTER_SAVE_R11	(REGISTER_SAVE_R10 + 8)
+
 	.text
 
      /* This function is used to compute the TP offset for symbols in
@@ -67,80 +79,26 @@ _dl_tlsdesc_undefweak:
 	.size	_dl_tlsdesc_undefweak, .-_dl_tlsdesc_undefweak
 
 #ifdef SHARED
-	.hidden _dl_tlsdesc_dynamic
-	.global	_dl_tlsdesc_dynamic
-	.type	_dl_tlsdesc_dynamic,@function
-
-     /* %rax points to the TLS descriptor, such that 0(%rax) points to
-	_dl_tlsdesc_dynamic itself, and 8(%rax) points to a struct
-	tlsdesc_dynamic_arg object.  It must return in %rax the offset
-	between the thread pointer and the object denoted by the
-	argument, without clobbering any registers.
-
-	The assembly code that follows is a rendition of the following
-	C code, hand-optimized a little bit.
-
-ptrdiff_t
-_dl_tlsdesc_dynamic (register struct tlsdesc *tdp asm ("%rax"))
-{
-  struct tlsdesc_dynamic_arg *td = tdp->arg;
-  dtv_t *dtv = *(dtv_t **)((char *)__thread_pointer + DTV_OFFSET);
-  if (__builtin_expect (td->gen_count <= dtv[0].counter
-			&& (dtv[td->tlsinfo.ti_module].pointer.val
-			    != TLS_DTV_UNALLOCATED),
-			1))
-    return dtv[td->tlsinfo.ti_module].pointer.val + td->tlsinfo.ti_offset
-      - __thread_pointer;
-
-  return __tls_get_addr_internal (&td->tlsinfo) - __thread_pointer;
-}
-*/
-	cfi_startproc
-	.align 16
-_dl_tlsdesc_dynamic:
-	_CET_ENDBR
-	/* Preserve call-clobbered registers that we modify.
-	   We need two scratch regs anyway.  */
-	movq	%rsi, -16(%rsp)
-	mov	%fs:DTV_OFFSET, %RSI_LP
-	movq	%rdi, -8(%rsp)
-	movq	TLSDESC_ARG(%rax), %rdi
-	movq	(%rsi), %rax
-	cmpq	%rax, TLSDESC_GEN_COUNT(%rdi)
-	ja	.Lslow
-	movq	TLSDESC_MODID(%rdi), %rax
-	salq	$4, %rax
-	movq	(%rax,%rsi), %rax
-	cmpq	$-1, %rax
-	je	.Lslow
-	addq	TLSDESC_MODOFF(%rdi), %rax
-.Lret:
-	movq	-16(%rsp), %rsi
-	sub	%fs:0, %RAX_LP
-	movq	-8(%rsp), %rdi
-	ret
-.Lslow:
-	/* Besides rdi and rsi, saved above, save rdx, rcx, r8, r9,
-	   r10 and r11.  Also, align the stack, that's off by 8 bytes.	*/
-	subq	$72, %rsp
-	cfi_adjust_cfa_offset (72)
-	movq	%rdx, 8(%rsp)
-	movq	%rcx, 16(%rsp)
-	movq	%r8, 24(%rsp)
-	movq	%r9, 32(%rsp)
-	movq	%r10, 40(%rsp)
-	movq	%r11, 48(%rsp)
-	/* %rdi already points to the tlsinfo data structure.  */
-	call	HIDDEN_JUMPTARGET (__tls_get_addr)
-	movq	8(%rsp), %rdx
-	movq	16(%rsp), %rcx
-	movq	24(%rsp), %r8
-	movq	32(%rsp), %r9
-	movq	40(%rsp), %r10
-	movq	48(%rsp), %r11
-	addq	$72, %rsp
-	cfi_adjust_cfa_offset (-72)
-	jmp	.Lret
-	cfi_endproc
-	.size	_dl_tlsdesc_dynamic, .-_dl_tlsdesc_dynamic
+# if MINIMUM_X86_ISA_LEVEL < AVX_X86_ISA_LEVEL
+#  define USE_FXSAVE
+#  define STATE_SAVE_ALIGNMENT	16
+#  define _dl_tlsdesc_dynamic	_dl_tlsdesc_dynamic_fxsave
+#  include "dl-tlsdesc-dynamic.h"
+#  undef _dl_tlsdesc_dynamic
+#  undef USE_FXSAVE
+# endif
+
+# define USE_XSAVE
+# define STATE_SAVE_ALIGNMENT	64
+# define _dl_tlsdesc_dynamic	_dl_tlsdesc_dynamic_xsave
+# include "dl-tlsdesc-dynamic.h"
+# undef _dl_tlsdesc_dynamic
+# undef USE_XSAVE
+
+# define USE_XSAVEC
+# define STATE_SAVE_ALIGNMENT	64
+# define _dl_tlsdesc_dynamic	_dl_tlsdesc_dynamic_xsavec
+# include "dl-tlsdesc-dynamic.h"
+# undef _dl_tlsdesc_dynamic
+# undef USE_XSAVEC
 #endif /* SHARED */
diff --git a/sysdeps/x86_64/dl-trampoline-state.h b/sysdeps/x86_64/dl-trampoline-state.h
new file mode 100644
index 0000000000..575f120797
--- /dev/null
+++ b/sysdeps/x86_64/dl-trampoline-state.h
@@ -0,0 +1,51 @@
+/* x86-64 PLT dl-trampoline state macros.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#if (STATE_SAVE_ALIGNMENT % 16) != 0
+# error STATE_SAVE_ALIGNMENT must be multiple of 16
+#endif
+
+#if (STATE_SAVE_OFFSET % STATE_SAVE_ALIGNMENT) != 0
+# error STATE_SAVE_OFFSET must be multiple of STATE_SAVE_ALIGNMENT
+#endif
+
+#if DL_RUNTIME_RESOLVE_REALIGN_STACK
+/* Local stack area before jumping to function address: RBX.  */
+# define LOCAL_STORAGE_AREA	8
+# define BASE			rbx
+# ifdef USE_FXSAVE
+/* Use fxsave to save XMM registers.  */
+#  define REGISTER_SAVE_AREA	(512 + STATE_SAVE_OFFSET)
+#  if (REGISTER_SAVE_AREA % 16) != 0
+#   error REGISTER_SAVE_AREA must be multiple of 16
+#  endif
+# endif
+#else
+# ifndef USE_FXSAVE
+#  error USE_FXSAVE must be defined
+# endif
+/* Use fxsave to save XMM registers.  */
+# define REGISTER_SAVE_AREA	(512 + STATE_SAVE_OFFSET + 8)
+/* Local stack area before jumping to function address:  All saved
+   registers.  */
+# define LOCAL_STORAGE_AREA	REGISTER_SAVE_AREA
+# define BASE			rsp
+# if (REGISTER_SAVE_AREA % 16) != 8
+#  error REGISTER_SAVE_AREA must be odd multiple of 8
+# endif
+#endif
diff --git a/sysdeps/x86_64/dl-trampoline.S b/sysdeps/x86_64/dl-trampoline.S
index b2e7e0f69b..4c11fcf032 100644
--- a/sysdeps/x86_64/dl-trampoline.S
+++ b/sysdeps/x86_64/dl-trampoline.S
@@ -23,25 +23,6 @@
 #include <link-defines.h>
 #include <isa-level.h>
 
-#ifndef DL_STACK_ALIGNMENT
-/* Due to GCC bug:
-
-   https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58066
-
-   __tls_get_addr may be called with 8-byte stack alignment.  Although
-   this bug has been fixed in GCC 4.9.4, 5.3 and 6, we can't assume
-   that stack will be always aligned at 16 bytes.  We use unaligned
-   16-byte move to load and store SSE registers, which has no penalty
-   on modern processors if stack is 16-byte aligned.  */
-# define DL_STACK_ALIGNMENT 8
-#endif
-
-/* True if _dl_runtime_resolve should align stack for STATE_SAVE or align
-   stack to 16 bytes before calling _dl_fixup.  */
-#define DL_RUNTIME_RESOLVE_REALIGN_STACK \
-  (STATE_SAVE_ALIGNMENT > DL_STACK_ALIGNMENT \
-   || 16 > DL_STACK_ALIGNMENT)
-
 /* Area on stack to save and restore registers used for parameter
    passing when calling _dl_fixup.  */
 #define REGISTER_SAVE_RAX	0
diff --git a/sysdeps/x86_64/dl-trampoline.h b/sysdeps/x86_64/dl-trampoline.h
index f55c6ea040..d9ccfb40d4 100644
--- a/sysdeps/x86_64/dl-trampoline.h
+++ b/sysdeps/x86_64/dl-trampoline.h
@@ -27,39 +27,7 @@
 # undef LOCAL_STORAGE_AREA
 # undef BASE
 
-# if (STATE_SAVE_ALIGNMENT % 16) != 0
-#  error STATE_SAVE_ALIGNMENT must be multiple of 16
-# endif
-
-# if (STATE_SAVE_OFFSET % STATE_SAVE_ALIGNMENT) != 0
-#  error STATE_SAVE_OFFSET must be multiple of STATE_SAVE_ALIGNMENT
-# endif
-
-# if DL_RUNTIME_RESOLVE_REALIGN_STACK
-/* Local stack area before jumping to function address: RBX.  */
-#  define LOCAL_STORAGE_AREA	8
-#  define BASE			rbx
-#  ifdef USE_FXSAVE
-/* Use fxsave to save XMM registers.  */
-#   define REGISTER_SAVE_AREA	(512 + STATE_SAVE_OFFSET)
-#   if (REGISTER_SAVE_AREA % 16) != 0
-#    error REGISTER_SAVE_AREA must be multiple of 16
-#   endif
-#  endif
-# else
-#  ifndef USE_FXSAVE
-#   error USE_FXSAVE must be defined
-#  endif
-/* Use fxsave to save XMM registers.  */
-#  define REGISTER_SAVE_AREA	(512 + STATE_SAVE_OFFSET + 8)
-/* Local stack area before jumping to function address:  All saved
-   registers.  */
-#  define LOCAL_STORAGE_AREA	REGISTER_SAVE_AREA
-#  define BASE			rsp
-#  if (REGISTER_SAVE_AREA % 16) != 8
-#   error REGISTER_SAVE_AREA must be odd multiple of 8
-#  endif
-# endif
+# include "dl-trampoline-state.h"
 
 	.globl _dl_runtime_resolve
 	.hidden _dl_runtime_resolve
diff --git a/sysdeps/x86_64/fpu/multiarch/Makefile b/sysdeps/x86_64/fpu/multiarch/Makefile
index ea81753b70..bc479b42d2 100644
--- a/sysdeps/x86_64/fpu/multiarch/Makefile
+++ b/sysdeps/x86_64/fpu/multiarch/Makefile
@@ -1,79 +1,20 @@
 ifeq ($(subdir),math)
-libm-sysdep_routines += \
-  s_ceil-c \
-  s_ceilf-c \
-  s_floor-c \
-  s_floorf-c \
-  s_rint-c \
-  s_rintf-c \
-  s_nearbyint-c \
-  s_nearbyintf-c \
-  s_roundeven-c \
-  s_roundevenf-c \
-  s_trunc-c \
-  s_truncf-c \
-# libm-sysdep_routines
-
-libm-sysdep_routines += \
-  s_ceil-sse4_1 \
-  s_ceilf-sse4_1 \
-  s_floor-sse4_1 \
-  s_floorf-sse4_1 \
-  s_nearbyint-sse4_1 \
-  s_nearbyintf-sse4_1 \
-  s_roundeven-sse4_1 \
-  s_roundevenf-sse4_1 \
-  s_rint-sse4_1 \
-  s_rintf-sse4_1 \
-  s_trunc-sse4_1 \
-  s_truncf-sse4_1 \
-# libm-sysdep_routines
-
-libm-sysdep_routines += \
-  e_asin-fma \
-  e_atan2-fma \
-  e_exp-fma \
-  e_log-fma \
-  e_log2-fma \
-  e_pow-fma \
-  s_atan-fma \
-  s_expm1-fma \
-  s_log1p-fma \
-  s_sin-fma \
-  s_sincos-fma \
-  s_tan-fma \
-# libm-sysdep_routines
-
 CFLAGS-e_asin-fma.c = -mfma -mavx2
 CFLAGS-e_atan2-fma.c = -mfma -mavx2
+CFLAGS-e_atanh-fma.c = -mfma -mavx2
 CFLAGS-e_exp-fma.c = -mfma -mavx2
 CFLAGS-e_log-fma.c = -mfma -mavx2
 CFLAGS-e_log2-fma.c = -mfma -mavx2
 CFLAGS-e_pow-fma.c = -mfma -mavx2
+CFLAGS-e_sinh-fma.c = -mfma -mavx2
 CFLAGS-s_atan-fma.c = -mfma -mavx2
 CFLAGS-s_expm1-fma.c = -mfma -mavx2
 CFLAGS-s_log1p-fma.c = -mfma -mavx2
 CFLAGS-s_sin-fma.c = -mfma -mavx2
 CFLAGS-s_tan-fma.c = -mfma -mavx2
+CFLAGS-s_tanh-fma.c = -mfma -mavx2
 CFLAGS-s_sincos-fma.c = -mfma -mavx2
 
-libm-sysdep_routines += \
-  s_cosf-sse2 \
-  s_sincosf-sse2 \
-  s_sinf-sse2 \
-# libm-sysdep_routines
-
-libm-sysdep_routines += \
-  e_exp2f-fma \
-  e_expf-fma \
-  e_log2f-fma \
-  e_logf-fma \
-  e_powf-fma \
-  s_cosf-fma \
-  s_sincosf-fma \
-  s_sinf-fma \
-# libm-sysdep_routines
-
 CFLAGS-e_exp2f-fma.c = -mfma -mavx2
 CFLAGS-e_expf-fma.c = -mfma -mavx2
 CFLAGS-e_log2f-fma.c = -mfma -mavx2
@@ -83,17 +24,100 @@ CFLAGS-s_sinf-fma.c = -mfma -mavx2
 CFLAGS-s_cosf-fma.c = -mfma -mavx2
 CFLAGS-s_sincosf-fma.c = -mfma -mavx2
 
+# Check if ISA level is 3 or above.
+ifneq (,$(filter $(have-x86-isa-level),$(x86-isa-level-3-or-above)))
 libm-sysdep_routines += \
+  s_ceil-avx \
+  s_ceilf-avx \
+  s_floor-avx \
+  s_floorf-avx \
+  s_nearbyint-avx \
+  s_nearbyintf-avx \
+  s_rint-avx \
+  s_rintf-avx \
+  s_roundeven-avx \
+  s_roundevenf-avx \
+  s_trunc-avx \
+  s_truncf-avx \
+# libm-sysdep_routines
+else
+ifeq (no,$(have-x86-apx))
+libm-sysdep_routines += \
+  e_asin-fma4 \
+  e_atan2-fma4 \
   e_exp-fma4 \
   e_log-fma4 \
   e_pow-fma4 \
-  e_asin-fma4 \
   s_atan-fma4 \
-  e_atan2-fma4 \
   s_sin-fma4 \
   s_sincos-fma4 \
   s_tan-fma4 \
 # libm-sysdep_routines
+endif
+libm-sysdep_routines += \
+  e_asin-fma \
+  e_atan2-avx \
+  e_atan2-fma \
+  e_atanh-fma \
+  e_exp-avx \
+  e_exp-fma \
+  e_exp2f-fma \
+  e_expf-fma \
+  e_log-avx \
+  e_log-fma \
+  e_log2-fma \
+  e_log2f-fma \
+  e_logf-fma \
+  e_pow-fma \
+  e_powf-fma \
+  e_sinh-fma \
+  s_atan-avx \
+  s_atan-fma \
+  s_ceil-sse4_1 \
+  s_ceilf-sse4_1 \
+  s_cosf-fma \
+  s_cosf-sse2 \
+  s_expm1-fma \
+  s_floor-sse4_1 \
+  s_floorf-sse4_1 \
+  s_log1p-fma \
+  s_nearbyint-sse4_1 \
+  s_nearbyintf-sse4_1 \
+  s_rint-sse4_1 \
+  s_rintf-sse4_1 \
+  s_roundeven-sse4_1 \
+  s_roundevenf-sse4_1 \
+  s_sin-avx \
+  s_sin-fma \
+  s_sincos-avx \
+  s_sincos-fma \
+  s_sincosf-fma \
+  s_sincosf-sse2 \
+  s_sinf-fma \
+  s_sinf-sse2 \
+  s_tan-avx \
+  s_tan-fma \
+  s_tanh-fma \
+  s_trunc-sse4_1 \
+  s_truncf-sse4_1 \
+# libm-sysdep_routines
+ifeq ($(have-x86-isa-level),baseline)
+libm-sysdep_routines += \
+  s_ceil-c \
+  s_ceilf-c \
+  s_floor-c \
+  s_floorf-c \
+  s_nearbyint-c \
+  s_nearbyintf-c \
+  s_rint-c \
+  s_rintf-c \
+  s_roundeven-c \
+  s_roundevenf-c \
+  s_trunc-c \
+  s_truncf-c \
+# libm-sysdep_routines
+endif
+endif
 
 CFLAGS-e_asin-fma4.c = -mfma4
 CFLAGS-e_atan2-fma4.c = -mfma4
@@ -105,16 +129,6 @@ CFLAGS-s_sin-fma4.c = -mfma4
 CFLAGS-s_tan-fma4.c = -mfma4
 CFLAGS-s_sincos-fma4.c = -mfma4
 
-libm-sysdep_routines += \
-  e_exp-avx \
-  e_log-avx \
-  s_atan-avx \
-  e_atan2-avx \
-  s_sin-avx \
-  s_sincos-avx \
-  s_tan-avx \
-# libm-sysdep_routines
-
 CFLAGS-e_atan2-avx.c = -msse2avx -DSSE2AVX
 CFLAGS-e_exp-avx.c = -msse2avx -DSSE2AVX
 CFLAGS-e_log-avx.c = -msse2avx -DSSE2AVX
diff --git a/sysdeps/x86_64/fpu/multiarch/e_asin.c b/sysdeps/x86_64/fpu/multiarch/e_asin.c
index 2eaa6c2c04..d64fca2586 100644
--- a/sysdeps/x86_64/fpu/multiarch/e_asin.c
+++ b/sysdeps/x86_64/fpu/multiarch/e_asin.c
@@ -16,26 +16,29 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <libm-alias-finite.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < AVX2_X86_ISA_LEVEL
+# include <libm-alias-finite.h>
 
 extern double __redirect_ieee754_asin (double);
 extern double __redirect_ieee754_acos (double);
 
-#define SYMBOL_NAME ieee754_asin
-#include "ifunc-fma4.h"
+# define SYMBOL_NAME ieee754_asin
+# include "ifunc-fma4.h"
 
 libc_ifunc_redirected (__redirect_ieee754_asin, __ieee754_asin,
 		       IFUNC_SELECTOR ());
 libm_alias_finite (__ieee754_asin, __asin)
 
-#undef SYMBOL_NAME
-#define SYMBOL_NAME ieee754_acos
-#include "ifunc-fma4.h"
+# undef SYMBOL_NAME
+# define SYMBOL_NAME ieee754_acos
+# include "ifunc-fma4.h"
 
 libc_ifunc_redirected (__redirect_ieee754_acos, __ieee754_acos,
 		       IFUNC_SELECTOR ());
 libm_alias_finite (__ieee754_acos, __acos)
 
-#define __ieee754_acos __ieee754_acos_sse2
-#define __ieee754_asin __ieee754_asin_sse2
+# define __ieee754_acos __ieee754_acos_sse2
+# define __ieee754_asin __ieee754_asin_sse2
+#endif
 #include <sysdeps/ieee754/dbl-64/e_asin.c>
diff --git a/sysdeps/x86_64/fpu/multiarch/e_atan2.c b/sysdeps/x86_64/fpu/multiarch/e_atan2.c
index 17ee4f3c36..8a86c14ded 100644
--- a/sysdeps/x86_64/fpu/multiarch/e_atan2.c
+++ b/sysdeps/x86_64/fpu/multiarch/e_atan2.c
@@ -16,16 +16,19 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <libm-alias-finite.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < AVX2_X86_ISA_LEVEL
+# include <libm-alias-finite.h>
 
 extern double __redirect_ieee754_atan2 (double, double);
 
-#define SYMBOL_NAME ieee754_atan2
-#include "ifunc-avx-fma4.h"
+# define SYMBOL_NAME ieee754_atan2
+# include "ifunc-avx-fma4.h"
 
 libc_ifunc_redirected (__redirect_ieee754_atan2,
 		       __ieee754_atan2, IFUNC_SELECTOR ());
 libm_alias_finite (__ieee754_atan2, __atan2)
 
-#define __ieee754_atan2 __ieee754_atan2_sse2
+# define __ieee754_atan2 __ieee754_atan2_sse2
+#endif
 #include <sysdeps/ieee754/dbl-64/e_atan2.c>
diff --git a/sysdeps/x86_64/fpu/multiarch/e_atanh-fma.c b/sysdeps/x86_64/fpu/multiarch/e_atanh-fma.c
new file mode 100644
index 0000000000..c3f2f9e550
--- /dev/null
+++ b/sysdeps/x86_64/fpu/multiarch/e_atanh-fma.c
@@ -0,0 +1,6 @@
+#define __ieee754_atanh __ieee754_atanh_fma
+#define __log1p __log1p_fma
+
+#define SECTION __attribute__ ((section (".text.fma")))
+
+#include <sysdeps/ieee754/dbl-64/e_atanh.c>
diff --git a/sysdeps/x86_64/fpu/multiarch/e_atanh.c b/sysdeps/x86_64/fpu/multiarch/e_atanh.c
new file mode 100644
index 0000000000..d2b785dfc0
--- /dev/null
+++ b/sysdeps/x86_64/fpu/multiarch/e_atanh.c
@@ -0,0 +1,34 @@
+/* Multiple versions of atanh.
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < AVX2_X86_ISA_LEVEL
+# include <libm-alias-finite.h>
+
+extern double __redirect_ieee754_atanh (double);
+
+# define SYMBOL_NAME ieee754_atanh
+# include "ifunc-fma.h"
+
+libc_ifunc_redirected (__redirect_ieee754_atanh, __ieee754_atanh, IFUNC_SELECTOR ());
+
+libm_alias_finite (__ieee754_atanh, __atanh)
+
+# define __ieee754_atanh __ieee754_atanh_sse2
+#endif
+#include <sysdeps/ieee754/dbl-64/e_atanh.c>
diff --git a/sysdeps/x86_64/fpu/multiarch/e_exp.c b/sysdeps/x86_64/fpu/multiarch/e_exp.c
index 406b7ebd44..d56329291a 100644
--- a/sysdeps/x86_64/fpu/multiarch/e_exp.c
+++ b/sysdeps/x86_64/fpu/multiarch/e_exp.c
@@ -16,17 +16,20 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <math.h>
-#include <libm-alias-finite.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < AVX2_X86_ISA_LEVEL
+# include <math.h>
+# include <libm-alias-finite.h>
 
 extern double __redirect_ieee754_exp (double);
 
-#define SYMBOL_NAME ieee754_exp
-#include "ifunc-avx-fma4.h"
+# define SYMBOL_NAME ieee754_exp
+# include "ifunc-avx-fma4.h"
 
 libc_ifunc_redirected (__redirect_ieee754_exp, __ieee754_exp,
 		       IFUNC_SELECTOR ());
 libm_alias_finite (__ieee754_exp, __exp)
 
-#define __exp __ieee754_exp_sse2
+# define __exp __ieee754_exp_sse2
+#endif
 #include <sysdeps/ieee754/dbl-64/e_exp.c>
diff --git a/sysdeps/x86_64/fpu/multiarch/e_exp2f.c b/sysdeps/x86_64/fpu/multiarch/e_exp2f.c
index 804fd6be85..06fe5028d6 100644
--- a/sysdeps/x86_64/fpu/multiarch/e_exp2f.c
+++ b/sysdeps/x86_64/fpu/multiarch/e_exp2f.c
@@ -16,25 +16,28 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <libm-alias-float.h>
-#include <libm-alias-finite.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < AVX2_X86_ISA_LEVEL
+# include <libm-alias-float.h>
+# include <libm-alias-finite.h>
 
 extern float __redirect_exp2f (float);
 
-#define SYMBOL_NAME exp2f
-#include "ifunc-fma.h"
+# define SYMBOL_NAME exp2f
+# include "ifunc-fma.h"
 
 libc_ifunc_redirected (__redirect_exp2f, __exp2f, IFUNC_SELECTOR ());
 
-#ifdef SHARED
+# ifdef SHARED
 versioned_symbol (libm, __ieee754_exp2f, exp2f, GLIBC_2_27);
 libm_alias_float_other (__exp2, exp2)
-#else
+# else
 libm_alias_float (__exp2, exp2)
-#endif
+# endif
 
 strong_alias (__exp2f, __ieee754_exp2f)
 libm_alias_finite (__exp2f, __exp2f)
 
-#define __exp2f __exp2f_sse2
+# define __exp2f __exp2f_sse2
+#endif
 #include <sysdeps/ieee754/flt-32/e_exp2f.c>
diff --git a/sysdeps/x86_64/fpu/multiarch/e_expf.c b/sysdeps/x86_64/fpu/multiarch/e_expf.c
index 4a7e2a5bce..19d767f636 100644
--- a/sysdeps/x86_64/fpu/multiarch/e_expf.c
+++ b/sysdeps/x86_64/fpu/multiarch/e_expf.c
@@ -16,28 +16,31 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <libm-alias-float.h>
-#include <libm-alias-finite.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < AVX2_X86_ISA_LEVEL
+# include <libm-alias-float.h>
+# include <libm-alias-finite.h>
 
 extern float __redirect_expf (float);
 
-#define SYMBOL_NAME expf
-#include "ifunc-fma.h"
+# define SYMBOL_NAME expf
+# include "ifunc-fma.h"
 
 libc_ifunc_redirected (__redirect_expf, __expf, IFUNC_SELECTOR ());
 
-#ifdef SHARED
+# ifdef SHARED
 __hidden_ver1 (__expf, __GI___expf, __redirect_expf)
   __attribute__ ((visibility ("hidden")));
 
 versioned_symbol (libm, __ieee754_expf, expf, GLIBC_2_27);
 libm_alias_float_other (__exp, exp)
-#else
+# else
 libm_alias_float (__exp, exp)
-#endif
+# endif
 
 strong_alias (__expf, __ieee754_expf)
 libm_alias_finite (__expf, __expf)
 
-#define __expf __expf_sse2
+# define __expf __expf_sse2
+#endif
 #include <sysdeps/ieee754/flt-32/e_expf.c>
diff --git a/sysdeps/x86_64/fpu/multiarch/e_log.c b/sysdeps/x86_64/fpu/multiarch/e_log.c
index 067fbf58c3..d80c1b1463 100644
--- a/sysdeps/x86_64/fpu/multiarch/e_log.c
+++ b/sysdeps/x86_64/fpu/multiarch/e_log.c
@@ -16,17 +16,20 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <math.h>
-#include <libm-alias-finite.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < AVX2_X86_ISA_LEVEL
+# include <math.h>
+# include <libm-alias-finite.h>
 
 extern double __redirect_ieee754_log (double);
 
-#define SYMBOL_NAME ieee754_log
-#include "ifunc-avx-fma4.h"
+# define SYMBOL_NAME ieee754_log
+# include "ifunc-avx-fma4.h"
 
 libc_ifunc_redirected (__redirect_ieee754_log, __ieee754_log,
 		       IFUNC_SELECTOR ());
 libm_alias_finite (__ieee754_log, __log)
 
-#define __log __ieee754_log_sse2
+# define __log __ieee754_log_sse2
+#endif
 #include <sysdeps/ieee754/dbl-64/e_log.c>
diff --git a/sysdeps/x86_64/fpu/multiarch/e_log2.c b/sysdeps/x86_64/fpu/multiarch/e_log2.c
index 9c57a2f6cc..9686782c09 100644
--- a/sysdeps/x86_64/fpu/multiarch/e_log2.c
+++ b/sysdeps/x86_64/fpu/multiarch/e_log2.c
@@ -16,28 +16,31 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <libm-alias-double.h>
-#include <libm-alias-finite.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < AVX2_X86_ISA_LEVEL
+# include <libm-alias-double.h>
+# include <libm-alias-finite.h>
 
 extern double __redirect_log2 (double);
 
-#define SYMBOL_NAME log2
-#include "ifunc-fma.h"
+# define SYMBOL_NAME log2
+# include "ifunc-fma.h"
 
 libc_ifunc_redirected (__redirect_log2, __log2, IFUNC_SELECTOR ());
 
-#ifdef SHARED
+# ifdef SHARED
 __hidden_ver1 (__log2, __GI___log2, __redirect_log2)
   __attribute__ ((visibility ("hidden")));
 
 versioned_symbol (libm, __ieee754_log2, log2, GLIBC_2_29);
 libm_alias_double_other (__log2, log2)
-#else
+# else
 libm_alias_double (__log2, log2)
-#endif
+# endif
 
 strong_alias (__log2, __ieee754_log2)
 libm_alias_finite (__log2, __log2)
 
-#define __log2 __log2_sse2
+# define __log2 __log2_sse2
+#endif
 #include <sysdeps/ieee754/dbl-64/e_log2.c>
diff --git a/sysdeps/x86_64/fpu/multiarch/e_log2f.c b/sysdeps/x86_64/fpu/multiarch/e_log2f.c
index 2b45c87f38..8ada46e11e 100644
--- a/sysdeps/x86_64/fpu/multiarch/e_log2f.c
+++ b/sysdeps/x86_64/fpu/multiarch/e_log2f.c
@@ -16,28 +16,31 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <libm-alias-float.h>
-#include <libm-alias-finite.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < AVX2_X86_ISA_LEVEL
+# include <libm-alias-float.h>
+# include <libm-alias-finite.h>
 
 extern float __redirect_log2f (float);
 
-#define SYMBOL_NAME log2f
-#include "ifunc-fma.h"
+# define SYMBOL_NAME log2f
+# include "ifunc-fma.h"
 
 libc_ifunc_redirected (__redirect_log2f, __log2f, IFUNC_SELECTOR ());
 
-#ifdef SHARED
+# ifdef SHARED
 __hidden_ver1 (__log2f, __GI___log2f, __redirect_log2f)
   __attribute__ ((visibility ("hidden")));
 
 versioned_symbol (libm, __ieee754_log2f, log2f, GLIBC_2_27);
 libm_alias_float_other (__log2, log2)
-#else
+# else
 libm_alias_float (__log2, log2)
-#endif
+# endif
 
 strong_alias (__log2f, __ieee754_log2f)
 libm_alias_finite (__log2f, __log2f)
 
-#define __log2f __log2f_sse2
+# define __log2f __log2f_sse2
+#endif
 #include <sysdeps/ieee754/flt-32/e_log2f.c>
diff --git a/sysdeps/x86_64/fpu/multiarch/e_logf.c b/sysdeps/x86_64/fpu/multiarch/e_logf.c
index 97e23c8fea..a3978d9a8e 100644
--- a/sysdeps/x86_64/fpu/multiarch/e_logf.c
+++ b/sysdeps/x86_64/fpu/multiarch/e_logf.c
@@ -16,28 +16,31 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <libm-alias-float.h>
-#include <libm-alias-finite.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < AVX2_X86_ISA_LEVEL
+# include <libm-alias-float.h>
+# include <libm-alias-finite.h>
 
 extern float __redirect_logf (float);
 
-#define SYMBOL_NAME logf
-#include "ifunc-fma.h"
+# define SYMBOL_NAME logf
+# include "ifunc-fma.h"
 
 libc_ifunc_redirected (__redirect_logf, __logf, IFUNC_SELECTOR ());
 
-#ifdef SHARED
+# ifdef SHARED
 __hidden_ver1 (__logf, __GI___logf, __redirect_logf)
   __attribute__ ((visibility ("hidden")));
 
 versioned_symbol (libm, __ieee754_logf, logf, GLIBC_2_27);
 libm_alias_float_other (__log, log)
-#else
+# else
 libm_alias_float (__log, log)
-#endif
+# endif
 
 strong_alias (__logf, __ieee754_logf)
 libm_alias_finite (__logf, __logf)
 
-#define __logf __logf_sse2
+# define __logf __logf_sse2
+#endif
 #include <sysdeps/ieee754/flt-32/e_logf.c>
diff --git a/sysdeps/x86_64/fpu/multiarch/e_pow.c b/sysdeps/x86_64/fpu/multiarch/e_pow.c
index 42618e7112..f8f17aff9f 100644
--- a/sysdeps/x86_64/fpu/multiarch/e_pow.c
+++ b/sysdeps/x86_64/fpu/multiarch/e_pow.c
@@ -16,17 +16,20 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <math.h>
-#include <libm-alias-finite.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < AVX2_X86_ISA_LEVEL
+# include <math.h>
+# include <libm-alias-finite.h>
 
 extern double __redirect_ieee754_pow (double, double);
 
-#define SYMBOL_NAME ieee754_pow
-#include "ifunc-fma4.h"
+# define SYMBOL_NAME ieee754_pow
+# include "ifunc-fma4.h"
 
 libc_ifunc_redirected (__redirect_ieee754_pow,
 		       __ieee754_pow, IFUNC_SELECTOR ());
 libm_alias_finite (__ieee754_pow, __pow)
 
-#define __pow __ieee754_pow_sse2
+# define __pow __ieee754_pow_sse2
+#endif
 #include <sysdeps/ieee754/dbl-64/e_pow.c>
diff --git a/sysdeps/x86_64/fpu/multiarch/e_powf.c b/sysdeps/x86_64/fpu/multiarch/e_powf.c
index 8e6ce13cc1..8b1a4c7d04 100644
--- a/sysdeps/x86_64/fpu/multiarch/e_powf.c
+++ b/sysdeps/x86_64/fpu/multiarch/e_powf.c
@@ -16,31 +16,34 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <libm-alias-float.h>
-#include <libm-alias-finite.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < AVX2_X86_ISA_LEVEL
+# include <libm-alias-float.h>
+# include <libm-alias-finite.h>
 
-#define powf __redirect_powf
-#define __DECL_SIMD___redirect_powf
-#include <math.h>
-#undef powf
+# define powf __redirect_powf
+# define __DECL_SIMD___redirect_powf
+# include <math.h>
+# undef powf
 
-#define SYMBOL_NAME powf
-#include "ifunc-fma.h"
+# define SYMBOL_NAME powf
+# include "ifunc-fma.h"
 
 libc_ifunc_redirected (__redirect_powf, __powf, IFUNC_SELECTOR ());
 
-#ifdef SHARED
+# ifdef SHARED
 __hidden_ver1 (__powf, __GI___powf, __redirect_powf)
   __attribute__ ((visibility ("hidden")));
 
 versioned_symbol (libm, __ieee754_powf, powf, GLIBC_2_27);
 libm_alias_float_other (__pow, pow)
-#else
+# else
 libm_alias_float (__pow, pow)
-#endif
+# endif
 
 strong_alias (__powf, __ieee754_powf)
 libm_alias_finite (__powf, __powf)
 
-#define __powf __powf_sse2
+# define __powf __powf_sse2
+#endif
 #include <sysdeps/ieee754/flt-32/e_powf.c>
diff --git a/sysdeps/x86_64/fpu/multiarch/e_sinh-fma.c b/sysdeps/x86_64/fpu/multiarch/e_sinh-fma.c
new file mode 100644
index 0000000000..e0e1e39a7a
--- /dev/null
+++ b/sysdeps/x86_64/fpu/multiarch/e_sinh-fma.c
@@ -0,0 +1,12 @@
+#define __ieee754_sinh __ieee754_sinh_fma
+#define __ieee754_exp __ieee754_exp_fma
+#define __expm1 __expm1_fma
+
+/* NB: __expm1 may be expanded to __expm1_fma in the following
+   prototypes.  */
+extern long double __expm1l (long double);
+extern long double __expm1f128 (long double);
+
+#define SECTION __attribute__ ((section (".text.fma")))
+
+#include <sysdeps/ieee754/dbl-64/e_sinh.c>
diff --git a/sysdeps/x86_64/fpu/multiarch/e_sinh.c b/sysdeps/x86_64/fpu/multiarch/e_sinh.c
new file mode 100644
index 0000000000..3d3c18ccdf
--- /dev/null
+++ b/sysdeps/x86_64/fpu/multiarch/e_sinh.c
@@ -0,0 +1,35 @@
+/* Multiple versions of sinh.
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < AVX2_X86_ISA_LEVEL
+# include <libm-alias-finite.h>
+
+extern double __redirect_ieee754_sinh (double);
+
+# define SYMBOL_NAME ieee754_sinh
+# include "ifunc-fma.h"
+
+libc_ifunc_redirected (__redirect_ieee754_sinh, __ieee754_sinh,
+		       IFUNC_SELECTOR ());
+
+libm_alias_finite (__ieee754_sinh, __sinh)
+
+# define __ieee754_sinh __ieee754_sinh_sse2
+#endif
+#include <sysdeps/ieee754/dbl-64/e_sinh.c>
diff --git a/sysdeps/x86_64/fpu/multiarch/ifunc-avx-fma4.h b/sysdeps/x86_64/fpu/multiarch/ifunc-avx-fma4.h
index 7719188888..d126cf9cd5 100644
--- a/sysdeps/x86_64/fpu/multiarch/ifunc-avx-fma4.h
+++ b/sysdeps/x86_64/fpu/multiarch/ifunc-avx-fma4.h
@@ -33,8 +33,10 @@ IFUNC_SELECTOR (void)
       && CPU_FEATURE_USABLE_P (cpu_features, AVX2))
     return OPTIMIZE (fma);
 
+#ifndef HAVE_X86_APX
   if (CPU_FEATURE_USABLE_P (cpu_features, FMA4))
     return OPTIMIZE (fma4);
+#endif
 
   if (CPU_FEATURE_USABLE_P (cpu_features, AVX))
     return OPTIMIZE (avx);
diff --git a/sysdeps/x86_64/fpu/multiarch/ifunc-fma4.h b/sysdeps/x86_64/fpu/multiarch/ifunc-fma4.h
index c35ba13845..18d372d25c 100644
--- a/sysdeps/x86_64/fpu/multiarch/ifunc-fma4.h
+++ b/sysdeps/x86_64/fpu/multiarch/ifunc-fma4.h
@@ -32,8 +32,10 @@ IFUNC_SELECTOR (void)
       && CPU_FEATURE_USABLE_P (cpu_features, AVX2))
     return OPTIMIZE (fma);
 
+#ifndef HAVE_X86_APX
   if (CPU_FEATURE_USABLE_P (cpu_features, FMA4))
     return OPTIMIZE (fma4);
+#endif
 
   return OPTIMIZE (sse2);
 }
diff --git a/sysdeps/x86_64/fpu/multiarch/s_atan.c b/sysdeps/x86_64/fpu/multiarch/s_atan.c
index 71bad096a9..4d2c6ce006 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_atan.c
+++ b/sysdeps/x86_64/fpu/multiarch/s_atan.c
@@ -16,15 +16,18 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <libm-alias-double.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < AVX2_X86_ISA_LEVEL
+# include <libm-alias-double.h>
 
 extern double __redirect_atan (double);
 
-#define SYMBOL_NAME atan
-#include "ifunc-avx-fma4.h"
+# define SYMBOL_NAME atan
+# include "ifunc-avx-fma4.h"
 
 libc_ifunc_redirected (__redirect_atan, __atan, IFUNC_SELECTOR ());
 libm_alias_double (__atan, atan)
 
-#define __atan __atan_sse2
+# define __atan __atan_sse2
+#endif
 #include <sysdeps/ieee754/dbl-64/s_atan.c>
diff --git a/sysdeps/x86_64/fpu/multiarch/s_ceil-avx.S b/sysdeps/x86_64/fpu/multiarch/s_ceil-avx.S
new file mode 100644
index 0000000000..e6c1106753
--- /dev/null
+++ b/sysdeps/x86_64/fpu/multiarch/s_ceil-avx.S
@@ -0,0 +1,28 @@
+/* AVX implementation of ceil function.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <libm-alias-double.h>
+
+	.text
+ENTRY(__ceil)
+	vroundsd $10, %xmm0, %xmm0, %xmm0
+	ret
+END(__ceil)
+
+libm_alias_double (__ceil, ceil)
diff --git a/sysdeps/x86_64/fpu/multiarch/s_ceil-sse4_1.S b/sysdeps/x86_64/fpu/multiarch/s_ceil-sse4_1.S
index 64119011ad..dba756c38f 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_ceil-sse4_1.S
+++ b/sysdeps/x86_64/fpu/multiarch/s_ceil-sse4_1.S
@@ -17,8 +17,20 @@
 
 #include <sysdep.h>
 
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL == SSE4_1_X86_ISA_LEVEL
+# include <libm-alias-double.h>
+# define __ceil_sse41 __ceil
+	.text
+#else
 	.section .text.sse4.1,"ax",@progbits
+#endif
+
 ENTRY(__ceil_sse41)
 	roundsd	$10, %xmm0, %xmm0
 	ret
 END(__ceil_sse41)
+
+#if MINIMUM_X86_ISA_LEVEL == SSE4_1_X86_ISA_LEVEL
+libm_alias_double (__ceil, ceil)
+#endif
diff --git a/sysdeps/x86_64/fpu/multiarch/s_ceil.c b/sysdeps/x86_64/fpu/multiarch/s_ceil.c
index cc028addee..46c8e91e19 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_ceil.c
+++ b/sysdeps/x86_64/fpu/multiarch/s_ceil.c
@@ -16,17 +16,20 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#define NO_MATH_REDIRECT
-#include <libm-alias-double.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < SSE4_1_X86_ISA_LEVEL
+# define NO_MATH_REDIRECT
+# include <libm-alias-double.h>
 
-#define ceil __redirect_ceil
-#define __ceil __redirect___ceil
-#include <math.h>
-#undef ceil
-#undef __ceil
+# define ceil __redirect_ceil
+# define __ceil __redirect___ceil
+# include <math.h>
+# undef ceil
+# undef __ceil
 
-#define SYMBOL_NAME ceil
-#include "ifunc-sse4_1.h"
+# define SYMBOL_NAME ceil
+# include "ifunc-sse4_1.h"
 
 libc_ifunc_redirected (__redirect_ceil, __ceil, IFUNC_SELECTOR ());
 libm_alias_double (__ceil, ceil)
+#endif
diff --git a/sysdeps/x86_64/fpu/multiarch/s_ceilf-avx.S b/sysdeps/x86_64/fpu/multiarch/s_ceilf-avx.S
new file mode 100644
index 0000000000..b4d8ac0455
--- /dev/null
+++ b/sysdeps/x86_64/fpu/multiarch/s_ceilf-avx.S
@@ -0,0 +1,28 @@
+/* AVX implementation of ceilf function.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <libm-alias-float.h>
+
+	.text
+ENTRY(__ceilf)
+	vroundss $10, %xmm0, %xmm0, %xmm0
+	ret
+END(__ceilf)
+
+libm_alias_float (__ceil, ceil)
diff --git a/sysdeps/x86_64/fpu/multiarch/s_ceilf-sse4_1.S b/sysdeps/x86_64/fpu/multiarch/s_ceilf-sse4_1.S
index dd9a9f6b71..9abc87b91a 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_ceilf-sse4_1.S
+++ b/sysdeps/x86_64/fpu/multiarch/s_ceilf-sse4_1.S
@@ -17,8 +17,20 @@
 
 #include <sysdep.h>
 
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL == SSE4_1_X86_ISA_LEVEL
+# include <libm-alias-float.h>
+# define __ceilf_sse41 __ceilf
+	.text
+#else
 	.section .text.sse4.1,"ax",@progbits
+#endif
+
 ENTRY(__ceilf_sse41)
 	roundss	$10, %xmm0, %xmm0
 	ret
 END(__ceilf_sse41)
+
+#if MINIMUM_X86_ISA_LEVEL == SSE4_1_X86_ISA_LEVEL
+libm_alias_float (__ceil, ceil)
+#endif
diff --git a/sysdeps/x86_64/fpu/multiarch/s_ceilf.c b/sysdeps/x86_64/fpu/multiarch/s_ceilf.c
index 97a0ca7d19..bb53108f73 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_ceilf.c
+++ b/sysdeps/x86_64/fpu/multiarch/s_ceilf.c
@@ -16,17 +16,20 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#define NO_MATH_REDIRECT
-#include <libm-alias-float.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < SSE4_1_X86_ISA_LEVEL
+# define NO_MATH_REDIRECT
+# include <libm-alias-float.h>
 
-#define ceilf __redirect_ceilf
-#define __ceilf __redirect___ceilf
-#include <math.h>
-#undef ceilf
-#undef __ceilf
+# define ceilf __redirect_ceilf
+# define __ceilf __redirect___ceilf
+# include <math.h>
+# undef ceilf
+# undef __ceilf
 
-#define SYMBOL_NAME ceilf
-#include "ifunc-sse4_1.h"
+# define SYMBOL_NAME ceilf
+# include "ifunc-sse4_1.h"
 
 libc_ifunc_redirected (__redirect_ceilf, __ceilf, IFUNC_SELECTOR ());
 libm_alias_float (__ceil, ceil)
+#endif
diff --git a/sysdeps/x86_64/fpu/multiarch/s_cosf.c b/sysdeps/x86_64/fpu/multiarch/s_cosf.c
index 2703c576df..8a02e04538 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_cosf.c
+++ b/sysdeps/x86_64/fpu/multiarch/s_cosf.c
@@ -16,13 +16,18 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <libm-alias-float.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < AVX2_X86_ISA_LEVEL
+# include <libm-alias-float.h>
 
 extern float __redirect_cosf (float);
 
-#define SYMBOL_NAME cosf
-#include "ifunc-fma.h"
+# define SYMBOL_NAME cosf
+# include "ifunc-fma.h"
 
 libc_ifunc_redirected (__redirect_cosf, __cosf, IFUNC_SELECTOR ());
 
 libm_alias_float (__cos, cos)
+#else
+# include <sysdeps/ieee754/flt-32/s_cosf.c>
+#endif
diff --git a/sysdeps/x86_64/fpu/multiarch/s_expm1.c b/sysdeps/x86_64/fpu/multiarch/s_expm1.c
index 8a2d69f9b2..d58ef3d8f5 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_expm1.c
+++ b/sysdeps/x86_64/fpu/multiarch/s_expm1.c
@@ -16,21 +16,24 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <libm-alias-double.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < AVX2_X86_ISA_LEVEL
+# include <libm-alias-double.h>
 
 extern double __redirect_expm1 (double);
 
-#define SYMBOL_NAME expm1
-#include "ifunc-fma.h"
+# define SYMBOL_NAME expm1
+# include "ifunc-fma.h"
 
 libc_ifunc_redirected (__redirect_expm1, __expm1, IFUNC_SELECTOR ());
 libm_alias_double (__expm1, expm1)
 
-#define __expm1 __expm1_sse2
+# define __expm1 __expm1_sse2
 
 /* NB: __expm1 may be expanded to __expm1_sse2 in the following
    prototypes.  */
 extern long double __expm1l (long double);
 extern long double __expm1f128 (long double);
 
+#endif
 #include <sysdeps/ieee754/dbl-64/s_expm1.c>
diff --git a/sysdeps/x86_64/fpu/multiarch/s_floor-avx.S b/sysdeps/x86_64/fpu/multiarch/s_floor-avx.S
new file mode 100644
index 0000000000..ff74b5a8bf
--- /dev/null
+++ b/sysdeps/x86_64/fpu/multiarch/s_floor-avx.S
@@ -0,0 +1,28 @@
+/* AVX implementation of floor function.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <libm-alias-double.h>
+
+	.text
+ENTRY(__floor)
+	vroundsd $9, %xmm0, %xmm0, %xmm0
+	ret
+END(__floor)
+
+libm_alias_double (__floor, floor)
diff --git a/sysdeps/x86_64/fpu/multiarch/s_floor-sse4_1.S b/sysdeps/x86_64/fpu/multiarch/s_floor-sse4_1.S
index 2f7521f39f..c9b9b0639b 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_floor-sse4_1.S
+++ b/sysdeps/x86_64/fpu/multiarch/s_floor-sse4_1.S
@@ -17,8 +17,20 @@
 
 #include <sysdep.h>
 
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL == SSE4_1_X86_ISA_LEVEL
+# include <libm-alias-double.h>
+# define __floor_sse41 __floor
+	.text
+#else
 	.section .text.sse4.1,"ax",@progbits
+#endif
+
 ENTRY(__floor_sse41)
 	roundsd	$9, %xmm0, %xmm0
 	ret
 END(__floor_sse41)
+
+#if MINIMUM_X86_ISA_LEVEL == SSE4_1_X86_ISA_LEVEL
+libm_alias_double (__floor, floor)
+#endif
diff --git a/sysdeps/x86_64/fpu/multiarch/s_floor.c b/sysdeps/x86_64/fpu/multiarch/s_floor.c
index 8cebd48e10..2c87dd0056 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_floor.c
+++ b/sysdeps/x86_64/fpu/multiarch/s_floor.c
@@ -16,17 +16,20 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#define NO_MATH_REDIRECT
-#include <libm-alias-double.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < SSE4_1_X86_ISA_LEVEL
+# define NO_MATH_REDIRECT
+# include <libm-alias-double.h>
 
-#define floor __redirect_floor
-#define __floor __redirect___floor
-#include <math.h>
-#undef floor
-#undef __floor
+# define floor __redirect_floor
+# define __floor __redirect___floor
+# include <math.h>
+# undef floor
+# undef __floor
 
-#define SYMBOL_NAME floor
-#include "ifunc-sse4_1.h"
+# define SYMBOL_NAME floor
+# include "ifunc-sse4_1.h"
 
 libc_ifunc_redirected (__redirect_floor, __floor, IFUNC_SELECTOR ());
 libm_alias_double (__floor, floor)
+#endif
diff --git a/sysdeps/x86_64/fpu/multiarch/s_floorf-avx.S b/sysdeps/x86_64/fpu/multiarch/s_floorf-avx.S
new file mode 100644
index 0000000000..c378baae8e
--- /dev/null
+++ b/sysdeps/x86_64/fpu/multiarch/s_floorf-avx.S
@@ -0,0 +1,28 @@
+/* AVX implementation of floorf function.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <libm-alias-float.h>
+
+	.text
+ENTRY(__floorf)
+	vroundss $9, %xmm0, %xmm0, %xmm0
+	ret
+END(__floorf)
+
+libm_alias_float (__floor, floor)
diff --git a/sysdeps/x86_64/fpu/multiarch/s_floorf-sse4_1.S b/sysdeps/x86_64/fpu/multiarch/s_floorf-sse4_1.S
index 5f6020d27d..c2216899db 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_floorf-sse4_1.S
+++ b/sysdeps/x86_64/fpu/multiarch/s_floorf-sse4_1.S
@@ -17,8 +17,20 @@
 
 #include <sysdep.h>
 
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL == SSE4_1_X86_ISA_LEVEL
+# include <libm-alias-float.h>
+# define __floorf_sse41 __floorf
+	.text
+#else
 	.section .text.sse4.1,"ax",@progbits
+#endif
+
 ENTRY(__floorf_sse41)
 	roundss	$9, %xmm0, %xmm0
 	ret
 END(__floorf_sse41)
+
+#if MINIMUM_X86_ISA_LEVEL == SSE4_1_X86_ISA_LEVEL
+libm_alias_float (__floor, floor)
+#endif
diff --git a/sysdeps/x86_64/fpu/multiarch/s_floorf.c b/sysdeps/x86_64/fpu/multiarch/s_floorf.c
index a14e18b03c..a277802b6d 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_floorf.c
+++ b/sysdeps/x86_64/fpu/multiarch/s_floorf.c
@@ -16,17 +16,20 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#define NO_MATH_REDIRECT
-#include <libm-alias-float.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < SSE4_1_X86_ISA_LEVEL
+# define NO_MATH_REDIRECT
+# include <libm-alias-float.h>
 
-#define floorf __redirect_floorf
-#define __floorf __redirect___floorf
-#include <math.h>
-#undef floorf
-#undef __floorf
+# define floorf __redirect_floorf
+# define __floorf __redirect___floorf
+# include <math.h>
+# undef floorf
+# undef __floorf
 
-#define SYMBOL_NAME floorf
-#include "ifunc-sse4_1.h"
+# define SYMBOL_NAME floorf
+# include "ifunc-sse4_1.h"
 
 libc_ifunc_redirected (__redirect_floorf, __floorf, IFUNC_SELECTOR ());
 libm_alias_float (__floor, floor)
+#endif
diff --git a/sysdeps/x86_64/fpu/multiarch/s_log1p.c b/sysdeps/x86_64/fpu/multiarch/s_log1p.c
index a8e1a3f21b..3fa1185d81 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_log1p.c
+++ b/sysdeps/x86_64/fpu/multiarch/s_log1p.c
@@ -16,14 +16,17 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <libm-alias-double.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < AVX2_X86_ISA_LEVEL
+# include <libm-alias-double.h>
 
 extern double __redirect_log1p (double);
 
-#define SYMBOL_NAME log1p
-#include "ifunc-fma.h"
+# define SYMBOL_NAME log1p
+# include "ifunc-fma.h"
 
 libc_ifunc_redirected (__redirect_log1p, __log1p, IFUNC_SELECTOR ());
 
-#define __log1p __log1p_sse2
+# define __log1p __log1p_sse2
+#endif
 #include <sysdeps/ieee754/dbl-64/s_log1p.c>
diff --git a/sysdeps/x86_64/fpu/multiarch/s_nearbyint-avx.S b/sysdeps/x86_64/fpu/multiarch/s_nearbyint-avx.S
new file mode 100644
index 0000000000..5bfdf73c28
--- /dev/null
+++ b/sysdeps/x86_64/fpu/multiarch/s_nearbyint-avx.S
@@ -0,0 +1,28 @@
+/* AVX implementation of nearbyint function.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <libm-alias-double.h>
+
+	.text
+ENTRY(__nearbyint)
+	vroundsd $0xc, %xmm0, %xmm0, %xmm0
+	ret
+END(__nearbyint)
+
+libm_alias_double (__nearbyint, nearbyint)
diff --git a/sysdeps/x86_64/fpu/multiarch/s_nearbyint-sse4_1.S b/sysdeps/x86_64/fpu/multiarch/s_nearbyint-sse4_1.S
index 674f7eb40a..9d84410a1f 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_nearbyint-sse4_1.S
+++ b/sysdeps/x86_64/fpu/multiarch/s_nearbyint-sse4_1.S
@@ -17,8 +17,20 @@
 
 #include <sysdep.h>
 
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL == SSE4_1_X86_ISA_LEVEL
+# include <libm-alias-double.h>
+# define __nearbyint_sse41 __nearbyint
+	.text
+#else
 	.section .text.sse4.1,"ax",@progbits
+#endif
+
 ENTRY(__nearbyint_sse41)
 	roundsd	$0xc, %xmm0, %xmm0
 	ret
 END(__nearbyint_sse41)
+
+#if MINIMUM_X86_ISA_LEVEL == SSE4_1_X86_ISA_LEVEL
+libm_alias_double (__nearbyint, nearbyint)
+#endif
diff --git a/sysdeps/x86_64/fpu/multiarch/s_nearbyint.c b/sysdeps/x86_64/fpu/multiarch/s_nearbyint.c
index 693e42dd4e..057a7ca60f 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_nearbyint.c
+++ b/sysdeps/x86_64/fpu/multiarch/s_nearbyint.c
@@ -16,17 +16,20 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <libm-alias-double.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < SSE4_1_X86_ISA_LEVEL
+# include <libm-alias-double.h>
 
-#define nearbyint __redirect_nearbyint
-#define __nearbyint __redirect___nearbyint
-#include <math.h>
-#undef nearbyint
-#undef __nearbyint
+# define nearbyint __redirect_nearbyint
+# define __nearbyint __redirect___nearbyint
+# include <math.h>
+# undef nearbyint
+# undef __nearbyint
 
-#define SYMBOL_NAME nearbyint
-#include "ifunc-sse4_1.h"
+# define SYMBOL_NAME nearbyint
+# include "ifunc-sse4_1.h"
 
 libc_ifunc_redirected (__redirect_nearbyint, __nearbyint,
 		       IFUNC_SELECTOR ());
 libm_alias_double (__nearbyint, nearbyint)
+#endif
diff --git a/sysdeps/x86_64/fpu/multiarch/s_nearbyintf-avx.S b/sysdeps/x86_64/fpu/multiarch/s_nearbyintf-avx.S
new file mode 100644
index 0000000000..1dbaed0324
--- /dev/null
+++ b/sysdeps/x86_64/fpu/multiarch/s_nearbyintf-avx.S
@@ -0,0 +1,28 @@
+/* AVX implmentation of nearbyintf function.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <libm-alias-float.h>
+
+	.text
+ENTRY(__nearbyintf)
+	vroundss $0xc, %xmm0, %xmm0, %xmm0
+	ret
+END(__nearbyintf)
+
+libm_alias_float (__nearbyint, nearbyint)
diff --git a/sysdeps/x86_64/fpu/multiarch/s_nearbyintf-sse4_1.S b/sysdeps/x86_64/fpu/multiarch/s_nearbyintf-sse4_1.S
index 5892bd7563..3cf35f92d6 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_nearbyintf-sse4_1.S
+++ b/sysdeps/x86_64/fpu/multiarch/s_nearbyintf-sse4_1.S
@@ -17,8 +17,20 @@
 
 #include <sysdep.h>
 
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL == SSE4_1_X86_ISA_LEVEL
+# include <libm-alias-float.h>
+# define __nearbyintf_sse41 __nearbyintf
+	.text
+#else
 	.section .text.sse4.1,"ax",@progbits
+#endif
+
 ENTRY(__nearbyintf_sse41)
 	roundss	$0xc, %xmm0, %xmm0
 	ret
 END(__nearbyintf_sse41)
+
+#if MINIMUM_X86_ISA_LEVEL == SSE4_1_X86_ISA_LEVEL
+libm_alias_float (__nearbyint, nearbyint)
+#endif
diff --git a/sysdeps/x86_64/fpu/multiarch/s_nearbyintf.c b/sysdeps/x86_64/fpu/multiarch/s_nearbyintf.c
index a0ac009f4b..41f374ba72 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_nearbyintf.c
+++ b/sysdeps/x86_64/fpu/multiarch/s_nearbyintf.c
@@ -16,17 +16,20 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <libm-alias-float.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < SSE4_1_X86_ISA_LEVEL
+# include <libm-alias-float.h>
 
-#define nearbyintf __redirect_nearbyintf
-#define __nearbyintf __redirect___nearbyintf
-#include <math.h>
-#undef nearbyintf
-#undef __nearbyintf
+# define nearbyintf __redirect_nearbyintf
+# define __nearbyintf __redirect___nearbyintf
+# include <math.h>
+# undef nearbyintf
+# undef __nearbyintf
 
-#define SYMBOL_NAME nearbyintf
-#include "ifunc-sse4_1.h"
+# define SYMBOL_NAME nearbyintf
+# include "ifunc-sse4_1.h"
 
 libc_ifunc_redirected (__redirect_nearbyintf, __nearbyintf,
 		       IFUNC_SELECTOR ());
 libm_alias_float (__nearbyint, nearbyint)
+#endif
diff --git a/sysdeps/x86_64/fpu/multiarch/s_rint-avx.S b/sysdeps/x86_64/fpu/multiarch/s_rint-avx.S
new file mode 100644
index 0000000000..2b403b331f
--- /dev/null
+++ b/sysdeps/x86_64/fpu/multiarch/s_rint-avx.S
@@ -0,0 +1,28 @@
+/* AVX implementation of rint function.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <libm-alias-double.h>
+
+	.text
+ENTRY(__rint)
+	vroundsd $4, %xmm0, %xmm0, %xmm0
+	ret
+END(__rint)
+
+libm_alias_double (__rint, rint)
diff --git a/sysdeps/x86_64/fpu/multiarch/s_rint-sse4_1.S b/sysdeps/x86_64/fpu/multiarch/s_rint-sse4_1.S
index 405372991b..8cd9cf759f 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_rint-sse4_1.S
+++ b/sysdeps/x86_64/fpu/multiarch/s_rint-sse4_1.S
@@ -17,8 +17,20 @@
 
 #include <sysdep.h>
 
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL == SSE4_1_X86_ISA_LEVEL
+# include <libm-alias-double.h>
+# define __rint_sse41 __rint
+	.text
+#else
 	.section .text.sse4.1,"ax",@progbits
+#endif
+
 ENTRY(__rint_sse41)
 	roundsd	$4, %xmm0, %xmm0
 	ret
 END(__rint_sse41)
+
+#if MINIMUM_X86_ISA_LEVEL == SSE4_1_X86_ISA_LEVEL
+libm_alias_double (__rint, rint)
+#endif
diff --git a/sysdeps/x86_64/fpu/multiarch/s_rint.c b/sysdeps/x86_64/fpu/multiarch/s_rint.c
index 754c87e004..18623b7d99 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_rint.c
+++ b/sysdeps/x86_64/fpu/multiarch/s_rint.c
@@ -16,17 +16,20 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#define NO_MATH_REDIRECT
-#include <libm-alias-double.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < SSE4_1_X86_ISA_LEVEL
+# define NO_MATH_REDIRECT
+# include <libm-alias-double.h>
 
-#define rint __redirect_rint
-#define __rint __redirect___rint
-#include <math.h>
-#undef rint
-#undef __rint
+# define rint __redirect_rint
+# define __rint __redirect___rint
+# include <math.h>
+# undef rint
+# undef __rint
 
-#define SYMBOL_NAME rint
-#include "ifunc-sse4_1.h"
+# define SYMBOL_NAME rint
+# include "ifunc-sse4_1.h"
 
 libc_ifunc_redirected (__redirect_rint, __rint, IFUNC_SELECTOR ());
 libm_alias_double (__rint, rint)
+#endif
diff --git a/sysdeps/x86_64/fpu/multiarch/s_rintf-avx.S b/sysdeps/x86_64/fpu/multiarch/s_rintf-avx.S
new file mode 100644
index 0000000000..171c2867f4
--- /dev/null
+++ b/sysdeps/x86_64/fpu/multiarch/s_rintf-avx.S
@@ -0,0 +1,28 @@
+/* AVX implementation of rintf function.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <libm-alias-float.h>
+
+	.text
+ENTRY(__rintf)
+	vroundss $4, %xmm0, %xmm0, %xmm0
+	ret
+END(__rintf)
+
+libm_alias_float (__rint, rint)
diff --git a/sysdeps/x86_64/fpu/multiarch/s_rintf-sse4_1.S b/sysdeps/x86_64/fpu/multiarch/s_rintf-sse4_1.S
index 8ac67ce767..fc1e70f0c9 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_rintf-sse4_1.S
+++ b/sysdeps/x86_64/fpu/multiarch/s_rintf-sse4_1.S
@@ -17,8 +17,20 @@
 
 #include <sysdep.h>
 
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL == SSE4_1_X86_ISA_LEVEL
+# include <libm-alias-float.h>
+# define __rintf_sse41 __rintf
+	.text
+#else
 	.section .text.sse4.1,"ax",@progbits
+#endif
+
 ENTRY(__rintf_sse41)
 	roundss	$4, %xmm0, %xmm0
 	ret
 END(__rintf_sse41)
+
+#if MINIMUM_X86_ISA_LEVEL == SSE4_1_X86_ISA_LEVEL
+libm_alias_float (__rint, rint)
+#endif
diff --git a/sysdeps/x86_64/fpu/multiarch/s_rintf.c b/sysdeps/x86_64/fpu/multiarch/s_rintf.c
index e9d6b7a5f2..e275368dec 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_rintf.c
+++ b/sysdeps/x86_64/fpu/multiarch/s_rintf.c
@@ -16,17 +16,20 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#define NO_MATH_REDIRECT
-#include <libm-alias-float.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < SSE4_1_X86_ISA_LEVEL
+# define NO_MATH_REDIRECT
+# include <libm-alias-float.h>
 
-#define rintf __redirect_rintf
-#define __rintf __redirect___rintf
-#include <math.h>
-#undef rintf
-#undef __rintf
+# define rintf __redirect_rintf
+# define __rintf __redirect___rintf
+# include <math.h>
+# undef rintf
+# undef __rintf
 
-#define SYMBOL_NAME rintf
-#include "ifunc-sse4_1.h"
+# define SYMBOL_NAME rintf
+# include "ifunc-sse4_1.h"
 
 libc_ifunc_redirected (__redirect_rintf, __rintf, IFUNC_SELECTOR ());
 libm_alias_float (__rint, rint)
+#endif
diff --git a/sysdeps/x86_64/fpu/multiarch/s_roundeven-avx.S b/sysdeps/x86_64/fpu/multiarch/s_roundeven-avx.S
new file mode 100644
index 0000000000..576790355c
--- /dev/null
+++ b/sysdeps/x86_64/fpu/multiarch/s_roundeven-avx.S
@@ -0,0 +1,28 @@
+/* AVX implementation of roundeven function.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <libm-alias-double.h>
+
+	.text
+ENTRY(__roundeven)
+	vroundsd $8, %xmm0, %xmm0, %xmm0
+	ret
+END(__roundeven)
+
+libm_alias_double (__roundeven, roundeven)
diff --git a/sysdeps/x86_64/fpu/multiarch/s_roundeven-sse4_1.S b/sysdeps/x86_64/fpu/multiarch/s_roundeven-sse4_1.S
index 5ef102336b..f00be56c59 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_roundeven-sse4_1.S
+++ b/sysdeps/x86_64/fpu/multiarch/s_roundeven-sse4_1.S
@@ -17,8 +17,20 @@
 
 #include <sysdep.h>
 
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL == SSE4_1_X86_ISA_LEVEL
+# include <libm-alias-double.h>
+# define __roundeven_sse41 __roundeven
+	.text
+#else
 	.section .text.sse4.1,"ax",@progbits
+#endif
+
 ENTRY(__roundeven_sse41)
 	roundsd	$8, %xmm0, %xmm0
 	ret
 END(__roundeven_sse41)
+
+#if MINIMUM_X86_ISA_LEVEL == SSE4_1_X86_ISA_LEVEL
+libm_alias_double (__roundeven, roundeven)
+#endif
diff --git a/sysdeps/x86_64/fpu/multiarch/s_roundeven.c b/sysdeps/x86_64/fpu/multiarch/s_roundeven.c
index 8737b32e26..139aad088f 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_roundeven.c
+++ b/sysdeps/x86_64/fpu/multiarch/s_roundeven.c
@@ -16,16 +16,19 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <libm-alias-double.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < SSE4_1_X86_ISA_LEVEL
+# include <libm-alias-double.h>
 
-#define roundeven __redirect_roundeven
-#define __roundeven __redirect___roundeven
-#include <math.h>
-#undef roundeven
-#undef __roundeven
+# define roundeven __redirect_roundeven
+# define __roundeven __redirect___roundeven
+# include <math.h>
+# undef roundeven
+# undef __roundeven
 
-#define SYMBOL_NAME roundeven
-#include "ifunc-sse4_1.h"
+# define SYMBOL_NAME roundeven
+# include "ifunc-sse4_1.h"
 
 libc_ifunc_redirected (__redirect_roundeven, __roundeven, IFUNC_SELECTOR ());
 libm_alias_double (__roundeven, roundeven)
+#endif
diff --git a/sysdeps/x86_64/fpu/multiarch/s_roundevenf-avx.S b/sysdeps/x86_64/fpu/multiarch/s_roundevenf-avx.S
new file mode 100644
index 0000000000..42c359f4cd
--- /dev/null
+++ b/sysdeps/x86_64/fpu/multiarch/s_roundevenf-avx.S
@@ -0,0 +1,28 @@
+/* AVX implementation of roundevenf function.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <libm-alias-float.h>
+
+	.text
+ENTRY(__roundevenf)
+	vroundss $8, %xmm0, %xmm0, %xmm0
+	ret
+END(__roundevenf)
+
+libm_alias_float (__roundeven, roundeven)
diff --git a/sysdeps/x86_64/fpu/multiarch/s_roundevenf-sse4_1.S b/sysdeps/x86_64/fpu/multiarch/s_roundevenf-sse4_1.S
index 792c90ba07..6b148e4353 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_roundevenf-sse4_1.S
+++ b/sysdeps/x86_64/fpu/multiarch/s_roundevenf-sse4_1.S
@@ -17,8 +17,20 @@
 
 #include <sysdep.h>
 
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL == SSE4_1_X86_ISA_LEVEL
+# include <libm-alias-float.h>
+# define __roundevenf_sse41 __roundevenf
+	.text
+#else
 	.section .text.sse4.1,"ax",@progbits
+#endif
+
 ENTRY(__roundevenf_sse41)
 	roundss	$8, %xmm0, %xmm0
 	ret
 END(__roundevenf_sse41)
+
+#if MINIMUM_X86_ISA_LEVEL == SSE4_1_X86_ISA_LEVEL
+libm_alias_float (__roundeven, roundeven)
+#endif
diff --git a/sysdeps/x86_64/fpu/multiarch/s_roundevenf.c b/sysdeps/x86_64/fpu/multiarch/s_roundevenf.c
index e96016a4d5..2fb090075d 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_roundevenf.c
+++ b/sysdeps/x86_64/fpu/multiarch/s_roundevenf.c
@@ -16,16 +16,19 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <libm-alias-float.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < SSE4_1_X86_ISA_LEVEL
+# include <libm-alias-float.h>
 
-#define roundevenf __redirect_roundevenf
-#define __roundevenf __redirect___roundevenf
-#include <math.h>
-#undef roundevenf
-#undef __roundevenf
+# define roundevenf __redirect_roundevenf
+# define __roundevenf __redirect___roundevenf
+# include <math.h>
+# undef roundevenf
+# undef __roundevenf
 
-#define SYMBOL_NAME roundevenf
-#include "ifunc-sse4_1.h"
+# define SYMBOL_NAME roundevenf
+# include "ifunc-sse4_1.h"
 
 libc_ifunc_redirected (__redirect_roundevenf, __roundevenf, IFUNC_SELECTOR ());
 libm_alias_float (__roundeven, roundeven)
+#endif
diff --git a/sysdeps/x86_64/fpu/multiarch/s_sin.c b/sysdeps/x86_64/fpu/multiarch/s_sin.c
index 355cc0092e..21e77943a3 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_sin.c
+++ b/sysdeps/x86_64/fpu/multiarch/s_sin.c
@@ -16,24 +16,27 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <libm-alias-double.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < AVX2_X86_ISA_LEVEL
+# include <libm-alias-double.h>
 
 extern double __redirect_sin (double);
 extern double __redirect_cos (double);
 
-#define SYMBOL_NAME sin
-#include "ifunc-avx-fma4.h"
+# define SYMBOL_NAME sin
+# include "ifunc-avx-fma4.h"
 
 libc_ifunc_redirected (__redirect_sin, __sin, IFUNC_SELECTOR ());
 libm_alias_double (__sin, sin)
 
-#undef SYMBOL_NAME
-#define SYMBOL_NAME cos
-#include "ifunc-avx-fma4.h"
+# undef SYMBOL_NAME
+# define SYMBOL_NAME cos
+# include "ifunc-avx-fma4.h"
 
 libc_ifunc_redirected (__redirect_cos, __cos, IFUNC_SELECTOR ());
 libm_alias_double (__cos, cos)
 
-#define __cos __cos_sse2
-#define __sin __sin_sse2
+# define __cos __cos_sse2
+# define __sin __sin_sse2
+#endif
 #include <sysdeps/ieee754/dbl-64/s_sin.c>
diff --git a/sysdeps/x86_64/fpu/multiarch/s_sincos.c b/sysdeps/x86_64/fpu/multiarch/s_sincos.c
index 70107e999c..b35757f8de 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_sincos.c
+++ b/sysdeps/x86_64/fpu/multiarch/s_sincos.c
@@ -16,15 +16,18 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <libm-alias-double.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < AVX2_X86_ISA_LEVEL
+# include <libm-alias-double.h>
 
 extern void __redirect_sincos (double, double *, double *);
 
-#define SYMBOL_NAME sincos
-#include "ifunc-fma4.h"
+# define SYMBOL_NAME sincos
+# include "ifunc-fma4.h"
 
 libc_ifunc_redirected (__redirect_sincos, __sincos, IFUNC_SELECTOR ());
 libm_alias_double (__sincos, sincos)
 
-#define __sincos __sincos_sse2
+# define __sincos __sincos_sse2
+#endif
 #include <sysdeps/ieee754/dbl-64/s_sincos.c>
diff --git a/sysdeps/x86_64/fpu/multiarch/s_sincosf.c b/sysdeps/x86_64/fpu/multiarch/s_sincosf.c
index 80bc028451..0ea9b40e84 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_sincosf.c
+++ b/sysdeps/x86_64/fpu/multiarch/s_sincosf.c
@@ -16,13 +16,18 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <libm-alias-float.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < AVX2_X86_ISA_LEVEL
+# include <libm-alias-float.h>
 
 extern void __redirect_sincosf (float, float *, float *);
 
-#define SYMBOL_NAME sincosf
-#include "ifunc-fma.h"
+# define SYMBOL_NAME sincosf
+# include "ifunc-fma.h"
 
 libc_ifunc_redirected (__redirect_sincosf, __sincosf, IFUNC_SELECTOR ());
 
 libm_alias_float (__sincos, sincos)
+#else
+# include <sysdeps/ieee754/flt-32/s_sincosf.c>
+#endif
diff --git a/sysdeps/x86_64/fpu/multiarch/s_sinf.c b/sysdeps/x86_64/fpu/multiarch/s_sinf.c
index a32b9e9550..c61624e3ee 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_sinf.c
+++ b/sysdeps/x86_64/fpu/multiarch/s_sinf.c
@@ -16,13 +16,18 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <libm-alias-float.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < AVX2_X86_ISA_LEVEL
+# include <libm-alias-float.h>
 
 extern float __redirect_sinf (float);
 
-#define SYMBOL_NAME sinf
-#include "ifunc-fma.h"
+# define SYMBOL_NAME sinf
+# include "ifunc-fma.h"
 
 libc_ifunc_redirected (__redirect_sinf, __sinf, IFUNC_SELECTOR ());
 
 libm_alias_float (__sin, sin)
+#else
+# include <sysdeps/ieee754/flt-32/s_sinf.c>
+#endif
diff --git a/sysdeps/x86_64/fpu/multiarch/s_tan.c b/sysdeps/x86_64/fpu/multiarch/s_tan.c
index f9a2474a13..125d992ba1 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_tan.c
+++ b/sysdeps/x86_64/fpu/multiarch/s_tan.c
@@ -16,15 +16,18 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#include <libm-alias-double.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < AVX2_X86_ISA_LEVEL
+# include <libm-alias-double.h>
 
 extern double __redirect_tan (double);
 
-#define SYMBOL_NAME tan
-#include "ifunc-avx-fma4.h"
+# define SYMBOL_NAME tan
+# include "ifunc-avx-fma4.h"
 
 libc_ifunc_redirected (__redirect_tan, __tan, IFUNC_SELECTOR ());
 libm_alias_double (__tan, tan)
 
-#define __tan __tan_sse2
+# define __tan __tan_sse2
+#endif
 #include <sysdeps/ieee754/dbl-64/s_tan.c>
diff --git a/sysdeps/x86_64/fpu/multiarch/s_tanh-fma.c b/sysdeps/x86_64/fpu/multiarch/s_tanh-fma.c
new file mode 100644
index 0000000000..1b808b1227
--- /dev/null
+++ b/sysdeps/x86_64/fpu/multiarch/s_tanh-fma.c
@@ -0,0 +1,11 @@
+#define __tanh __tanh_fma
+#define __expm1 __expm1_fma
+
+/* NB: __expm1 may be expanded to __expm1_fma in the following
+   prototypes.  */
+extern long double __expm1l (long double);
+extern long double __expm1f128 (long double);
+
+#define SECTION __attribute__ ((section (".text.fma")))
+
+#include <sysdeps/ieee754/dbl-64/s_tanh.c>
diff --git a/sysdeps/x86_64/fpu/multiarch/s_tanh.c b/sysdeps/x86_64/fpu/multiarch/s_tanh.c
new file mode 100644
index 0000000000..5539b6c61c
--- /dev/null
+++ b/sysdeps/x86_64/fpu/multiarch/s_tanh.c
@@ -0,0 +1,31 @@
+/* Multiple versions of tanh.
+   Copyright (C) 2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < AVX2_X86_ISA_LEVEL
+
+extern double __redirect_tanh (double);
+
+# define SYMBOL_NAME tanh
+# include "ifunc-fma.h"
+
+libc_ifunc_redirected (__redirect_tanh, __tanh, IFUNC_SELECTOR ());
+
+# define __tanh __tanh_sse2
+#endif
+#include <sysdeps/ieee754/dbl-64/s_tanh.c>
diff --git a/sysdeps/x86_64/fpu/multiarch/s_trunc-avx.S b/sysdeps/x86_64/fpu/multiarch/s_trunc-avx.S
new file mode 100644
index 0000000000..b3e87e9606
--- /dev/null
+++ b/sysdeps/x86_64/fpu/multiarch/s_trunc-avx.S
@@ -0,0 +1,28 @@
+/* AVX implementation of trunc function.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <libm-alias-double.h>
+
+	.text
+ENTRY(__trunc)
+	vroundsd $11, %xmm0, %xmm0, %xmm0
+	ret
+END(__trunc)
+
+libm_alias_double (__trunc, trunc)
diff --git a/sysdeps/x86_64/fpu/multiarch/s_trunc-sse4_1.S b/sysdeps/x86_64/fpu/multiarch/s_trunc-sse4_1.S
index b496a6ef49..2b79174eed 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_trunc-sse4_1.S
+++ b/sysdeps/x86_64/fpu/multiarch/s_trunc-sse4_1.S
@@ -18,8 +18,20 @@
 
 #include <sysdep.h>
 
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL == SSE4_1_X86_ISA_LEVEL
+# include <libm-alias-double.h>
+# define __trunc_sse41 __trunc
+	.text
+#else
 	.section .text.sse4.1,"ax",@progbits
+#endif
+
 ENTRY(__trunc_sse41)
 	roundsd	$11, %xmm0, %xmm0
 	ret
 END(__trunc_sse41)
+
+#if MINIMUM_X86_ISA_LEVEL == SSE4_1_X86_ISA_LEVEL
+libm_alias_double (__trunc, trunc)
+#endif
diff --git a/sysdeps/x86_64/fpu/multiarch/s_trunc.c b/sysdeps/x86_64/fpu/multiarch/s_trunc.c
index 9bc9df8744..ea89c4f85d 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_trunc.c
+++ b/sysdeps/x86_64/fpu/multiarch/s_trunc.c
@@ -16,17 +16,20 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#define NO_MATH_REDIRECT
-#include <libm-alias-double.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < SSE4_1_X86_ISA_LEVEL
+# define NO_MATH_REDIRECT
+# include <libm-alias-double.h>
 
-#define trunc __redirect_trunc
-#define __trunc __redirect___trunc
-#include <math.h>
-#undef trunc
-#undef __trunc
+# define trunc __redirect_trunc
+# define __trunc __redirect___trunc
+# include <math.h>
+# undef trunc
+# undef __trunc
 
-#define SYMBOL_NAME trunc
-#include "ifunc-sse4_1.h"
+# define SYMBOL_NAME trunc
+# include "ifunc-sse4_1.h"
 
 libc_ifunc_redirected (__redirect_trunc, __trunc, IFUNC_SELECTOR ());
 libm_alias_double (__trunc, trunc)
+#endif
diff --git a/sysdeps/x86_64/fpu/multiarch/s_truncf-avx.S b/sysdeps/x86_64/fpu/multiarch/s_truncf-avx.S
new file mode 100644
index 0000000000..f31ac7d7f7
--- /dev/null
+++ b/sysdeps/x86_64/fpu/multiarch/s_truncf-avx.S
@@ -0,0 +1,28 @@
+/* AVX implementation of truncf function.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <libm-alias-float.h>
+
+	.text
+ENTRY(__truncf)
+	vroundss $11, %xmm0, %xmm0, %xmm0
+	ret
+END(__truncf)
+
+libm_alias_float (__trunc, trunc)
diff --git a/sysdeps/x86_64/fpu/multiarch/s_truncf-sse4_1.S b/sysdeps/x86_64/fpu/multiarch/s_truncf-sse4_1.S
index 22e9a83307..60498b2cb2 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_truncf-sse4_1.S
+++ b/sysdeps/x86_64/fpu/multiarch/s_truncf-sse4_1.S
@@ -18,8 +18,20 @@
 
 #include <sysdep.h>
 
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL == SSE4_1_X86_ISA_LEVEL
+# include <libm-alias-float.h>
+# define __truncf_sse41 __truncf
+	.text
+#else
 	.section .text.sse4.1,"ax",@progbits
+#endif
+
 ENTRY(__truncf_sse41)
 	roundss	$11, %xmm0, %xmm0
 	ret
 END(__truncf_sse41)
+
+#if MINIMUM_X86_ISA_LEVEL == SSE4_1_X86_ISA_LEVEL
+libm_alias_float (__trunc, trunc)
+#endif
diff --git a/sysdeps/x86_64/fpu/multiarch/s_truncf.c b/sysdeps/x86_64/fpu/multiarch/s_truncf.c
index dae01d166a..92435ce39d 100644
--- a/sysdeps/x86_64/fpu/multiarch/s_truncf.c
+++ b/sysdeps/x86_64/fpu/multiarch/s_truncf.c
@@ -16,17 +16,20 @@
    License along with the GNU C Library; if not, see
    <https://www.gnu.org/licenses/>.  */
 
-#define NO_MATH_REDIRECT
-#include <libm-alias-float.h>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL < SSE4_1_X86_ISA_LEVEL
+# define NO_MATH_REDIRECT
+# include <libm-alias-float.h>
 
-#define truncf __redirect_truncf
-#define __truncf __redirect___truncf
-#include <math.h>
-#undef truncf
-#undef __truncf
+# define truncf __redirect_truncf
+# define __truncf __redirect___truncf
+# include <math.h>
+# undef truncf
+# undef __truncf
 
-#define SYMBOL_NAME truncf
-#include "ifunc-sse4_1.h"
+# define SYMBOL_NAME truncf
+# include "ifunc-sse4_1.h"
 
 libc_ifunc_redirected (__redirect_truncf, __truncf, IFUNC_SELECTOR ());
 libm_alias_float (__trunc, trunc)
+#endif
diff --git a/sysdeps/x86_64/fpu/multiarch/w_exp.c b/sysdeps/x86_64/fpu/multiarch/w_exp.c
index 27eee98a0a..3584187e0e 100644
--- a/sysdeps/x86_64/fpu/multiarch/w_exp.c
+++ b/sysdeps/x86_64/fpu/multiarch/w_exp.c
@@ -1 +1,6 @@
-#include <sysdeps/../math/w_exp.c>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL >= AVX2_X86_ISA_LEVEL
+# include <sysdeps/ieee754/dbl-64/w_exp.c>
+#else
+# include <sysdeps/../math/w_exp.c>
+#endif
diff --git a/sysdeps/x86_64/fpu/multiarch/w_log.c b/sysdeps/x86_64/fpu/multiarch/w_log.c
index 9b2b018711..414ca3ca3d 100644
--- a/sysdeps/x86_64/fpu/multiarch/w_log.c
+++ b/sysdeps/x86_64/fpu/multiarch/w_log.c
@@ -1 +1,6 @@
-#include <sysdeps/../math/w_log.c>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL >= AVX2_X86_ISA_LEVEL
+# include <sysdeps/ieee754/dbl-64/w_log.c>
+#else
+# include <sysdeps/../math/w_log.c>
+#endif
diff --git a/sysdeps/x86_64/fpu/multiarch/w_pow.c b/sysdeps/x86_64/fpu/multiarch/w_pow.c
index b50c1988de..d5fcc4f871 100644
--- a/sysdeps/x86_64/fpu/multiarch/w_pow.c
+++ b/sysdeps/x86_64/fpu/multiarch/w_pow.c
@@ -1 +1,6 @@
-#include <sysdeps/../math/w_pow.c>
+#include <sysdeps/x86/isa-level.h>
+#if MINIMUM_X86_ISA_LEVEL >= AVX2_X86_ISA_LEVEL
+# include <sysdeps/ieee754/dbl-64/w_pow.c>
+#else
+# include <sysdeps/../math/w_pow.c>
+#endif
diff --git a/sysdeps/x86_64/multiarch/Makefile b/sysdeps/x86_64/multiarch/Makefile
index e1e894c963..d3d2270394 100644
--- a/sysdeps/x86_64/multiarch/Makefile
+++ b/sysdeps/x86_64/multiarch/Makefile
@@ -4,8 +4,8 @@ sysdep_routines += \
   memchr-avx2 \
   memchr-avx2-rtm \
   memchr-evex \
-  memchr-evex512 \
   memchr-evex-rtm \
+  memchr-evex512 \
   memchr-sse2 \
   memcmp-avx2-movbe \
   memcmp-avx2-movbe-rtm \
@@ -37,8 +37,8 @@ sysdep_routines += \
   rawmemchr-avx2 \
   rawmemchr-avx2-rtm \
   rawmemchr-evex \
-  rawmemchr-evex512 \
   rawmemchr-evex-rtm \
+  rawmemchr-evex512 \
   rawmemchr-sse2 \
   stpcpy-avx2 \
   stpcpy-avx2-rtm \
diff --git a/sysdeps/x86_64/multiarch/ifunc-impl-list.c b/sysdeps/x86_64/multiarch/ifunc-impl-list.c
index c4a21d4b7c..c34c94cb58 100644
--- a/sysdeps/x86_64/multiarch/ifunc-impl-list.c
+++ b/sysdeps/x86_64/multiarch/ifunc-impl-list.c
@@ -928,7 +928,7 @@ __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
 				     (CPU_FEATURE_USABLE (AVX2)
 				      && CPU_FEATURE_USABLE (BMI2)),
 				     __wcsncpy_avx2)
-	      X86_IFUNC_IMPL_ADD_V2 (array, i, wcpncpy,
+	      X86_IFUNC_IMPL_ADD_V2 (array, i, wcsncpy,
 				     1,
 				     __wcsncpy_generic))
 
@@ -958,7 +958,7 @@ __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
 				     (CPU_FEATURE_USABLE (AVX2)
 				      && CPU_FEATURE_USABLE (BMI2)),
 				     __wcpncpy_avx2)
-	      X86_IFUNC_IMPL_ADD_V2 (array, i, wcsncpy,
+	      X86_IFUNC_IMPL_ADD_V2 (array, i, wcpncpy,
 				     1,
 				     __wcpncpy_generic))
 
diff --git a/sysdeps/x86_64/multiarch/ifunc-wmemset.h b/sysdeps/x86_64/multiarch/ifunc-wmemset.h
index 6e20d9dd5a..727b69f95b 100644
--- a/sysdeps/x86_64/multiarch/ifunc-wmemset.h
+++ b/sysdeps/x86_64/multiarch/ifunc-wmemset.h
@@ -35,7 +35,7 @@ IFUNC_SELECTOR (void)
 
   if (X86_ISA_CPU_FEATURE_USABLE_P (cpu_features, AVX2)
       && X86_ISA_CPU_FEATURES_ARCH_P (cpu_features,
-				      AVX_Fast_Unaligned_Load, !))
+				      AVX_Fast_Unaligned_Load,))
     {
       if (X86_ISA_CPU_FEATURE_USABLE_P (cpu_features, AVX512VL))
 	{
diff --git a/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S b/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
index 9984c3ca0f..88bf08e4f4 100644
--- a/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
+++ b/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
@@ -21,8 +21,13 @@
    2. If size is less than VEC, use integer register stores.
    3. If size is from VEC_SIZE to 2 * VEC_SIZE, use 2 VEC stores.
    4. If size is from 2 * VEC_SIZE to 4 * VEC_SIZE, use 4 VEC stores.
-   5. If size is more to 4 * VEC_SIZE, align to 4 * VEC_SIZE with
-      4 VEC stores and store 4 * VEC at a time until done.  */
+   5. If size is more to 4 * VEC_SIZE, align to 1 * VEC_SIZE with
+      4 VEC stores and store 4 * VEC at a time until done.
+   6. On machines ERMS feature, if size is range
+	  [__x86_rep_stosb_threshold, __x86_memset_non_temporal_threshold)
+	  then REP STOSB will be used.
+   7. If size >= __x86_memset_non_temporal_threshold, use a
+	  non-temporal stores.  */
 
 #include <sysdep.h>
 
@@ -145,6 +150,41 @@ L(entry_from_wmemset):
 	VMOVU	%VMM(0), -VEC_SIZE(%rdi,%rdx)
 	VMOVU	%VMM(0), (%rdi)
 	VZEROUPPER_RETURN
+
+	/* If have AVX512 mask instructions put L(less_vec) close to
+	   entry as it doesn't take much space and is likely a hot target.  */
+#ifdef USE_LESS_VEC_MASK_STORE
+    /* Align to ensure the L(less_vec) logic all fits in 1x cache lines.  */
+	.p2align 6,, 47
+	.p2align 4
+L(less_vec):
+L(less_vec_from_wmemset):
+	/* Less than 1 VEC.  */
+# if VEC_SIZE != 16 && VEC_SIZE != 32 && VEC_SIZE != 64
+#  error Unsupported VEC_SIZE!
+# endif
+	/* Clear high bits from edi. Only keeping bits relevant to page
+	   cross check. Note that we are using rax which is set in
+	   MEMSET_VDUP_TO_VEC0_AND_SET_RETURN as ptr from here on out.  */
+	andl	$(PAGE_SIZE - 1), %edi
+	/* Check if VEC_SIZE store cross page. Mask stores suffer
+	   serious performance degradation when it has to fault suppress.  */
+	cmpl	$(PAGE_SIZE - VEC_SIZE), %edi
+	/* This is generally considered a cold target.  */
+	ja	L(cross_page)
+# if VEC_SIZE > 32
+	movq	$-1, %rcx
+	bzhiq	%rdx, %rcx, %rcx
+	kmovq	%rcx, %k1
+# else
+	movl	$-1, %ecx
+	bzhil	%edx, %ecx, %ecx
+	kmovd	%ecx, %k1
+# endif
+	vmovdqu8 %VMM(0), (%rax){%k1}
+	VZEROUPPER_RETURN
+#endif
+
 #if defined USE_MULTIARCH && IS_IN (libc)
 END (MEMSET_SYMBOL (__memset, unaligned))
 
@@ -183,54 +223,6 @@ L(last_2x_vec):
 #endif
 	VZEROUPPER_RETURN
 
-	/* If have AVX512 mask instructions put L(less_vec) close to
-	   entry as it doesn't take much space and is likely a hot target.
-	 */
-#ifdef USE_LESS_VEC_MASK_STORE
-	.p2align 4,, 10
-L(less_vec):
-L(less_vec_from_wmemset):
-	/* Less than 1 VEC.  */
-# if VEC_SIZE != 16 && VEC_SIZE != 32 && VEC_SIZE != 64
-#  error Unsupported VEC_SIZE!
-# endif
-	/* Clear high bits from edi. Only keeping bits relevant to page
-	   cross check. Note that we are using rax which is set in
-	   MEMSET_VDUP_TO_VEC0_AND_SET_RETURN as ptr from here on out.  */
-	andl	$(PAGE_SIZE - 1), %edi
-	/* Check if VEC_SIZE store cross page. Mask stores suffer
-	   serious performance degradation when it has to fault suppress.
-	 */
-	cmpl	$(PAGE_SIZE - VEC_SIZE), %edi
-	/* This is generally considered a cold target.  */
-	ja	L(cross_page)
-# if VEC_SIZE > 32
-	movq	$-1, %rcx
-	bzhiq	%rdx, %rcx, %rcx
-	kmovq	%rcx, %k1
-# else
-	movl	$-1, %ecx
-	bzhil	%edx, %ecx, %ecx
-	kmovd	%ecx, %k1
-# endif
-	vmovdqu8 %VMM(0), (%rax){%k1}
-	VZEROUPPER_RETURN
-
-# if defined USE_MULTIARCH && IS_IN (libc)
-	/* Include L(stosb_local) here if including L(less_vec) between
-	   L(stosb_more_2x_vec) and ENTRY. This is to cache align the
-	   L(stosb_more_2x_vec) target.  */
-	.p2align 4,, 10
-L(stosb_local):
-	movzbl	%sil, %eax
-	mov	%RDX_LP, %RCX_LP
-	mov	%RDI_LP, %RDX_LP
-	rep	stosb
-	mov	%RDX_LP, %RAX_LP
-	VZEROUPPER_RETURN
-# endif
-#endif
-
 #if defined USE_MULTIARCH && IS_IN (libc)
 	.p2align 4
 L(stosb_more_2x_vec):
@@ -316,21 +308,33 @@ L(return_vzeroupper):
 	ret
 #endif
 
-	.p2align 4,, 10
-#ifndef USE_LESS_VEC_MASK_STORE
-# if defined USE_MULTIARCH && IS_IN (libc)
+#ifdef USE_WITH_AVX2
+	.p2align 4
+#else
+	.p2align 4,, 4
+#endif
+
+#if defined USE_MULTIARCH && IS_IN (libc)
 	/* If no USE_LESS_VEC_MASK put L(stosb_local) here. Will be in
 	   range for 2-byte jump encoding.  */
 L(stosb_local):
+	cmp	__x86_memset_non_temporal_threshold(%rip), %RDX_LP
+	jae	L(nt_memset)
 	movzbl	%sil, %eax
 	mov	%RDX_LP, %RCX_LP
 	mov	%RDI_LP, %RDX_LP
 	rep	stosb
+# if (defined USE_WITH_SSE2) || (defined USE_WITH_AVX512)
+	/* Use xchg to save 1-byte (this helps align targets below).  */
+	xchg	%RDX_LP, %RAX_LP
+# else
 	mov	%RDX_LP, %RAX_LP
-	VZEROUPPER_RETURN
 # endif
+	VZEROUPPER_RETURN
+#endif
+#ifndef USE_LESS_VEC_MASK_STORE
 	/* Define L(less_vec) only if not otherwise defined.  */
-	.p2align 4
+	.p2align 4,, 12
 L(less_vec):
 	/* Broadcast esi to partial register (i.e VEC_SIZE == 32 broadcast to
 	   xmm). This is only does anything for AVX2.  */
@@ -421,4 +425,35 @@ L(between_2_3):
 	movb	%SET_REG8, -1(%LESS_VEC_REG, %rdx)
 #endif
 	ret
-END (MEMSET_SYMBOL (__memset, unaligned_erms))
+
+#if defined USE_MULTIARCH && IS_IN (libc)
+# ifdef USE_WITH_AVX512
+	/* Force align so the loop doesn't cross a cache-line.  */
+	.p2align 4
+# endif
+	.p2align 4,, 7
+    /* Memset using non-temporal stores.  */
+L(nt_memset):
+	VMOVU	%VMM(0), (VEC_SIZE * 0)(%rdi)
+	leaq	(VEC_SIZE * -4)(%rdi, %rdx), %rdx
+    /* Align DST.  */
+	orq	$(VEC_SIZE * 1 - 1), %rdi
+	incq	%rdi
+	.p2align 4,, 7
+L(nt_loop):
+	VMOVNT	%VMM(0), (VEC_SIZE * 0)(%rdi)
+	VMOVNT	%VMM(0), (VEC_SIZE * 1)(%rdi)
+	VMOVNT	%VMM(0), (VEC_SIZE * 2)(%rdi)
+	VMOVNT	%VMM(0), (VEC_SIZE * 3)(%rdi)
+	subq	$(VEC_SIZE * -4), %rdi
+	cmpq	%rdx, %rdi
+	jb	L(nt_loop)
+	sfence
+	VMOVU	%VMM(0), (VEC_SIZE * 0)(%rdx)
+	VMOVU	%VMM(0), (VEC_SIZE * 1)(%rdx)
+	VMOVU	%VMM(0), (VEC_SIZE * 2)(%rdx)
+	VMOVU	%VMM(0), (VEC_SIZE * 3)(%rdx)
+	VZEROUPPER_RETURN
+#endif
+
+END(MEMSET_SYMBOL(__memset, unaligned_erms))
diff --git a/sysdeps/x86_64/multiarch/strchr-evex-base.S b/sysdeps/x86_64/multiarch/strchr-evex-base.S
index 04e2c0e79e..3a0b7c9d64 100644
--- a/sysdeps/x86_64/multiarch/strchr-evex-base.S
+++ b/sysdeps/x86_64/multiarch/strchr-evex-base.S
@@ -124,13 +124,13 @@ L(page_cross):
 	VPCMPNE	%VMM(1), %VMM(0), %k1
 	VPTEST	%VMM(1), %VMM(1), %k0{%k1}
 	KMOV	%k0, %VRAX
-# ifdef USE_AS_WCSCHR
+	sar	%cl, %VRAX
+#ifdef USE_AS_WCSCHR
 	sub	$VEC_MATCH_MASK, %VRAX
-# else
+#else
 	inc	%VRAX
-# endif
+#endif
 	/* Ignore number of character for alignment adjustment.  */
-	shr	%cl, %VRAX
 	jz	L(align_more)
 
 	bsf	%VRAX, %VRAX
diff --git a/sysdeps/x86_64/multiarch/strcmp-evex.S b/sysdeps/x86_64/multiarch/strcmp-evex.S
index 06730ab2a1..cea034f394 100644
--- a/sysdeps/x86_64/multiarch/strcmp-evex.S
+++ b/sysdeps/x86_64/multiarch/strcmp-evex.S
@@ -209,7 +209,9 @@
    returned.  */
 
 	.section SECTION(.text), "ax", @progbits
-	.align	16
+	/* Align 64 bytes here. This is to get the L(loop) block ideally
+	   aligned for the DSB.  */
+	.align	64
 	.type	STRCMP, @function
 	.globl	STRCMP
 # ifdef USE_AS_STRCASECMP_L
@@ -509,9 +511,7 @@ L(ret4):
 	ret
 # endif
 
-	/* 32 byte align here ensures the main loop is ideally aligned
-	   for DSB.  */
-	.p2align 5
+	.p2align 4,, 4
 L(more_3x_vec):
 	/* Safe to compare 4x vectors.  */
 	VMOVU	(VEC_SIZE)(%rdi), %VMM(0)
@@ -1426,10 +1426,9 @@ L(less_32_till_page):
 L(ret_zero_page_cross_slow_case0):
 	xorl	%eax, %eax
 	ret
-# endif
-
-
+# else
 	.p2align 4,, 10
+# endif
 L(less_16_till_page):
 	cmpl	$((VEC_SIZE - 8) / SIZE_OF_CHAR), %eax
 	ja	L(less_8_till_page)
@@ -1482,8 +1481,12 @@ L(less_16_till_page):
 # endif
 	jmp	L(prepare_loop_aligned)
 
-
-
+# ifndef USE_AS_STRNCMP
+	/* Fits in aligning bytes.  */
+L(ret_zero_4_loop):
+	xorl	%eax, %eax
+	ret
+# endif
 
 	.p2align 4,, 10
 L(less_8_till_page):
@@ -1554,6 +1557,7 @@ L(ret_less_8_wcs):
 
 #  ifdef USE_AS_STRNCMP
 	.p2align 4,, 2
+L(ret_zero_4_loop):
 L(ret_zero_page_cross_slow_case1):
 	xorl	%eax, %eax
 	ret
@@ -1586,10 +1590,6 @@ L(less_4_loop):
 	subq	$-(CHAR_PER_VEC * 4), %rdx
 #  endif
 	jmp	L(prepare_loop_aligned)
-
-L(ret_zero_4_loop):
-	xorl	%eax, %eax
-	ret
 L(ret_less_4_loop):
 	xorl	%r8d, %eax
 	subl	%r8d, %eax
diff --git a/sysdeps/x86_64/multiarch/wcsncat-evex.S b/sysdeps/x86_64/multiarch/wcsncat-evex.S
index 392215950a..10bfb0a531 100644
--- a/sysdeps/x86_64/multiarch/wcsncat-evex.S
+++ b/sysdeps/x86_64/multiarch/wcsncat-evex.S
@@ -1,9 +1,9 @@
-#ifndef WCSCAT
-# define WCSCAT	__wcsncat_evex
+#ifndef WCSNCAT
+# define WCSNCAT	__wcsncat_evex
 #endif
 
 #define USE_AS_WCSCPY
 #define USE_AS_STRCAT
 
-#define STRNCAT	WCSCAT
+#define STRNCAT	WCSNCAT
 #include "strncat-evex.S"
diff --git a/sysdeps/x86_64/tst-gnu2-tls2mod1.S b/sysdeps/x86_64/tst-gnu2-tls2mod1.S
new file mode 100644
index 0000000000..1d636669ba
--- /dev/null
+++ b/sysdeps/x86_64/tst-gnu2-tls2mod1.S
@@ -0,0 +1,87 @@
+/* Check if TLSDESC relocation preserves %rdi, %rsi and %rbx.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+/* On AVX512 machines, OFFSET == 40 caused _dl_tlsdesc_dynamic_xsavec
+   to clobber %rdi, %rsi and %rbx.  On Intel AVX CPUs, the state size
+   is 960 bytes and this test didn't fail.  It may be due to the unused
+   last 128 bytes.  On AMD AVX CPUs, the state size is 832 bytes and
+   this test might fail without the fix.  */
+#ifndef OFFSET
+# define OFFSET 40
+#endif
+
+	.text
+	.p2align 4
+	.globl	apply_tls
+	.type	apply_tls, @function
+apply_tls:
+	cfi_startproc
+	_CET_ENDBR
+	pushq	%rbp
+	cfi_def_cfa_offset (16)
+	cfi_offset (6, -16)
+	movdqu	(%RDI_LP), %xmm0
+	lea	tls_var1@TLSDESC(%rip), %RAX_LP
+	mov	%RSP_LP, %RBP_LP
+	cfi_def_cfa_register (6)
+	/* Align stack to 64 bytes.  */
+	and	$-64, %RSP_LP
+	sub	$OFFSET, %RSP_LP
+	pushq	%rbx
+	/* Set %ebx to 0xbadbeef.  */
+	movl	$0xbadbeef, %ebx
+	movl	$0xbadbeef, %esi
+	movq	%rdi, saved_rdi(%rip)
+	movq	%rsi, saved_rsi(%rip)
+	call	*tls_var1@TLSCALL(%RAX_LP)
+	/* Check if _dl_tlsdesc_dynamic preserves %rdi, %rsi and %rbx.  */
+	cmpq	saved_rdi(%rip), %rdi
+	jne	L(hlt)
+	cmpq	saved_rsi(%rip), %rsi
+	jne	L(hlt)
+	cmpl	$0xbadbeef, %ebx
+	jne	L(hlt)
+	add	%fs:0, %RAX_LP
+	movups	%xmm0, 32(%RAX_LP)
+	movdqu	16(%RDI_LP), %xmm1
+	mov	%RAX_LP, %RBX_LP
+	movups	%xmm1, 48(%RAX_LP)
+	lea	32(%RBX_LP), %RAX_LP
+	pop	%rbx
+	leave
+	cfi_def_cfa (7, 8)
+	ret
+L(hlt):
+	hlt
+	cfi_endproc
+	.size	apply_tls, .-apply_tls
+	.hidden	tls_var1
+	.globl	tls_var1
+	.section	.tbss,"awT",@nobits
+	.align 16
+	.type	tls_var1, @object
+	.size	tls_var1, 3200
+tls_var1:
+	.zero	3200
+	.local	saved_rdi
+	.comm	saved_rdi,8,8
+	.local	saved_rsi
+	.comm	saved_rsi,8,8
+	.section	.note.GNU-stack,"",@progbits
diff --git a/sysdeps/x86_64/tst-shstk-legacy-1e-static.sh b/sysdeps/x86_64/tst-shstk-legacy-1e-static.sh
index 46f1233757..0a9a164a3e 100755
--- a/sysdeps/x86_64/tst-shstk-legacy-1e-static.sh
+++ b/sysdeps/x86_64/tst-shstk-legacy-1e-static.sh
@@ -26,7 +26,7 @@ ${common_objpfx}elf/tst-shstk-legacy-1e-static
 status=$?
 if test $status -eq 77; then
   exit 77
-elif test $status == 139; then
+elif test $status -eq 139; then
   exit 0
 else
   exit 1
diff --git a/sysdeps/x86_64/tst-shstk-legacy-1e.sh b/sysdeps/x86_64/tst-shstk-legacy-1e.sh
index 31212453d9..3dec5623e4 100755
--- a/sysdeps/x86_64/tst-shstk-legacy-1e.sh
+++ b/sysdeps/x86_64/tst-shstk-legacy-1e.sh
@@ -28,7 +28,7 @@ ${test_program_prefix} \
 status=$?
 if test $status -eq 77; then
   exit 77
-elif test $status == 139; then
+elif test $status -eq 139; then
   exit 0
 else
   exit 1
diff --git a/sysdeps/x86_64/tst-shstk-legacy-1g.sh b/sysdeps/x86_64/tst-shstk-legacy-1g.sh
index e84087068e..249831e816 100755
--- a/sysdeps/x86_64/tst-shstk-legacy-1g.sh
+++ b/sysdeps/x86_64/tst-shstk-legacy-1g.sh
@@ -28,7 +28,7 @@ ${test_program_prefix} \
 status=$?
 if test $status -eq 77; then
   exit 77
-elif test $status == 139; then
+elif test $status -eq 139; then
   exit 0
 else
   exit 1
diff --git a/sysdeps/x86_64/x32/dl-machine.h b/sysdeps/x86_64/x32/dl-machine.h
deleted file mode 100644
index c35cee9261..0000000000
--- a/sysdeps/x86_64/x32/dl-machine.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/* Machine-dependent ELF dynamic relocation inline functions.  x32 version.
-   Copyright (C) 2012-2024 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <https://www.gnu.org/licenses/>.  */
-
-/* Must allow <sysdeps/x86_64/dl-machine.h> to be included more than once.
-   See #ifdef RESOLVE_MAP in sysdeps/x86_64/dl-machine.h.  */
-#include <sysdeps/x86_64/dl-machine.h>
-
-#ifndef _X32_DL_MACHINE_H
-#define _X32_DL_MACHINE_H
-
-#undef ARCH_LA_PLTENTER
-#undef ARCH_LA_PLTEXIT
-#undef RTLD_START
-
-/* Names of the architecture-specific auditing callback functions.  */
-#define ARCH_LA_PLTENTER x32_gnu_pltenter
-#define ARCH_LA_PLTEXIT x32_gnu_pltexit
-
-/* Initial entry point code for the dynamic linker.
-   The C function `_dl_start' is the real entry point;
-   its return value is the user program's entry point.  */
-#define RTLD_START asm ("\n\
-.text\n\
-	.p2align 4\n\
-.globl _start\n\
-.globl _dl_start_user\n\
-_start:\n\
-	movl %esp, %edi\n\
-	call _dl_start\n\
-_dl_start_user:\n\
-	# Save the user entry point address in %r12.\n\
-	movl %eax, %r12d\n\
-	# Read the original argument count.\n\
-	movl (%rsp), %edx\n\
-	# Call _dl_init (struct link_map *main_map, int argc, char **argv, char **env)\n\
-	# argc -> rsi\n\
-	movl %edx, %esi\n\
-	# Save %rsp value in %r13.\n\
-	movl %esp, %r13d\n\
-	# And align stack for the _dl_init call.\n\
-	and $-16, %esp\n\
-	# _dl_loaded -> rdi\n\
-	movl _rtld_local(%rip), %edi\n\
-	# env -> rcx\n\
-	lea 8(%r13,%rdx,4), %ecx\n\
-	# argv -> rdx\n\
-	lea 4(%r13), %edx\n\
-	# Clear %rbp to mark outermost frame obviously even for constructors.\n\
-	xorl %ebp, %ebp\n\
-	# Call the function to run the initializers.\n\
-	call _dl_init\n\
-	# Pass our finalizer function to the user in %rdx, as per ELF ABI.\n\
-	lea _dl_fini(%rip), %edx\n\
-	# And make sure %rsp points to argc stored on the stack.\n\
-	movl %r13d, %esp\n\
-	# Jump to the user's entry point.\n\
-	jmp *%r12\n\
-.previous\n\
-");
-
-#endif /* !_X32_DL_MACHINE_H */
diff --git a/sysvipc/sys/msg.h b/sysvipc/sys/msg.h
index d0388b0522..4178ad9955 100644
--- a/sysvipc/sys/msg.h
+++ b/sysvipc/sys/msg.h
@@ -58,7 +58,7 @@ struct msgbuf
 __BEGIN_DECLS
 
 /* Message queue control operation.  */
-#ifndef __USE_TIME_BITS64
+#ifndef __USE_TIME64_REDIRECTS
 extern int msgctl (int __msqid, int __cmd, struct msqid_ds *__buf) __THROW;
 #else
 # ifdef __REDIRECT_NTH
diff --git a/sysvipc/sys/sem.h b/sysvipc/sys/sem.h
index 5d9ec39296..812f1303b3 100644
--- a/sysvipc/sys/sem.h
+++ b/sysvipc/sys/sem.h
@@ -48,7 +48,7 @@ struct sembuf
 __BEGIN_DECLS
 
 /* Semaphore control operation.  */
-#ifndef __USE_TIME_BITS64
+#ifndef __USE_TIME64_REDIRECTS
 extern int semctl (int __semid, int __semnum, int __cmd, ...) __THROW;
 #else
 # ifdef __REDIRECT_NTH
@@ -68,7 +68,7 @@ extern int semop (int __semid, struct sembuf *__sops, size_t __nsops) __THROW;
 
 #ifdef __USE_GNU
 /* Operate on semaphore with timeout.  */
-# ifndef __USE_TIME_BITS64
+# ifndef __USE_TIME64_REDIRECTS
 extern int semtimedop (int __semid, struct sembuf *__sops, size_t __nsops,
 		       const struct timespec *__timeout) __THROW;
 # else
diff --git a/sysvipc/sys/shm.h b/sysvipc/sys/shm.h
index 04191656d5..496e57ef45 100644
--- a/sysvipc/sys/shm.h
+++ b/sysvipc/sys/shm.h
@@ -46,7 +46,7 @@ __BEGIN_DECLS
    facility.  The definition is found in XPG4.2.  */
 
 /* Shared memory control operation.  */
-#ifndef __USE_TIME_BITS64
+#ifndef __USE_TIME64_REDIRECTS
 extern int shmctl (int __shmid, int __cmd, struct shmid_ds *__buf) __THROW;
 #else
 # ifdef __REDIRECT_NTH
diff --git a/test-skeleton.c b/test-skeleton.c
index ae185a4f28..690f26e7cf 100644
--- a/test-skeleton.c
+++ b/test-skeleton.c
@@ -27,7 +27,6 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <getopt.h>
-#include <malloc.h>
 #include <paths.h>
 #include <search.h>
 #include <signal.h>
diff --git a/time/bits/types/struct_timespec.h b/time/bits/types/struct_timespec.h
index 489e81136d..1141015f27 100644
--- a/time/bits/types/struct_timespec.h
+++ b/time/bits/types/struct_timespec.h
@@ -10,14 +10,14 @@
    has nanoseconds instead of microseconds.  */
 struct timespec
 {
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
   __time64_t tv_sec;		/* Seconds.  */
 #else
   __time_t tv_sec;		/* Seconds.  */
 #endif
 #if __WORDSIZE == 64 \
   || (defined __SYSCALL_WORDSIZE && __SYSCALL_WORDSIZE == 64) \
-  || (__TIMESIZE == 32 && !defined __USE_TIME_BITS64)
+  || (__TIMESIZE == 32 && !defined __USE_TIME64_REDIRECTS)
   __syscall_slong_t tv_nsec;	/* Nanoseconds.  */
 #else
 # if __BYTE_ORDER == __BIG_ENDIAN
diff --git a/time/bits/types/struct_timeval.h b/time/bits/types/struct_timeval.h
index 3466137c35..0c8e88c82c 100644
--- a/time/bits/types/struct_timeval.h
+++ b/time/bits/types/struct_timeval.h
@@ -7,7 +7,7 @@
    microsecond but also has a range of years.  */
 struct timeval
 {
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
   __time64_t tv_sec;		/* Seconds.  */
   __suseconds64_t tv_usec;	/* Microseconds.  */
 #else
diff --git a/time/bits/types/time_t.h b/time/bits/types/time_t.h
index 84d67f6ac3..00cde92c62 100644
--- a/time/bits/types/time_t.h
+++ b/time/bits/types/time_t.h
@@ -4,7 +4,7 @@
 #include <bits/types.h>
 
 /* Returned by `time'.  */
-#ifdef __USE_TIME_BITS64
+#ifdef __USE_TIME64_REDIRECTS
 typedef __time64_t time_t;
 #else
 typedef __time_t time_t;
diff --git a/time/strftime_l.c b/time/strftime_l.c
index 77adec9050..066c839c2f 100644
--- a/time/strftime_l.c
+++ b/time/strftime_l.c
@@ -40,6 +40,7 @@
 #endif
 
 #include <ctype.h>
+#include <errno.h>
 #include <sys/types.h>		/* Some systems define `time_t' here.  */
 
 #ifdef TIME_WITH_SYS_TIME
diff --git a/time/sys/time.h b/time/sys/time.h
index c8708198a5..8c3d0c3022 100644
--- a/time/sys/time.h
+++ b/time/sys/time.h
@@ -63,7 +63,7 @@ struct timezone
    use localtime etc. instead.
    This function itself is semi-obsolete;
    most callers should use time or clock_gettime instead. */
-#ifndef __USE_TIME_BITS64
+#ifndef __USE_TIME64_REDIRECTS
 extern int gettimeofday (struct timeval *__restrict __tv,
 			 void *__restrict __tz) __THROW __nonnull ((1));
 #else
@@ -77,7 +77,7 @@ extern int __REDIRECT_NTH (gettimeofday, (struct timeval *__restrict __tv,
 #endif
 
 #ifdef __USE_MISC
-# ifndef __USE_TIME_BITS64
+# ifndef __USE_TIME64_REDIRECTS
 /* Set the current time of day and timezone information.
    This call is restricted to the super-user.
    Setting the timezone in this way is obsolete, but we don't yet
@@ -143,7 +143,7 @@ typedef enum __itimer_which __itimer_which_t;
 typedef int __itimer_which_t;
 #endif
 
-#ifndef __USE_TIME_BITS64
+#ifndef __USE_TIME64_REDIRECTS
 /* Set *VALUE to the current setting of timer WHICH.
    Return 0 on success, -1 on errors.  */
 extern int getitimer (__itimer_which_t __which,
@@ -184,7 +184,7 @@ extern int __REDIRECT_NTH (utimes, (const char *__file,
 #endif
 
 #ifdef __USE_MISC
-# ifndef __USE_TIME_BITS64
+# ifndef __USE_TIME64_REDIRECTS
 /* Same as `utimes', but does not follow symbolic links.  */
 extern int lutimes (const char *__file, const struct timeval __tvp[2])
      __THROW __nonnull ((1));
@@ -207,7 +207,7 @@ extern int __REDIRECT_NTH (futimes, (int __fd, const struct timeval __tvp[2]),
 #endif
 
 #ifdef __USE_GNU
-# ifndef __USE_TIME_BITS64
+# ifndef __USE_TIME64_REDIRECTS
 /* Change the access time of FILE relative to FD to TVP[0] and the
    modification time of FILE to TVP[1].  If TVP is a null pointer, use
    the current time instead.  Returns 0 on success, -1 on errors.  */
diff --git a/time/time.h b/time/time.h
index 1609aaeffa..3785dc608f 100644
--- a/time/time.h
+++ b/time/time.h
@@ -71,7 +71,7 @@ __BEGIN_DECLS
    The result / CLOCKS_PER_SEC is program time in seconds.  */
 extern clock_t clock (void) __THROW;
 
-#ifndef __USE_TIME_BITS64
+#ifndef __USE_TIME64_REDIRECTS
 /* Return the current time and put it in *TIMER if TIMER is not NULL.  */
 extern time_t time (time_t *__timer) __THROW;
 
@@ -127,7 +127,7 @@ extern char *strptime_l (const char *__restrict __s,
 #endif
 
 
-#ifndef __USE_TIME_BITS64
+#ifndef __USE_TIME64_REDIRECTS
 /* Return the `struct tm' representation of *TIMER
    in Universal Coordinated Time (aka Greenwich Mean Time).  */
 extern struct tm *gmtime (const time_t *__timer) __THROW;
@@ -149,7 +149,7 @@ extern struct tm *__REDIRECT_NTH (localtime, (const time_t *__timer),
 
 
 #if defined __USE_POSIX || __GLIBC_USE (ISOC2X)
-# ifndef __USE_TIME_BITS64
+# ifndef __USE_TIME64_REDIRECTS
 /* Return the `struct tm' representation of *TIMER in UTC,
    using *TP to store the result.  */
 extern struct tm *gmtime_r (const time_t *__restrict __timer,
@@ -180,7 +180,7 @@ extern struct tm*__REDIRECT_NTH (localtime_r, (const time_t *__restrict __t,
 extern char *asctime (const struct tm *__tp) __THROW;
 
 /* Equivalent to `asctime (localtime (timer))'.  */
-#ifndef __USE_TIME_BITS64
+#ifndef __USE_TIME64_REDIRECTS
 extern char *ctime (const time_t *__timer) __THROW;
 #else
 # ifdef __REDIRECT_NTH
@@ -199,7 +199,7 @@ extern char *asctime_r (const struct tm *__restrict __tp,
 			char *__restrict __buf) __THROW;
 
 /* Equivalent to `asctime_r (localtime_r (timer, *TMP*), buf)'.  */
-#ifndef __USE_TIME_BITS64
+#ifndef __USE_TIME64_REDIRECTS
 extern char *ctime_r (const time_t *__restrict __timer,
 		      char *__restrict __buf) __THROW;
 #else
@@ -242,7 +242,7 @@ extern long int timezone;
 
 
 #if defined __USE_MISC || __GLIBC_USE (ISOC2X)
-# ifndef __USE_TIME_BITS64
+# ifndef __USE_TIME64_REDIRECTS
 /* Like `mktime', but for TP represents Universal Time, not local time.  */
 extern time_t timegm (struct tm *__tp) __THROW;
 # else
@@ -259,7 +259,7 @@ extern time_t __REDIRECT_NTH (timegm, (struct tm *__tp), __timegm64);
 /* Miscellaneous functions many Unices inherited from the public domain
    localtime package.  These are included only for compatibility.  */
 
-#ifndef __USE_TIME_BITS64
+#ifndef __USE_TIME64_REDIRECTS
 /* Another name for `mktime'.  */
 extern time_t timelocal (struct tm *__tp) __THROW;
 #else
@@ -274,7 +274,7 @@ extern int dysize (int __year) __THROW  __attribute__ ((__const__));
 
 
 #ifdef __USE_POSIX199309
-# ifndef __USE_TIME_BITS64
+# ifndef __USE_TIME64_REDIRECTS
 /* Pause execution for a number of nanoseconds.
 
    This function is a cancellation point and therefore not marked with
@@ -320,7 +320,7 @@ extern int __REDIRECT_NTH (clock_settime, (clockid_t __clock_id, const struct
 
    This function is a cancellation point and therefore not marked with
    __THROW.  */
-#  ifndef __USE_TIME_BITS64
+#  ifndef __USE_TIME64_REDIRECTS
 extern int clock_nanosleep (clockid_t __clock_id, int __flags,
 			    const struct timespec *__req,
 			    struct timespec *__rem);
@@ -349,7 +349,7 @@ extern int timer_create (clockid_t __clock_id,
 extern int timer_delete (timer_t __timerid) __THROW;
 
 /* Set timer TIMERID to VALUE, returning old value in OVALUE.  */
-# ifndef __USE_TIME_BITS64
+# ifndef __USE_TIME64_REDIRECTS
 extern int timer_settime (timer_t __timerid, int __flags,
 			  const struct itimerspec *__restrict __value,
 			  struct itimerspec *__restrict __ovalue) __THROW;
@@ -379,7 +379,7 @@ extern int timer_getoverrun (timer_t __timerid) __THROW;
 
 
 #ifdef __USE_ISOC11
-# ifndef __USE_TIME_BITS64
+# ifndef __USE_TIME64_REDIRECTS
 /* Set TS to calendar time based in time base BASE.  */
 extern int timespec_get (struct timespec *__ts, int __base)
      __THROW __nonnull ((1));
@@ -395,7 +395,7 @@ extern int __REDIRECT_NTH (timespec_get, (struct timespec *__ts, int __base),
 
 
 #if __GLIBC_USE (ISOC2X)
-# ifndef __USE_TIME_BITS64
+# ifndef __USE_TIME64_REDIRECTS
 /* Set TS to resolution of time base BASE.  */
 extern int timespec_getres (struct timespec *__ts, int __base)
      __THROW;
diff --git a/time/timespec_get.c b/time/timespec_get.c
index b031e42ca2..26a044bca6 100644
--- a/time/timespec_get.c
+++ b/time/timespec_get.c
@@ -4,7 +4,7 @@
    The GNU C Library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
-   version 2.1 of the License.
+   version 2.1 of the License, or (at your option) any later version.
 
    The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
diff --git a/time/timespec_getres.c b/time/timespec_getres.c
index edb397507c..2e18b8bcac 100644
--- a/time/timespec_getres.c
+++ b/time/timespec_getres.c
@@ -5,7 +5,7 @@
    The GNU C Library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
-   version 2.1 of the License.
+   version 2.1 of the License, or (at your option) any later version.
 
    The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
diff --git a/wcsmbs/Makefile b/wcsmbs/Makefile
index 65173e28aa..6eb38c2dcd 100644
--- a/wcsmbs/Makefile
+++ b/wcsmbs/Makefile
@@ -160,6 +160,7 @@ tests := \
   test-wcsncmp \
   test-wcsncpy \
   test-wcsnlen \
+  test-wcsnlen-nonarray \
   test-wcspbrk \
   test-wcsrchr \
   test-wcsspn \
@@ -204,6 +205,10 @@ tests := \
   wcsmbs-tst1 \
   # tests
 
+# This test runs for a long time.
+xtests += test-wcsncmp-nonarray
+
+
 include ../Rules
 
 ifeq ($(run-built-tests),yes)
diff --git a/wcsmbs/bits/wchar2.h b/wcsmbs/bits/wchar2.h
index 49f19bca19..c863b60ec2 100644
--- a/wcsmbs/bits/wchar2.h
+++ b/wcsmbs/bits/wchar2.h
@@ -59,18 +59,18 @@ __NTH (wmemset (wchar_t *__s, wchar_t __c, size_t __n))
 __fortify_function wchar_t *
 __NTH (wcscpy (wchar_t *__restrict __dest, const wchar_t *__restrict __src))
 {
-  size_t sz = __glibc_objsize (__dest);
-  if (sz != (size_t) -1)
-    return __wcscpy_chk (__dest, __src, sz / sizeof (wchar_t));
+  size_t __sz = __glibc_objsize (__dest);
+  if (__sz != (size_t) -1)
+    return __wcscpy_chk (__dest, __src, __sz / sizeof (wchar_t));
   return __wcscpy_alias (__dest, __src);
 }
 
 __fortify_function wchar_t *
 __NTH (wcpcpy (wchar_t *__restrict __dest, const wchar_t *__restrict __src))
 {
-  size_t sz = __glibc_objsize (__dest);
-  if (sz != (size_t) -1)
-    return __wcpcpy_chk (__dest, __src, sz / sizeof (wchar_t));
+  size_t __sz = __glibc_objsize (__dest);
+  if (__sz != (size_t) -1)
+    return __wcpcpy_chk (__dest, __src, __sz / sizeof (wchar_t));
   return __wcpcpy_alias (__dest, __src);
 }
 
@@ -95,9 +95,9 @@ __NTH (wcpncpy (wchar_t *__restrict __dest, const wchar_t *__restrict __src,
 __fortify_function wchar_t *
 __NTH (wcscat (wchar_t *__restrict __dest, const wchar_t *__restrict __src))
 {
-  size_t sz = __glibc_objsize (__dest);
-  if (sz != (size_t) -1)
-    return __wcscat_chk (__dest, __src, sz / sizeof (wchar_t));
+  size_t __sz = __glibc_objsize (__dest);
+  if (__sz != (size_t) -1)
+    return __wcscat_chk (__dest, __src, __sz / sizeof (wchar_t));
   return __wcscat_alias (__dest, __src);
 }
 
@@ -105,9 +105,9 @@ __fortify_function wchar_t *
 __NTH (wcsncat (wchar_t *__restrict __dest, const wchar_t *__restrict __src,
 		size_t __n))
 {
-  size_t sz = __glibc_objsize (__dest);
-  if (sz != (size_t) -1)
-    return __wcsncat_chk (__dest, __src, __n, sz / sizeof (wchar_t));
+  size_t __sz = __glibc_objsize (__dest);
+  if (__sz != (size_t) -1)
+    return __wcsncat_chk (__dest, __src, __n, __sz / sizeof (wchar_t));
   return __wcsncat_alias (__dest, __src, __n);
 }
 
@@ -144,10 +144,10 @@ __fortify_function int
 __NTH (swprintf (wchar_t *__restrict __s, size_t __n,
 		 const wchar_t *__restrict __fmt, ...))
 {
-  size_t sz = __glibc_objsize (__s);
-  if (sz != (size_t) -1 || __USE_FORTIFY_LEVEL > 1)
+  size_t __sz = __glibc_objsize (__s);
+  if (__sz != (size_t) -1 || __USE_FORTIFY_LEVEL > 1)
     return __swprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
-			   sz / sizeof (wchar_t), __fmt, __va_arg_pack ());
+			   __sz / sizeof (wchar_t), __fmt, __va_arg_pack ());
   return __swprintf_alias (__s, __n, __fmt, __va_arg_pack ());
 }
 #elif !defined __cplusplus
@@ -163,10 +163,10 @@ __fortify_function int
 __NTH (vswprintf (wchar_t *__restrict __s, size_t __n,
 		  const wchar_t *__restrict __fmt, __gnuc_va_list __ap))
 {
-  size_t sz = __glibc_objsize (__s);
-  if (sz != (size_t) -1 || __USE_FORTIFY_LEVEL > 1)
+  size_t __sz = __glibc_objsize (__s);
+  if (__sz != (size_t) -1 || __USE_FORTIFY_LEVEL > 1)
     return __vswprintf_chk (__s, __n,  __USE_FORTIFY_LEVEL - 1,
-			    sz / sizeof (wchar_t), __fmt, __ap);
+			    __sz / sizeof (wchar_t), __fmt, __ap);
   return __vswprintf_alias (__s, __n, __fmt, __ap);
 }
 
@@ -210,25 +210,25 @@ vfwprintf (__FILE *__restrict __stream,
 __fortify_function __wur wchar_t *
 fgetws (wchar_t *__restrict __s, int __n, __FILE *__restrict __stream)
 {
-  size_t sz = __glibc_objsize (__s);
-  if (__glibc_safe_or_unknown_len (__n, sizeof (wchar_t), sz))
+  size_t __sz = __glibc_objsize (__s);
+  if (__glibc_safe_or_unknown_len (__n, sizeof (wchar_t), __sz))
     return __fgetws_alias (__s, __n, __stream);
-  if (__glibc_unsafe_len (__n, sizeof (wchar_t), sz))
-    return __fgetws_chk_warn (__s, sz / sizeof (wchar_t), __n, __stream);
-  return __fgetws_chk (__s, sz / sizeof (wchar_t), __n, __stream);
+  if (__glibc_unsafe_len (__n, sizeof (wchar_t), __sz))
+    return __fgetws_chk_warn (__s, __sz / sizeof (wchar_t), __n, __stream);
+  return __fgetws_chk (__s, __sz / sizeof (wchar_t), __n, __stream);
 }
 
 #ifdef __USE_GNU
 __fortify_function __wur wchar_t *
 fgetws_unlocked (wchar_t *__restrict __s, int __n, __FILE *__restrict __stream)
 {
-  size_t sz = __glibc_objsize (__s);
-  if (__glibc_safe_or_unknown_len (__n, sizeof (wchar_t), sz))
+  size_t __sz = __glibc_objsize (__s);
+  if (__glibc_safe_or_unknown_len (__n, sizeof (wchar_t), __sz))
     return __fgetws_unlocked_alias (__s, __n, __stream);
-  if (__glibc_unsafe_len (__n, sizeof (wchar_t), sz))
-    return __fgetws_unlocked_chk_warn (__s, sz / sizeof (wchar_t), __n,
+  if (__glibc_unsafe_len (__n, sizeof (wchar_t), __sz))
+    return __fgetws_unlocked_chk_warn (__s, __sz / sizeof (wchar_t), __n,
 				       __stream);
-  return __fgetws_unlocked_chk (__s, sz / sizeof (wchar_t), __n, __stream);
+  return __fgetws_unlocked_chk (__s, __sz / sizeof (wchar_t), __n, __stream);
 }
 #endif
 
diff --git a/wcsmbs/test-wcsncmp-nonarray.c b/wcsmbs/test-wcsncmp-nonarray.c
new file mode 100644
index 0000000000..1ad9ebd8fd
--- /dev/null
+++ b/wcsmbs/test-wcsncmp-nonarray.c
@@ -0,0 +1,5 @@
+#include <wchar.h>
+#define TEST_IDENTIFIER wcsncmp
+#define TEST_NAME "wcsncmp"
+typedef wchar_t CHAR;
+#include "../string/test-Xncmp-nonarray.c"
diff --git a/wcsmbs/test-wcsnlen-nonarray.c b/wcsmbs/test-wcsnlen-nonarray.c
new file mode 100644
index 0000000000..a4b21fecd3
--- /dev/null
+++ b/wcsmbs/test-wcsnlen-nonarray.c
@@ -0,0 +1,5 @@
+#include <wchar.h>
+#define TEST_IDENTIFIER wcsnlen
+#define TEST_NAME "wcsnlen"
+typedef wchar_t CHAR;
+#include "../string/test-Xnlen-nonarray.c"
