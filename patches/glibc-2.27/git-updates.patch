diff --git a/ChangeLog b/ChangeLog
index f3fe2716b2..2760eee9a6 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,1153 @@
+2018-08-28  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #23520]
+	nscd: Fix use-after-free in addgetnetgrentX and its callers.
+	* nscd/netgroupcache.c
+	(addgetnetgrentX): Add tofreep parameter.  Do not free
+	heap-allocated buffer.
+	(addinnetgrX): Free buffer allocated bt addgetnetgrentX.
+	(addgetnetgrentX_ignore): New function.
+	(addgetnetgrent): Call it.
+	(readdgetnetgrent): Likewise.
+
+2019-02-01  Florian Weimer  <fweimer@redhat.com>
+
+	* support/support_test_compare_string.c
+	(support_test_compare_string): Use "string" in error message.
+	* support/tst-test_compare_string.c (do_test): Adjust.
+
+2018-11-07  Adhemerval Zanella  <adhemerval.zanella@linaro.org>
+
+	* support/support_test_compare_string.c
+	(support_test_compare_string): Fix printf format.
+
+2018-11-07  Florian Weimer  <fweimer@redhat.com>
+
+	Implement TEST_COMPARE_STRING.
+	* support/check.h (TEST_COMPARE_STRING): Define.
+	(support_test_compare_string): Declare.
+	* support/Makefile (libsupport-routines): Add
+	support_test_compare_string.
+	(tests): Add tst-test_compare_string.
+	* support/support_test_compare_string.c: New file.
+	* support/tst-test_compare_string.c: Likewise.
+
+2019-06-04  Andreas Schwab  <schwab@suse.de>
+
+	[BZ #18830]
+	* iconv/skeleton.c (FUNCTION_NAME): Use RESET_INPUT_BUFFER only if
+	no irreversible characters occurred.
+	* iconv/gconv_simple.c (internal_ucs4_loop)
+	(internal_ucs4_loop_unaligned, internal_ucs4_loop_single)
+	(ucs4_internal_loop, ucs4_internal_loop_unaligned)
+	(ucs4_internal_loop_single, internal_ucs4le_loop)
+	(internal_ucs4le_loop_unaligned, internal_ucs4le_loop_single)
+	(ucs4le_internal_loop, ucs4le_internal_loop_unaligned)
+	(ucs4le_internal_loop_single): Add const to outend.
+	* sysdeps/s390/multiarch/gconv_simple.c (internal_ucs4le_loop)
+	(ucs4_internal_loop, ucs4le_internal_loop): Likewise.
+	* iconv/Makefile (tests): Add tst-iconv7.
+	* iconv/tst-iconv7.c: New file.
+
+2018-02-18  Aurelien Jarno  <aurelien@aurel32.net>
+
+	[BZ #21508]
+	* catgets/xopen-msg.awk: Ignore POT-Creation-Date line.
+	* intl/Makefile ($(objpfx)tst-gettext-de.po): Generate
+	intl/tst-gettext-de.po from po/de.po by removing the
+	POT-Creation-Date line.
+	($(objpfx)msgs.h): Depend on $(objpfx)tst-gettext-de.po instead of
+	../po/de.po.
+	* intl/tst-gettext.sh: Use ${objpfx}tst-gettext-de.po instead of
+	../po/de.po.
+
+2018-07-06  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	* sysdeps/unix/sysv/linux/aarch64/dl-procinfo.h (HWCAP_IMPORTANT): Add
+	HWCAP_ATOMICS.
+
+2018-07-06  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	* sysdeps/unix/sysv/linux/aarch64/cpu-features.c (init_cpu_features):
+	Use dl_hwcap without masking.
+	* sysdeps/unix/sysv/linux/aarch64/dl-procinfo.h (HWCAP_IMPORTANT):
+	Remove HWCAP_CPUID.
+
+2019-09-13  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	* string/memmem.c (__memmem): Rewrite to improve performance.
+
+2019-06-12  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	* string/str-two-way.h (two_way_short_needle): Add inline to avoid
+	warning.
+	(two_way_long_needle): Block inlining.
+	* string/strstr.c (strstr2): Add new function.
+	(strstr3): Likewise.
+	(STRSTR): Completely rewrite strstr to improve performance.
+
+2019-09-13  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	[BZ #23637]
+	* string/test-strstr.c (pr23637): New function.
+	(test_main): Add tests with longer needles.
+	* string/strcasestr.c (AVAILABLE): Fix readahead distance.
+	* string/strstr.c (AVAILABLE): Likewise.
+
+2019-09-13  Rajalakshmi Srinivasaraghavan  <raji@linux.vnet.ibm.com>
+
+	* string/memmem.c: Use memcmp for first match.
+
+2019-09-13  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	* string/strcasestr.c (STRCASESTR): Simplify and speedup first match.
+	* string/strstr.c (AVAILABLE): Likewise.
+
+2019-09-13  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	* benchtests/bench-strcasestr.c: Rename __strnlen to strnlen.
+	* benchtests/bench-strstr.c: Likewise.
+	* string/memmem.c (FASTSEARCH): Define.
+	* string/str-two-way.h (two_way_short_needle): Minor cleanups.
+	Add support for FASTSEARCH.
+	* string/strcasestr.c (AVAILABLE): Use read-ahead __strnlen.
+	* string/strstr.c (AVAILABLE): Use read-ahead __strnlen.
+	(FASTSEARCH): Define.
+	* string/test-strcasestr.c: Rename __strnlen to strnlen.
+	* string/test-strstr.c: Likewise.
+
+2019-09-06  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	* manual/tunables.texi (glibc.cpu.name): Add ares tunable.
+	* sysdeps/aarch64/multiarch/memcpy.c (__libc_memcpy): Use
+	__memcpy_falkor for ares.
+	* sysdeps/unix/sysv/linux/aarch64/cpu-features.h (IS_ARES):
+	Add new define.
+	* sysdeps/unix/sysv/linux/aarch64/cpu-features.c (cpu_list):
+	Add ares cpu.
+
+2019-09-06  Siddhesh Poyarekar  <siddhesh@sourceware.org>
+
+	* sysdeps/aarch64/multiarch/memcpy_falkor.S (__memcpy_falkor):
+	Use vector registers.
+
+2019-09-06  Siddhesh Poyarekar  <siddhesh@sourceware.org>
+
+	* sysdeps/aarch64/multiarch/memcpy_falkor.S (__memcpy_falkor):
+	Use multiple registers to copy data in loop tail.
+
+2019-09-06  Siddhesh Poyarekar  <siddhesh@sourceware.org>
+
+	* sysdeps/aarch64/strncmp.S (strncmp): Use lsr instead of
+	mov + lsr.
+
+2019-09-06  Siddhesh Poyarekar  <siddhesh@sourceware.org>
+
+	* sysdeps/aarch64/strncmp.S (strncmp): Use a separate shift
+	instruction to unbreak builds with binutils 2.26 and older.
+
+2019-09-06  Siddhesh Poyarekar  <siddhesh@sourceware.org>
+
+	* sysdeps/aarch64/strncmp.S (count): New macro.
+	(strncmp): Store misaligned length in SRC1 in COUNT.
+	(mutual_align): Adjust.
+	(misaligned8): Load dword at a time when it is safe.
+
+2019-09-06  Siddhesh Poyarekar  <siddhesh@sourceware.org>
+
+	* sysdeps/aarch64/strcmp.S (do_misaligned): Jump back to
+	do_misaligned, not misaligned8.
+
+2019-09-06  Siddhesh Poyarekar  <siddhesh@sourceware.org>
+
+	* sysdeps/aarch64/strcmp.S (misaligned8): Compare dword at a
+	time whenever possible.
+
+2019-09-06  Siddhesh Poyarekar  <siddhesh@sourceware.org>
+
+	* sysdeps/aarch64/memcmp.S: Widen comparison to 16 bytes at a
+	time.
+
+2019-09-06  Siddhesh Poyarekar  <siddhesh@sourceware.org>
+
+	* sysdeps/aarch64/memcmp.S (more16): Fix loop16 branch target.
+
+2019-09-06  Siddhesh Poyarekar  <siddhesh@sourceware.org>
+
+	* sysdeps/aarch64/memcmp.S: Use L() macro for labels.
+
+2019-07-15  Adhemerval Zanella  <adhemerval.zanella@linaro.org>
+
+	[BZ #24699]
+	* posix/tst-mmap-offset.c: Mention BZ #24699.
+	(do_test_bz21270): Rename to do_test_large_offset and use
+	mmap64_maximum_offset to check for maximum expected offset value.
+	* sysdeps/generic/mmap_info.h: New file.
+	* sysdeps/unix/sysv/linux/mips/mmap_info.h: Likewise.
+	* sysdeps/unix/sysv/linux/mmap64.c (MMAP_OFF_HIGH_MASK): Define iff
+	__NR_mmap2 is used.
+
+2019-07-12  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	* sysdeps/aarch64/dl-machine.h (elf_machine_lazy_rel): Check
+	STO_AARCH64_VARIANT_PCS and bind such symbols at load time.
+
+2019-06-13  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	* elf/elf.h (STO_AARCH64_VARIANT_PCS): Define.
+	(DT_AARCH64_VARIANT_PCS): Define.
+
+2019-06-28  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #24744]
+	io: Remove the copy_file_range emulation.
+	* sysdeps/unix/sysv/linux/copy_file_range.c (copy_file_range): Do
+	not define and call copy_file_range_compat.
+	* io/Makefile (tests-static, tests-internal): Do not add
+	tst-copy_file_range-compat.
+	* io/copy_file_range-compat.c: Remove file.
+	* io/copy_file_range.c (copy_file_range): Define as stub.
+	* io/tst-copy_file_range-compat.c: Remove file.
+	* io/tst-copy_file_range.c (xdevfile): Remove variable.
+	(typical_sizes): Update comment.  Remove 16K sizes.
+	(maximum_offset, maximum_offset_errno, maximum_offset_hard_limit):
+	Remove variables.
+	(find_maximum_offset, pipe_as_source, pipe_as_destination)
+	(delayed_write_failure_beginning, delayed_write_failure_end)
+	(cross_device_failure, enospc_failure_1, enospc_failure)
+	(oappend_failure): Remove functions.
+	(tests): Adjust test case list.
+	(do_test): Remove file system search code.  Check for ENOSYS from
+	copy_file_range.  Do not free xdevfile.
+	* manual/llio.texi (Copying File Data): Document ENOSYS error from
+	copy_file_range.  Do not document the EXDEV error, which future
+	kernels may not report.  Update the wording to reflect that
+	further errors are possible.
+	* sysdeps/unix/sysv/linux/kernel-features.h
+	[__LINUX_KERNEL_VERSION >= 0x040500] (__ASSUME_COPY_FILE_RANGE):
+	Remove definition.
+	* sysdeps/unix/sysv/linux/microblaze/kernel-features.h
+	[__LINUX_KERNEL_VERSION < 0x040A00] (__ASSUME_COPY_FILE_RANGE): Do
+	not undefine.
+
+2019-06-20  Dmitry V. Levin  <ldv@altlinux.org>
+	    Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #24228]
+	* libio/genops.c (_IO_unbuffer_all)
+	[SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)]: Do not attempt to free wide
+	buffers and access _IO_FILE_complete members of legacy libio streams.
+	* libio/tst-bz24228.c: New file.
+	* libio/tst-bz24228.map: Likewise.
+	* libio/Makefile [build-shared] (tests): Add tst-bz24228.
+	[build-shared] (generated): Add tst-bz24228.mtrace and
+	tst-bz24228.check.
+	[run-built-tests && build-shared] (tests-special): Add
+	$(objpfx)tst-bz24228-mem.out.
+	(LDFLAGS-tst-bz24228, tst-bz24228-ENV): New variables.
+	($(objpfx)tst-bz24228-mem.out): New rule.
+
+2019-05-22  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	[BZ #24531]
+	* malloc/malloc.c (MAX_TCACHE_COUNT): New define.
+	(do_set_tcache_count): Only update if count is small enough.
+	* manual/tunables.texi (glibc.malloc.tcache_count): Document max value.
+
+2019-05-15  Andreas Schwab  <schwab@suse.de>
+
+	[BZ #20568]
+	* libio/wfileops.c (_IO_wfile_sync): Correct last argument to
+	__codecvt_do_length.
+	* libio/Makefile (tests): Add tst-wfile-sync.
+	($(objpfx)tst-wfile-sync.out): Depend on $(gen-locales).
+	* libio/tst-wfile-sync.c: New file.
+	* libio/tst-wfile-sync.input: New file.
+
+2019-04-23  Adhemerval Zanella  <adhemerval.zanella@linaro.org>
+
+	[BZ #18035]
+	* elf/pldd-xx.c: Use _Static_assert in of pldd_assert.
+	(E(find_maps)): Avoid use alloca, use default read file operations
+	instead of explicit LFS names, and fix infinite loop.
+	* elf/pldd.c: Explicit set _FILE_OFFSET_BITS, cleanup headers.
+	(get_process_info): Use _Static_assert instead of assert, use default
+	directory operations instead of explicit LFS names, and free some
+	leadek pointers.
+
+2019-04-02  TAMUKI Shoichi  <tamuki@linet.gr.jp>
+
+	[BZ #22964]
+	* localedata/locales/ja_JP (LC_TIME): Add entry for the new Japanese
+	era.
+
+2019-03-21  Stefan Liebler  <stli@linux.ibm.com>
+
+	* sysdeps/s390/dl-procinfo.h (HWCAP_IMPORTANT):
+	Add HWCAP_S390_VX and HWCAP_S390_VXE.
+
+2019-02-07  Stefan Liebler  <stli@linux.ibm.com>
+
+	[BZ #24180]
+	* nptl/pthread_mutex_trylock.c (__pthread_mutex_trylock):
+	Add compiler barriers and comments.
+
+2019-02-04  H.J. Lu  <hongjiu.lu@intel.com>
+
+	[BZ #24155]
+	CVE-2019-7309
+	* NEWS: Updated for CVE-2019-7309.
+	* sysdeps/x86_64/memcmp.S: Use RDX_LP for size.  Clear the
+	upper 32 bits of RDX register for x32.  Use unsigned Jcc
+	instructions, instead of signed.
+	* sysdeps/x86_64/x32/Makefile (tests): Add tst-size_t-memcmp-2.
+	* sysdeps/x86_64/x32/tst-size_t-memcmp-2.c: New test.
+
+2019-02-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	[BZ #24097]
+	CVE-2019-6488
+	* sysdeps/x86_64/multiarch/strlen-avx2.S: Use RSI_LP for length.
+	Clear the upper 32 bits of RSI register.
+	* sysdeps/x86_64/strlen.S: Use RSI_LP for length.
+	* sysdeps/x86_64/x32/Makefile (tests): Add tst-size_t-strnlen
+	and tst-size_t-wcsnlen.
+	* sysdeps/x86_64/x32/tst-size_t-strnlen.c: New file.
+	* sysdeps/x86_64/x32/tst-size_t-wcsnlen.c: Likewise.
+
+2019-02-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	[BZ #24097]
+	CVE-2019-6488
+	* sysdeps/x86_64/multiarch/strcpy-sse2-unaligned.S: Use RDX_LP
+	for length.
+	* sysdeps/x86_64/multiarch/strcpy-ssse3.S: Likewise.
+	* sysdeps/x86_64/x32/Makefile (tests): Add tst-size_t-strncpy.
+	* sysdeps/x86_64/x32/tst-size_t-strncpy.c: New file.
+
+2019-02-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	[BZ #24097]
+	CVE-2019-6488
+	* sysdeps/x86_64/multiarch/strcmp-sse42.S: Use RDX_LP for length.
+	* sysdeps/x86_64/strcmp.S: Likewise.
+	* sysdeps/x86_64/x32/Makefile (tests): Add tst-size_t-strncasecmp,
+	tst-size_t-strncmp and tst-size_t-wcsncmp.
+	* sysdeps/x86_64/x32/tst-size_t-strncasecmp.c: New file.
+	* sysdeps/x86_64/x32/tst-size_t-strncmp.c: Likewise.
+	* sysdeps/x86_64/x32/tst-size_t-wcsncmp.c: Likewise.
+
+2019-02-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	[BZ #24097]
+	CVE-2019-6488
+	* sysdeps/x86_64/multiarch/memset-avx512-no-vzeroupper.S: Use
+	RDX_LP for length.  Clear the upper 32 bits of RDX register.
+	* sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S: Likewise.
+	* sysdeps/x86_64/x32/Makefile (tests): Add tst-size_t-wmemset.
+	* sysdeps/x86_64/x32/tst-size_t-memset.c: New file.
+	* sysdeps/x86_64/x32/tst-size_t-wmemset.c: Likewise.
+
+2019-02-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	[BZ #24097]
+	CVE-2019-6488
+	* sysdeps/x86_64/memrchr.S: Use RDX_LP for length.
+	* sysdeps/x86_64/multiarch/memrchr-avx2.S: Likewise.
+	* sysdeps/x86_64/x32/Makefile (tests): Add tst-size_t-memrchr.
+	* sysdeps/x86_64/x32/tst-size_t-memrchr.c: New file.
+
+2019-02-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	[BZ #24097]
+	CVE-2019-6488
+	* sysdeps/x86_64/multiarch/memcpy-ssse3-back.S: Use RDX_LP for
+	length.  Clear the upper 32 bits of RDX register.
+	* sysdeps/x86_64/multiarch/memcpy-ssse3.S: Likewise.
+	* sysdeps/x86_64/multiarch/memmove-avx512-no-vzeroupper.S:
+	Likewise.
+	* sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:
+	Likewise.
+	* sysdeps/x86_64/x32/Makefile (tests): Add tst-size_t-memcpy.
+	tst-size_t-wmemchr.
+	* sysdeps/x86_64/x32/tst-size_t-memcpy.c: New file.
+
+2019-02-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	[BZ #24097]
+	CVE-2019-6488
+	* sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S: Use RDX_LP for
+	length.  Clear the upper 32 bits of RDX register.
+	* sysdeps/x86_64/multiarch/memcmp-sse4.S: Likewise.
+	* sysdeps/x86_64/multiarch/memcmp-ssse3.S: Likewise.
+	* sysdeps/x86_64/x32/Makefile (tests): Add tst-size_t-memcmp and
+	tst-size_t-wmemcmp.
+	* sysdeps/x86_64/x32/tst-size_t-memcmp.c: New file.
+	* sysdeps/x86_64/x32/tst-size_t-wmemcmp.c: Likewise.
+
+2019-02-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	[BZ #24097]
+	CVE-2019-6488
+	* sysdeps/x86_64/memchr.S: Use RDX_LP for length.  Clear the
+	upper 32 bits of RDX register.
+	* sysdeps/x86_64/multiarch/memchr-avx2.S: Likewise.
+	* sysdeps/x86_64/x32/Makefile (tests): Add tst-size_t-memchr and
+	tst-size_t-wmemchr.
+	* sysdeps/x86_64/x32/test-size_t.h: New file.
+	* sysdeps/x86_64/x32/tst-size_t-memchr.c: Likewise.
+	* sysdeps/x86_64/x32/tst-size_t-wmemchr.c: Likewise.
+
+2019-01-02  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #24018]
+	* intl/dcigettext.c (DCIGETTEXT): Do not return NULL on asprintf
+	failure.
+
+2018-12-31  Florian Weimer  <fw@deneb.enyo.de>
+
+	[BZ #24027]
+	* malloc/malloc.c (_int_realloc): Always call memcpy for the
+	copying operation.  (ncopies had the wrong type, resulting in an
+	integer wraparound and too few elements being copied.)
+
+2018-12-13  Andreas Schwab  <schwab@suse.de>
+
+	[BZ #23861]
+	* nptl/pthread_rwlock_common.c: Reindent.  Fix typos.
+	(__pthread_rwlock_rdlock_full): Update expected value for
+	__readers while waiting on PTHREAD_RWLOCK_RWAITING.
+	* nptl/tst-rwlock-pwn.c: New file.
+	* nptl/Makefile (tests): Add tst-rwlock-pwn.
+
+2018-12-12  Tulio Magno Quites Machado Filho  <tuliom@linux.ibm.com>
+
+	[BZ #23614]
+	* sysdeps/powerpc/powerpc64/addmul_1.S (FUNC): Add CFI offset for
+	registers saved in the stack frame.
+	* sysdeps/powerpc/powerpc64/lshift.S (__mpn_lshift): Likewise.
+	* sysdeps/powerpc/powerpc64/mul_1.S (__mpn_mul_1): Likewise.
+
+2018-11-30  Tulio Magno Quites Machado Filho  <tuliom@linux.ibm.com>
+
+	[BZ #23690]
+	* elf/dl-runtime.c (_dl_profile_fixup): Guarantee memory
+	modification order when accessing reloc_result->addr.
+	* include/link.h (reloc_result): Add field init.
+	* nptl/Makefile (tests): Add tst-audit-threads.
+	(modules-names): Add tst-audit-threads-mod1 and
+	tst-audit-threads-mod2.
+	Add rules to build tst-audit-threads.
+	* nptl/tst-audit-threads-mod1.c: New file.
+	* nptl/tst-audit-threads-mod2.c: Likewise.
+	* nptl/tst-audit-threads.c: Likewise.
+	* nptl/tst-audit-threads.h: Likewise.
+
+2018-12-07  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #23927]
+	CVE-2018-19591
+	* inet/tst-if_index-long.c: New file.
+	* inet/Makefile (tests): Add tst-if_index-long.
+
+2018-12-07  Florian Weimer  <fweimer@redhat.com>
+
+	* support/check.h (support_record_failure_is_failed): Declare.
+	* support/descriptors.h: New file.
+	* support/support_descriptors.c: Likewise.
+	* support/tst-support_descriptors.c: Likewise.
+	* support/support_record_failure.c
+	(support_record_failure_is_failed): New function.
+	* support/Makefile (libsupport-routines): Add support_descriptors.
+	(tests): Add tst-support_descriptors.
+
+2018-12-01  Florian Weimer  <fweimer@redhat.com>
+
+	* support/support_capture_subprocess.c
+	(support_capture_subprocess): Check that pipe descriptors have
+	expected values.  Close original pipe descriptors in subprocess.
+
+2018-11-28  Florian Weimer  <fweimer@redhat.com>
+
+	* support/support.h (support_quote_string): Do not use str
+	parameter name.
+
+2018-11-27  Florian Weimer  <fweimer@redhat.com>
+
+	* support/support.h (support_quote_string): Declare.
+	* support/support_quote_string.c: New file.
+	* support/tst-support_quote_string.c: Likewise.
+	* support/Makefile (libsupport-routines): Add
+	support_quote_string.
+	(tests): Add tst-support_quote_string.
+
+2018-12-07  DJ Delorie  <dj@redhat.com>
+
+	[BZ #23907]
+	* malloc/tst-tcfree3.c: New.
+	* malloc/Makefile: Add it.
+
+2018-11-26  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #23907]
+	* malloc/malloc.c (_int_free): Validate tc_idx before checking for
+	double-frees.
+
+
+2018-11-20  DJ Delorie  <dj@redhat.com>
+
+	* malloc/malloc.c (tcache_entry): Add key field.
+	(tcache_put): Set it.
+	(tcache_get): Likewise.
+	(_int_free): Check for double free in tcache.
+	* malloc/tst-tcfree1.c: New.
+	* malloc/tst-tcfree2.c: New.
+	* malloc/Makefile: Run the new tests.
+	* manual/probes.texi: Document memory_tcache_double_free probe.
+
+	* dlfcn/dlerror.c (check_free): Prevent double frees.
+
+2018-11-27  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #23927]
+	CVE-2018-19591
+	* sysdeps/unix/sysv/linux/if_index.c (__if_nametoindex): Avoid
+	descriptor leak in case of ENODEV error.
+
+2018-11-08  Alexandra Hájková  <ahajkova@redhat.com>
+
+	[BZ #17630]
+	* resolv/tst-resolv-network.c: Add test for getnetbyname.
+
+2018-11-05  Andreas Schwab  <schwab@suse.de>
+
+	[BZ #22927]
+	* resolv/gai_misc.c (__gai_enqueue_request): Don't crash if
+	creating the first helper thread failed.
+
+2018-10-23  Adhemerval Zanella  <adhemerval.zanella@linaro.org>
+
+	[BZ #23709]
+	* sysdeps/x86/cpu-features.c (init_cpu_features): Set TSX bits
+	independently of other flags.
+
+2018-10-26  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	[BZ #23822]
+	* sysdeps/ia64/fpu/e_exp2f.S (exp2f): Use WEAK_LIBM_ENTRY.
+	* sysdeps/ia64/fpu/e_log2f.S (log2f): Likewise.
+	* sysdeps/ia64/fpu/e_exp2f.S (powf): Likewise.
+
+2018-10-25  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #23562]
+	[BZ #23821]
+	XFAIL siginfo_t si_band conform test on sparc64.
+	* sysdeps/unix/sysv/linux/sparc/bits/siginfo-arch.h
+	(__SI_BAND_TYPE): Only override long int default type on sparc64.
+	* sysdeps/unix/sysv/linux/sparc/sparc64/Makefile
+	(conformtest-xfail-conds): Add sparc64-linux.
+	* conform/data/signal.h-data (siginfo_t): XFAIL si_band test on
+	sparc64.
+	* conform/data/sys/wait.h-data (siginfo_t): Likewise.
+
+2018-10-19  Ilya Yu. Malakhov  <malakhov@mcst.ru>
+
+	[BZ #23562]
+	* sysdeps/unix/sysv/linux/bits/types/siginfo_t.h
+	(struct siginfo_t): Use correct type for si_band.
+
+2018-10-17  Stefan Liebler  <stli@linux.ibm.com>
+
+	[BZ #23275]
+	* nptl/tst-mutex10.c: New File.
+	* nptl/Makefile (tests): Add tst-mutex10.
+	(tst-mutex10-ENV): New variable.
+	* sysdeps/unix/sysv/linux/s390/force-elision.h: (FORCE_ELISION):
+	Ensure that elision path is used if elision is available.
+	* sysdeps/unix/sysv/linux/powerpc/force-elision.h (FORCE_ELISION):
+	Likewise.
+	* sysdeps/unix/sysv/linux/x86/force-elision.h: (FORCE_ELISION):
+	Likewise.
+	* nptl/pthreadP.h (PTHREAD_MUTEX_TYPE, PTHREAD_MUTEX_TYPE_ELISION)
+	(PTHREAD_MUTEX_PSHARED): Use atomic_load_relaxed.
+	* nptl/pthread_mutex_consistent.c (pthread_mutex_consistent): Likewise.
+	* nptl/pthread_mutex_getprioceiling.c (pthread_mutex_getprioceiling):
+	Likewise.
+	* nptl/pthread_mutex_lock.c (__pthread_mutex_lock_full)
+	(__pthread_mutex_cond_lock_adjust): Likewise.
+	* nptl/pthread_mutex_setprioceiling.c (pthread_mutex_setprioceiling):
+	Likewise.
+	* nptl/pthread_mutex_timedlock.c (__pthread_mutex_timedlock): Likewise.
+	* nptl/pthread_mutex_trylock.c (__pthread_mutex_trylock): Likewise.
+	* nptl/pthread_mutex_unlock.c (__pthread_mutex_unlock_full): Likewise.
+	* sysdeps/nptl/bits/thread-shared-types.h (struct __pthread_mutex_s):
+	Add comments.
+	* nptl/pthread_mutex_destroy.c (__pthread_mutex_destroy):
+	Use atomic_load_relaxed and atomic_store_relaxed.
+	* nptl/pthread_mutex_init.c (__pthread_mutex_init):
+	Use atomic_store_relaxed.
+
+2018-09-28  Adhemerval Zanella  <adhemerval.zanella@linaro.org>
+
+	[BZ #23579]
+	* misc/tst-preadvwritev2-common.c (do_test_with_invalid_fd,
+	do_test_with_invalid_iov): New tests.
+	* misc/tst-preadvwritev2.c, misc/tst-preadvwritev64v2.c (do_test):
+	Call do_test_with_invalid_fd and do_test_with_invalid_iov.
+	* sysdeps/unix/sysv/linux/preadv2.c (preadv2): Use fallback code iff
+	errno is ENOSYS.
+	* sysdeps/unix/sysv/linux/preadv64v2.c (preadv64v2): Likewise.
+	* sysdeps/unix/sysv/linux/pwritev2.c (pwritev2): Likewise.
+	* sysdeps/unix/sysv/linux/pwritev64v2.c (pwritev64v2): Likewise.
+	* NEWS: Add bug fixed.
+
+2018-09-28  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #22753]
+	* sysdeps/posix/preadv2.c (preadv2): Handle offset == -1.
+	* sysdeps/posix/preadv64v2.c (preadv64v2): Likewise.
+	* sysdeps/posix/pwritev2.c (pwritev2): Likewise.
+	* sysdeps/posix/pwritev64v2.c (pwritev64v2): Likweise.
+	* sysdeps/unix/sysv/linux/preadv2.c (preadv2): Likewise.
+	* sysdeps/unix/sysv/linux/preadv64v2.c (preadv64v2): Likewise.
+	* sysdeps/unix/sysv/linux/pwritev2.c (pwritev2): Likewise.
+	* sysdeps/unix/sysv/linux/pwritev64v2.c (pwritev64v2): Likweise.
+	* manual/llio.texi (Scatter-Gather): Mention offset -1.
+	* misc/tst-preadvwritev-common.c (do_test_without_offset): New.
+	* misc/tst-preadvwritev2.c (do_test): Call it.
+	* misc/tst-preadvwritev64v2.c (do_test): Likewise.
+	* NEWS: Add bug fixed.
+
+2018-09-06  Stefan Liebler  <stli@linux.ibm.com>
+
+	* sysdeps/unix/sysv/linux/spawni.c (maybe_script_execute):
+	Increment size of new_argv by one.
+
+2018-08-27 Martin Kuchta  <martin.kuchta@netapp.com>
+	   Torvald Riegel  <triegel@redhat.com>
+
+	[BZ #23538]
+	* nptl/pthread_cond_common.c (__condvar_quiesce_and_switch_g1):
+	Update r to include the set wake-request flag if waiters are
+	remaining after spinning.
+
+2018-07-29  H.J. Lu  <hongjiu.lu@intel.com>
+
+	[BZ #23459]
+	* sysdeps/x86/cpu-features.c (get_extended_indices): New
+	function.
+	(init_cpu_features): Call get_extended_indices for both Intel
+	and AMD CPUs.
+	* sysdeps/x86/cpu-features.h (COMMON_CPUID_INDEX_80000001):
+	Remove "for AMD" comment.
+
+2018-07-29  H.J. Lu  <hongjiu.lu@intel.com>
+
+	[BZ #23456]
+	* sysdeps/x86/cpu-features.h (index_cpu_LZCNT): Set to
+	COMMON_CPUID_INDEX_80000001.
+
+2018-07-10  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #23036]
+	* posix/regexec.c (check_node_accept_bytes): When comparing
+	weights, do not compare an extra byte after the end of the
+	weights.
+
+2018-06-29  Sylvain Lesage  <severo@rednegra.net>
+
+	[BZ #22996]
+	* localedata/locales/es_BO (LC_PAPER): Change to “copy "en_US"”.
+
+2018-07-06  Florian Weimer  <fweimer@redhat.com>
+
+	* conform/conformtest.pl (checknamespace): Escape literal braces
+	in regular expressions.
+
+2018-06-21  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #23253]
+	* sysdeps/generic/math_private.h (default_libc_feholdsetround_ctx):
+	Renamed from libc_feholdsetround_ctx.
+	(default_libc_feresetround_ctx): Renamed from
+	libc_feresetround_ctx.
+	(default_libc_feholdsetround_noex_ctx): Renamed from
+	libc_feholdsetround_noex_ctx.
+	(default_libc_feresetround_noex_ctx): Renamed from
+	libc_feresetround_noex_ctx.
+	[!HAVE_RM_CTX] (libc_feholdsetround_ctx, libc_feresetround_ctx)
+	(libc_feholdsetround_noex_ctx, libc_feresetround_noex_ctx): Macros
+	forwardning to the old implementations under the new names.
+	* sysdeps/i386/fpu/fenv_private.h [__SSE_MATH__]
+	(libc_feholdexcept_setround_ctx, libc_fesetenv_ctx)
+	(libc_feupdateenv_ctx, libc_feholdsetround_ctx)
+	(libc_feresetround_ctx): Forward to default implements for i386
+	and MATH_SET_BOTH_ROUNDING_MODES.
+	* sysdeps/i386/Makefile [$(subdir) == math] (CFLAGS-e_gamma_r.c):
+	Add -DMATH_SET_BOTH_ROUNDING_MODES.
+
+2018-07-03  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #23363]
+	* stdio-common/tst-printf.c (DEC, INT, UNS, fp_test): Remove.
+	* stdio-common/tst-printf.sh: Adjust expected output.
+	* LICENSES: Update.
+
+2018-06-26  Florian Weimer  <fweimer@redhat.com>
+
+	* libio/Makefile (tests-internal): Add tst-vtables,
+	tst-vtables-interposed.
+	* libio/tst-vtables.c: New file.
+	* libio/tst-vtables-common.c: Likewise.
+	* libio/tst-vtables-interposed.c: Likewise.
+
+2018-06-26  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #23313]
+	* libio/vtables.c (check_stdfiles_vtables): New ELF constructor.
+
+2018-06-29  Daniel Alvarez  <dalvarez@redhat.com>
+	    Jakub Sitnicki  <jkbs@redhat.com>
+
+	[BZ #21812]
+	* sysdeps/unix/sysv/linux/ifaddrs.c (getifaddrs_internal): Retry
+	on NLM_F_DUMP_INTR.
+
+2018-06-28  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #23349]
+	* time/bits/types/struct_timespec.h: Change header inclusion guard to
+	_STRUCT_TIMESPEC.
+
+2018-05-24  Gabriel F. T. Gomes  <gabriel@inconstante.eti.br>
+
+	[BZ #23171]
+	* math/math.h [C++] (iseqsig): Fix parameter type for the long
+	double version.
+
+2018-06-12  Carlos O'Donell  <carlos@redhat.com>
+	    Andreas Schwab  <schwab@suse.de>
+	    Dmitry V. Levin  <ldv@altlinux.org>
+	    Florian Weimer <fweimer@redhat.com>
+
+	[BZ #23102]
+	[BZ #21942]
+	[BZ #18018]
+	[BZ #23259]
+	CVE-2011-0536
+	* elf/dl-dst.h: Remove DL_DST_COUNT.
+	* elf/dl-deps.c (expand_dst): Call _dl_dst_count.
+	* elf/dl-load.c (is_trusted_path_normalize): Don't handle colons.
+	(is_dst): Comment.  Support ELF gABI.
+	(_dl_dst_count): Comment.  Simplify and count DSTs.
+	(_dl_dst_substitute): Comment.  Support __libc_enable_secure handling.
+	(expand_dybamic_string_token): Comment. Call _dl_dst_count. Rename
+	locals.
+
+2018-06-12  Florian Weimer  <fweimer@redhat.com>
+
+	x86: Make strncmp usable from rtld.
+	* sysdeps/i386/i686/multiarch/strncmp-c.c: Only rename strncmp to
+	__strncmp_ia32 if in libc (and not in rtld).
+	* sysdeps/x86_64/multiarch/strncmp-sse2.S: Rename strcmp to
+	strncmp if not in libc (and not to __strncmp_sse2).
+
+2018-06-01  Florian Weimer  <fweimer@redhat.com>
+
+	* sysdeps/i386/i686/fpu/multiarch/libm-test-ulps: Update from master
+	branch, commit e02c026f38505cd474ff1bdaa88fc671804f5805.
+	* sysdeps/i386/fpu/libm-test-ulps: Likewise.
+
+2018-06-08  Adhemerval Zanella  <adhemerval.zanella@linaro.org>
+
+	[BZ #23264]
+	* include/unistd.h (__execvpex): New prototype.
+	* posix/Makefile (tests): Add tst-spawn4.
+	(tests-internal): Add tst-spawn4-compat.
+	* posix/execvpe.c (__execvpe_common, __execvpex): New functions.
+	* posix/tst-spawn4-compat.c: New file.
+	* posix/tst-spawn4.c: Likewise.
+	* sysdeps/unix/sysv/linux/spawni.c (__spawni): Do not interpret invalid
+	binaries as shell scripts.
+	* sysdeps/posix/spawni.c (__spawni): Likewise.
+	* NEWS: Add BZ#22264.
+
+2018-06-01  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #23236]
+	* libio/strfile.h (struct _IO_str_fields): Rename members to
+	discourage their use and add comment.
+	(_IO_STR_DYNAMIC): Remove unused macro.
+	* libio/strops.c (_IO_str_init_static_internal): Do not use
+	callback pointers.  Call malloc and free.
+	(_IO_str_overflow): Do not use callback pointers.  Call malloc
+	and free.
+	(enlarge_userbuf): Likewise.
+	(_IO_str_finish): Call free.
+	* libio/wstrops.c (_IO_wstr_init_static): Initialize
+	_allocate_buffer_unused.
+	(_IO_wstr_overflow): Do not use callback pointers.  Call malloc
+	and free.
+	(enlarge_userbuf): Likewise.
+	(_IO_wstr_finish): Call free.
+	* debug/vasprintf_chk.c (__vasprintf_chk): Initialize
+	_allocate_buffer_unused, _free_buffer_unused.
+	* libio/memstream.c (__open_memstream): Likewise.
+	* libio/vasprintf.c (_IO_vasprintf): Likewise.
+	* libio/wmemstream.c (open_wmemstream): Likewise.
+
+2018-05-23  H.J. Lu  <hongjiu.lu@intel.com>
+
+	[BZ #23196]
+	* string/test-memcpy.c (do_test1): New function.
+	(test_main): Call it.
+
+2018-05-23  Andreas Schwab  <schwab@suse.de>
+
+	[BZ #23196]
+	CVE-2018-11237
+	* sysdeps/x86_64/multiarch/memmove-avx512-no-vzeroupper.S
+	(L(preloop_large)): Save initial destination pointer in %r11 and
+	use it instead of %rax after the loop.
+	* string/test-mempcpy.c (MIN_PAGE_SIZE): Define.
+
+2018-05-11  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #23166]
+	* include/rpc/clnt.h (rpc_createerr): Declare hidden alias.
+	* include/rpc/svc.h (svc_pollfd, svc_max_pollfd, svc_fdset):
+	Likewise.
+	* sunrpc/rpc_common.c (svc_fdset, rpc_createerr, svc_pollfd)
+	(svc_max_pollfd): Add nocommon attribute and hidden alias.  Do not
+	export without --enable-obsolete-rpc.
+	* sunrpc/svcauth_des.c (svcauthdes_stats): Turn into compatibility
+	symbol.  This should not have been exported, ever.
+
+2018-05-11  Rafal Luzynski  <digitalfreak@lingonborough.com>
+
+	[BZ #23152]
+	* localedata/locales/gd_GB (abmon): Fix typo in May:
+	"Mhàrt" -> "Cèit".  Adjust the comment according to the change.
+
+2018-05-09  Paul Pluzhnikov  <ppluzhnikov@google.com>
+
+	[BZ #22786]
+	CVE-2018-11236
+	* stdlib/canonicalize.c (__realpath): Fix overflow in path length
+	computation.
+	* stdlib/Makefile (test-bz22786): New test.
+	* stdlib/test-bz22786.c: New test.
+
+2018-05-05  Paul Pluzhnikov  <ppluzhnikov@google.com>
+
+	[BZ #20419]
+	* elf/dl-load.c (open_verify): Fix stack overflow.
+	* elf/Makefile (tst-big-note): New test.
+	* elf/tst-big-note-lib.S: New.
+	* elf/tst-big-note.c: New.
+
+2018-05-04  Stefan Liebler  <stli@linux.vnet.ibm.com>
+
+	[BZ #23137]
+	* sysdeps/nptl/lowlevellock.h (lll_wait_tid):
+	Use atomic_load_acquire to load __tid.
+
+2018-04-24  Joseph Myers  <joseph@codesourcery.com>
+
+	* sysdeps/unix/sysv/linux/sys/ptrace.h
+	(PTRACE_SECCOMP_GET_METADATA): New enum value and macro.
+	* sysdeps/unix/sysv/linux/bits/ptrace-shared.h
+	(struct __ptrace_seccomp_metadata): New type.
+	* sysdeps/unix/sysv/linux/aarch64/sys/ptrace.h
+	(PTRACE_SECCOMP_GET_METADATA): Likewise.
+	* sysdeps/unix/sysv/linux/arm/sys/ptrace.h
+	(PTRACE_SECCOMP_GET_METADATA): Likewise.
+	* sysdeps/unix/sysv/linux/ia64/sys/ptrace.h
+	(PTRACE_SECCOMP_GET_METADATA): Likewise.
+	* sysdeps/unix/sysv/linux/powerpc/sys/ptrace.h
+	(PTRACE_SECCOMP_GET_METADATA): Likewise.
+	* sysdeps/unix/sysv/linux/s390/sys/ptrace.h
+	(PTRACE_SECCOMP_GET_METADATA): Likewise.
+	* sysdeps/unix/sysv/linux/sparc/sys/ptrace.h
+	(PTRACE_SECCOMP_GET_METADATA): Likewise.
+	* sysdeps/unix/sysv/linux/tile/sys/ptrace.h
+	(PTRACE_SECCOMP_GET_METADATA): Likewise.
+	* sysdeps/unix/sysv/linux/x86/sys/ptrace.h
+	(PTRACE_SECCOMP_GET_METADATA): Likewise.
+
+2018-04-09  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #23037]
+	* resolv/res_send.c (send_dg): Use designated initializers instead
+	of assignment to zero-initialize other fields of struct mmsghdr.
+
+2018-04-06  Andreas Schwab  <schwab@linux-m68k.org>
+
+	* manual/charset.texi (Converting a Character): Fix typo.
+
+2018-04-05  Florian Weimer  <fweimer@redhat.com>
+
+	* manual/examples/mbstouwcs.c (mbstouwcs): Fix loop termination,
+	integer overflow, memory leak on error, and indeterminate errno
+	value.  Add a null wide character to terminate the result string.
+	* manual/charset.texi (Converting a Character): Mention embedded
+	null bytes in the mbrtowc input string.  Explain what happens in
+	the -2 result case.  Do not claim that mbrtowc is simple or
+	obvious to use.  Adjust the description of the code example.  Use
+	@code, not @var, for concrete variables.
+
+2018-04-05  Florian Weimer  <fweimer@redhat.com>
+
+	* manual/examples/mbstouwcs.c: New file.
+	* manual/charset.texi (Converting a Character): Include it.
+
+2018-04-03  H.J. Lu  <hongjiu.lu@intel.com>
+
+	[BZ #22947]
+	* bits/uio-ext.h (RWF_APPEND): New.
+	* sysdeps/unix/sysv/linux/bits/uio-ext.h (RWF_APPEND): Likewise.
+	* manual/llio.texi: Document RWF_APPEND.
+	* misc/tst-preadvwritev2-common.c (RWF_APPEND): New.
+	(RWF_SUPPORTED): Add RWF_APPEND.
+
+2018-03-27  Jesse Hathaway  <jesse@mbuki-mvuki.org>
+
+	* sysdeps/unix/sysv/linux/getlogin_r.c (__getlogin_r_loginuid): Return
+	early when linux sentinel value is set.
+
+2018-03-27  Andreas Schwab  <schwab@suse.de>
+
+	[BZ #23005]
+	* resolv/res_send.c (__res_context_send): Return ENOMEM if
+	allocation of private copy of nsaddr_list fails.
+
+2018-03-20  Joseph Myers  <joseph@codesourcery.com>
+
+	[BZ #17343]
+	* stdlib/random_r.c (__random_r): Use unsigned arithmetic for
+	possibly overflowing computations.
+
+2018-04-26  Aurelien Jarno  <aurelien@aurel32.net>
+
+	* signal/tst-sigaction.c: New file to test BZ #23069.
+	* signal/Makefile (tests): Fix indentation. Add tst-sigaction.
+
+2018-04-28  Aurelien Jarno  <aurelien@aurel32.net>
+
+	[BZ #23069]
+	* sysdeps/unix/sysv/linux/riscv/kernel_sigaction.h: New file.
+
+2018-03-29  Florian Weimer  <fweimer@redhat.com>
+
+	* sysdeps/unix/sysv/linux/i386/tst-bz21269.c (do_test): Also
+	capture SIGBUS.
+
+2018-03-23  Andrew Senkevich  <andrew.senkevich@intel.com>
+	    Max Horn  <max@quendi.de>
+
+	[BZ #22644]
+	CVE-2017-18269
+	* sysdeps/i386/i686/multiarch/memcpy-sse2-unaligned.S: Fixed
+	branch conditions.
+	* string/test-memmove.c (do_test2): New testcase.
+
+2018-02-22  Andrew Waterman <andrew@sifive.com>
+
+	[BZ # 22884]
+	* sysdeps/riscv/rvd/s_fmax.c (__fmax): Handle sNaNs correctly.
+	* sysdeps/riscv/rvd/s_fmin.c (__fmin): Likewise.
+	* sysdeps/riscv/rvf/s_fmaxf.c (__fmaxf): Likewise.
+	* sysdeps/riscv/rvf/s_fminf.c (__fminf): Likewise.
+
+2018-02-22  DJ Delorie  <dj@delorie.com>
+
+	* sysdeps/riscv/tls-macros.h: Do not initialize $gp.
+
+2018-03-16  Rafal Luzynski  <digitalfreak@lingonborough.com>
+
+	[BZ #22963]
+	* localedata/locales/cs_CZ (mon): Rename to...
+	(alt_mon): This.
+	(mon): Import from CLDR (genitive case).
+
+2018-03-16  Rafal Luzynski  <digitalfreak@lingonborough.com>
+
+	[BZ #22937]
+	* localedata/locales/el_CY (abmon): Rename to...
+	(ab_alt_mon): This.
+	(abmon): Import from CLDR (abbreviated genitive case).
+	* localedata/locales/el_GR (abmon): Rename to...
+	(ab_alt_mon): This.
+	(abmon): Import from CLDR (abbreviated genitive case).
+
+2018-03-16  Rafal Luzynski  <digitalfreak@lingonborough.com>
+
+	[BZ #22932]
+	* localedata/locales/lt_LT (abmon): Synchronize with CLDR.
+
+2018-03-16  Robert Buj  <robert.buj@gmail.com>
+
+	[BZ #22848]
+	* localedata/locales/ca_ES (abmon): Rename to...
+	(ab_alt_mon): This, then synchronize with CLDR (nominative case).
+	(mon): Rename to...
+	(alt_mon): This.
+	(abmon): Import from CLDR (genitive case, month names preceded by
+	"de" or "d’").
+	(mon): Likewise.
+	(abday): Synchronize with CLDR.
+	(d_t_fmt): Likewise.
+	(d_fmt): Likewise.
+	(am_pm): Likewise.
+
+	(LC_TIME): Improve indentation.
+	(LC_TELEPHONE): Likewise.
+	(LC_NAME): Likewise.
+	(LC_ADDRESS): Likewise.
+
+2018-03-12  Dmitry V. Levin  <ldv@altlinux.org>
+
+	* po/pt_BR.po: Update translations.
+
+2018-03-03  Adhemerval Zanella  <adhemerval.zanella@linaro.org>
+
+	[BZ #21269]
+	* sysdeps/unix/sysv/linux/i386/Makefile (tests): Add tst-bz21269.
+	* sysdeps/unix/sysv/linux/i386/sigaction.c (SET_SA_RESTORER): Clear
+	sa_restorer for vDSO case.
+	* sysdeps/unix/sysv/linux/i386/tst-bz21269.c: New file.
+
+2018-03-03  Andreas Schwab  <schwab@linux-m68k.org>
+
+	[BZ #22918]
+	* nss/nsswitch.h (DEFINE_DATABASE): Don't define __nss_*_database.
+	* nss/nsswitch.c (DEFINE_DATABASE): Define __nss_*_database here.
+	* nscd/gai.c (__nss_hosts_database): Readd definition.
+	* posix/tst-rfc3484.c (__nss_hosts_database): Likewise.
+	* posix/tst-rfc3484-3.c (__nss_hosts_database): Likewise.
+	* posix/tst-rfc3484-2.c (__nss_hosts_database): Likewise.
+
+2018-03-01  DJ Delorie  <dj@delorie.com>
+
+	[BZ #22342]
+	* nscd/netgroupcache.c (addinnetgrX): Include trailing NUL in
+	key value.
+
+2018-02-26  Dmitry V. Levin  <ldv@altlinux.org>
+
+	[BZ #22433]
+	[BZ #22807]
+	* sysdeps/unix/sysv/linux/powerpc/sys/ptrace.h (__ptrace_request): Add
+	PTRACE_GETREGS, PTRACE_SETREGS, PTRACE_GETFPREGS, PTRACE_SETFPREGS,
+	PTRACE_GETVRREGS, PTRACE_SETVRREGS, PTRACE_GETEVRREGS,
+	PTRACE_SETEVRREGS, PTRACE_GETREGS64, PTRACE_SETREGS64,
+	PTRACE_GET_DEBUGREG, PTRACE_SET_DEBUGREG, PTRACE_GETVSRREGS,
+	PTRACE_SETVSRREGS, and PTRACE_SINGLEBLOCK.
+
+2018-02-26  Tulio Magno Quites Machado Filho  <tuliom@linux.vnet.ibm.com>
+
+	* sysdeps/unix/sysv/linux/powerpc/sys/ptrace.h: Undefine Linux
+	macros used in __ptrace_request.
+
+2018-02-21  Mike FABIAN  <mfabian@redhat.com>
+
+	[BZ #22517]
+	* localedata/locales/et_EE (LC_COLLATE): add missing “reorder-end”
+
+2018-02-21  Rical Jasan  <ricaljasan@pacific.net>
+
+	* io/fcntl.h: Fix a typo in a comment.
+
+2018-02-20  Rical Jasan  <ricaljasan@pacific.net>
+
+	* manual/creature.texi (_ISOC99_SOURCE): Update the dated
+	description.
+
+	[BZ #16335]
+	* manual/creature.texi (_POSIX_C_SOURCE): Document special values
+	of 199606L, 200112L, and 200809L.
+	(_XOPEN_SOURCE): Document special values of 600 and 700.
+	(_ISOC11_SOURCE): Document macro.
+	(_ATFILE_SOURCE): Likewise.
+	(_FORTIFY_SOURCE): Likewise.
+
+2018-03-09  Aurelien Jarno  <aurelien@aurel32.net>
+
+	[BZ #22919]
+	* sysdeps/unix/sysv/linux/sparc/sparc32/setcontext.S (__startcontext):
+	Add nop before __startcontext, add explaining comments.
+
+2018-03-07  Adhemerval Zanella  <adhemerval.zanella@linaro.org>
+
+	[BZ #22926]
+	* sysdeps/powerpc/powerpc32/sysdep.h (ABORT_TRANSACTION_IMPL): Define
+	empty for __SPE__.
+	* sysdeps/powerpc/sysdep.h (ABORT_TRANSACTION): Likewise.
+	* sysdeps/unix/sysv/linux/powerpc/elision-lock.c (__lll_lock_elision):
+	Do not build hardware transactional code for __SPE__.
+	* sysdeps/unix/sysv/linux/powerpc/elision-trylock.c
+	(__lll_trylock_elision): Likewise.
+	* sysdeps/unix/sysv/linux/powerpc/elision-unlock.c
+	(__lll_unlock_elision): Likewise.
+
+2018-02-19  Rical Jasan  <ricaljasan@pacific.net>
+
+	[BZ #6889]
+	* manual/filesys.texi (get_current_dir_name): Clarify behaviour.
+
+2018-02-16  Rical Jasan  <ricaljasan@pacific.net>
+
+	* manual/platform.texi (__riscv_flush_icache): Fix @deftypefun
+	syntax.
+
+2018-02-09  Rical Jasan  <ricaljasan@pacific.net>
+
+	* manual/creature.texi: Convert references to gcc.info to gcc.
+	* manual/stdio.texi: Likewise.
+	* manual/string.texi: Likewise.
+
+2018-02-18  Aurelien Jarno  <aurelien@aurel32.net>
+
+	[BZ #22818]
+	* posix/tst-glob_lstat_compat.c [__alpha__] (glob): Access
+	the GLIBC_2.1 version.
+
+2018-02-02  Sean McKean  <smckean83@gmail.com>
+
+	[BZ #22735]
+	* time/time.h (clock): Reference CLOCKS_PER_SEC in comment.
+
+2018-02-10  Dmitry V. Levin  <ldv@altlinux.org>
+
+	[BZ #22433]
+	* sysdeps/unix/sysv/linux/aarch64/sys/ptrace.h (__ptrace_request):
+	Remove arm-specific PTRACE_GET_THREAD_AREA, PTRACE_GETHBPREGS,
+	and PTRACE_SETHBPREGS.
+
+2018-02-14  Adhemerval Zanella  <adhemerval.zanella@linaro.org>
+
+	* sysdeps/sh/libm-test-ulps: Update.
+
+2018-02-09  DJ Delorie  <dj@redhat.com>
+
+	[BZ #22827]
+	* sysdeps/unix/sysv/linux/riscv/readelflib.c (process_elf_file): Use
+	64-bit ELF type for 64-bit ELF objects.
+
+2018-02-07  Igor Gnatenko  <ignatenko@redhat.com>
+
+	[BZ #22797]
+	* sysdeps/unix/sysv/linux/bits/mman-shared.h (pkey_get): Add
+	missing second underscore to parameter name.
+
+2018-02-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	[BZ #22638]
+	* sysdeps/sparc/sparc32/start.S (_start): Check PIC instead of
+	SHARED.
+	* sysdeps/sparc/sparc64/start.S (_start): Likewise.
+
 2018-02-01  Dmitry V. Levin  <ldv@altlinux.org>
 
 	* version.h (RELEASE): Set to "stable".
@@ -710,7 +1860,9 @@
 2018-01-18  Arjun Shankar  <arjun@redhat.com>
 
 	[BZ #22343]
+	[BZ #22774]
 	CVE-2018-6485
+	CVE-2018-6551
 	* malloc/malloc.c (checked_request2size): call REQUEST_OUT_OF_RANGE
 	after padding.
 	(_int_memalign): check for integer overflow before calling
diff --git a/LICENSES b/LICENSES
index 80f7f14879..858076d9d3 100644
--- a/LICENSES
+++ b/LICENSES
@@ -441,15 +441,6 @@ Permission to use, copy, modify, and distribute this
 software is freely granted, provided that this notice
 is preserved.
 
-Part of stdio-common/tst-printf.c is copyright C E Chew:
-
-(C) Copyright C E Chew
-
-Feel free to copy, use and distribute this software provided:
-
-     1. you do not pretend that you wrote it
-     2. you leave this copyright notice intact.
-
 Various long double libm functions are copyright Stephen L. Moshier:
 
 Copyright 2001 by Stephen L. Moshier <moshier@na-net.ornl.gov>
diff --git a/NEWS b/NEWS
index a71c1038a8..b434ba0616 100644
--- a/NEWS
+++ b/NEWS
@@ -4,6 +4,209 @@ See the end for copying conditions.
 
 Please send GNU C library bug reports via <https://sourceware.org/bugzilla/>
 using `glibc' in the "product" field.
+
+Version 2.27.1
+
+Major new features:
+
+* The entry for the new Japanese era has been added for ja_JP locale.
+
+* Nominative and genitive month names are now supported for the Catalan and
+  Czech languages.  The Catalan and Greek languages now support abbreviated
+  alternative month names.
+
+* Parsing of dynamic string tokens in DT_RPATH, DT_RUNPATH, DT_NEEDED,
+  DT_AUXILIARY, and DT_FILTER has been expanded to support the full
+  range of ELF gABI expressions including such constructs as
+  '$ORIGIN$ORIGIN' (if valid).  For SUID/GUID applications the rules
+  have been further restricted, and where in the past a dynamic string
+  token sequence may have been interpreted as a literal string it will
+  now cause a load failure.  These load failures were always considered
+  unspecified behaviour from the perspective of the dynamic loader, and
+  for safety are now load errors e.g. /foo/${ORIGIN}.so in DT_NEEDED
+  results in a load failure now.
+
+Deprecated and removed features, and other changes affecting compatibility:
+
+* The copy_file_range function fails with ENOSYS if the kernel does not
+  support the system call of the same name.  Previously, user space
+  emulation was performed, but its behavior did not match the kernel
+  behavior, which was deemed too confusing.  Applications which use the
+  copy_file_range function will have to be run on kernels which implement
+  the copy_file_range system call.  Support for most architectures was added
+  in version 4.5 of the mainline Linux kernel.
+
+Security related changes:
+
+  CVE-2016-10228: An infinite loop has been fixed in the iconv program when
+  invoked with the -c option and when processing invalid multi-byte input
+  sequences.  Reported by Jan Engelhardt.
+
+  CVE-2017-18269: An SSE2-based memmove implementation for the i386
+  architecture could corrupt memory.  Reported by Max Horn.
+
+  CVE-2018-11236: Very long pathname arguments to realpath function could
+  result in an integer overflow and buffer overflow.  Reported by Alexey
+  Izbyshev.
+
+  CVE-2018-11237: The mempcpy implementation for the Intel Xeon Phi
+  architecture could write beyond the target buffer, resulting in a buffer
+  overflow.  Reported by Andreas Schwab.
+
+  CVE-2018-19591: A file descriptor leak in if_nametoindex can lead to a
+  denial of service due to resource exhaustion when processing getaddrinfo
+  calls with crafted host names.  Reported by Guido Vranken.
+
+  CVE-2019-6488: On x32, the size_t parameter may be passed in the lower
+  32 bits of a 64-bit register with with non-zero upper 32 bit.  When it
+  happened, accessing the 32-bit size_t value as the full 64-bit register
+  in the assembly string/memory functions would cause a buffer overflow.
+  Reported by H.J. Lu.
+
+  CVE-2019-7309: x86-64 memcmp used signed Jcc instructions to check
+  size.  For x86-64, memcmp on an object size larger than SSIZE_MAX
+  has undefined behavior.  On x32, the size_t argument may be passed
+  in the lower 32 bits of the 64-bit RDX register with non-zero upper
+  32 bits.  When it happened with the sign bit of RDX register set,
+  memcmp gave the wrong result since it treated the size argument as
+  zero.  Reported by H.J. Lu.
+
+  CVE-2019-19126: ld.so failed to ignore the LD_PREFER_MAP_32BIT_EXEC
+  environment variable during program execution after a security
+  transition, allowing local attackers to restrict the possible mapping
+  addresses for loaded libraries and thus bypass ASLR for a setuid
+  program.  Reported by Marcin Kościelnicki.
+
+  CVE-2020-1751: A defect in the PowerPC backtrace function could cause an
+  out-of-bounds write when executed in a signal frame context.
+
+  CVE-2020-1752: A use-after-free vulnerability in the glob function when
+  expanding ~user has been fixed.
+
+  CVE-2020-6096: A signed comparison vulnerability in the ARMv7 memcpy and
+  memmove functions has been fixed.  Discovered by Jason Royes and Samual
+  Dytrych of the Cisco Security Assessment and Penetration Team (See
+  TALOS-2020-1019).
+
+  CVE-2020-10029: Trigonometric functions on x86 targets suffered from stack
+  corruption when they were passed a pseudo-zero argument.  Reported by Guido
+  Vranken / ForAllSecure Mayhem.
+
+  CVE-2020-27618: An infinite loop has been fixed in the iconv program when
+  invoked with input containing redundant shift sequences in the IBM1364,
+  IBM1371, IBM1388, IBM1390, or IBM1399 character sets.
+
+  CVE-2020-29562: An assertion failure has been fixed in the iconv function
+  when invoked with UCS4 input containing an invalid character.
+
+  CVE-2021-27645: The nameserver caching daemon (nscd), when processing
+  a request for netgroup lookup, may crash due to a double-free,
+  potentially resulting in degraded service or Denial of Service on the
+  local system.  Reported by Chris Schanzle.
+
+  CVE-2021-35942: The wordexp function may overflow the positional
+  parameter number when processing the expansion resulting in a crash.
+  Reported by Philippe Antoine.
+
+The following bugs are resolved with this release:
+
+  [6889] 'PWD' mentioned but not specified
+  [16335] Feature test macro documentation incomplete and out of date
+  [17343] Signed integer overflow in /stdlib/random_r.c
+  [18018] Additional $ORIGIN handling issues (CVE-2011-0536)
+  [18035] Fix pldd hang
+  [18830] locale: iconv -c -f ascii with >buffer size worth of input before
+    invalid input drops valid char
+  [19519] iconv(1) with -c option hangs on illegal multi-byte sequences
+    (CVE-2016-10228)
+  [20419] files with large allocated notes crash in open_verify
+  [20568] Fix crash in _IO_wfile_sync
+  [21269] i386 sigaction sa_restorer handling is wrong
+  [21812] getifaddrs: Don't return ifa entries with NULL names
+  [21942] _dl_dst_substitute incorrectly handles $ORIGIN: with AT_SECURE=1
+  [22342] NSCD not properly caching netgroup
+  [22638] sparc: static binaries are broken if glibc is built by gcc
+    configured with --enable-default-pie
+  [22644] memmove-sse2-unaligned on 32bit x86 produces garbage when crossing
+    2GB threshold
+  [22735] Misleading typo in time.h source comment regarding CLOCKS_PER_SECOND
+  [22753] libc: preadv2/pwritev2 fallback code should handle offset=-1
+  [22786] Stack buffer overflow in realpath() if input size is close
+    to SSIZE_MAX
+  [22797] Linux: use reserved name __key in pkey_get
+  [22807] PTRACE_* constants missing for powerpc
+  [22818] posix/tst-glob_lstat_compat failure on alpha
+  [22827] RISC-V ELF64 parser mis-reads flag in ldconfig
+  [22848] ca_ES: update date definitions from CLDR
+  [22884] RISCV fmax/fmin handle signalling NANs incorrectly
+  [22918] multiple common of `__nss_shadow_database'
+  [22919] sparc32: backtrace yields infinite backtrace with makecontext
+  [22926] FTBFS on powerpcspe
+  [22927] libanl: properly cleanup if first helper thread creation failed
+  [22932] lt_LT: Update of abbreviated month names from CLDR required
+  [22937] Greek (el_GR, el_CY) locales actually need ab_alt_mon
+  [22947] FAIL: misc/tst-preadvwritev2
+  [22963] cs_CZ: Add alternative month names
+  [22964] The Japanese Era name will be changed on May 1, 2019
+  [22996] localedata: change LC_PAPER to en_US in es_BO locale
+  [23005] Crash in __res_context_send after memory allocation failure
+  [23036] regexec: Fix off-by-one bug in weight comparison
+  [23037] initialize msg_flags to zero for sendmmsg() calls
+  [23069] sigaction broken on riscv64-linux-gnu
+  [23102] Incorrect parsing of consecutive $ variables in runpath entries
+  [23132] localedata: Missing transliterations in Miscellaneous Mathematical
+    Symbols-A/B Unicode blocks
+  [23137] s390: pthread_join sometimes block indefinitely (on 31bit and libc
+    build with -Os)
+  [23152] gd_GB: Fix typo in "May" (abbreviated)
+  [23166] sunrpc: Remove stray exports without --enable-obsolete-rpc
+  [23171] Fix parameter type in C++ version of iseqsig
+  [23196] __mempcpy_avx512_no_vzeroupper mishandles large copies
+  [23236] Harden function pointers in _IO_str_fields
+  [23253] Set 387 and SSE2 rounding mode for tgamma on i386
+  [23259] Unsubstituted ${ORIGIN} remains in DT_NEEDED for AT_SECURE
+  [23264] libc: posix_spawnp wrongly executes ENOEXEC in non compat mode
+  [23275] Race in pthread_mutex_lock while promoting to PTHREAD_MUTEX_ELISION_NP
+  [23313] libio: Disable vtable validation in case of interposition
+  [23349] Various glibc headers no longer compatible with <linux/time.h>
+  [23363] stdio-common/tst-printf.c has non-free license
+  [23456] Wrong index_cpu_LZCNT
+  [23459] COMMON_CPUID_INDEX_80000001 isn't populated for Intel processors
+  [23520] nscd: nscd: Use-after-free in addgetnetgrentX and its callers
+  [23538] pthread_cond_broadcast: Fix waiters-after-spinning case
+  [23562] signal: Use correct type for si_band in siginfo_t
+  [23579] libc: Errors misreported in preadv2
+  [23614] powerpc: missing CFI register information in __mpn_* functions
+  [23690] Fix _dl_profile_fixup data-dependency issue
+  [23709] Fix CPU string flags for Haswell-type CPUs
+  [23821] si_band in siginfo_t has wrong type long int on sparc64
+  [23822] ia64 static libm.a is missing exp2f, log2f and powf symbols
+  [23861] rdlock stalls indefinitely on an unlocked pthread rwlock
+  [23907] Incorrect double-free malloc tcache check disregards tcache size
+  [23927] Linux if_nametoindex() does not close descriptor (CVE-2018-19591)
+  [24018] gettext may return NULL
+  [24027] malloc: Integer overflow in realloc
+  [24097] Can't use 64-bit register for size_t in assembly codes for x32 (CVE-2019-6488)
+  [24155] x32 memcmp can treat positive length as 0 (if sign bit in RDX is set) (CVE-2019-7309)
+  [24180] pthread_mutex_trylock does not use the correct order of instructions
+    while maintaining the robust mutex list due to missing compiler barriers
+  [24228] old x86 applications that use legacy libio crash on exit
+  [24531] Malloc tunables give tcache assertion failures
+  [24744] io: Remove the copy_file_range emulation
+  [25203] libio: Disable vtable validation for pre-2.1 interposed handles
+  [25204] Ignore LD_PREFER_MAP_32BIT_EXEC for SUID programs
+  [25232] No const correctness for strchr et al. for Clang++
+  [25414] 'glob' use-after-free bug (CVE-2020-1752)
+  [25423] Array overflow in backtrace on powerpc
+  [25487] sinl() stack corruption from crafted input (CVE-2020-10029)
+  [25620] libc: Signed comparison vulnerability in the ARMv7 memcpy() (CVE-2020-6096)
+  [26224] iconv hangs when converting some invalid inputs from several IBM
+    character sets (CVE-2020-27618)
+  [26383] bind_textdomain_codeset doesn't accept //TRANSLIT anymore
+  [26923] Assertion failure in iconv when converting invalid UCS4 (CVE-2020-29562)
+  [27462] nscd: double-free in nscd (CVE-2021-27645)
+  [28011] libc: Wild read in wordexp (parse_param) (CVE-2021-35942)
+
 
 Version 2.27
 
@@ -262,6 +465,10 @@ Security related changes:
   an object size near the value of SIZE_MAX, would return a pointer to a
   buffer which is too small, instead of NULL.  Reported by Jakub Wilk.
 
+  CVE-2018-6551: The malloc function, when called with an object size near
+  the value of SIZE_MAX, would return a pointer to a buffer which is too
+  small, instead of NULL.
+
 The following bugs are resolved with this release:
 
   [866] glob: glob should match dangling symlinks
@@ -334,6 +541,7 @@ The following bugs are resolved with this release:
   [21326] libc: C99 functions are not declared for C++11 and later if
     _GNU_SOURCE is not predefined by g++
   [21457] libc: sys/ucontext.h namespace
+  [21508] locale: intl/tst-gettext failure with latest msgfmt
   [21530] libc: tmpfile() should be implemented using O_TMPFILE
   [21660] math: GCC fails to compile a formula with tgmath.h
   [21672] nptl: sys-libs/glibc on ia64 crashes on thread exit: signal
diff --git a/benchtests/bench-strcasestr.c b/benchtests/bench-strcasestr.c
index e6659ea79e..4337e0c18d 100644
--- a/benchtests/bench-strcasestr.c
+++ b/benchtests/bench-strcasestr.c
@@ -24,6 +24,7 @@
 #define STRCASESTR simple_strcasestr
 #define NO_ALIAS
 #define __strncasecmp strncasecmp
+#define __strnlen strnlen
 #include "../string/strcasestr.c"
 
 
diff --git a/benchtests/bench-strstr.c b/benchtests/bench-strstr.c
index 86d5e829da..b7431de320 100644
--- a/benchtests/bench-strstr.c
+++ b/benchtests/bench-strstr.c
@@ -22,6 +22,9 @@
 
 
 #define STRSTR simple_strstr
+#undef libc_hidden_builtin_def
+#define libc_hidden_builtin_def(X)
+#define __strnlen strnlen
 #include "../string/strstr.c"
 
 
diff --git a/bits/uio-ext.h b/bits/uio-ext.h
index 8c15a05d9a..d5aa06fd08 100644
--- a/bits/uio-ext.h
+++ b/bits/uio-ext.h
@@ -28,5 +28,6 @@
 #define RWF_DSYNC	0x00000002 /* per-IO O_DSYNC.  */
 #define RWF_SYNC	0x00000004 /* per-IO O_SYNC.  */
 #define RWF_NOWAIT	0x00000008 /* per-IO nonblocking mode.  */
+#define RWF_APPEND	0x00000010 /* per-IO O_APPEND.  */
 
 #endif /* sys/uio_ext.h */
diff --git a/catgets/xopen-msg.awk b/catgets/xopen-msg.awk
index a13d6fa06a..bab0f6b4ef 100644
--- a/catgets/xopen-msg.awk
+++ b/catgets/xopen-msg.awk
@@ -58,6 +58,11 @@ $1 ~ "msg(id|str)" {
     next
 }
 
+/^"POT-Creation-Date: [0-9-]+ [0-9:+-]+\\n"/ {
+    # Ignore POT-Creation-Date to match what is done in intl/Makefile.
+    next
+}
+
 /^".*"/ {
     # Append to current message
     sub(/^"/, "", $0)
diff --git a/conform/conformtest.pl b/conform/conformtest.pl
index cb500f0e76..a4ef756105 100644
--- a/conform/conformtest.pl
+++ b/conform/conformtest.pl
@@ -367,7 +367,7 @@ while ($#headers >= 0) {
       s/^optional-//;
       $optional = 1;
     }
-    if (/^element *({([^}]*)}|([^{ ]*)) *({([^}]*)}|([^{ ]*)) *([A-Za-z0-9_]*) *(.*)/) {
+    if (/^element *(\{([^}]*)\}|([^{ ]*)) *(\{([^}]*)\}|([^{ ]*)) *([A-Za-z0-9_]*) *(.*)/) {
       my($struct) = "$2$3";
       my($type) = "$5$6";
       my($member) = "$7";
@@ -556,7 +556,7 @@ while ($#headers >= 0) {
 			"Symbol \"$symbol\" has not the right value.", $res,
 			$xfail);
       }
-    } elsif (/^type *({([^}]*)|([a-zA-Z0-9_]*))/) {
+    } elsif (/^type *(\{([^}]*)|([a-zA-Z0-9_]*))/) {
       my($type) = "$2$3";
       my($maybe_opaque) = 0;
 
@@ -586,7 +586,7 @@ while ($#headers >= 0) {
 		    ? "NOT AVAILABLE"
 		    : "Type \"$type\" not available."), $missing, $optional,
 		   $xfail);
-    } elsif (/^tag *({([^}]*)|([a-zA-Z0-9_]*))/) {
+    } elsif (/^tag *(\{([^}]*)|([a-zA-Z0-9_]*))/) {
       my($type) = "$2$3";
 
       # Remember that this name is allowed.
@@ -607,7 +607,7 @@ while ($#headers >= 0) {
 
       compiletest ($fnamebase, "Testing for type $type",
 		   "Type \"$type\" not available.", $missing, 0, $xfail);
-    } elsif (/^function *({([^}]*)}|([a-zA-Z0-9_]*)) [(][*]([a-zA-Z0-9_]*) ([(].*[)])/) {
+    } elsif (/^function *(\{([^}]*)\}|([a-zA-Z0-9_]*)) [(][*]([a-zA-Z0-9_]*) ([(].*[)])/) {
       my($rettype) = "$2$3";
       my($fname) = "$4";
       my($args) = "$5";
@@ -644,7 +644,7 @@ while ($#headers >= 0) {
 		     "Function \"$fname\" has incorrect type.", $res, 0,
 		     $xfail);
       }
-    } elsif (/^function *({([^}]*)}|([a-zA-Z0-9_]*)) ([a-zA-Z0-9_]*) ([(].*[)])/) {
+    } elsif (/^function *(\{([^}]*)\}|([a-zA-Z0-9_]*)) ([a-zA-Z0-9_]*) ([(].*[)])/) {
       my($rettype) = "$2$3";
       my($fname) = "$4";
       my($args) = "$5";
@@ -681,7 +681,7 @@ while ($#headers >= 0) {
 		     "Function \"$fname\" has incorrect type.", $res, 0,
 		     $xfail);
       }
-    } elsif (/^variable *({([^}]*)}|([a-zA-Z0-9_]*)) ([a-zA-Z0-9_]*) *(.*)/) {
+    } elsif (/^variable *(\{([^}]*)\}|([a-zA-Z0-9_]*)) ([a-zA-Z0-9_]*) *(.*)/) {
       my($type) = "$2$3";
       my($vname) = "$4";
       my($rest) = "$5";
@@ -713,7 +713,7 @@ while ($#headers >= 0) {
 
       compiletest ($fnamebase, "Test for type of variable $fname",
 		   "Variable \"$vname\" has incorrect type.", $res, 0, $xfail);
-    } elsif (/^macro-function *({([^}]*)}|([a-zA-Z0-9_]*)) ([a-zA-Z0-9_]*) ([(].*[)])/) {
+    } elsif (/^macro-function *(\{([^}]*)\}|([a-zA-Z0-9_]*)) ([a-zA-Z0-9_]*) ([(].*[)])/) {
       my($rettype) = "$2$3";
       my($fname) = "$4";
       my($args) = "$5";
@@ -812,11 +812,11 @@ while ($#headers >= 0) {
 
       s/^xfail(\[([^\]]*)\])?-//;
       s/^optional-//;
-      if (/^element *({([^}]*)}|([^ ]*)) *({([^}]*)}|([^ ]*)) *([A-Za-z0-9_]*) *(.*)/) {
+      if (/^element *(\{([^}]*)\}|([^ ]*)) *(\{([^}]*)\}|([^ ]*)) *([A-Za-z0-9_]*) *(.*)/) {
 	push @allow, $7;
       } elsif (/^(macro|constant|macro-constant|macro-int-constant) +([a-zA-Z0-9_]*) *(?:{([^}]*)} *)?(?:([>=<!]+) ([A-Za-z0-9_-]*))?/) {
 	push @allow, $2;
-      } elsif (/^(type|tag) *({([^}]*)|([a-zA-Z0-9_]*))/) {
+      } elsif (/^(type|tag) *(\{([^}]*)|([a-zA-Z0-9_]*))/) {
 	my($type) = "$3$4";
 
 	# Remember that this name is allowed.
@@ -827,13 +827,13 @@ while ($#headers >= 0) {
 	} else {
 	  push @allow, $type;
 	}
-      } elsif (/^function *({([^}]*)}|([a-zA-Z0-9_]*)) [(][*]([a-zA-Z0-9_]*) ([(].*[)])/) {
+      } elsif (/^function *(\{([^}]*)\}|([a-zA-Z0-9_]*)) [(][*]([a-zA-Z0-9_]*) ([(].*[)])/) {
 	push @allow, $4;
-      } elsif (/^function *({([^}]*)}|([a-zA-Z0-9_]*)) ([a-zA-Z0-9_]*) ([(].*[)])/) {
+      } elsif (/^function *(\{([^}]*)\}|([a-zA-Z0-9_]*)) ([a-zA-Z0-9_]*) ([(].*[)])/) {
 	push @allow, $4;
-      } elsif (/^variable *({([^}]*)}|([a-zA-Z0-9_]*)) ([a-zA-Z0-9_]*)/) {
+      } elsif (/^variable *(\{([^}]*)\}|([a-zA-Z0-9_]*)) ([a-zA-Z0-9_]*)/) {
 	push @allow, $4;
-      } elsif (/^macro-function *({([^}]*)}|([a-zA-Z0-9_]*)) ([a-zA-Z0-9_]*) ([(].*[)])/) {
+      } elsif (/^macro-function *(\{([^}]*)\}|([a-zA-Z0-9_]*)) ([a-zA-Z0-9_]*) ([(].*[)])/) {
 	push @allow, $4;
       } elsif (/^symbol *([a-zA-Z0-9_]*) *([A-Za-z0-9_-]*)?/) {
 	push @allow, $1;
diff --git a/conform/data/signal.h-data b/conform/data/signal.h-data
index fa841cfdbe..88c1f5eba2 100644
--- a/conform/data/signal.h-data
+++ b/conform/data/signal.h-data
@@ -170,7 +170,8 @@ element siginfo_t pid_t si_pid
 element siginfo_t uid_t si_uid
 element siginfo_t {void*} si_addr
 element siginfo_t int si_status
-element siginfo_t long si_band
+// Bug 23821: si_band has type int on sparc64.
+xfail[sparc64-linux]-element siginfo_t long si_band
 #  endif
 #  ifndef XPG42
 element siginfo_t {union sigval} si_value
diff --git a/conform/data/sys/wait.h-data b/conform/data/sys/wait.h-data
index 559ebdf677..a6713461ea 100644
--- a/conform/data/sys/wait.h-data
+++ b/conform/data/sys/wait.h-data
@@ -44,7 +44,8 @@ element siginfo_t pid_t si_pid
 element siginfo_t uid_t si_uid
 element siginfo_t {void*} si_addr
 element siginfo_t int si_status
-element siginfo_t long si_band
+// Bug 23821: si_band has type int on sparc64.
+xfail[sparc64-linux]-element siginfo_t long si_band
 # ifndef XPG42
 element siginfo_t {union sigval} si_value
 # endif
diff --git a/debug/tst-backtrace5.c b/debug/tst-backtrace5.c
index 0e6fb1a024..a117f1544f 100644
--- a/debug/tst-backtrace5.c
+++ b/debug/tst-backtrace5.c
@@ -88,6 +88,18 @@ handle_signal (int signum)
       }
   /* Symbol names are not available for static functions, so we do not
      check do_test.  */
+
+  /* Check that backtrace does not return more than what fits in the array
+     (bug 25423).  */
+  for (int j = 0; j < NUM_FUNCTIONS; j++)
+    {
+      n = backtrace (addresses, j);
+      if (n > j)
+	{
+	  FAIL ();
+	  return;
+	}
+    }
 }
 
 NO_INLINE int
diff --git a/debug/vasprintf_chk.c b/debug/vasprintf_chk.c
index a00ef771e6..3eb64617fd 100644
--- a/debug/vasprintf_chk.c
+++ b/debug/vasprintf_chk.c
@@ -55,8 +55,8 @@ __vasprintf_chk (char **result_ptr, int flags, const char *format,
   _IO_JUMPS (&sf._sbf) = &_IO_str_jumps;
   _IO_str_init_static_internal (&sf, string, init_string_size, string);
   sf._sbf._f._flags &= ~_IO_USER_BUF;
-  sf._s._allocate_buffer = (_IO_alloc_type) malloc;
-  sf._s._free_buffer = (_IO_free_type) free;
+  sf._s._allocate_buffer_unused = (_IO_alloc_type) malloc;
+  sf._s._free_buffer_unused = (_IO_free_type) free;
 
   /* For flags > 0 (i.e. __USE_FORTIFY_LEVEL > 1) request that %n
      can only come from read-only format strings.  */
diff --git a/dlfcn/dlerror.c b/dlfcn/dlerror.c
index 04dce9ddc6..0fd1cf1adc 100644
--- a/dlfcn/dlerror.c
+++ b/dlfcn/dlerror.c
@@ -197,7 +197,10 @@ check_free (struct dl_action_result *rec)
       Dl_info info;
       if (_dl_addr (check_free, &info, &map, NULL) != 0 && map->l_ns == 0)
 #endif
-	free ((char *) rec->errstring);
+	{
+	  free ((char *) rec->errstring);
+	  rec->errstring = NULL;
+	}
     }
 }
 
diff --git a/elf/Makefile b/elf/Makefile
index 2a432d8bee..2d8fe88aa6 100644
--- a/elf/Makefile
+++ b/elf/Makefile
@@ -187,7 +187,7 @@ tests += restest1 preloadtest loadfail multiload origtest resolvfail \
 	 tst-tlsalign tst-tlsalign-extern tst-nodelete-opened \
 	 tst-nodelete2 tst-audit11 tst-audit12 tst-dlsym-error tst-noload \
 	 tst-latepthread tst-tls-manydynamic tst-nodelete-dlclose \
-	 tst-debug1 tst-main1
+	 tst-debug1 tst-main1 tst-big-note
 #	 reldep9
 tests-internal += loadtest unload unload2 circleload1 \
 	 neededtest neededtest2 neededtest3 neededtest4 \
@@ -272,7 +272,9 @@ modules-names = testobj1 testobj2 testobj3 testobj4 testobj5 testobj6 \
 		tst-audit12mod1 tst-audit12mod2 tst-audit12mod3 tst-auditmod12 \
 		tst-latepthreadmod $(tst-tls-many-dynamic-modules) \
 		tst-nodelete-dlclose-dso tst-nodelete-dlclose-plugin \
-		tst-main1mod tst-libc_dlvsym-dso
+		tst-main1mod tst-libc_dlvsym-dso \
+		tst-big-note-lib
+
 ifeq (yes,$(have-mtls-dialect-gnu2))
 tests += tst-gnu2-tls1
 modules-names += tst-gnu2-tls1mod
@@ -1446,3 +1448,5 @@ $(objpfx)tst-libc_dlvsym-static: $(common-objpfx)dlfcn/libdl.a
 tst-libc_dlvsym-static-ENV = \
   LD_LIBRARY_PATH=$(objpfx):$(common-objpfx):$(common-objpfx)dlfcn
 $(objpfx)tst-libc_dlvsym-static.out: $(objpfx)tst-libc_dlvsym-dso.so
+
+$(objpfx)tst-big-note: $(objpfx)tst-big-note-lib.so
diff --git a/elf/dl-deps.c b/elf/dl-deps.c
index c975fcffd7..20b8e94f2e 100644
--- a/elf/dl-deps.c
+++ b/elf/dl-deps.c
@@ -100,7 +100,7 @@ struct list
   ({									      \
     const char *__str = (str);						      \
     const char *__result = __str;					      \
-    size_t __dst_cnt = DL_DST_COUNT (__str);				      \
+    size_t __dst_cnt = _dl_dst_count (__str);				      \
 									      \
     if (__dst_cnt != 0)							      \
       {									      \
diff --git a/elf/dl-dst.h b/elf/dl-dst.h
index 32de5d225a..859032be0d 100644
--- a/elf/dl-dst.h
+++ b/elf/dl-dst.h
@@ -18,19 +18,6 @@
 
 #include "trusted-dirs.h"
 
-/* Determine the number of DST elements in the name.  Only if IS_PATH is
-   nonzero paths are recognized (i.e., multiple, ':' separated filenames).  */
-#define DL_DST_COUNT(name) \
-  ({									      \
-    size_t __cnt = 0;							      \
-    const char *__sf = strchr (name, '$');				      \
-									      \
-    if (__glibc_unlikely (__sf != NULL))				      \
-      __cnt = _dl_dst_count (__sf);					      \
-									      \
-    __cnt; })
-
-
 #ifdef SHARED
 # define IS_RTLD(l) (l) == &GL(dl_rtld_map)
 #else
diff --git a/elf/dl-load.c b/elf/dl-load.c
index 7554a99b5a..b20e2a46d0 100644
--- a/elf/dl-load.c
+++ b/elf/dl-load.c
@@ -122,12 +122,6 @@ is_trusted_path_normalize (const char *path, size_t len)
   if (len == 0)
     return false;
 
-  if (*path == ':')
-    {
-      ++path;
-      --len;
-    }
-
   char *npath = (char *) alloca (len + 2);
   char *wnp = npath;
   while (*path != '\0')
@@ -178,114 +172,165 @@ is_trusted_path_normalize (const char *path, size_t len)
   return false;
 }
 
+/* Given a substring starting at INPUT, just after the DST '$' start
+   token, determine if INPUT contains DST token REF, following the
+   ELF gABI rules for DSTs:
+
+   * Longest possible sequence using the rules (greedy).
 
+   * Must start with a $ (enforced by caller).
+
+   * Must follow $ with one underscore or ASCII [A-Za-z] (caller
+     follows these rules for REF) or '{' (start curly quoted name).
+
+   * Must follow first two characters with zero or more [A-Za-z0-9_]
+     (enforced by caller) or '}' (end curly quoted name).
+
+   If the sequence is a DST matching REF then the length of the DST
+   (excluding the $ sign but including curly braces, if any) is
+   returned, otherwise 0.  */
 static size_t
-is_dst (const char *start, const char *name, const char *str, int secure)
+is_dst (const char *input, const char *ref)
 {
-  size_t len;
   bool is_curly = false;
 
-  if (name[0] == '{')
+  /* Is a ${...} input sequence?  */
+  if (input[0] == '{')
     {
       is_curly = true;
-      ++name;
-    }
-
-  len = 0;
-  while (name[len] == str[len] && name[len] != '\0')
-    ++len;
-
-  if (is_curly)
-    {
-      if (name[len] != '}')
-	return 0;
-
-      /* Point again at the beginning of the name.  */
-      --name;
-      /* Skip over closing curly brace and adjust for the --name.  */
-      len += 2;
+      ++input;
     }
-  else if (name[len] != '\0' && name[len] != '/')
-    return 0;
 
-  if (__glibc_unlikely (secure)
-      && ((name[len] != '\0' && name[len] != '/')
-	  || (name != start + 1)))
+  /* Check for matching name, following closing curly brace (if
+     required), or trailing characters which are part of an
+     identifier.  */
+  size_t rlen = strlen (ref);
+  if (strncmp (input, ref, rlen) != 0
+      || (is_curly && input[rlen] != '}')
+      || ((input[rlen] >= 'A' && input[rlen] <= 'Z')
+	  || (input[rlen] >= 'a' && input[rlen] <= 'z')
+	  || (input[rlen] >= '0' && input[rlen] <= '9')
+	  || (input[rlen] == '_')))
     return 0;
 
-  return len;
+  if (is_curly)
+    /* Count the two curly braces.  */
+    return rlen + 2;
+  else
+    return rlen;
 }
 
-
+/* INPUT is the start of a DST sequence at the first '$' occurrence.
+   If there is a DST we call into _dl_dst_count to count the number of
+   DSTs.  We count all known DSTs regardless of __libc_enable_secure;
+   the caller is responsible for enforcing the security of the
+   substitution rules (usually _dl_dst_substitute).  */
 size_t
-_dl_dst_count (const char *name)
+_dl_dst_count (const char *input)
 {
-  const char *const start = name;
   size_t cnt = 0;
 
+  input = strchr (input, '$');
+
+  /* Most likely there is no DST.  */
+  if (__glibc_likely (input == NULL))
+    return 0;
+
   do
     {
       size_t len;
 
-      /* $ORIGIN is not expanded for SUID/GUID programs (except if it
-	 is $ORIGIN alone) and it must always appear first in path.  */
-      ++name;
-      if ((len = is_dst (start, name, "ORIGIN", __libc_enable_secure)) != 0
-	  || (len = is_dst (start, name, "PLATFORM", 0)) != 0
-	  || (len = is_dst (start, name, "LIB", 0)) != 0)
+      ++input;
+      /* All DSTs must follow ELF gABI rules, see is_dst ().  */
+      if ((len = is_dst (input, "ORIGIN")) != 0
+	  || (len = is_dst (input, "PLATFORM")) != 0
+	  || (len = is_dst (input, "LIB")) != 0)
 	++cnt;
 
-      name = strchr (name + len, '$');
+      /* There may be more than one DST in the input.  */
+      input = strchr (input + len, '$');
     }
-  while (name != NULL);
+  while (input != NULL);
 
   return cnt;
 }
 
-
+/* Process INPUT for DSTs and store in RESULT using the information
+   from link map L to resolve the DSTs. This function only handles one
+   path at a time and does not handle colon-separated path lists (see
+   fillin_rpath ()).  Lastly the size of result in bytes should be at
+   least equal to the value returned by DL_DST_REQUIRED.  Note that it
+   is possible for a DT_NEEDED, DT_AUXILIARY, and DT_FILTER entries to
+   have colons, but we treat those as literal colons here, not as path
+   list delimeters.  */
 char *
-_dl_dst_substitute (struct link_map *l, const char *name, char *result)
+_dl_dst_substitute (struct link_map *l, const char *input, char *result)
 {
-  const char *const start = name;
-
-  /* Now fill the result path.  While copying over the string we keep
-     track of the start of the last path element.  When we come across
-     a DST we copy over the value or (if the value is not available)
-     leave the entire path element out.  */
+  /* Copy character-by-character from input into the working pointer
+     looking for any DSTs.  We track the start of input and if we are
+     going to check for trusted paths, all of which are part of $ORIGIN
+     handling in SUID/SGID cases (see below).  In some cases, like when
+     a DST cannot be replaced, we may set result to an empty string and
+     return.  */
   char *wp = result;
-  char *last_elem = result;
+  const char *start = input;
   bool check_for_trusted = false;
 
   do
     {
-      if (__glibc_unlikely (*name == '$'))
+      if (__glibc_unlikely (*input == '$'))
 	{
 	  const char *repl = NULL;
 	  size_t len;
 
-	  ++name;
-	  if ((len = is_dst (start, name, "ORIGIN", __libc_enable_secure)) != 0)
+	  ++input;
+	  if ((len = is_dst (input, "ORIGIN")) != 0)
 	    {
-	      repl = l->l_origin;
+	      /* For SUID/GUID programs we normally ignore the path with
+		 $ORIGIN in DT_RUNPATH, or DT_RPATH.  However, there is
+		 one exception to this rule, and it is:
+
+		   * $ORIGIN appears as the first path element, and is
+		     the only string in the path or is immediately
+		     followed by a path separator and the rest of the
+		     path.
+
+		   * The path is rooted in a trusted directory.
+
+		 This exception allows such programs to reference
+		 shared libraries in subdirectories of trusted
+		 directories.  The use case is one of general
+		 organization and deployment flexibility.
+		 Trusted directories are usually such paths as "/lib64"
+		 or "/usr/lib64", and the usual RPATHs take the form of
+		 [$ORIGIN/../$LIB/somedir].  */
+	      if (__glibc_unlikely (__libc_enable_secure)
+		  && !(input == start + 1
+		       && (input[len] == '\0' || input[len] == '/')))
+		repl = (const char *) -1;
+	      else
+	        repl = l->l_origin;
+
 	      check_for_trusted = (__libc_enable_secure
 				   && l->l_type == lt_executable);
 	    }
-	  else if ((len = is_dst (start, name, "PLATFORM", 0)) != 0)
+	  else if ((len = is_dst (input, "PLATFORM")) != 0)
 	    repl = GLRO(dl_platform);
-	  else if ((len = is_dst (start, name, "LIB", 0)) != 0)
+	  else if ((len = is_dst (input, "LIB")) != 0)
 	    repl = DL_DST_LIB;
 
 	  if (repl != NULL && repl != (const char *) -1)
 	    {
 	      wp = __stpcpy (wp, repl);
-	      name += len;
+	      input += len;
 	    }
-	  else if (len > 1)
+	  else if (len != 0)
 	    {
-	      /* We cannot use this path element, the value of the
-		 replacement is unknown.  */
-	      wp = last_elem;
-	      break;
+	      /* We found a valid DST that we know about, but we could
+	         not find a replacement value for it, therefore we
+		 cannot use this path and discard it.  */
+	      *result = '\0';
+	      return result;
 	    }
 	  else
 	    /* No DST we recognize.  */
@@ -293,16 +338,26 @@ _dl_dst_substitute (struct link_map *l, const char *name, char *result)
 	}
       else
 	{
-	  *wp++ = *name++;
+	  *wp++ = *input++;
 	}
     }
-  while (*name != '\0');
+  while (*input != '\0');
 
   /* In SUID/SGID programs, after $ORIGIN expansion the normalized
-     path must be rooted in one of the trusted directories.  */
+     path must be rooted in one of the trusted directories.  The $LIB
+     and $PLATFORM DST cannot in any way be manipulated by the caller
+     because they are fixed values that are set by the dynamic loader
+     and therefore any paths using just $LIB or $PLATFORM need not be
+     checked for trust, the authors of the binaries themselves are
+     trusted to have designed this correctly.  Only $ORIGIN is tested in
+     this way because it may be manipulated in some ways with hard
+     links.  */
   if (__glibc_unlikely (check_for_trusted)
-      && !is_trusted_path_normalize (last_elem, wp - last_elem))
-    wp = last_elem;
+      && !is_trusted_path_normalize (result, wp - result))
+    {
+      *result = '\0';
+      return result;
+    }
 
   *wp = '\0';
 
@@ -310,13 +365,13 @@ _dl_dst_substitute (struct link_map *l, const char *name, char *result)
 }
 
 
-/* Return copy of argument with all recognized dynamic string tokens
-   ($ORIGIN and $PLATFORM for now) replaced.  On some platforms it
-   might not be possible to determine the path from which the object
-   belonging to the map is loaded.  In this case the path element
-   containing $ORIGIN is left out.  */
+/* Return a malloc allocated copy of INPUT with all recognized DSTs
+   replaced. On some platforms it might not be possible to determine the
+   path from which the object belonging to the map is loaded.  In this
+   case the path containing the DST is left out.  On error NULL
+   is returned.  */
 static char *
-expand_dynamic_string_token (struct link_map *l, const char *s)
+expand_dynamic_string_token (struct link_map *l, const char *input)
 {
   /* We make two runs over the string.  First we determine how large the
      resulting string is and then we copy it over.  Since this is no
@@ -326,22 +381,22 @@ expand_dynamic_string_token (struct link_map *l, const char *s)
   size_t total;
   char *result;
 
-  /* Determine the number of DST elements.  */
-  cnt = DL_DST_COUNT (s);
+  /* Determine the number of DSTs.  */
+  cnt = _dl_dst_count (input);
 
   /* If we do not have to replace anything simply copy the string.  */
   if (__glibc_likely (cnt == 0))
-    return __strdup (s);
+    return __strdup (input);
 
   /* Determine the length of the substituted string.  */
-  total = DL_DST_REQUIRED (l, s, strlen (s), cnt);
+  total = DL_DST_REQUIRED (l, input, strlen (input), cnt);
 
   /* Allocate the necessary memory.  */
   result = (char *) malloc (total + 1);
   if (result == NULL)
     return NULL;
 
-  return _dl_dst_substitute (l, s, result);
+  return _dl_dst_substitute (l, input, result);
 }
 
 
@@ -1469,6 +1524,7 @@ open_verify (const char *name, int fd,
       ElfW(Ehdr) *ehdr;
       ElfW(Phdr) *phdr, *ph;
       ElfW(Word) *abi_note;
+      ElfW(Word) *abi_note_malloced = NULL;
       unsigned int osversion;
       size_t maplength;
 
@@ -1640,10 +1696,25 @@ open_verify (const char *name, int fd,
 	      abi_note = (void *) (fbp->buf + ph->p_offset);
 	    else
 	      {
-		abi_note = alloca (size);
+		/* Note: __libc_use_alloca is not usable here, because
+		   thread info may not have been set up yet.  */
+		if (size < __MAX_ALLOCA_CUTOFF)
+		  abi_note = alloca (size);
+		else
+		  {
+		    /* There could be multiple PT_NOTEs.  */
+		    abi_note_malloced = realloc (abi_note_malloced, size);
+		    if (abi_note_malloced == NULL)
+		      goto read_error;
+
+		    abi_note = abi_note_malloced;
+		  }
 		__lseek (fd, ph->p_offset, SEEK_SET);
 		if (__libc_read (fd, (void *) abi_note, size) != size)
-		  goto read_error;
+		  {
+		    free (abi_note_malloced);
+		    goto read_error;
+		  }
 	      }
 
 	    while (memcmp (abi_note, &expected_note, sizeof (expected_note)))
@@ -1678,6 +1749,7 @@ open_verify (const char *name, int fd,
 
 	    break;
 	  }
+      free (abi_note_malloced);
     }
 
   return fd;
diff --git a/elf/dl-runtime.c b/elf/dl-runtime.c
index 61ef6d61ca..9ce488b673 100644
--- a/elf/dl-runtime.c
+++ b/elf/dl-runtime.c
@@ -184,10 +184,36 @@ _dl_profile_fixup (
   /* This is the address in the array where we store the result of previous
      relocations.  */
   struct reloc_result *reloc_result = &l->l_reloc_result[reloc_index];
-  DL_FIXUP_VALUE_TYPE *resultp = &reloc_result->addr;
 
-  DL_FIXUP_VALUE_TYPE value = *resultp;
-  if (DL_FIXUP_VALUE_CODE_ADDR (value) == 0)
+ /* CONCURRENCY NOTES:
+
+  Multiple threads may be calling the same PLT sequence and with
+  LD_AUDIT enabled they will be calling into _dl_profile_fixup to
+  update the reloc_result with the result of the lazy resolution.
+  The reloc_result guard variable is reloc_init, and we use
+  acquire/release loads and store to it to ensure that the results of
+  the structure are consistent with the loaded value of the guard.
+  This does not fix all of the data races that occur when two or more
+  threads read reloc_result->reloc_init with a value of zero and read
+  and write to that reloc_result concurrently.  The expectation is
+  generally that while this is a data race it works because the
+  threads write the same values.  Until the data races are fixed
+  there is a potential for problems to arise from these data races.
+  The reloc result updates should happen in parallel but there should
+  be an atomic RMW which does the final update to the real result
+  entry (see bug 23790).
+
+  The following code uses reloc_result->init set to 0 to indicate if it is
+  the first time this object is being relocated, otherwise 1 which
+  indicates the object has already been relocated.
+
+  Reading/Writing from/to reloc_result->reloc_init must not happen
+  before previous writes to reloc_result complete as they could
+  end-up with an incomplete struct.  */
+  DL_FIXUP_VALUE_TYPE value;
+  unsigned int init = atomic_load_acquire (&reloc_result->init);
+
+  if (init == 0)
     {
       /* This is the first time we have to relocate this object.  */
       const ElfW(Sym) *const symtab
@@ -349,19 +375,31 @@ _dl_profile_fixup (
 
       /* Store the result for later runs.  */
       if (__glibc_likely (! GLRO(dl_bind_not)))
-	*resultp = value;
+	{
+	  reloc_result->addr = value;
+	  /* Guarantee all previous writes complete before
+	     init is updated.  See CONCURRENCY NOTES earlier  */
+	  atomic_store_release (&reloc_result->init, 1);
+	}
+      init = 1;
     }
+  else
+    value = reloc_result->addr;
 
   /* By default we do not call the pltexit function.  */
   long int framesize = -1;
 
+
 #ifdef SHARED
   /* Auditing checkpoint: report the PLT entering and allow the
      auditors to change the value.  */
-  if (DL_FIXUP_VALUE_CODE_ADDR (value) != 0 && GLRO(dl_naudit) > 0
+  if (GLRO(dl_naudit) > 0
       /* Don't do anything if no auditor wants to intercept this call.  */
       && (reloc_result->enterexit & LA_SYMB_NOPLTENTER) == 0)
     {
+      /* Sanity check:  DL_FIXUP_VALUE_CODE_ADDR (value) should have been
+	 initialized earlier in this function or in another thread.  */
+      assert (DL_FIXUP_VALUE_CODE_ADDR (value) != 0);
       ElfW(Sym) *defsym = ((ElfW(Sym) *) D_PTR (reloc_result->bound,
 						l_info[DT_SYMTAB])
 			   + reloc_result->boundndx);
diff --git a/elf/elf.h b/elf/elf.h
index 954f3266f7..f6ce814d43 100644
--- a/elf/elf.h
+++ b/elf/elf.h
@@ -2835,6 +2835,13 @@ enum
 #define R_AARCH64_TLSDESC      1031	/* TLS Descriptor.  */
 #define R_AARCH64_IRELATIVE	1032	/* STT_GNU_IFUNC relocation.  */
 
+/* AArch64 specific values for the Dyn d_tag field.  */
+#define DT_AARCH64_VARIANT_PCS	(DT_LOPROC + 5)
+#define DT_AARCH64_NUM		6
+
+/* AArch64 specific values for the st_other field.  */
+#define STO_AARCH64_VARIANT_PCS 0x80
+
 /* ARM relocs.  */
 
 #define R_ARM_NONE		0	/* No reloc */
diff --git a/elf/pldd-xx.c b/elf/pldd-xx.c
index 2823dea662..f818d98582 100644
--- a/elf/pldd-xx.c
+++ b/elf/pldd-xx.c
@@ -23,10 +23,6 @@
 #define EW_(e, w, t) EW__(e, w, _##t)
 #define EW__(e, w, t) e##w##t
 
-#define pldd_assert(name, exp) \
-  typedef int __assert_##name[((exp) != 0) - 1]
-
-
 struct E(link_map)
 {
   EW(Addr) l_addr;
@@ -39,12 +35,12 @@ struct E(link_map)
   EW(Addr) l_libname;
 };
 #if CLASS == __ELF_NATIVE_CLASS
-pldd_assert (l_addr, (offsetof (struct link_map, l_addr)
-			== offsetof (struct E(link_map), l_addr)));
-pldd_assert (l_name, (offsetof (struct link_map, l_name)
-			== offsetof (struct E(link_map), l_name)));
-pldd_assert (l_next, (offsetof (struct link_map, l_next)
-			== offsetof (struct E(link_map), l_next)));
+_Static_assert (offsetof (struct link_map, l_addr)
+		== offsetof (struct E(link_map), l_addr), "l_addr");
+_Static_assert (offsetof (struct link_map, l_name)
+		== offsetof (struct E(link_map), l_name), "l_name");
+_Static_assert (offsetof (struct link_map, l_next)
+		== offsetof (struct E(link_map), l_next), "l_next");
 #endif
 
 
@@ -54,10 +50,10 @@ struct E(libname_list)
   EW(Addr) next;
 };
 #if CLASS == __ELF_NATIVE_CLASS
-pldd_assert (name, (offsetof (struct libname_list, name)
-		      == offsetof (struct E(libname_list), name)));
-pldd_assert (next, (offsetof (struct libname_list, next)
-		      == offsetof (struct E(libname_list), next)));
+_Static_assert (offsetof (struct libname_list, name)
+		== offsetof (struct E(libname_list), name), "name");
+_Static_assert (offsetof (struct libname_list, next)
+		== offsetof (struct E(libname_list), next), "next");
 #endif
 
 struct E(r_debug)
@@ -69,16 +65,17 @@ struct E(r_debug)
   EW(Addr) r_map;
 };
 #if CLASS == __ELF_NATIVE_CLASS
-pldd_assert (r_version, (offsetof (struct r_debug, r_version)
-			   == offsetof (struct E(r_debug), r_version)));
-pldd_assert (r_map, (offsetof (struct r_debug, r_map)
-		       == offsetof (struct E(r_debug), r_map)));
+_Static_assert (offsetof (struct r_debug, r_version)
+		== offsetof (struct E(r_debug), r_version), "r_version");
+_Static_assert (offsetof (struct r_debug, r_map)
+		== offsetof (struct E(r_debug), r_map), "r_map");
 #endif
 
 
 static int
 
-E(find_maps) (pid_t pid, void *auxv, size_t auxv_size)
+E(find_maps) (const char *exe, int memfd, pid_t pid, void *auxv,
+	      size_t auxv_size)
 {
   EW(Addr) phdr = 0;
   unsigned int phnum = 0;
@@ -104,12 +101,9 @@ E(find_maps) (pid_t pid, void *auxv, size_t auxv_size)
   if (phdr == 0 || phnum == 0 || phent == 0)
     error (EXIT_FAILURE, 0, gettext ("cannot find program header of process"));
 
-  EW(Phdr) *p = alloca (phnum * phent);
-  if (pread64 (memfd, p, phnum * phent, phdr) != phnum * phent)
-    {
-      error (0, 0, gettext ("cannot read program header"));
-      return EXIT_FAILURE;
-    }
+  EW(Phdr) *p = xmalloc (phnum * phent);
+  if (pread (memfd, p, phnum * phent, phdr) != phnum * phent)
+    error (EXIT_FAILURE, 0, gettext ("cannot read program header"));
 
   /* Determine the load offset.  We need this for interpreting the
      other program header entries so we do this in a separate loop.
@@ -129,24 +123,18 @@ E(find_maps) (pid_t pid, void *auxv, size_t auxv_size)
     if (p[i].p_type == PT_DYNAMIC)
       {
 	EW(Dyn) *dyn = xmalloc (p[i].p_filesz);
-	if (pread64 (memfd, dyn, p[i].p_filesz, offset + p[i].p_vaddr)
+	if (pread (memfd, dyn, p[i].p_filesz, offset + p[i].p_vaddr)
 	    != p[i].p_filesz)
-	  {
-	    error (0, 0, gettext ("cannot read dynamic section"));
-	    return EXIT_FAILURE;
-	  }
+	  error (EXIT_FAILURE, 0, gettext ("cannot read dynamic section"));
 
 	/* Search for the DT_DEBUG entry.  */
 	for (unsigned int j = 0; j < p[i].p_filesz / sizeof (EW(Dyn)); ++j)
 	  if (dyn[j].d_tag == DT_DEBUG && dyn[j].d_un.d_ptr != 0)
 	    {
 	      struct E(r_debug) r;
-	      if (pread64 (memfd, &r, sizeof (r), dyn[j].d_un.d_ptr)
+	      if (pread (memfd, &r, sizeof (r), dyn[j].d_un.d_ptr)
 		  != sizeof (r))
-		{
-		  error (0, 0, gettext ("cannot read r_debug"));
-		  return EXIT_FAILURE;
-		}
+		error (EXIT_FAILURE, 0, gettext ("cannot read r_debug"));
 
 	      if (r.r_map != 0)
 		{
@@ -160,13 +148,10 @@ E(find_maps) (pid_t pid, void *auxv, size_t auxv_size)
       }
     else if (p[i].p_type == PT_INTERP)
       {
-	interp = alloca (p[i].p_filesz);
-	if (pread64 (memfd, interp, p[i].p_filesz, offset + p[i].p_vaddr)
+	interp = xmalloc (p[i].p_filesz);
+	if (pread (memfd, interp, p[i].p_filesz, offset + p[i].p_vaddr)
 	    != p[i].p_filesz)
-	  {
-	    error (0, 0, gettext ("cannot read program interpreter"));
-	    return EXIT_FAILURE;
-	  }
+	  error (EXIT_FAILURE, 0, gettext ("cannot read program interpreter"));
       }
 
   if (list == 0)
@@ -174,14 +159,16 @@ E(find_maps) (pid_t pid, void *auxv, size_t auxv_size)
       if (interp == NULL)
 	{
 	  // XXX check whether the executable itself is the loader
-	  return EXIT_FAILURE;
+	  exit (EXIT_FAILURE);
 	}
 
       // XXX perhaps try finding ld.so and _r_debug in it
-
-      return EXIT_FAILURE;
+      exit (EXIT_FAILURE);
     }
 
+  free (p);
+  free (interp);
+
   /* Print the PID and program name first.  */
   printf ("%lu:\t%s\n", (unsigned long int) pid, exe);
 
@@ -192,47 +179,27 @@ E(find_maps) (pid_t pid, void *auxv, size_t auxv_size)
   do
     {
       struct E(link_map) m;
-      if (pread64 (memfd, &m, sizeof (m), list) != sizeof (m))
-	{
-	  error (0, 0, gettext ("cannot read link map"));
-	  status = EXIT_FAILURE;
-	  goto out;
-	}
+      if (pread (memfd, &m, sizeof (m), list) != sizeof (m))
+	error (EXIT_FAILURE, 0, gettext ("cannot read link map"));
 
       EW(Addr) name_offset = m.l_name;
-    again:
       while (1)
 	{
-	  ssize_t n = pread64 (memfd, tmpbuf.data, tmpbuf.length, name_offset);
+	  ssize_t n = pread (memfd, tmpbuf.data, tmpbuf.length, name_offset);
 	  if (n == -1)
-	    {
-	      error (0, 0, gettext ("cannot read object name"));
-	      status = EXIT_FAILURE;
-	      goto out;
-	    }
+	    error (EXIT_FAILURE, 0, gettext ("cannot read object name"));
 
 	  if (memchr (tmpbuf.data, '\0', n) != NULL)
 	    break;
 
 	  if (!scratch_buffer_grow (&tmpbuf))
-	    {
-	      error (0, 0, gettext ("cannot allocate buffer for object name"));
-	      status = EXIT_FAILURE;
-	      goto out;
-	    }
+	    error (EXIT_FAILURE, 0,
+		   gettext ("cannot allocate buffer for object name"));
 	}
 
-      if (((char *)tmpbuf.data)[0] == '\0' && name_offset == m.l_name
-	  && m.l_libname != 0)
-	{
-	  /* Try the l_libname element.  */
-	  struct E(libname_list) ln;
-	  if (pread64 (memfd, &ln, sizeof (ln), m.l_libname) == sizeof (ln))
-	    {
-	      name_offset = ln.name;
-	      goto again;
-	    }
-	}
+      /* The m.l_name and m.l_libname.name for loader linkmap points to same
+	 values (since BZ#387 fix).  Trying to use l_libname name as the
+	 shared object name might lead to an infinite loop (BZ#18035).  */
 
       /* Skip over the executable.  */
       if (((char *)tmpbuf.data)[0] != '\0')
@@ -242,7 +209,6 @@ E(find_maps) (pid_t pid, void *auxv, size_t auxv_size)
     }
   while (list != 0);
 
- out:
   scratch_buffer_free (&tmpbuf);
   return status;
 }
diff --git a/elf/pldd.c b/elf/pldd.c
index b8106fdc33..0bdfff450a 100644
--- a/elf/pldd.c
+++ b/elf/pldd.c
@@ -17,23 +17,17 @@
    License along with the GNU C Library; if not, see
    <http://www.gnu.org/licenses/>.  */
 
-#include <alloca.h>
+#define _FILE_OFFSET_BITS 64
+
 #include <argp.h>
-#include <assert.h>
 #include <dirent.h>
-#include <elf.h>
-#include <errno.h>
 #include <error.h>
 #include <fcntl.h>
 #include <libintl.h>
-#include <link.h>
-#include <stddef.h>
 #include <stdio.h>
 #include <stdlib.h>
-#include <string.h>
 #include <unistd.h>
 #include <sys/ptrace.h>
-#include <sys/stat.h>
 #include <sys/wait.h>
 #include <scratch_buffer.h>
 
@@ -76,14 +70,9 @@ static struct argp argp =
   options, parse_opt, args_doc, doc, NULL, more_help, NULL
 };
 
-// File descriptor of /proc/*/mem file.
-static int memfd;
-
-/* Name of the executable  */
-static char *exe;
 
 /* Local functions.  */
-static int get_process_info (int dfd, long int pid);
+static int get_process_info (const char *exe, int dfd, long int pid);
 static void wait_for_ptrace_stop (long int pid);
 
 
@@ -102,8 +91,10 @@ main (int argc, char *argv[])
       return 1;
     }
 
-  assert (sizeof (pid_t) == sizeof (int)
-	  || sizeof (pid_t) == sizeof (long int));
+  _Static_assert (sizeof (pid_t) == sizeof (int)
+		  || sizeof (pid_t) == sizeof (long int),
+		  "sizeof (pid_t) != sizeof (int) or sizeof (long int)");
+
   char *endp;
   errno = 0;
   long int pid = strtol (argv[remaining], &endp, 10);
@@ -119,25 +110,24 @@ main (int argc, char *argv[])
   if (dfd == -1)
     error (EXIT_FAILURE, errno, gettext ("cannot open %s"), buf);
 
-  struct scratch_buffer exebuf;
-  scratch_buffer_init (&exebuf);
+  /* Name of the executable  */
+  struct scratch_buffer exe;
+  scratch_buffer_init (&exe);
   ssize_t nexe;
   while ((nexe = readlinkat (dfd, "exe",
-			     exebuf.data, exebuf.length)) == exebuf.length)
+			     exe.data, exe.length)) == exe.length)
     {
-      if (!scratch_buffer_grow (&exebuf))
+      if (!scratch_buffer_grow (&exe))
 	{
 	  nexe = -1;
 	  break;
 	}
     }
   if (nexe == -1)
-    exe = (char *) "<program name undetermined>";
+    /* Default stack allocation is at least 1024.  */
+    snprintf (exe.data, exe.length, "<program name undetermined>");
   else
-    {
-      exe = exebuf.data;
-      exe[nexe] = '\0';
-    }
+    ((char*)exe.data)[nexe] = '\0';
 
   /* Stop all threads since otherwise the list of loaded modules might
      change while we are reading it.  */
@@ -155,8 +145,8 @@ main (int argc, char *argv[])
     error (EXIT_FAILURE, errno, gettext ("cannot prepare reading %s/task"),
 	   buf);
 
-  struct dirent64 *d;
-  while ((d = readdir64 (dir)) != NULL)
+  struct dirent *d;
+  while ((d = readdir (dir)) != NULL)
     {
       if (! isdigit (d->d_name[0]))
 	continue;
@@ -182,7 +172,7 @@ main (int argc, char *argv[])
 
       wait_for_ptrace_stop (tid);
 
-      struct thread_list *newp = alloca (sizeof (*newp));
+      struct thread_list *newp = xmalloc (sizeof (*newp));
       newp->tid = tid;
       newp->next = thread_list;
       thread_list = newp;
@@ -190,17 +180,22 @@ main (int argc, char *argv[])
 
   closedir (dir);
 
-  int status = get_process_info (dfd, pid);
+  if (thread_list == NULL)
+    error (EXIT_FAILURE, 0, gettext ("no valid %s/task entries"), buf);
+
+  int status = get_process_info (exe.data, dfd, pid);
 
-  assert (thread_list != NULL);
   do
     {
       ptrace (PTRACE_DETACH, thread_list->tid, NULL, NULL);
+      struct thread_list *prev = thread_list;
       thread_list = thread_list->next;
+      free (prev);
     }
   while (thread_list != NULL);
 
   close (dfd);
+  scratch_buffer_free (&exe);
 
   return status;
 }
@@ -281,9 +276,10 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\
 
 
 static int
-get_process_info (int dfd, long int pid)
+get_process_info (const char *exe, int dfd, long int pid)
 {
-  memfd = openat (dfd, "mem", O_RDONLY);
+  /* File descriptor of /proc/<pid>/mem file.  */
+  int memfd = openat (dfd, "mem", O_RDONLY);
   if (memfd == -1)
     goto no_info;
 
@@ -333,9 +329,9 @@ get_process_info (int dfd, long int pid)
 
   int retval;
   if (e_ident[EI_CLASS] == ELFCLASS32)
-    retval = find_maps32 (pid, auxv, auxv_size);
+    retval = find_maps32 (exe, memfd, pid, auxv, auxv_size);
   else
-    retval = find_maps64 (pid, auxv, auxv_size);
+    retval = find_maps64 (exe, memfd, pid, auxv, auxv_size);
 
   free (auxv);
   close (memfd);
diff --git a/elf/tst-big-note-lib.S b/elf/tst-big-note-lib.S
new file mode 100644
index 0000000000..6b514a03cc
--- /dev/null
+++ b/elf/tst-big-note-lib.S
@@ -0,0 +1,26 @@
+/* Bug 20419: test for stack overflow in elf/dl-load.c open_verify()
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This creates a .so with 8MiB PT_NOTE segment.
+   On a typical Linux system with 8MiB "ulimit -s", that was enough
+   to trigger stack overflow in open_verify.  */
+
+.pushsection .note.big,"a"
+.balign 4
+.fill 8*1024*1024, 1, 0
+.popsection
diff --git a/io/tst-copy_file_range-compat.c b/elf/tst-big-note.c
similarity index 57%
rename from io/tst-copy_file_range-compat.c
rename to elf/tst-big-note.c
index 00c109a74d..fcd2b0ed82 100644
--- a/io/tst-copy_file_range-compat.c
+++ b/elf/tst-big-note.c
@@ -1,5 +1,5 @@
-/* Test the fallback implementation of copy_file_range.
-   Copyright (C) 2017-2018 Free Software Foundation, Inc.
+/* Bug 20419: test for stack overflow in elf/dl-load.c open_verify()
+   Copyright (C) 2018 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -16,15 +16,11 @@
    License along with the GNU C Library; if not, see
    <http://www.gnu.org/licenses/>.  */
 
-/* Get the declaration of the official copy_of_range function.  */
-#include <unistd.h>
+/* This file must be run from within a directory called "elf".  */
 
-/* Compile a local version of copy_file_range.  */
-#define COPY_FILE_RANGE_DECL static
-#define COPY_FILE_RANGE copy_file_range_compat
-#include <io/copy_file_range-compat.c>
-
-/* Re-use the test, but run it against copy_file_range_compat defined
-   above.  */
-#define copy_file_range copy_file_range_compat
-#include "tst-copy_file_range.c"
+int main (int argc, char *argv[])
+{
+  /* Nothing to do here: merely linking against tst-big-note-lib.so triggers
+     the bug.  */
+  return 0;
+}
diff --git a/iconv/Makefile b/iconv/Makefile
index d71319b39e..0d6aea6cd4 100644
--- a/iconv/Makefile
+++ b/iconv/Makefile
@@ -26,7 +26,7 @@ headers		= iconv.h gconv.h
 routines	= iconv_open iconv iconv_close \
 		  gconv_open gconv gconv_close gconv_db gconv_conf \
 		  gconv_builtin gconv_simple gconv_trans gconv_cache
-routines	+= gconv_dl
+routines	+= gconv_dl gconv_charset
 
 vpath %.c ../locale/programs ../intl
 
@@ -43,7 +43,8 @@ CFLAGS-charmap.c += -DCHARMAP_PATH='"$(i18ndir)/charmaps"' \
 CFLAGS-linereader.c += -DNO_TRANSLITERATION
 CFLAGS-simple-hash.c += -I../locale
 
-tests	= tst-iconv1 tst-iconv2 tst-iconv3 tst-iconv4 tst-iconv5 tst-iconv6
+tests	= tst-iconv1 tst-iconv2 tst-iconv3 tst-iconv4 tst-iconv5 tst-iconv6 \
+	  tst-iconv7 tst-iconv8 tst-iconv-opt
 
 others		= iconv_prog iconvconfig
 install-others-programs	= $(inst_bindir)/iconv
@@ -60,6 +61,7 @@ include $(patsubst %,$(..)libof-iterator.mk,$(cpp-srcs-left))
 
 ifeq ($(run-built-tests),yes)
 xtests-special += $(objpfx)test-iconvconfig.out
+tests-special += $(objpfx)tst-iconv_prog.out
 endif
 
 # Make a copy of the file because gconv module names are constructed
@@ -78,6 +80,13 @@ endif
 
 include ../Rules
 
+ifeq ($(run-built-tests),yes)
+LOCALES := en_US.UTF-8
+include ../gen-locales.mk
+
+$(objpfx)tst-iconv-opt.out: $(gen-locales)
+endif
+
 $(inst_bindir)/iconv: $(objpfx)iconv_prog $(+force)
 	$(do-install-program)
 
@@ -92,3 +101,8 @@ $(objpfx)test-iconvconfig.out: /dev/null $(objpfx)iconvconfig
 	 cmp $$tmp $(inst_gconvdir)/gconv-modules.cache; \
 	 rm -f $$tmp) > $@; \
 	$(evaluate-test)
+
+$(objpfx)tst-iconv_prog.out: tst-iconv_prog.sh $(objpfx)iconv_prog
+	$(BASH) $< $(common-objdir) '$(test-wrapper-env)' \
+		 '$(run-program-env)' > $@; \
+	$(evaluate-test)
diff --git a/iconv/Versions b/iconv/Versions
index 60ab10a277..d51af52fa3 100644
--- a/iconv/Versions
+++ b/iconv/Versions
@@ -7,6 +7,9 @@ libc {
     # functions shared with iconv program
     __gconv_get_alias_db; __gconv_get_cache; __gconv_get_modules_db;
 
+    # functions used elsewhere in glibc
+    __gconv_open; __gconv_create_spec; __gconv_destroy_spec;
+
     # function used by the gconv modules
     __gconv_transliterate;
   }
diff --git a/iconv/gconv_charset.c b/iconv/gconv_charset.c
new file mode 100644
index 0000000000..4ba0aa99f5
--- /dev/null
+++ b/iconv/gconv_charset.c
@@ -0,0 +1,228 @@
+/* Charset name normalization.
+   Copyright (C) 2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+
+#include <stdlib.h>
+#include <ctype.h>
+#include <locale.h>
+#include <stdbool.h>
+#include <string.h>
+#include <sys/stat.h>
+#include "gconv_int.h"
+#include "gconv_charset.h"
+
+
+/* This function returns a pointer to the last suffix in a conversion code
+   string.  Valid suffixes matched by this function are of the form: '/' or ','
+   followed by arbitrary text that doesn't contain '/' or ','.  It does not
+   edit the string in any way.  The caller is expected to parse the suffix and
+   remove it (by e.g. truncating the string) before the next call.  */
+static char *
+find_suffix (char *s)
+{
+  /* The conversion code is in the form of a triplet, separated by '/' chars.
+     The third component of the triplet contains suffixes. If we don't have two
+     slashes, we don't have a suffix.  */
+
+  int slash_count = 0;
+  char *suffix_term = NULL;
+
+  for (int i = 0; s[i] != '\0'; i++)
+    switch (s[i])
+      {
+        case '/':
+          slash_count++;
+          /* Fallthrough */
+        case ',':
+          suffix_term = &s[i];
+      }
+
+  if (slash_count >= 2)
+    return suffix_term;
+
+  return NULL;
+}
+
+
+struct gconv_parsed_code
+{
+  char *code;
+  bool translit;
+  bool ignore;
+};
+
+
+/* This function parses an iconv_open encoding PC.CODE, strips any suffixes
+   (such as TRANSLIT or IGNORE) from it and sets corresponding flags in it.  */
+static void
+gconv_parse_code (struct gconv_parsed_code *pc)
+{
+  pc->translit = false;
+  pc->ignore = false;
+
+  while (1)
+    {
+      /* First drop any trailing whitespaces and separators.  */
+      size_t len = strlen (pc->code);
+      while ((len > 0)
+             && (isspace (pc->code[len - 1])
+                 || pc->code[len - 1] == ','
+                 || pc->code[len - 1] == '/'))
+        len--;
+
+      pc->code[len] = '\0';
+
+      if (len == 0)
+        return;
+
+      char * suffix = find_suffix (pc->code);
+      if (suffix == NULL)
+        {
+          /* At this point, we have processed and removed all suffixes from the
+             code and what remains of the code is suffix free.  */
+          return;
+        }
+      else
+        {
+          /* A suffix is processed from the end of the code array going
+             backwards, one suffix at a time.  The suffix is an index into the
+             code character array and points to: one past the end of the code
+             and any unprocessed suffixes, and to the beginning of the suffix
+             currently being processed during this iteration.  We must process
+             this suffix and then drop it from the code by terminating the
+             preceding text with NULL.
+
+             We want to allow and recognize suffixes such as:
+
+             "/TRANSLIT"         i.e. single suffix
+             "//TRANSLIT"        i.e. single suffix and multiple separators
+             "//TRANSLIT/IGNORE" i.e. suffixes separated by "/"
+             "/TRANSLIT//IGNORE" i.e. suffixes separated by "//"
+             "//IGNORE,TRANSLIT" i.e. suffixes separated by ","
+             "//IGNORE,"         i.e. trailing ","
+             "//TRANSLIT/"       i.e. trailing "/"
+             "//TRANSLIT//"      i.e. trailing "//"
+             "/"                 i.e. empty suffix.
+
+             Unknown suffixes are silently discarded and ignored.  */
+
+          if ((__strcasecmp_l (suffix,
+                               GCONV_TRIPLE_SEPARATOR
+                               GCONV_TRANSLIT_SUFFIX,
+                               _nl_C_locobj_ptr) == 0)
+              || (__strcasecmp_l (suffix,
+                                  GCONV_SUFFIX_SEPARATOR
+                                  GCONV_TRANSLIT_SUFFIX,
+                                  _nl_C_locobj_ptr) == 0))
+            pc->translit = true;
+
+          if ((__strcasecmp_l (suffix,
+                               GCONV_TRIPLE_SEPARATOR
+                               GCONV_IGNORE_ERRORS_SUFFIX,
+                               _nl_C_locobj_ptr) == 0)
+              || (__strcasecmp_l (suffix,
+                                  GCONV_SUFFIX_SEPARATOR
+                                  GCONV_IGNORE_ERRORS_SUFFIX,
+                                  _nl_C_locobj_ptr) == 0))
+            pc->ignore = true;
+
+          /* We just processed this suffix.  We can now drop it from the
+             code string by truncating it at the suffix's position.  */
+          suffix[0] = '\0';
+        }
+    }
+}
+
+
+/* This function accepts the charset names of the source and destination of the
+   conversion and populates *conv_spec with an equivalent conversion
+   specification that may later be used by __gconv_open.  The charset names
+   might contain options in the form of suffixes that alter the conversion,
+   e.g. "ISO-10646/UTF-8/TRANSLIT".  It processes the charset names, ignoring
+   and truncating any suffix options in fromcode, and processing and truncating
+   any suffix options in tocode.  Supported suffix options ("TRANSLIT" or
+   "IGNORE") when found in tocode lead to the corresponding flag in *conv_spec
+   to be set to true.  Unrecognized suffix options are silently discarded.  If
+   the function succeeds, it returns conv_spec back to the caller.  It returns
+   NULL upon failure.  conv_spec must be allocated and freed by the caller.  */
+struct gconv_spec *
+__gconv_create_spec (struct gconv_spec *conv_spec, const char *fromcode,
+                   const char *tocode)
+{
+  struct gconv_parsed_code pfc, ptc;
+  struct gconv_spec *ret = NULL;
+
+  pfc.code = __strdup (fromcode);
+  ptc.code = __strdup (tocode);
+
+  if ((pfc.code == NULL)
+      || (ptc.code == NULL))
+    goto out;
+
+  gconv_parse_code (&pfc);
+  gconv_parse_code (&ptc);
+
+  /* We ignore suffixes in the fromcode because that is how the current
+     implementation has always handled them.  Only suffixes in the tocode are
+     processed and handled.  The reality is that invalid input in the input
+     character set should only be ignored if the fromcode specifies IGNORE.
+     The current implementation ignores invalid intput in the input character
+     set if the tocode contains IGNORE.  We preserve this behavior for
+     backwards compatibility.  In the future we may split the handling of
+     IGNORE to allow a finer grained specification of ignorning invalid input
+     and/or ignoring invalid output.  */
+  conv_spec->translit = ptc.translit;
+  conv_spec->ignore = ptc.ignore;
+
+  /* 3 extra bytes because 1 extra for '\0', and 2 extra so strip might
+     be able to add one or two trailing '/' characters if necessary.  */
+  conv_spec->fromcode = malloc (strlen (fromcode) + 3);
+  if (conv_spec->fromcode == NULL)
+    goto out;
+
+  conv_spec->tocode = malloc (strlen (tocode) + 3);
+  if (conv_spec->tocode == NULL)
+    {
+      free (conv_spec->fromcode);
+      conv_spec->fromcode = NULL;
+      goto out;
+    }
+
+  /* Strip unrecognized characters and ensure that the code has two '/'
+     characters as per conversion code triplet specification.  */
+  strip (conv_spec->fromcode, pfc.code);
+  strip (conv_spec->tocode, ptc.code);
+  ret = conv_spec;
+
+out:
+  free (pfc.code);
+  free (ptc.code);
+
+  return ret;
+}
+libc_hidden_def (__gconv_create_spec)
+
+
+void
+__gconv_destroy_spec (struct gconv_spec *conv_spec)
+{
+  free (conv_spec->fromcode);
+  free (conv_spec->tocode);
+  return;
+}
+libc_hidden_def (__gconv_destroy_spec)
diff --git a/iconv/gconv_charset.h b/iconv/gconv_charset.h
index 123e2a62ce..4b98073389 100644
--- a/iconv/gconv_charset.h
+++ b/iconv/gconv_charset.h
@@ -19,9 +19,41 @@
 
 #include <ctype.h>
 #include <locale.h>
+#include <stdbool.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <stdlib.h>
+#include "gconv_int.h"
 
 
-static void
+/* An iconv encoding is in the form of a triplet, with parts separated by
+   a '/' character.  The first part is the standard name, the second part is
+   the character set, and the third part is the error handler.  If the first
+   part is sufficient to identify both the standard and the character set
+   then the second part can be empty e.g. UTF-8//.  If the first part is not
+   sufficient to identify both the standard and the character set then the
+   second part is required e.g. ISO-10646/UTF8/.  If neither the first or
+   second parts are provided e.g. //, then the current locale is used.
+   The actual values used in the first and second parts are not entirely
+   relevant to the implementation.  The values themselves are used in a hash
+   table to lookup modules and so the naming convention of the first two parts
+   is somewhat arbitrary and only helps locate the entries in the cache.
+   The third part is the error handler and is comprised of a ',' or '/'
+   separated list of suffixes.  Currently, we support "TRANSLIT" for
+   transliteration and "IGNORE" for ignoring conversion errors due to
+   unrecognized input characters.  */
+#define GCONV_TRIPLE_SEPARATOR "/"
+#define GCONV_SUFFIX_SEPARATOR ","
+#define GCONV_TRANSLIT_SUFFIX "TRANSLIT"
+#define GCONV_IGNORE_ERRORS_SUFFIX "IGNORE"
+
+
+/* This function copies in-order, characters from the source 's' that are
+   either alpha-numeric or one in one of these: "_-.,:/" - into the destination
+   'wp' while dropping all other characters.  In the process, it converts all
+   alphabetical characters to upper case.  It then appends up to two '/'
+   characters so that the total number of '/'es in the destination is 2.  */
+static inline void __attribute__ ((unused, always_inline))
 strip (char *wp, const char *s)
 {
   int slash_count = 0;
diff --git a/iconv/gconv_int.h b/iconv/gconv_int.h
index 3742557cae..8067a341b0 100644
--- a/iconv/gconv_int.h
+++ b/iconv/gconv_int.h
@@ -92,6 +92,15 @@ struct gconv_module
 };
 
 
+/* The specification of the conversion that needs to be performed.  */
+struct gconv_spec
+{
+  char *fromcode;
+  char *tocode;
+  bool translit;
+  bool ignore;
+};
+
 /* Flags for `gconv_open'.  */
 enum
 {
@@ -154,10 +163,33 @@ __libc_lock_define (extern, __gconv_lock attribute_hidden)
   })
 
 
-/* Return in *HANDLE decriptor for transformation from FROMSET to TOSET.  */
-extern int __gconv_open (const char *toset, const char *fromset,
-			 __gconv_t *handle, int flags)
-     attribute_hidden;
+/* Return in *HANDLE, a decriptor for the transformation.  The function expects
+   the specification of the transformation in the structure pointed to by
+   CONV_SPEC.  It only reads *CONV_SPEC and does not take ownership of it.  */
+extern int __gconv_open (struct gconv_spec *conv_spec,
+                         __gconv_t *handle, int flags);
+libc_hidden_proto (__gconv_open)
+
+/* This function accepts the charset names of the source and destination of the
+   conversion and populates *conv_spec with an equivalent conversion
+   specification that may later be used by __gconv_open.  The charset names
+   might contain options in the form of suffixes that alter the conversion,
+   e.g. "ISO-10646/UTF-8/TRANSLIT".  It processes the charset names, ignoring
+   and truncating any suffix options in fromcode, and processing and truncating
+   any suffix options in tocode.  Supported suffix options ("TRANSLIT" or
+   "IGNORE") when found in tocode lead to the corresponding flag in *conv_spec
+   to be set to true.  Unrecognized suffix options are silently discarded.  If
+   the function succeeds, it returns conv_spec back to the caller.  It returns
+   NULL upon failure.  */
+extern struct gconv_spec *
+__gconv_create_spec (struct gconv_spec *conv_spec, const char *fromcode,
+                     const char *tocode);
+libc_hidden_proto (__gconv_create_spec)
+
+/* This function frees all heap memory allocated by __gconv_create_spec.  */
+extern void
+__gconv_destroy_spec (struct gconv_spec *conv_spec);
+libc_hidden_proto (__gconv_destroy_spec)
 
 /* Free resources associated with transformation descriptor CD.  */
 extern int __gconv_close (__gconv_t cd)
diff --git a/iconv/gconv_open.c b/iconv/gconv_open.c
index f739561f6e..002faa111a 100644
--- a/iconv/gconv_open.c
+++ b/iconv/gconv_open.c
@@ -27,7 +27,7 @@
 
 
 int
-__gconv_open (const char *toset, const char *fromset, __gconv_t *handle,
+__gconv_open (struct gconv_spec *conv_spec, __gconv_t *handle,
 	      int flags)
 {
   struct __gconv_step *steps;
@@ -36,77 +36,38 @@ __gconv_open (const char *toset, const char *fromset, __gconv_t *handle,
   size_t cnt = 0;
   int res;
   int conv_flags = 0;
-  const char *errhand;
-  const char *ignore;
   bool translit = false;
+  char *tocode, *fromcode;
 
   /* Find out whether any error handling method is specified.  */
-  errhand = strchr (toset, '/');
-  if (errhand != NULL)
-    errhand = strchr (errhand + 1, '/');
-  if (__glibc_likely (errhand != NULL))
-    {
-      if (*++errhand == '\0')
-	errhand = NULL;
-      else
-	{
-	  /* Make copy without the error handling description.  */
-	  char *newtoset = (char *) alloca (errhand - toset + 1);
-	  char *tok;
-	  char *ptr = NULL /* Work around a bogus warning */;
-
-	  newtoset[errhand - toset] = '\0';
-	  toset = memcpy (newtoset, toset, errhand - toset);
+  translit = conv_spec->translit;
 
-	  /* Find the appropriate transliteration handlers.  */
-	  tok = strdupa (errhand);
+  if (conv_spec->ignore)
+    conv_flags |= __GCONV_IGNORE_ERRORS;
 
-	  tok = __strtok_r (tok, ",", &ptr);
-	  while (tok != NULL)
-	    {
-	      if (__strcasecmp_l (tok, "TRANSLIT", _nl_C_locobj_ptr) == 0)
-		translit = true;
-	      else if (__strcasecmp_l (tok, "IGNORE", _nl_C_locobj_ptr) == 0)
-		/* Set the flag to ignore all errors.  */
-		conv_flags |= __GCONV_IGNORE_ERRORS;
-
-	      tok = __strtok_r (NULL, ",", &ptr);
-	    }
-	}
-    }
-
-  /* For the source character set we ignore the error handler specification.
-     XXX Is this really always the best?  */
-  ignore = strchr (fromset, '/');
-  if (ignore != NULL && (ignore = strchr (ignore + 1, '/')) != NULL
-      && *++ignore != '\0')
-    {
-      char *newfromset = (char *) alloca (ignore - fromset + 1);
-
-      newfromset[ignore - fromset] = '\0';
-      fromset = memcpy (newfromset, fromset, ignore - fromset);
-    }
+  tocode = conv_spec->tocode;
+  fromcode = conv_spec->fromcode;
 
   /* If the string is empty define this to mean the charset of the
      currently selected locale.  */
-  if (strcmp (toset, "//") == 0)
+  if (strcmp (tocode, "//") == 0)
     {
       const char *codeset = _NL_CURRENT (LC_CTYPE, CODESET);
       size_t len = strlen (codeset);
       char *dest;
-      toset = dest = (char *) alloca (len + 3);
+      tocode = dest = (char *) alloca (len + 3);
       memcpy (__mempcpy (dest, codeset, len), "//", 3);
     }
-  if (strcmp (fromset, "//") == 0)
+  if (strcmp (fromcode, "//") == 0)
     {
       const char *codeset = _NL_CURRENT (LC_CTYPE, CODESET);
       size_t len = strlen (codeset);
       char *dest;
-      fromset = dest = (char *) alloca (len + 3);
+      fromcode = dest = (char *) alloca (len + 3);
       memcpy (__mempcpy (dest, codeset, len), "//", 3);
     }
 
-  res = __gconv_find_transform (toset, fromset, &steps, &nsteps, flags);
+  res = __gconv_find_transform (tocode, fromcode, &steps, &nsteps, flags);
   if (res == __GCONV_OK)
     {
       /* Allocate room for handle.  */
@@ -205,3 +166,4 @@ __gconv_open (const char *toset, const char *fromset, __gconv_t *handle,
   *handle = result;
   return res;
 }
+libc_hidden_def (__gconv_open)
diff --git a/iconv/gconv_simple.c b/iconv/gconv_simple.c
index 506c92caf2..f47d56f44e 100644
--- a/iconv/gconv_simple.c
+++ b/iconv/gconv_simple.c
@@ -76,7 +76,7 @@ __attribute ((always_inline))
 internal_ucs4_loop (struct __gconv_step *step,
 		    struct __gconv_step_data *step_data,
 		    const unsigned char **inptrp, const unsigned char *inend,
-		    unsigned char **outptrp, unsigned char *outend,
+		    unsigned char **outptrp, const unsigned char *outend,
 		    size_t *irreversible)
 {
   const unsigned char *inptr = *inptrp;
@@ -120,7 +120,8 @@ internal_ucs4_loop_unaligned (struct __gconv_step *step,
 			      struct __gconv_step_data *step_data,
 			      const unsigned char **inptrp,
 			      const unsigned char *inend,
-			      unsigned char **outptrp, unsigned char *outend,
+			      unsigned char **outptrp,
+			      const unsigned char *outend,
 			      size_t *irreversible)
 {
   const unsigned char *inptr = *inptrp;
@@ -169,7 +170,8 @@ internal_ucs4_loop_single (struct __gconv_step *step,
 			   struct __gconv_step_data *step_data,
 			   const unsigned char **inptrp,
 			   const unsigned char *inend,
-			   unsigned char **outptrp, unsigned char *outend,
+			   unsigned char **outptrp,
+			   const unsigned char *outend,
 			   size_t *irreversible)
 {
   mbstate_t *state = step_data->__statep;
@@ -231,17 +233,15 @@ __attribute ((always_inline))
 ucs4_internal_loop (struct __gconv_step *step,
 		    struct __gconv_step_data *step_data,
 		    const unsigned char **inptrp, const unsigned char *inend,
-		    unsigned char **outptrp, unsigned char *outend,
+		    unsigned char **outptrp, const unsigned char *outend,
 		    size_t *irreversible)
 {
   int flags = step_data->__flags;
   const unsigned char *inptr = *inptrp;
   unsigned char *outptr = *outptrp;
-  size_t n_convert = MIN (inend - inptr, outend - outptr) / 4;
   int result;
-  size_t cnt;
 
-  for (cnt = 0; cnt < n_convert; ++cnt, inptr += 4)
+  for (; inptr + 4 <= inend && outptr + 4 <= outend; inptr += 4)
     {
       uint32_t inval;
 
@@ -298,17 +298,16 @@ ucs4_internal_loop_unaligned (struct __gconv_step *step,
 			      struct __gconv_step_data *step_data,
 			      const unsigned char **inptrp,
 			      const unsigned char *inend,
-			      unsigned char **outptrp, unsigned char *outend,
+			      unsigned char **outptrp,
+			      const unsigned char *outend,
 			      size_t *irreversible)
 {
   int flags = step_data->__flags;
   const unsigned char *inptr = *inptrp;
   unsigned char *outptr = *outptrp;
-  size_t n_convert = MIN (inend - inptr, outend - outptr) / 4;
   int result;
-  size_t cnt;
 
-  for (cnt = 0; cnt < n_convert; ++cnt, inptr += 4)
+  for (; inptr + 4 <= inend && outptr + 4 <= outend; inptr += 4)
     {
       if (__glibc_unlikely (inptr[0] > 0x80))
 	{
@@ -368,7 +367,8 @@ ucs4_internal_loop_single (struct __gconv_step *step,
 			   struct __gconv_step_data *step_data,
 			   const unsigned char **inptrp,
 			   const unsigned char *inend,
-			   unsigned char **outptrp, unsigned char *outend,
+			   unsigned char **outptrp,
+			   const unsigned char *outend,
 			   size_t *irreversible)
 {
   mbstate_t *state = step_data->__statep;
@@ -443,7 +443,7 @@ __attribute ((always_inline))
 internal_ucs4le_loop (struct __gconv_step *step,
 		      struct __gconv_step_data *step_data,
 		      const unsigned char **inptrp, const unsigned char *inend,
-		      unsigned char **outptrp, unsigned char *outend,
+		      unsigned char **outptrp, const unsigned char *outend,
 		      size_t *irreversible)
 {
   const unsigned char *inptr = *inptrp;
@@ -488,7 +488,8 @@ internal_ucs4le_loop_unaligned (struct __gconv_step *step,
 				struct __gconv_step_data *step_data,
 				const unsigned char **inptrp,
 				const unsigned char *inend,
-				unsigned char **outptrp, unsigned char *outend,
+				unsigned char **outptrp,
+				const unsigned char *outend,
 				size_t *irreversible)
 {
   const unsigned char *inptr = *inptrp;
@@ -540,7 +541,8 @@ internal_ucs4le_loop_single (struct __gconv_step *step,
 			     struct __gconv_step_data *step_data,
 			     const unsigned char **inptrp,
 			     const unsigned char *inend,
-			     unsigned char **outptrp, unsigned char *outend,
+			     unsigned char **outptrp,
+			     const unsigned char *outend,
 			     size_t *irreversible)
 {
   mbstate_t *state = step_data->__statep;
@@ -601,17 +603,15 @@ __attribute ((always_inline))
 ucs4le_internal_loop (struct __gconv_step *step,
 		      struct __gconv_step_data *step_data,
 		      const unsigned char **inptrp, const unsigned char *inend,
-		      unsigned char **outptrp, unsigned char *outend,
+		      unsigned char **outptrp, const unsigned char *outend,
 		      size_t *irreversible)
 {
   int flags = step_data->__flags;
   const unsigned char *inptr = *inptrp;
   unsigned char *outptr = *outptrp;
-  size_t n_convert = MIN (inend - inptr, outend - outptr) / 4;
   int result;
-  size_t cnt;
 
-  for (cnt = 0; cnt < n_convert; ++cnt, inptr += 4)
+  for (; inptr + 4 <= inend && outptr + 4 <= outend; inptr += 4)
     {
       uint32_t inval;
 
@@ -671,17 +671,16 @@ ucs4le_internal_loop_unaligned (struct __gconv_step *step,
 				struct __gconv_step_data *step_data,
 				const unsigned char **inptrp,
 				const unsigned char *inend,
-				unsigned char **outptrp, unsigned char *outend,
+				unsigned char **outptrp,
+				const unsigned char *outend,
 				size_t *irreversible)
 {
   int flags = step_data->__flags;
   const unsigned char *inptr = *inptrp;
   unsigned char *outptr = *outptrp;
-  size_t n_convert = MIN (inend - inptr, outend - outptr) / 4;
   int result;
-  size_t cnt;
 
-  for (cnt = 0; cnt < n_convert; ++cnt, inptr += 4)
+  for (; inptr + 4 <= inend && outptr + 4 <= outend; inptr += 4)
     {
       if (__glibc_unlikely (inptr[3] > 0x80))
 	{
@@ -745,7 +744,8 @@ ucs4le_internal_loop_single (struct __gconv_step *step,
 			     struct __gconv_step_data *step_data,
 			     const unsigned char **inptrp,
 			     const unsigned char *inend,
-			     unsigned char **outptrp, unsigned char *outend,
+			     unsigned char **outptrp,
+			     const unsigned char *outend,
 			     size_t *irreversible)
 {
   mbstate_t *state = step_data->__statep;
diff --git a/iconv/iconv_open.c b/iconv/iconv_open.c
index 9f5c32c020..46da33bca6 100644
--- a/iconv/iconv_open.c
+++ b/iconv/iconv_open.c
@@ -31,49 +31,15 @@
 iconv_t
 iconv_open (const char *tocode, const char *fromcode)
 {
-  /* Normalize the name.  We remove all characters beside alpha-numeric,
-     '_', '-', '/', '.', and ':'.  */
-  size_t tocode_len = strlen (tocode) + 3;
-  char *tocode_conv;
-  bool tocode_usealloca = __libc_use_alloca (tocode_len);
-  if (tocode_usealloca)
-    tocode_conv = (char *) alloca (tocode_len);
-  else
-    {
-      tocode_conv = (char *) malloc (tocode_len);
-      if (tocode_conv == NULL)
-	return (iconv_t) -1;
-    }
-  strip (tocode_conv, tocode);
-  tocode = (tocode_conv[2] == '\0' && tocode[0] != '\0'
-	    ? upstr (tocode_conv, tocode) : tocode_conv);
+  __gconv_t cd;
+  struct gconv_spec conv_spec;
 
-  size_t fromcode_len = strlen (fromcode) + 3;
-  char *fromcode_conv;
-  bool fromcode_usealloca = __libc_use_alloca (fromcode_len);
-  if (fromcode_usealloca)
-    fromcode_conv = (char *) alloca (fromcode_len);
-  else
-    {
-      fromcode_conv = (char *) malloc (fromcode_len);
-      if (fromcode_conv == NULL)
-	{
-	  if (! tocode_usealloca)
-	    free (tocode_conv);
-	  return (iconv_t) -1;
-	}
-    }
-  strip (fromcode_conv, fromcode);
-  fromcode = (fromcode_conv[2] == '\0' && fromcode[0] != '\0'
-	      ? upstr (fromcode_conv, fromcode) : fromcode_conv);
+  if (__gconv_create_spec (&conv_spec, fromcode, tocode) == NULL)
+    return (iconv_t) -1;
 
-  __gconv_t cd;
-  int res = __gconv_open (tocode, fromcode, &cd, 0);
+  int res = __gconv_open (&conv_spec, &cd, 0);
 
-  if (! fromcode_usealloca)
-    free (fromcode_conv);
-  if (! tocode_usealloca)
-    free (tocode_conv);
+  __gconv_destroy_spec (&conv_spec);
 
   if (__builtin_expect (res, __GCONV_OK) != __GCONV_OK)
     {
diff --git a/iconv/iconv_prog.c b/iconv/iconv_prog.c
index 52e9d3f3dd..e26e9d02ca 100644
--- a/iconv/iconv_prog.c
+++ b/iconv/iconv_prog.c
@@ -39,6 +39,7 @@
 #include <gconv_int.h>
 #include "iconv_prog.h"
 #include "iconvconfig.h"
+#include "gconv_charset.h"
 
 /* Get libc version number.  */
 #include "../version.h"
@@ -118,8 +119,7 @@ main (int argc, char *argv[])
 {
   int status = EXIT_SUCCESS;
   int remaining;
-  iconv_t cd;
-  const char *orig_to_code;
+  __gconv_t cd;
   struct charmap_t *from_charmap = NULL;
   struct charmap_t *to_charmap = NULL;
 
@@ -139,39 +139,6 @@ main (int argc, char *argv[])
       exit (EXIT_SUCCESS);
     }
 
-  /* If we have to ignore errors make sure we use the appropriate name for
-     the to-character-set.  */
-  orig_to_code = to_code;
-  if (omit_invalid)
-    {
-      const char *errhand = strchrnul (to_code, '/');
-      int nslash = 2;
-      char *newp;
-      char *cp;
-
-      if (*errhand == '/')
-	{
-	  --nslash;
-	  errhand = strchrnul (errhand + 1, '/');
-
-	  if (*errhand == '/')
-	    {
-	      --nslash;
-	      errhand = strchr (errhand, '\0');
-	    }
-	}
-
-      newp = (char *) alloca (errhand - to_code + nslash + 7 + 1);
-      cp = mempcpy (newp, to_code, errhand - to_code);
-      while (nslash-- > 0)
-	*cp++ = '/';
-      if (cp[-1] != '/')
-	*cp++ = ',';
-      memcpy (cp, "IGNORE", sizeof ("IGNORE"));
-
-      to_code = newp;
-    }
-
   /* POSIX 1003.2b introduces a silly thing: the arguments to -t anf -f
      can be file names of charmaps.  In this case iconv will have to read
      those charmaps and use them to do the conversion.  But there are
@@ -184,10 +151,10 @@ main (int argc, char *argv[])
        file.  */
     from_charmap = charmap_read (from_code, /*0, 1*/1, 0, 0, 0);
 
-  if (strchr (orig_to_code, '/') != NULL)
+  if (strchr (to_code, '/') != NULL)
     /* The to-name might be a charmap file name.  Try reading the
        file.  */
-    to_charmap = charmap_read (orig_to_code, /*0, 1,*/1, 0, 0, 0);
+    to_charmap = charmap_read (to_code, /*0, 1,*/1, 0, 0, 0);
 
 
   /* At this point we have to handle two cases.  The first one is
@@ -201,9 +168,25 @@ main (int argc, char *argv[])
 				 argc, remaining, argv, output_file);
   else
     {
+      struct gconv_spec conv_spec;
+      int res;
+
+      if (__gconv_create_spec (&conv_spec, from_code, to_code) == NULL)
+        {
+          error (EXIT_FAILURE, errno,
+                 _("failed to start conversion processing"));
+          exit (1);
+        }
+
+      if (omit_invalid)
+        conv_spec.ignore = true;
+
       /* Let's see whether we have these coded character sets.  */
-      cd = iconv_open (to_code, from_code);
-      if (cd == (iconv_t) -1)
+      res = __gconv_open (&conv_spec, &cd, 0);
+
+      __gconv_destroy_spec (&conv_spec);
+
+      if (res != __GCONV_OK)
 	{
 	  if (errno == EINVAL)
 	    {
@@ -221,7 +204,7 @@ main (int argc, char *argv[])
 	      const char *from_pretty =
 		(from_code[0] ? from_code : nl_langinfo (CODESET));
 	      const char *to_pretty =
-		(orig_to_code[0] ? orig_to_code : nl_langinfo (CODESET));
+		(to_code[0] ? to_code : nl_langinfo (CODESET));
 
 	      if (from_wrong)
 		{
diff --git a/iconv/skeleton.c b/iconv/skeleton.c
index fa79930523..f4e499e233 100644
--- a/iconv/skeleton.c
+++ b/iconv/skeleton.c
@@ -83,6 +83,11 @@
      RESET_INPUT_BUFFER	If the input character sets allow this the macro
 			can be defined to reset the input buffer pointers
 			to cover only those characters up to the error.
+			Note that if the conversion has skipped over
+			irreversible characters (due to
+			__GCONV_IGNORE_ERRORS) there is no longer a direct
+			correspondence between input and output pointers,
+			and this macro is not called.
 
      FUNCTION_NAME	if not set the conversion function is named `gconv'.
 
@@ -597,6 +602,12 @@ FUNCTION_NAME (struct __gconv_step *step, struct __gconv_step_data *data,
 	  inptr = *inptrp;
 	  /* The outbuf buffer is empty.  */
 	  outstart = outbuf;
+#ifdef RESET_INPUT_BUFFER
+	  /* Remember how many irreversible characters were skipped before
+	     this round.  */
+	  size_t loop_irreversible
+	    = lirreversible + (irreversible ? *irreversible : 0);
+#endif
 
 #ifdef SAVE_RESET_STATE
 	  SAVE_RESET_STATE (1);
@@ -671,8 +682,16 @@ FUNCTION_NAME (struct __gconv_step *step, struct __gconv_step_data *data,
 		  if (__glibc_unlikely (outerr != outbuf))
 		    {
 #ifdef RESET_INPUT_BUFFER
-		      RESET_INPUT_BUFFER;
-#else
+		      /* RESET_INPUT_BUFFER can only work when there were
+			 no new irreversible characters skipped during
+			 this round.  */
+		      if (loop_irreversible
+			  == lirreversible + (irreversible ? *irreversible : 0))
+			{
+			  RESET_INPUT_BUFFER;
+			  goto done_reset;
+			}
+#endif
 		      /* We have a problem in one of the functions below.
 			 Undo the conversion upto the error point.  */
 		      size_t nstatus __attribute__ ((unused));
@@ -682,9 +701,9 @@ FUNCTION_NAME (struct __gconv_step *step, struct __gconv_step_data *data,
 		      outbuf = outstart;
 
 		      /* Restore the state.  */
-# ifdef SAVE_RESET_STATE
+#ifdef SAVE_RESET_STATE
 		      SAVE_RESET_STATE (0);
-# endif
+#endif
 
 		      if (__glibc_likely (!unaligned))
 			{
@@ -701,7 +720,7 @@ FUNCTION_NAME (struct __gconv_step *step, struct __gconv_step_data *data,
 					       lirreversiblep
 					       EXTRA_LOOP_ARGS);
 			}
-# if POSSIBLY_UNALIGNED
+#if POSSIBLY_UNALIGNED
 		      else
 			{
 			  if (FROM_DIRECTION)
@@ -720,7 +739,7 @@ FUNCTION_NAME (struct __gconv_step *step, struct __gconv_step_data *data,
 							       lirreversiblep
 							       EXTRA_LOOP_ARGS);
 			}
-# endif
+#endif
 
 		      /* We must run out of output buffer space in this
 			 rerun.  */
@@ -731,9 +750,11 @@ FUNCTION_NAME (struct __gconv_step *step, struct __gconv_step_data *data,
 			 the invocation counter.  */
 		      if (__glibc_unlikely (outbuf == outstart))
 			--data->__invocation_counter;
-#endif	/* reset input buffer */
 		    }
 
+#ifdef RESET_INPUT_BUFFER
+		done_reset:
+#endif
 		  /* Change the status.  */
 		  status = result;
 		}
diff --git a/iconv/tst-iconv-opt.c b/iconv/tst-iconv-opt.c
new file mode 100644
index 0000000000..669d812a6a
--- /dev/null
+++ b/iconv/tst-iconv-opt.c
@@ -0,0 +1,347 @@
+/* Test iconv's TRANSLIT and IGNORE option handling
+
+   Copyright (C) 2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+
+#include <iconv.h>
+#include <locale.h>
+#include <errno.h>
+#include <string.h>
+#include <support/support.h>
+#include <support/check.h>
+
+
+/* Run one iconv test.  Arguments:
+   to: destination character set and options
+   from: source character set
+   input: input string to be converted
+   exp_in: expected number of bytes consumed
+   exp_ret: expected return value (error or number of irreversible conversions)
+   exp_out: expected output string
+   exp_err: expected value of `errno' after iconv returns.  */
+static void
+test_iconv (const char *to, const char *from, char *input, size_t exp_in,
+            size_t exp_ret, const char *exp_out, int exp_err)
+{
+  iconv_t cd;
+  char outbuf[500];
+  size_t inlen, outlen;
+  char *inptr, *outptr;
+  size_t n;
+
+  cd = iconv_open (to, from);
+  TEST_VERIFY (cd != (iconv_t) -1);
+
+  inlen = strlen (input);
+  outlen = sizeof (outbuf);
+  inptr = input;
+  outptr = outbuf;
+
+  errno = 0;
+  n = iconv (cd, &inptr, &inlen, &outptr, &outlen);
+
+  TEST_COMPARE (n, exp_ret);
+  TEST_VERIFY (inptr == input + exp_in);
+  TEST_COMPARE (errno, exp_err);
+  TEST_COMPARE_BLOB (outbuf, outptr - outbuf, exp_out, strlen (exp_out));
+  TEST_VERIFY (iconv_close (cd) == 0);
+}
+
+
+/* We test option parsing by converting UTF-8 inputs to ASCII under various
+   option combinations. The UTF-8 inputs fall into three categories:
+   - ASCII-only,
+   - non-ASCII,
+   - non-ASCII with invalid UTF-8 characters.  */
+
+/* 1.  */
+char ascii[] = "Just some ASCII text";
+
+/* 2. Valid UTF-8 input and some corresponding expected outputs with various
+   options.  The two non-ASCII characters below are accented alphabets:
+   an `a' then an `o'.  */
+char utf8[] = "UTF-8 text with \u00E1 couple \u00F3f non-ASCII characters";
+char u2a[] = "UTF-8 text with ";
+char u2a_translit[] = "UTF-8 text with a couple of non-ASCII characters";
+char u2a_ignore[] = "UTF-8 text with  couple f non-ASCII characters";
+
+/* 3. Invalid UTF-8 input and some corresponding expected outputs.  \xff is
+   invalid UTF-8. It's followed by some valid but non-ASCII UTF-8.  */
+char iutf8[] = "Invalid UTF-8 \xff\u27E6text\u27E7";
+char iu2a[] = "Invalid UTF-8 ";
+char iu2a_ignore[] = "Invalid UTF-8 text";
+char iu2a_both[] = "Invalid UTF-8 [|text|]";
+
+/* 4. Another invalid UTF-8 input and corresponding expected outputs. This time
+   the valid non-ASCII UTF-8 characters appear before the invalid \xff.  */
+char jutf8[] = "Invalid \u27E6UTF-8\u27E7 \xfftext";
+char ju2a[] = "Invalid ";
+char ju2a_translit[] = "Invalid [|UTF-8|] ";
+char ju2a_ignore[] = "Invalid UTF-8 text";
+char ju2a_both[] = "Invalid [|UTF-8|] text";
+
+/* We also test option handling for character set names that have the form
+   "A/B".  In this test, we test conversions "ISO-10646/UTF-8", and either
+   ISO-8859-1 or ASCII.  */
+
+/* 5. Accented 'A' and 'a' characters in ISO-8859-1 and UTF-8, and an
+   equivalent ASCII transliteration.  */
+char iso8859_1_a[] = {0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, /* Accented A's.  */
+                      0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, /* Accented a's.  */
+                      0x00};
+char utf8_a[] = "\u00C0\u00C1\u00C2\u00C3\u00C4\u00C5"
+                "\u00E0\u00E1\u00E2\u00E3\u00E4\u00E5";
+char ascii_a[] = "AAAAAAaaaaaa";
+
+/* 6. An invalid ASCII string where [0] is invalid and [1] is '~'.  */
+char iascii [] = {0x80, '~', '\0'};
+char empty[] = "";
+char ia2u_ignore[] = "~";
+
+static int
+do_test (void)
+{
+  xsetlocale (LC_ALL, "en_US.UTF-8");
+
+
+  /* 0. iconv_open should gracefully fail for invalid character sets.  */
+
+  TEST_VERIFY (iconv_open ("INVALID", "UTF-8") == (iconv_t) -1);
+  TEST_VERIFY (iconv_open ("UTF-8", "INVALID") == (iconv_t) -1);
+  TEST_VERIFY (iconv_open ("INVALID", "INVALID") == (iconv_t) -1);
+
+
+  /* 1. ASCII-only UTF-8 input should convert to ASCII with no changes:  */
+
+  test_iconv ("ASCII", "UTF-8", ascii, strlen (ascii), 0, ascii, 0);
+  test_iconv ("ASCII//", "UTF-8", ascii, strlen (ascii), 0, ascii, 0);
+  test_iconv ("ASCII//TRANSLIT", "UTF-8", ascii, strlen (ascii), 0, ascii, 0);
+  test_iconv ("ASCII//TRANSLIT//", "UTF-8", ascii, strlen (ascii), 0, ascii,
+              0);
+  test_iconv ("ASCII//IGNORE", "UTF-8", ascii, strlen (ascii), 0, ascii, 0);
+  test_iconv ("ASCII//IGNORE//", "UTF-8", ascii, strlen (ascii), 0, ascii, 0);
+
+
+  /* 2. Valid UTF-8 input with non-ASCII characters:  */
+
+  /* EILSEQ when converted to ASCII.  */
+  test_iconv ("ASCII", "UTF-8", utf8, strlen (u2a), (size_t) -1, u2a, EILSEQ);
+
+  /* Converted without error with TRANSLIT enabled.  */
+  test_iconv ("ASCII//TRANSLIT", "UTF-8", utf8, strlen (utf8), 2, u2a_translit,
+              0);
+
+  /* EILSEQ with IGNORE enabled.  Non-ASCII chars dropped from output.  */
+  test_iconv ("ASCII//IGNORE", "UTF-8", utf8, strlen (utf8), (size_t) -1,
+              u2a_ignore, EILSEQ);
+
+  /* With TRANSLIT and IGNORE enabled, transliterated without error.  We test
+     four combinations.  */
+
+  test_iconv ("ASCII//TRANSLIT,IGNORE", "UTF-8", utf8, strlen (utf8), 2,
+              u2a_translit, 0);
+  test_iconv ("ASCII//TRANSLIT//IGNORE", "UTF-8", utf8, strlen (utf8), 2,
+              u2a_translit, 0);
+  test_iconv ("ASCII//IGNORE,TRANSLIT", "UTF-8", utf8, strlen (utf8), 2,
+              u2a_translit, 0);
+  /* Due to bug 19519, iconv was ignoring TRANSLIT for the following input.  */
+  test_iconv ("ASCII//IGNORE//TRANSLIT", "UTF-8", utf8, strlen (utf8), 2,
+              u2a_translit, 0);
+
+  /* Misspellings of TRANSLIT and IGNORE are ignored, but conversion still
+     works while respecting any other correctly spelled options.  */
+
+  test_iconv ("ASCII//T", "UTF-8", utf8, strlen (u2a), (size_t) -1, u2a,
+              EILSEQ);
+  test_iconv ("ASCII//TRANSLITERATE", "UTF-8", utf8, strlen (u2a), (size_t) -1,
+              u2a, EILSEQ);
+  test_iconv ("ASCII//I", "UTF-8", utf8, strlen (u2a), (size_t) -1, u2a,
+              EILSEQ);
+  test_iconv ("ASCII//IGNORED", "UTF-8", utf8, strlen (u2a), (size_t) -1, u2a,
+              EILSEQ);
+  test_iconv ("ASCII//TRANSLITERATE//IGNORED", "UTF-8", utf8, strlen (u2a),
+              (size_t) -1, u2a, EILSEQ);
+  test_iconv ("ASCII//IGNORED,TRANSLITERATE", "UTF-8", utf8, strlen (u2a),
+              (size_t) -1, u2a, EILSEQ);
+  test_iconv ("ASCII//T//I", "UTF-8", utf8, strlen (u2a), (size_t) -1, u2a,
+              EILSEQ);
+
+  test_iconv ("ASCII//TRANSLIT//I", "UTF-8", utf8, strlen (utf8), 2,
+              u2a_translit, 0);
+  /* Due to bug 19519, iconv was ignoring TRANSLIT for the following input.  */
+  test_iconv ("ASCII//I//TRANSLIT", "UTF-8", utf8, strlen (utf8), 2,
+              u2a_translit, 0);
+  test_iconv ("ASCII//IGNORED,TRANSLIT", "UTF-8", utf8, strlen (utf8), 2,
+              u2a_translit, 0);
+  test_iconv ("ASCII//TRANSLIT,IGNORED", "UTF-8", utf8, strlen (utf8), 2,
+              u2a_translit, 0);
+
+  test_iconv ("ASCII//IGNORE,T", "UTF-8", utf8, strlen (utf8), (size_t) -1,
+              u2a_ignore, EILSEQ);
+  test_iconv ("ASCII//T,IGNORE", "UTF-8", utf8, strlen (utf8), (size_t) -1,
+              u2a_ignore, EILSEQ);
+  /* Due to bug 19519, iconv was ignoring IGNORE for the following input.  */
+  test_iconv ("ASCII//TRANSLITERATE//IGNORE", "UTF-8", utf8, strlen (utf8),
+              (size_t) -1, u2a_ignore, EILSEQ);
+  test_iconv ("ASCII//IGNORE//TRANSLITERATE", "UTF-8", utf8, strlen (utf8),
+              (size_t) -1, u2a_ignore, EILSEQ);
+
+
+  /* 3. Invalid UTF-8 followed by some valid non-ASCII UTF-8 characters:  */
+
+  /* EILSEQ; output is truncated at the first invalid UTF-8 character.  */
+  test_iconv ("ASCII", "UTF-8", iutf8, strlen (iu2a), (size_t) -1, iu2a,
+              EILSEQ);
+
+  /* With TRANSLIT enabled: EILSEQ; output still truncated at the first invalid
+     UTF-8 character.  */
+  test_iconv ("ASCII//TRANSLIT", "UTF-8", iutf8, strlen (iu2a), (size_t) -1,
+              iu2a, EILSEQ);
+
+  /* With IGNORE enabled: EILSEQ; output omits invalid UTF-8 characters and
+     valid UTF-8 non-ASCII characters.  */
+  test_iconv ("ASCII//IGNORE", "UTF-8", iutf8, strlen (iutf8), (size_t) -1,
+              iu2a_ignore, EILSEQ);
+
+  /* With TRANSLIT and IGNORE enabled, output omits only invalid UTF-8
+     characters and transliterates valid non-ASCII UTF-8 characters.  We test
+     four combinations.  */
+
+  test_iconv ("ASCII//TRANSLIT,IGNORE", "UTF-8", iutf8, strlen (iutf8), 2,
+              iu2a_both, 0);
+  /* Due to bug 19519, iconv was ignoring IGNORE for the following input.  */
+  test_iconv ("ASCII//TRANSLIT//IGNORE", "UTF-8", iutf8, strlen (iutf8), 2,
+              iu2a_both, 0);
+  test_iconv ("ASCII//IGNORE,TRANSLIT", "UTF-8", iutf8, strlen (iutf8), 2,
+              iu2a_both, 0);
+  /* Due to bug 19519, iconv was ignoring TRANSLIT for the following input.  */
+  test_iconv ("ASCII//IGNORE//TRANSLIT", "UTF-8", iutf8, strlen (iutf8), 2,
+              iu2a_both, 0);
+
+
+  /* 4. Invalid UTF-8 with valid non-ASCII UTF-8 chars appearing first:  */
+
+  /* EILSEQ; output is truncated at the first non-ASCII character.  */
+  test_iconv ("ASCII", "UTF-8", jutf8, strlen (ju2a), (size_t) -1, ju2a,
+              EILSEQ);
+
+  /* With TRANSLIT enabled: EILSEQ; output now truncated at the first invalid
+     UTF-8 character.  */
+  test_iconv ("ASCII//TRANSLIT", "UTF-8", jutf8, strlen (jutf8) - 5,
+              (size_t) -1, ju2a_translit, EILSEQ);
+  test_iconv ("ASCII//translit", "UTF-8", jutf8, strlen (jutf8) - 5,
+              (size_t) -1, ju2a_translit, EILSEQ);
+
+  /* With IGNORE enabled: EILSEQ; output omits invalid UTF-8 characters and
+     valid UTF-8 non-ASCII characters.  */
+  test_iconv ("ASCII//IGNORE", "UTF-8", jutf8, strlen (jutf8), (size_t) -1,
+              ju2a_ignore, EILSEQ);
+  test_iconv ("ASCII//ignore", "UTF-8", jutf8, strlen (jutf8), (size_t) -1,
+              ju2a_ignore, EILSEQ);
+
+  /* With TRANSLIT and IGNORE enabled, output omits only invalid UTF-8
+     characters and transliterates valid non-ASCII UTF-8 characters.  We test
+     several combinations.  */
+
+  test_iconv ("ASCII//TRANSLIT,IGNORE", "UTF-8", jutf8, strlen (jutf8), 2,
+              ju2a_both, 0);
+  /* Due to bug 19519, iconv was ignoring IGNORE for the following input.  */
+  test_iconv ("ASCII//TRANSLIT//IGNORE", "UTF-8", jutf8, strlen (jutf8), 2,
+              ju2a_both, 0);
+  test_iconv ("ASCII//IGNORE,TRANSLIT", "UTF-8", jutf8, strlen (jutf8), 2,
+              ju2a_both, 0);
+  /* Due to bug 19519, iconv was ignoring TRANSLIT for the following input.  */
+  test_iconv ("ASCII//IGNORE//TRANSLIT", "UTF-8", jutf8, strlen (jutf8), 2,
+              ju2a_both, 0);
+  test_iconv ("ASCII//translit,ignore", "UTF-8", jutf8, strlen (jutf8), 2,
+              ju2a_both, 0);
+  /* Trailing whitespace and separators should be ignored.  */
+  test_iconv ("ASCII//IGNORE,TRANSLIT ", "UTF-8", jutf8, strlen (jutf8), 2,
+              ju2a_both, 0);
+  test_iconv ("ASCII//IGNORE,TRANSLIT/", "UTF-8", jutf8, strlen (jutf8), 2,
+              ju2a_both, 0);
+  test_iconv ("ASCII//IGNORE,TRANSLIT//", "UTF-8", jutf8, strlen (jutf8), 2,
+              ju2a_both, 0);
+  test_iconv ("ASCII//IGNORE,TRANSLIT,", "UTF-8", jutf8, strlen (jutf8), 2,
+              ju2a_both, 0);
+  test_iconv ("ASCII//IGNORE,TRANSLIT,,", "UTF-8", jutf8, strlen (jutf8), 2,
+              ju2a_both, 0);
+  test_iconv ("ASCII//IGNORE,TRANSLIT /,", "UTF-8", jutf8, strlen (jutf8), 2,
+              ju2a_both, 0);
+
+  /* TRANSLIT or IGNORE suffixes in fromcode should be ignored.  */
+  test_iconv ("ASCII", "UTF-8//TRANSLIT", jutf8, strlen (ju2a), (size_t) -1,
+              ju2a, EILSEQ);
+  test_iconv ("ASCII", "UTF-8//IGNORE", jutf8, strlen (ju2a), (size_t) -1,
+              ju2a, EILSEQ);
+  test_iconv ("ASCII", "UTF-8//TRANSLIT,IGNORE", jutf8, strlen (ju2a),
+              (size_t) -1, ju2a, EILSEQ);
+
+
+  /* 5. Charset names of the form "A/B/":  */
+
+  /* ISO-8859-1 is converted to UTF-8 without needing transliteration.  */
+  test_iconv ("ISO-10646/UTF-8", "ISO-8859-1", iso8859_1_a,
+              strlen (iso8859_1_a), 0, utf8_a, 0);
+  test_iconv ("ISO-10646/UTF-8/", "ISO-8859-1", iso8859_1_a,
+              strlen (iso8859_1_a), 0, utf8_a, 0);
+  test_iconv ("ISO-10646/UTF-8/IGNORE", "ISO-8859-1", iso8859_1_a,
+              strlen (iso8859_1_a), 0, utf8_a, 0);
+  test_iconv ("ISO-10646/UTF-8//IGNORE", "ISO-8859-1", iso8859_1_a,
+              strlen (iso8859_1_a), 0, utf8_a, 0);
+  test_iconv ("ISO-10646/UTF-8/TRANSLIT", "ISO-8859-1", iso8859_1_a,
+              strlen (iso8859_1_a), 0, utf8_a, 0);
+  test_iconv ("ISO-10646/UTF-8//TRANSLIT", "ISO-8859-1", iso8859_1_a,
+              strlen (iso8859_1_a), 0, utf8_a, 0);
+  test_iconv ("ISO-10646/UTF-8//TRANSLIT/IGNORE", "ISO-8859-1", iso8859_1_a,
+              strlen (iso8859_1_a), 0, utf8_a, 0);
+  test_iconv ("ISO-10646/UTF-8//TRANSLIT//IGNORE", "ISO-8859-1", iso8859_1_a,
+              strlen (iso8859_1_a), 0, utf8_a, 0);
+  test_iconv ("ISO-10646/UTF-8/TRANSLIT,IGNORE", "ISO-8859-1", iso8859_1_a,
+              strlen (iso8859_1_a), 0, utf8_a, 0);
+
+  /* UTF-8 with accented A's is converted to ASCII with transliteration.  */
+  test_iconv ("ASCII", "ISO-10646/UTF-8", utf8_a,
+              0, (size_t) -1, empty, EILSEQ);
+  test_iconv ("ASCII//IGNORE", "ISO-10646/UTF-8", utf8_a,
+              strlen (utf8_a), (size_t) -1, empty, EILSEQ);
+  test_iconv ("ASCII//TRANSLIT", "ISO-10646/UTF-8", utf8_a,
+              strlen (utf8_a), 12, ascii_a, 0);
+
+  /* Invalid ASCII is converted to UTF-8 only with IGNORE.  */
+  test_iconv ("ISO-10646/UTF-8", "ASCII", iascii, strlen (empty), (size_t) -1,
+              empty, EILSEQ);
+  test_iconv ("ISO-10646/UTF-8/TRANSLIT", "ASCII", iascii, strlen (empty),
+              (size_t) -1, empty, EILSEQ);
+  test_iconv ("ISO-10646/UTF-8/IGNORE", "ASCII", iascii, strlen (iascii),
+              (size_t) -1, ia2u_ignore, EILSEQ);
+  test_iconv ("ISO-10646/UTF-8/TRANSLIT,IGNORE", "ASCII", iascii,
+              strlen (iascii), (size_t) -1, ia2u_ignore, EILSEQ);
+  /* Due to bug 19519, iconv was ignoring IGNORE for the following three
+     inputs: */
+  test_iconv ("ISO-10646/UTF-8/TRANSLIT/IGNORE", "ASCII", iascii,
+              strlen (iascii), (size_t) -1, ia2u_ignore, EILSEQ);
+  test_iconv ("ISO-10646/UTF-8//TRANSLIT,IGNORE", "ASCII", iascii,
+              strlen (iascii), (size_t) -1, ia2u_ignore, EILSEQ);
+  test_iconv ("ISO-10646/UTF-8//TRANSLIT//IGNORE", "ASCII", iascii,
+              strlen (iascii), (size_t) -1, ia2u_ignore, EILSEQ);
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/iconv/tst-iconv7.c b/iconv/tst-iconv7.c
new file mode 100644
index 0000000000..10372bf79f
--- /dev/null
+++ b/iconv/tst-iconv7.c
@@ -0,0 +1,55 @@
+/* Test iconv buffer handling with the IGNORE error handler.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Derived from BZ #18830 */
+#include <errno.h>
+#include <iconv.h>
+#include <stdio.h>
+#include <support/check.h>
+
+static int
+do_test (void)
+{
+  /* This conversion needs two steps, from ASCII to INTERNAL to ASCII.  */
+  iconv_t cd = iconv_open ("ASCII//IGNORE", "ASCII");
+  TEST_VERIFY_EXIT (cd != (iconv_t) -1);
+
+  /* Convert some irreversible sequence, enough to trigger an overflow of
+     the output buffer before the irreversible character in the second
+     step, but after going past the irreversible character in the first
+     step.  */
+  char input[4 + 4] = { '0', '1', '2', '3', '4', '5', '\266', '7' };
+  char *inptr = input;
+  size_t insize = sizeof (input);
+  char output[4];
+  char *outptr = output;
+  size_t outsize = sizeof (output);
+
+  /* The conversion should fail.  */
+  TEST_VERIFY (iconv (cd, &inptr, &insize, &outptr, &outsize) == (size_t) -1);
+  TEST_VERIFY (errno == E2BIG);
+  /* The conversion should not consume more than it was able to store in
+     the output buffer.  */
+  TEST_COMPARE (inptr - input, sizeof (output) - outsize);
+
+  TEST_VERIFY_EXIT (iconv_close (cd) != -1);
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/iconv/tst-iconv8.c b/iconv/tst-iconv8.c
new file mode 100644
index 0000000000..0b92b19f66
--- /dev/null
+++ b/iconv/tst-iconv8.c
@@ -0,0 +1,50 @@
+/* Test iconv behavior on UCS4 conversions with //IGNORE.
+   Copyright (C) 2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Derived from BZ #26923 */
+#include <errno.h>
+#include <iconv.h>
+#include <stdio.h>
+#include <support/check.h>
+
+static int
+do_test (void)
+{
+  iconv_t cd = iconv_open ("UTF-8//IGNORE", "ISO-10646/UCS4/");
+  TEST_VERIFY_EXIT (cd != (iconv_t) -1);
+
+  /*
+   * Convert sequence beginning with an irreversible character into buffer that
+   * is too small.
+   */
+  char input[12] = "\xe1\x80\xa1" "AAAAAAAAA";
+  char *inptr = input;
+  size_t insize = sizeof (input);
+  char output[6];
+  char *outptr = output;
+  size_t outsize = sizeof (output);
+
+  TEST_VERIFY (iconv (cd, &inptr, &insize, &outptr, &outsize) == -1);
+  TEST_VERIFY (errno == E2BIG);
+
+  TEST_VERIFY_EXIT (iconv_close (cd) != -1);
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/iconv/tst-iconv_prog.sh b/iconv/tst-iconv_prog.sh
new file mode 100644
index 0000000000..d8db7b335c
--- /dev/null
+++ b/iconv/tst-iconv_prog.sh
@@ -0,0 +1,284 @@
+#!/bin/bash
+# Test for some known iconv(1) hangs from bug 19519, and miscellaneous
+# iconv(1) program error conditions.
+# Copyright (C) 2020 Free Software Foundation, Inc.
+# This file is part of the GNU C Library.
+
+# The GNU C Library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+
+# The GNU C Library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+
+# You should have received a copy of the GNU Lesser General Public
+# License along with the GNU C Library; if not, see
+# <https://www.gnu.org/licenses/>.
+
+codir=$1
+test_wrapper_env="$2"
+run_program_env="$3"
+
+# We have to have some directories in the library path.
+LIBPATH=$codir:$codir/iconvdata
+
+# How the start the iconv(1) program.  $from is not defined/expanded yet.
+ICONV='
+$codir/elf/ld.so --library-path $LIBPATH --inhibit-rpath ${from}.so
+$codir/iconv/iconv_prog
+'
+ICONV="$test_wrapper_env $run_program_env $ICONV"
+
+# List of known hangs;
+# Gathered by running an exhaustive 2 byte input search against glibc-2.28
+hangarray=(
+"\x00\x23;-c;ANSI_X3.110;UTF-8//TRANSLIT//IGNORE"
+"\x00\xa1;-c;ARMSCII-8;UTF-8//TRANSLIT//IGNORE"
+"\x00\xa1;-c;ASMO_449;UTF-8//TRANSLIT//IGNORE"
+"\x00\x81;-c;BIG5;UTF-8//TRANSLIT//IGNORE"
+"\x00\xff;-c;BIG5HKSCS;UTF-8//TRANSLIT//IGNORE"
+"\x00\xff;-c;BRF;UTF-8//TRANSLIT//IGNORE"
+"\x00\xff;-c;BS_4730;UTF-8//TRANSLIT//IGNORE"
+"\x00\x81;-c;CP1250;UTF-8//TRANSLIT//IGNORE"
+"\x00\x98;-c;CP1251;UTF-8//TRANSLIT//IGNORE"
+"\x00\x81;-c;CP1252;UTF-8//TRANSLIT//IGNORE"
+"\x00\x81;-c;CP1253;UTF-8//TRANSLIT//IGNORE"
+"\x00\x81;-c;CP1254;UTF-8//TRANSLIT//IGNORE"
+"\x00\x81;-c;CP1255;UTF-8//TRANSLIT//IGNORE"
+"\x00\x81;-c;CP1257;UTF-8//TRANSLIT//IGNORE"
+"\x00\x81;-c;CP1258;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;CP932;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;CSA_Z243.4-1985-1;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;CSA_Z243.4-1985-2;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;DEC-MCS;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;DIN_66003;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;DS_2089;UTF-8//TRANSLIT//IGNORE"
+"\x00\x41;-c;EBCDIC-AT-DE;UTF-8//TRANSLIT//IGNORE"
+"\x00\x41;-c;EBCDIC-AT-DE-A;UTF-8//TRANSLIT//IGNORE"
+"\x00\x41;-c;EBCDIC-CA-FR;UTF-8//TRANSLIT//IGNORE"
+"\x00\x41;-c;EBCDIC-DK-NO;UTF-8//TRANSLIT//IGNORE"
+"\x00\x41;-c;EBCDIC-DK-NO-A;UTF-8//TRANSLIT//IGNORE"
+"\x00\x41;-c;EBCDIC-ES;UTF-8//TRANSLIT//IGNORE"
+"\x00\x41;-c;EBCDIC-ES-A;UTF-8//TRANSLIT//IGNORE"
+"\x00\x41;-c;EBCDIC-ES-S;UTF-8//TRANSLIT//IGNORE"
+"\x00\x41;-c;EBCDIC-FI-SE;UTF-8//TRANSLIT//IGNORE"
+"\x00\x41;-c;EBCDIC-FI-SE-A;UTF-8//TRANSLIT//IGNORE"
+"\x00\x41;-c;EBCDIC-FR;UTF-8//TRANSLIT//IGNORE"
+"\x00\x41;-c;EBCDIC-IS-FRISS;UTF-8//TRANSLIT//IGNORE"
+"\x00\x41;-c;EBCDIC-IT;UTF-8//TRANSLIT//IGNORE"
+"\x00\x41;-c;EBCDIC-PT;UTF-8//TRANSLIT//IGNORE"
+"\x00\x41;-c;EBCDIC-UK;UTF-8//TRANSLIT//IGNORE"
+"\x00\x41;-c;EBCDIC-US;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;ES;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;ES2;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;EUC-CN;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;EUC-JISX0213;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;EUC-JP;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;EUC-JP-MS;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;EUC-KR;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;EUC-TW;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;GB18030;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;GB_1988-80;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;GBK;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;GOST_19768-74;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;GREEK7;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;GREEK7-OLD;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;GREEK-CCITT;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;HP-GREEK8;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;HP-ROMAN8;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;HP-ROMAN9;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;HP-THAI8;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;HP-TURKISH8;UTF-8//TRANSLIT//IGNORE"
+"\x00\x41;-c;IBM038;UTF-8//TRANSLIT//IGNORE"
+"\x00\x80;-c;IBM1004;UTF-8//TRANSLIT//IGNORE"
+"\x00\xff;-c;IBM1008;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;IBM1046;UTF-8//TRANSLIT//IGNORE"
+"\x00\x51;-c;IBM1132;UTF-8//TRANSLIT//IGNORE"
+"\x00\xa0;-c;IBM1133;UTF-8//TRANSLIT//IGNORE"
+"\x00\xce;-c;IBM1137;UTF-8//TRANSLIT//IGNORE"
+"\x00\x80;-c;IBM1161;UTF-8//TRANSLIT//IGNORE"
+"\x00\xdb;-c;IBM1162;UTF-8//TRANSLIT//IGNORE"
+"\x00\x70;-c;IBM12712;UTF-8//TRANSLIT//IGNORE"
+"\x00\x0f;-c;IBM1364;UTF-8"
+"\x0e\x0e;-c;IBM1364;UTF-8"
+"\x00\x0f;-c;IBM1371;UTF-8"
+"\x0e\x0e;-c;IBM1371;UTF-8"
+"\x00\x0f;-c;IBM1388;UTF-8"
+"\x0e\x0e;-c;IBM1388;UTF-8"
+"\x00\x0f;-c;IBM1390;UTF-8"
+"\x0e\x0e;-c;IBM1390;UTF-8"
+"\x00\x0f;-c;IBM1399;UTF-8"
+"\x0e\x0e;-c;IBM1399;UTF-8"
+"\x00\x53;-c;IBM16804;UTF-8//TRANSLIT//IGNORE"
+"\x00\x41;-c;IBM274;UTF-8//TRANSLIT//IGNORE"
+"\x00\x41;-c;IBM275;UTF-8//TRANSLIT//IGNORE"
+"\x00\x41;-c;IBM281;UTF-8//TRANSLIT//IGNORE"
+"\x00\x57;-c;IBM290;UTF-8//TRANSLIT//IGNORE"
+"\x00\x45;-c;IBM420;UTF-8//TRANSLIT//IGNORE"
+"\x00\x68;-c;IBM423;UTF-8//TRANSLIT//IGNORE"
+"\x00\x70;-c;IBM424;UTF-8//TRANSLIT//IGNORE"
+"\x00\x53;-c;IBM4517;UTF-8//TRANSLIT//IGNORE"
+"\x00\x53;-c;IBM4899;UTF-8//TRANSLIT//IGNORE"
+"\x00\xa5;-c;IBM4909;UTF-8//TRANSLIT//IGNORE"
+"\x00\xdc;-c;IBM4971;UTF-8//TRANSLIT//IGNORE"
+"\x00\x41;-c;IBM803;UTF-8//TRANSLIT//IGNORE"
+"\x00\x91;-c;IBM851;UTF-8//TRANSLIT//IGNORE"
+"\x00\x9b;-c;IBM856;UTF-8//TRANSLIT//IGNORE"
+"\x00\xd5;-c;IBM857;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;IBM864;UTF-8//TRANSLIT//IGNORE"
+"\x00\x94;-c;IBM868;UTF-8//TRANSLIT//IGNORE"
+"\x00\x94;-c;IBM869;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;IBM874;UTF-8//TRANSLIT//IGNORE"
+"\x00\x6a;-c;IBM875;UTF-8//TRANSLIT//IGNORE"
+"\x00\x41;-c;IBM880;UTF-8//TRANSLIT//IGNORE"
+"\x00\x80;-c;IBM891;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;IBM903;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;IBM904;UTF-8//TRANSLIT//IGNORE"
+"\x00\x41;-c;IBM905;UTF-8//TRANSLIT//IGNORE"
+"\x00\x80;-c;IBM9066;UTF-8//TRANSLIT//IGNORE"
+"\x00\x48;-c;IBM918;UTF-8//TRANSLIT//IGNORE"
+"\x00\x57;-c;IBM930;UTF-8//TRANSLIT//IGNORE"
+"\x00\x80;-c;IBM932;UTF-8//TRANSLIT//IGNORE"
+"\x00\x41;-c;IBM933;UTF-8//TRANSLIT//IGNORE"
+"\x00\x41;-c;IBM935;UTF-8//TRANSLIT//IGNORE"
+"\x00\x41;-c;IBM937;UTF-8//TRANSLIT//IGNORE"
+"\x00\x41;-c;IBM939;UTF-8//TRANSLIT//IGNORE"
+"\x00\x80;-c;IBM943;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;INIS;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;INIS-8;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;INIS-CYRILLIC;UTF-8//TRANSLIT//IGNORE"
+"\x00\xec;-c;ISIRI-3342;UTF-8//TRANSLIT//IGNORE"
+"\x00\xec;-c;ISO_10367-BOX;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;ISO-2022-CN;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;ISO-2022-CN-EXT;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;ISO-2022-JP;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;ISO-2022-JP-2;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;ISO-2022-JP-3;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;ISO-2022-KR;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;ISO_2033;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;ISO_5427;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;ISO_5427-EXT;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;ISO_5428;UTF-8//TRANSLIT//IGNORE"
+"\x00\xa4;-c;ISO_6937;UTF-8//TRANSLIT//IGNORE"
+"\x00\xa0;-c;ISO_6937-2;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;ISO-8859-11;UTF-8//TRANSLIT//IGNORE"
+"\x00\xa5;-c;ISO-8859-3;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;ISO-8859-6;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;ISO-8859-7;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;ISO-8859-8;UTF-8//TRANSLIT//IGNORE"
+"\x00\x80;-c;ISO-IR-197;UTF-8//TRANSLIT//IGNORE"
+"\x00\x80;-c;ISO-IR-209;UTF-8//TRANSLIT//IGNORE"
+"\x00\x80;-c;IT;UTF-8//TRANSLIT//IGNORE"
+"\x00\x80;-c;JIS_C6220-1969-RO;UTF-8//TRANSLIT//IGNORE"
+"\x00\x80;-c;JIS_C6229-1984-B;UTF-8//TRANSLIT//IGNORE"
+"\x00\x80;-c;JOHAB;UTF-8//TRANSLIT//IGNORE"
+"\x00\x80;-c;JUS_I.B1.002;UTF-8//TRANSLIT//IGNORE"
+"\x00\x80;-c;KOI-8;UTF-8//TRANSLIT//IGNORE"
+"\x00\x88;-c;KOI8-T;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;KSC5636;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;LATIN-GREEK;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;LATIN-GREEK-1;UTF-8//TRANSLIT//IGNORE"
+"\x00\xf6;-c;MAC-IS;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;MSZ_7795.3;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;NATS-DANO;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;NATS-SEFI;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;NC_NC00-10;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;NF_Z_62-010;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;NF_Z_62-010_1973;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;NS_4551-1;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;NS_4551-2;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;PT;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;PT2;UTF-8//TRANSLIT//IGNORE"
+"\x00\x98;-c;RK1048;UTF-8//TRANSLIT//IGNORE"
+"\x00\x98;-c;SEN_850200_B;UTF-8//TRANSLIT//IGNORE"
+"\x00\x98;-c;SEN_850200_C;UTF-8//TRANSLIT//IGNORE"
+"\x00\x80;-c;Shift_JISX0213;UTF-8//TRANSLIT//IGNORE"
+"\x00\x80;-c;SJIS;UTF-8//TRANSLIT//IGNORE"
+"\x00\x23;-c;T.61-8BIT;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;TIS-620;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;TSCII;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;UHC;UTF-8//TRANSLIT//IGNORE"
+"\x00\xd8;-c;UNICODE;UTF-8//TRANSLIT//IGNORE"
+"\x00\xdc;-c;UTF-16;UTF-8//TRANSLIT//IGNORE"
+"\xdc\x00;-c;UTF-16BE;UTF-8//TRANSLIT//IGNORE"
+"\x00\xdc;-c;UTF-16LE;UTF-8//TRANSLIT//IGNORE"
+"\xff\xff;-c;UTF-7;UTF-8//TRANSLIT//IGNORE"
+"\x00\x81;-c;WIN-SAMI-2;UTF-8//TRANSLIT//IGNORE"
+)
+
+# List of option combinations that *should* lead to an error
+errorarray=(
+# Converting from/to invalid character sets should cause error
+"\x00\x00;;INVALID;INVALID"
+"\x00\x00;;INVALID;UTF-8"
+"\x00\x00;;UTF-8;INVALID"
+)
+
+# Requires $twobyte input, $c flag, $from, and $to to be set; sets $ret
+execute_test ()
+{
+  eval PROG=\"$ICONV\"
+  echo -en "$twobyte" \
+    | timeout -k 4 3 $PROG $c -f $from -t "$to" &>/dev/null
+  ret=$?
+}
+
+check_hangtest_result ()
+{
+  if [ "$ret" -eq "124" ] || [ "$ret" -eq "137" ]; then # timeout/hang
+    result="HANG"
+  else
+    if [ "$ret" -eq "139" ]; then # segfault
+      result="SEGFAULT"
+    else
+      if [ "$ret" -gt "127" ]; then # unexpected error
+        result="UNEXPECTED"
+      else
+        result="OK"
+      fi
+    fi
+  fi
+
+  echo -n "$result: from: \"$from\", to: \"$to\","
+  echo    " input \"$twobyte\", flags \"$c\""
+
+  if [ "$result" != "OK" ]; then
+    exit 1
+  fi
+}
+
+for hangcommand in "${hangarray[@]}"; do
+  twobyte="$(echo "$hangcommand" | cut -d";" -f 1)"
+  c="$(echo "$hangcommand" | cut -d";" -f 2)"
+  from="$(echo "$hangcommand" | cut -d";" -f 3)"
+  to="$(echo "$hangcommand" | cut -d";" -f 4)"
+  execute_test
+  check_hangtest_result
+done
+
+check_errtest_result ()
+{
+  if [ "$ret" -eq "1" ]; then # we errored out as expected
+    result="PASS"
+  else
+    result="FAIL"
+  fi
+  echo -n "$result: from: \"$from\", to: \"$to\","
+  echo    " input \"$twobyte\", flags \"$c\", return code $ret"
+
+  if [ "$result" != "PASS" ]; then
+    exit 1
+  fi
+}
+
+for errorcommand in "${errorarray[@]}"; do
+  twobyte="$(echo "$errorcommand" | cut -d";" -f 1)"
+  c="$(echo "$errorcommand" | cut -d";" -f 2)"
+  from="$(echo "$errorcommand" | cut -d";" -f 3)"
+  to="$(echo "$errorcommand" | cut -d";" -f 4)"
+  execute_test
+  check_errtest_result
+done
diff --git a/iconvdata/ibm1364.c b/iconvdata/ibm1364.c
index b833273aa8..27900c4307 100644
--- a/iconvdata/ibm1364.c
+++ b/iconvdata/ibm1364.c
@@ -157,24 +157,14 @@ enum
 									      \
     if (__builtin_expect (ch, 0) == SO)					      \
       {									      \
-	/* Shift OUT, change to DBCS converter.  */			      \
-	if (curcs == db)						      \
-	  {								      \
-	    result = __GCONV_ILLEGAL_INPUT;				      \
-	    break;							      \
-	  }								      \
+	/* Shift OUT, change to DBCS converter (redundant escape okay).  */   \
 	curcs = db;							      \
 	++inptr;							      \
 	continue;							      \
       }									      \
     if (__builtin_expect (ch, 0) == SI)					      \
       {									      \
-	/* Shift IN, change to SBCS converter.  */			      \
-	if (curcs == sb)						      \
-	  {								      \
-	    result = __GCONV_ILLEGAL_INPUT;				      \
-	    break;							      \
-	  }								      \
+	/* Shift IN, change to SBCS converter (redundant escape okay).  */    \
 	curcs = sb;							      \
 	++inptr;							      \
 	continue;							      \
diff --git a/include/link.h b/include/link.h
index 5924594548..83b1c34b7b 100644
--- a/include/link.h
+++ b/include/link.h
@@ -216,6 +216,10 @@ struct link_map
       unsigned int boundndx;
       uint32_t enterexit;
       unsigned int flags;
+      /* CONCURRENCY NOTE: This is used to guard the concurrent initialization
+	 of the relocation result across multiple threads.  See the more
+	 detailed notes in elf/dl-runtime.c.  */
+      unsigned int init;
     } *l_reloc_result;
 
     /* Pointer to the version information if available.  */
diff --git a/include/rpc/clnt.h b/include/rpc/clnt.h
index a397023a93..80be0a9cec 100644
--- a/include/rpc/clnt.h
+++ b/include/rpc/clnt.h
@@ -28,6 +28,7 @@ libc_hidden_proto (clntudp_create)
 libc_hidden_proto (get_myaddress)
 libc_hidden_proto (clntunix_create)
 libc_hidden_proto (__libc_clntudp_bufcreate)
+libc_hidden_proto (rpc_createerr)
 
 # endif /* !_ISOMAC */
 #endif
diff --git a/include/rpc/svc.h b/include/rpc/svc.h
index 465bf4427d..40ba2546a9 100644
--- a/include/rpc/svc.h
+++ b/include/rpc/svc.h
@@ -3,6 +3,10 @@
 
 # ifndef _ISOMAC
 
+libc_hidden_proto (svc_pollfd)
+libc_hidden_proto (svc_max_pollfd)
+libc_hidden_proto (svc_fdset)
+
 libc_hidden_proto (xprt_register)
 libc_hidden_proto (xprt_unregister)
 libc_hidden_proto (svc_register)
diff --git a/include/unistd.h b/include/unistd.h
index 0f91b8babc..a171b00326 100644
--- a/include/unistd.h
+++ b/include/unistd.h
@@ -77,6 +77,8 @@ extern char *__getcwd (char *__buf, size_t __size) attribute_hidden;
 extern int __rmdir (const char *__path) attribute_hidden;
 extern int __execvpe (const char *file, char *const argv[],
 		      char *const envp[]) attribute_hidden;
+extern int __execvpex (const char *file, char *const argv[],
+		       char *const envp[]) attribute_hidden;
 
 /* Get the canonical absolute name of the named directory, and put it in SIZE
    bytes of BUF.  Returns NULL if the directory couldn't be determined or
diff --git a/inet/Makefile b/inet/Makefile
index f63c7e25ba..3274977bf6 100644
--- a/inet/Makefile
+++ b/inet/Makefile
@@ -52,7 +52,7 @@ aux := check_pf check_native ifreq
 tests := htontest test_ifindex tst-ntoa tst-ether_aton tst-network \
 	 tst-gethnm test-ifaddrs bug-if1 test-inet6_opt tst-ether_line \
 	 tst-getni1 tst-getni2 tst-inet6_rth tst-checks tst-checks-posix \
-	 tst-sockaddr test-hnto-types
+	 tst-sockaddr test-hnto-types tst-if_index-long
 
 # tst-deadline must be linked statically so that we can access
 # internal functions.
diff --git a/inet/tst-if_index-long.c b/inet/tst-if_index-long.c
new file mode 100644
index 0000000000..3dc74874e5
--- /dev/null
+++ b/inet/tst-if_index-long.c
@@ -0,0 +1,61 @@
+/* Check for descriptor leak in if_nametoindex with a long interface name.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This test checks for a descriptor leak in case of a long interface
+   name (CVE-2018-19591, bug 23927).  */
+
+#include <errno.h>
+#include <net/if.h>
+#include <netdb.h>
+#include <string.h>
+#include <support/check.h>
+#include <support/descriptors.h>
+#include <support/support.h>
+
+static int
+do_test (void)
+{
+  struct support_descriptors *descrs = support_descriptors_list ();
+
+  /* Prepare a name which is just as long as required for trigging the
+     bug.  */
+  char name[IFNAMSIZ + 1];
+  memset (name, 'A', IFNAMSIZ);
+  name[IFNAMSIZ] = '\0';
+  TEST_COMPARE (strlen (name), IFNAMSIZ);
+  struct ifreq ifr;
+  TEST_COMPARE (strlen (name), sizeof (ifr.ifr_name));
+
+  /* Test directly via if_nametoindex.  */
+  TEST_COMPARE (if_nametoindex (name), 0);
+  TEST_COMPARE (errno, ENODEV);
+  support_descriptors_check (descrs);
+
+  /* Same test via getaddrinfo.  */
+  char *host = xasprintf ("fea0::%%%s", name);
+  struct addrinfo hints = { .ai_flags = AI_NUMERICHOST, };
+  struct addrinfo *ai;
+  TEST_COMPARE (getaddrinfo (host, NULL, &hints, &ai), EAI_NONAME);
+  support_descriptors_check (descrs);
+
+  support_descriptors_free (descrs);
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/intl/Makefile b/intl/Makefile
index 2219717a5a..672edf1b38 100644
--- a/intl/Makefile
+++ b/intl/Makefile
@@ -120,7 +120,11 @@ $(objpfx)tst-gettext6.out: $(gen-locales)
 $(objpfx)tst-translit.out: $(gen-locales)
 endif
 
-$(objpfx)msgs.h: po2test.awk ../po/de.po
+$(objpfx)tst-gettext-de.po: ../po/de.po
+	$(make-target-directory)
+	LC_ALL=C $(AWK) '!/^"POT-Creation-Date: [0-9-]+ [0-9:+-]+\\n"$$/' $^ > $@
+
+$(objpfx)msgs.h: po2test.awk $(objpfx)tst-gettext-de.po
 	$(make-target-directory)
 	LC_ALL=C $(AWK) -f $^ > $@
 
diff --git a/intl/dcigettext.c b/intl/dcigettext.c
index 2a50369948..7ebe67b4ac 100644
--- a/intl/dcigettext.c
+++ b/intl/dcigettext.c
@@ -631,7 +631,7 @@ DCIGETTEXT (const char *domainname, const char *msgid1, const char *msgid2,
 	  int ret = __asprintf (&xdirname, "%s/%s", cwd, dirname);
 	  free (cwd);
 	  if (ret < 0)
-	      return NULL;
+	    goto return_untranslated;
 	  dirname = xdirname;
 	}
 #ifndef IN_LIBGLOCALE
@@ -1120,11 +1120,19 @@ _nl_find_msg (struct loaded_l10nfile *domain_file,
 		      outcharset = encoding;
 
 # ifdef _LIBC
+
+		      struct gconv_spec conv_spec;
+
+                      __gconv_create_spec (&conv_spec, charset, outcharset);
+
 		      /* We always want to use transliteration.  */
-		      outcharset = norm_add_slashes (outcharset, "TRANSLIT");
-		      charset = norm_add_slashes (charset, "");
-		      int r = __gconv_open (outcharset, charset, &convd->conv,
-					    GCONV_AVOID_NOCONV);
+                      conv_spec.translit = true;
+
+		      int r = __gconv_open (&conv_spec, &convd->conv,
+		                            GCONV_AVOID_NOCONV);
+
+                      __gconv_destroy_spec (&conv_spec);
+
 		      if (__builtin_expect (r != __GCONV_OK, 0))
 			{
 			  /* If the output encoding is the same there is
diff --git a/intl/tst-codeset.c b/intl/tst-codeset.c
index e71382aeee..52e4aaa6ff 100644
--- a/intl/tst-codeset.c
+++ b/intl/tst-codeset.c
@@ -22,13 +22,11 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <support/check.h>
 
 static int
 do_test (void)
 {
-  char *s;
-  int result = 0;
-
   unsetenv ("LANGUAGE");
   unsetenv ("OUTPUT_CHARSET");
   setlocale (LC_ALL, "de_DE.ISO-8859-1");
@@ -36,25 +34,21 @@ do_test (void)
   bindtextdomain ("codeset", OBJPFX "domaindir");
 
   /* Here we expect output in ISO-8859-1.  */
-  s = gettext ("cheese");
-  if (strcmp (s, "K\344se"))
-    {
-      printf ("call 1 returned: %s\n", s);
-      result = 1;
-    }
+  TEST_COMPARE_STRING (gettext ("cheese"), "K\344se");
 
+  /* Here we expect output in UTF-8.  */
   bind_textdomain_codeset ("codeset", "UTF-8");
+  TEST_COMPARE_STRING (gettext ("cheese"), "K\303\244se");
 
-  /* Here we expect output in UTF-8.  */
-  s = gettext ("cheese");
-  if (strcmp (s, "K\303\244se"))
-    {
-      printf ("call 2 returned: %s\n", s);
-      result = 1;
-    }
-
-  return result;
+  /* `a with umlaut' is transliterated to `ae'.  */
+  bind_textdomain_codeset ("codeset", "ASCII//TRANSLIT");
+  TEST_COMPARE_STRING (gettext ("cheese"), "Kaese");
+
+  /* Transliteration also works by default even if not set.  */
+  bind_textdomain_codeset ("codeset", "ASCII");
+  TEST_COMPARE_STRING (gettext ("cheese"), "Kaese");
+
+  return 0;
 }
 
-#define TEST_FUNCTION do_test ()
-#include "../test-skeleton.c"
+#include <support/test-driver.c>
diff --git a/intl/tst-gettext.sh b/intl/tst-gettext.sh
index af9c7d7d92..0c65583149 100755
--- a/intl/tst-gettext.sh
+++ b/intl/tst-gettext.sh
@@ -42,9 +42,9 @@ mkdir -p ${objpfx}domaindir/existing-locale/LC_MESSAGES
 mkdir -p ${objpfx}domaindir/existing-locale/LC_TIME
 # Populate them.
 msgfmt -o ${objpfx}domaindir/existing-locale/LC_MESSAGES/existing-domain.mo \
-       -f ../po/de.po
+       -f ${objpfx}tst-gettext-de.po
 msgfmt -o ${objpfx}domaindir/existing-locale/LC_TIME/existing-time-domain.mo \
-       -f ../po/de.po
+       -f ${objpfx}tst-gettext-de.po
 
 # Now run the test.
 ${test_program_prefix_before_env} \
diff --git a/io/Makefile b/io/Makefile
index 2117cb6b62..943833f8bd 100644
--- a/io/Makefile
+++ b/io/Makefile
@@ -73,11 +73,6 @@ tests		:= test-utime test-stat test-stat2 test-lfs tst-getcwd \
 		   tst-fts tst-fts-lfs tst-open-tmpfile \
 		   tst-copy_file_range tst-getcwd-abspath \
 
-# This test includes the compat implementation of copy_file_range,
-# which uses internal, unexported libc functions.
-tests-static += tst-copy_file_range-compat
-tests-internal += tst-copy_file_range-compat
-
 ifeq ($(run-built-tests),yes)
 tests-special += $(objpfx)ftwtest.out
 endif
diff --git a/io/copy_file_range-compat.c b/io/copy_file_range-compat.c
deleted file mode 100644
index 4ab22cad19..0000000000
--- a/io/copy_file_range-compat.c
+++ /dev/null
@@ -1,160 +0,0 @@
-/* Emulation of copy_file_range.
-   Copyright (C) 2017-2018 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-/* The following macros should be defined before including this
-   file:
-
-   COPY_FILE_RANGE_DECL   Declaration specifiers for the function below.
-   COPY_FILE_RANGE        Name of the function to define.  */
-
-#include <errno.h>
-#include <fcntl.h>
-#include <inttypes.h>
-#include <limits.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <unistd.h>
-
-COPY_FILE_RANGE_DECL
-ssize_t
-COPY_FILE_RANGE (int infd, __off64_t *pinoff,
-                 int outfd, __off64_t *poutoff,
-                 size_t length, unsigned int flags)
-{
-  if (flags != 0)
-    {
-      __set_errno (EINVAL);
-      return -1;
-    }
-
-  {
-    struct stat64 instat;
-    struct stat64 outstat;
-    if (fstat64 (infd, &instat) != 0 || fstat64 (outfd, &outstat) != 0)
-      return -1;
-    if (S_ISDIR (instat.st_mode) || S_ISDIR (outstat.st_mode))
-      {
-        __set_errno (EISDIR);
-        return -1;
-      }
-    if (!S_ISREG (instat.st_mode) || !S_ISREG (outstat.st_mode))
-      {
-        /* We need a regular input file so that the we can seek
-           backwards in case of a write failure.  */
-        __set_errno (EINVAL);
-        return -1;
-      }
-    if (instat.st_dev != outstat.st_dev)
-      {
-        /* Cross-device copies are not supported.  */
-        __set_errno (EXDEV);
-        return -1;
-      }
-  }
-
-  /* The output descriptor must not have O_APPEND set.  */
-  {
-    int flags = __fcntl (outfd, F_GETFL);
-    if (flags & O_APPEND)
-      {
-        __set_errno (EBADF);
-        return -1;
-      }
-  }
-
-  /* Avoid an overflow in the result.  */
-  if (length > SSIZE_MAX)
-    length = SSIZE_MAX;
-
-  /* Main copying loop.  The buffer size is arbitrary and is a
-     trade-off between stack size consumption, cache usage, and
-     amortization of system call overhead.  */
-  size_t copied = 0;
-  char buf[8192];
-  while (length > 0)
-    {
-      size_t to_read = length;
-      if (to_read > sizeof (buf))
-        to_read = sizeof (buf);
-
-      /* Fill the buffer.  */
-      ssize_t read_count;
-      if (pinoff == NULL)
-        read_count = read (infd, buf, to_read);
-      else
-        read_count = __libc_pread64 (infd, buf, to_read, *pinoff);
-      if (read_count == 0)
-        /* End of file reached prematurely.  */
-        return copied;
-      if (read_count < 0)
-        {
-          if (copied > 0)
-            /* Report the number of bytes copied so far.  */
-            return copied;
-          return -1;
-        }
-      if (pinoff != NULL)
-        *pinoff += read_count;
-
-      /* Write the buffer part which was read to the destination.  */
-      char *end = buf + read_count;
-      for (char *p = buf; p < end; )
-        {
-          ssize_t write_count;
-          if (poutoff == NULL)
-            write_count = write (outfd, p, end - p);
-          else
-            write_count = __libc_pwrite64 (outfd, p, end - p, *poutoff);
-          if (write_count < 0)
-            {
-              /* Adjust the input read position to match what we have
-                 written, so that the caller can pick up after the
-                 error.  */
-              size_t written = p - buf;
-              /* NB: This needs to be signed so that we can form the
-                 negative value below.  */
-              ssize_t overread = read_count - written;
-              if (pinoff == NULL)
-                {
-                  if (overread > 0)
-                    {
-                      /* We are on an error recovery path, so we
-                         cannot deal with failure here.  */
-                      int save_errno = errno;
-                      (void) __libc_lseek64 (infd, -overread, SEEK_CUR);
-                      __set_errno (save_errno);
-                    }
-                }
-              else /* pinoff != NULL */
-                *pinoff -= overread;
-
-              if (copied + written > 0)
-                /* Report the number of bytes copied so far.  */
-                return copied + written;
-              return -1;
-            }
-          p += write_count;
-          if (poutoff != NULL)
-            *poutoff += write_count;
-        } /* Write loop.  */
-
-      copied += read_count;
-      length -= read_count;
-    }
-  return copied;
-}
diff --git a/io/copy_file_range.c b/io/copy_file_range.c
index 98bff8bd26..59fb979773 100644
--- a/io/copy_file_range.c
+++ b/io/copy_file_range.c
@@ -1,5 +1,5 @@
-/* Generic implementation of copy_file_range.
-   Copyright (C) 2017-2018 Free Software Foundation, Inc.
+/* Stub implementation of copy_file_range.
+   Copyright (C) 2017-2019 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -16,7 +16,15 @@
    License along with the GNU C Library; if not, see
    <http://www.gnu.org/licenses/>.  */
 
-#define COPY_FILE_RANGE_DECL
-#define COPY_FILE_RANGE copy_file_range
+#include <errno.h>
+#include <unistd.h>
 
-#include <io/copy_file_range-compat.c>
+ssize_t
+copy_file_range (int infd, __off64_t *pinoff,
+                 int outfd, __off64_t *poutoff,
+                 size_t length, unsigned int flags)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+stub_warning (copy_file_range)
diff --git a/io/fcntl.h b/io/fcntl.h
index 3d239e8f09..69a4394191 100644
--- a/io/fcntl.h
+++ b/io/fcntl.h
@@ -139,7 +139,7 @@ typedef __pid_t pid_t;
 # define SEEK_END	2	/* Seek from end of file.  */
 #endif	/* XPG */
 
-/* The constants AT_REMOVEDIR and AT_EACCESS have the same value.  AT_EASSESS
+/* The constants AT_REMOVEDIR and AT_EACCESS have the same value.  AT_EACCESS
    is meaningful only to faccessat, while AT_REMOVEDIR is meaningful only to
    unlinkat.  The two functions do completely different things and therefore,
    the flags can be allowed to overlap.  For example, passing AT_REMOVEDIR to
diff --git a/io/tst-copy_file_range.c b/io/tst-copy_file_range.c
index 3d531a1937..a9237cb384 100644
--- a/io/tst-copy_file_range.c
+++ b/io/tst-copy_file_range.c
@@ -1,5 +1,5 @@
 /* Tests for copy_file_range.
-   Copyright (C) 2017-2018 Free Software Foundation, Inc.
+   Copyright (C) 2017-2019 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -20,22 +20,15 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <inttypes.h>
-#include <libgen.h>
-#include <poll.h>
-#include <sched.h>
 #include <stdbool.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <support/check.h>
-#include <support/namespace.h>
 #include <support/support.h>
 #include <support/temp_file.h>
 #include <support/test-driver.h>
 #include <support/xunistd.h>
-#ifdef CLONE_NEWNS
-# include <sys/mount.h>
-#endif
 
 /* Boolean flags which indicate whether to use pointers with explicit
    output flags.  */
@@ -49,10 +42,6 @@ static int infd;
 static char *outfile;
 static int outfd;
 
-/* Like the above, but on a different file system.  xdevfile can be
-   NULL if no suitable file system has been found.  */
-static char *xdevfile;
-
 /* Input and output offsets.  Set according to do_inoff and do_outoff
    before the test.  The offsets themselves are always set to
    zero.  */
@@ -61,13 +50,10 @@ static off64_t *pinoff;
 static off64_t outoff;
 static off64_t *poutoff;
 
-/* These are a collection of copy sizes used in tests.  The selection
-   takes into account that the fallback implementation uses an
-   internal buffer of 8192 bytes.  */
+/* These are a collection of copy sizes used in tests.    */
 enum { maximum_size = 99999 };
 static const int typical_sizes[] =
-  { 0, 1, 2, 3, 1024, 2048, 4096, 8191, 8192, 8193, 16383, 16384, 16385,
-    maximum_size };
+  { 0, 1, 2, 3, 1024, 2048, 4096, 8191, 8192, 8193, maximum_size };
 
 /* The random contents of this array can be used as a pattern to check
    for correct write operations.  */
@@ -76,101 +62,6 @@ static unsigned char random_data[maximum_size];
 /* The size chosen by the test harness.  */
 static int current_size;
 
-/* Maximum writable file offset.  Updated by find_maximum_offset
-   below.  */
-static off64_t maximum_offset;
-
-/* Error code when crossing the offset.  */
-static int maximum_offset_errno;
-
-/* If true: Writes which cross the limit will fail.  If false: Writes
-   which cross the limit will result in a partial write.  */
-static bool maximum_offset_hard_limit;
-
-/* Fills maximum_offset etc. above.  Truncates outfd as a side
-   effect.  */
-static void
-find_maximum_offset (void)
-{
-  xftruncate (outfd, 0);
-  if (maximum_offset != 0)
-    return;
-
-  uint64_t upper = -1;
-  upper >>= 1;                  /* Maximum of off64_t.  */
-  TEST_VERIFY ((off64_t) upper > 0);
-  TEST_VERIFY ((off64_t) (upper + 1) < 0);
-  if (lseek64 (outfd, upper, SEEK_SET) >= 0)
-    {
-      if (write (outfd, "", 1) == 1)
-        FAIL_EXIT1 ("created a file larger than the off64_t range");
-    }
-
-  uint64_t lower = 1024 * 1024; /* A reasonable minimum file size.  */
-  /* Loop invariant: writing at lower succeeds, writing at upper fails.  */
-  while (lower + 1 < upper)
-    {
-      uint64_t middle = (lower + upper) / 2;
-      if (test_verbose > 0)
-        printf ("info: %s: remaining test range %" PRIu64 " .. %" PRIu64
-                ", probe at %" PRIu64 "\n", __func__, lower, upper, middle);
-      xftruncate (outfd, 0);
-      if (lseek64 (outfd, middle, SEEK_SET) >= 0
-          && write (outfd, "", 1) == 1)
-        lower = middle;
-      else
-        upper = middle;
-    }
-  TEST_VERIFY (lower + 1 == upper);
-  maximum_offset = lower;
-  printf ("info: maximum writable file offset: %" PRIu64 " (%" PRIx64 ")\n",
-          lower, lower);
-
-  /* Check that writing at the valid offset actually works.  */
-  xftruncate (outfd, 0);
-  xlseek (outfd, lower, SEEK_SET);
-  TEST_COMPARE (write (outfd, "", 1), 1);
-
-  /* Cross the boundary with a two-byte write.  This can either result
-     in a short write, or a failure.  */
-  xlseek (outfd, lower, SEEK_SET);
-  ssize_t ret = write (outfd, " ", 2);
-  if (ret < 0)
-    {
-      maximum_offset_errno = errno;
-      maximum_offset_hard_limit = true;
-    }
-  else
-    maximum_offset_hard_limit = false;
-
-  /* Check that writing at the next offset actually fails.  This also
-     obtains the expected errno value.  */
-  xftruncate (outfd, 0);
-  const char *action;
-  if (lseek64 (outfd, lower + 1, SEEK_SET) != 0)
-    {
-      if (write (outfd, "", 1) != -1)
-        FAIL_EXIT1 ("write to impossible offset %" PRIu64 " succeeded",
-                    lower + 1);
-      action = "writing";
-      int errno_copy = errno;
-      if (maximum_offset_hard_limit)
-        TEST_COMPARE (errno_copy, maximum_offset_errno);
-      else
-        maximum_offset_errno = errno_copy;
-    }
-  else
-    {
-      action = "seeking";
-      maximum_offset_errno = errno;
-    }
-  printf ("info: %s out of range fails with %m (%d)\n",
-          action, maximum_offset_errno);
-
-  xftruncate (outfd, 0);
-  xlseek (outfd, 0, SEEK_SET);
-}
-
 /* Perform a copy of a file.  */
 static void
 simple_file_copy (void)
@@ -247,390 +138,6 @@ simple_file_copy (void)
   free (bytes);
 }
 
-/* Test that reading from a pipe willfails.  */
-static void
-pipe_as_source (void)
-{
-  int pipefds[2];
-  xpipe (pipefds);
-
-  for (int length = 0; length < 2; ++length)
-    {
-      if (test_verbose > 0)
-        printf ("info: %s: length=%d\n", __func__, length);
-
-      /* Make sure that there is something to copy in the pipe.  */
-      xwrite (pipefds[1], "@", 1);
-
-      TEST_COMPARE (copy_file_range (pipefds[0], pinoff, outfd, poutoff,
-                                     length, 0), -1);
-      /* Linux 4.10 and later return EINVAL.  Older kernels return
-         EXDEV.  */
-      TEST_VERIFY (errno == EINVAL || errno == EXDEV);
-      TEST_COMPARE (inoff, 0);
-      TEST_COMPARE (outoff, 0);
-      TEST_COMPARE (xlseek (outfd, 0, SEEK_CUR), 0);
-
-      /* Make sure that nothing was read.  */
-      char buf = 'A';
-      TEST_COMPARE (read (pipefds[0], &buf, 1), 1);
-      TEST_COMPARE (buf, '@');
-    }
-
-  xclose (pipefds[0]);
-  xclose (pipefds[1]);
-}
-
-/* Test that writing to a pipe fails.  */
-static void
-pipe_as_destination (void)
-{
-  /* Make sure that there is something to read in the input file.  */
-  xwrite (infd, "abc", 3);
-  xlseek (infd, 0, SEEK_SET);
-
-  int pipefds[2];
-  xpipe (pipefds);
-
-  for (int length = 0; length < 2; ++length)
-    {
-      if (test_verbose > 0)
-        printf ("info: %s: length=%d\n", __func__, length);
-
-      TEST_COMPARE (copy_file_range (infd, pinoff, pipefds[1], poutoff,
-                                     length, 0), -1);
-      /* Linux 4.10 and later return EINVAL.  Older kernels return
-         EXDEV.  */
-      TEST_VERIFY (errno == EINVAL || errno == EXDEV);
-      TEST_COMPARE (inoff, 0);
-      TEST_COMPARE (outoff, 0);
-      TEST_COMPARE (xlseek (infd, 0, SEEK_CUR), 0);
-
-      /* Make sure that nothing was written.  */
-      struct pollfd pollfd = { .fd = pipefds[0], .events = POLLIN, };
-      TEST_COMPARE (poll (&pollfd, 1, 0), 0);
-    }
-
-  xclose (pipefds[0]);
-  xclose (pipefds[1]);
-}
-
-/* Test a write failure after (potentially) writing some bytes.
-   Failure occurs near the start of the buffer.  */
-static void
-delayed_write_failure_beginning (void)
-{
-  /* We need to write something to provoke the error.  */
-  if (current_size == 0)
-    return;
-  xwrite (infd, random_data, sizeof (random_data));
-  xlseek (infd, 0, SEEK_SET);
-
-  /* Write failure near the start.  The actual error code varies among
-     file systems.  */
-  find_maximum_offset ();
-  off64_t where = maximum_offset;
-
-  if (current_size == 1)
-    ++where;
-  outoff = where;
-  if (do_outoff)
-    xlseek (outfd, 1, SEEK_SET);
-  else
-    xlseek (outfd, where, SEEK_SET);
-  if (maximum_offset_hard_limit || where > maximum_offset)
-    {
-      TEST_COMPARE (copy_file_range (infd, pinoff, outfd, poutoff,
-                                     sizeof (random_data), 0), -1);
-      TEST_COMPARE (errno, maximum_offset_errno);
-      TEST_COMPARE (xlseek (infd, 0, SEEK_CUR), 0);
-      TEST_COMPARE (inoff, 0);
-      if (do_outoff)
-        TEST_COMPARE (xlseek (outfd, 0, SEEK_CUR), 1);
-      else
-        TEST_COMPARE (xlseek (outfd, 0, SEEK_CUR), where);
-      TEST_COMPARE (outoff, where);
-      struct stat64 st;
-      xfstat (outfd, &st);
-      TEST_COMPARE (st.st_size, 0);
-    }
-  else
-    {
-      /* The offset is not a hard limit.  This means we write one
-         byte.  */
-      TEST_COMPARE (copy_file_range (infd, pinoff, outfd, poutoff,
-                                     sizeof (random_data), 0), 1);
-      if (do_inoff)
-        {
-          TEST_COMPARE (inoff, 1);
-          TEST_COMPARE (xlseek (infd, 0, SEEK_CUR), 0);
-        }
-      else
-        {
-          TEST_COMPARE (xlseek (infd, 0, SEEK_CUR), 1);
-          TEST_COMPARE (inoff, 0);
-        }
-      if (do_outoff)
-        {
-          TEST_COMPARE (xlseek (outfd, 0, SEEK_CUR), 1);
-          TEST_COMPARE (outoff, where + 1);
-        }
-      else
-        {
-          TEST_COMPARE (xlseek (outfd, 0, SEEK_CUR), where + 1);
-          TEST_COMPARE (outoff, where);
-        }
-      struct stat64 st;
-      xfstat (outfd, &st);
-      TEST_COMPARE (st.st_size, where + 1);
-    }
-}
-
-/* Test a write failure after (potentially) writing some bytes.
-   Failure occurs near the end of the buffer.  */
-static void
-delayed_write_failure_end (void)
-{
-  if (current_size <= 1)
-    /* This would be same as the first test because there is not
-       enough data to write to make a difference.  */
-    return;
-  xwrite (infd, random_data, sizeof (random_data));
-  xlseek (infd, 0, SEEK_SET);
-
-  find_maximum_offset ();
-  off64_t where = maximum_offset - current_size + 1;
-  if (current_size == sizeof (random_data))
-    /* Otherwise we do not reach the non-writable byte.  */
-    ++where;
-  outoff = where;
-  if (do_outoff)
-    xlseek (outfd, 1, SEEK_SET);
-  else
-    xlseek (outfd, where, SEEK_SET);
-  ssize_t ret = copy_file_range (infd, pinoff, outfd, poutoff,
-                                 sizeof (random_data), 0);
-  if (ret < 0)
-    {
-      TEST_COMPARE (ret, -1);
-      TEST_COMPARE (errno, maximum_offset_errno);
-      struct stat64 st;
-      xfstat (outfd, &st);
-      TEST_COMPARE (st.st_size, 0);
-    }
-  else
-    {
-      /* The first copy succeeded.  This happens in the emulation
-         because the internal buffer of limited size does not
-         necessarily cross the off64_t boundary on the first write
-         operation.  */
-      if (test_verbose > 0)
-        printf ("info:   copy_file_range (%zu) returned %zd\n",
-                sizeof (random_data), ret);
-      TEST_VERIFY (ret > 0);
-      TEST_VERIFY (ret < maximum_size);
-      struct stat64 st;
-      xfstat (outfd, &st);
-      TEST_COMPARE (st.st_size, where + ret);
-      if (do_inoff)
-        {
-          TEST_COMPARE (inoff, ret);
-          TEST_COMPARE (xlseek (infd, 0, SEEK_CUR), 0);
-        }
-      else
-          TEST_COMPARE (xlseek (infd, 0, SEEK_CUR), ret);
-
-      char *buffer = xmalloc (ret);
-      TEST_COMPARE (pread64 (outfd, buffer, ret, where), ret);
-      TEST_VERIFY (memcmp (buffer, random_data, ret) == 0);
-      free (buffer);
-
-      /* The second copy fails.  */
-      TEST_COMPARE (copy_file_range (infd, pinoff, outfd, poutoff,
-                                     sizeof (random_data), 0), -1);
-      TEST_COMPARE (errno, maximum_offset_errno);
-    }
-}
-
-/* Test a write failure across devices.  */
-static void
-cross_device_failure (void)
-{
-  if (xdevfile == NULL)
-    /* Subtest not supported due to missing cross-device file.  */
-    return;
-
-  /* We need something to write.  */
-  xwrite (infd, random_data, sizeof (random_data));
-  xlseek (infd, 0, SEEK_SET);
-
-  int xdevfd = xopen (xdevfile, O_RDWR | O_LARGEFILE, 0);
-  TEST_COMPARE (copy_file_range (infd, pinoff, xdevfd, poutoff,
-                                 current_size, 0), -1);
-  TEST_COMPARE (errno, EXDEV);
-  TEST_COMPARE (xlseek (infd, 0, SEEK_CUR), 0);
-  struct stat64 st;
-  xfstat (xdevfd, &st);
-  TEST_COMPARE (st.st_size, 0);
-
-  xclose (xdevfd);
-}
-
-/* Try to exercise ENOSPC behavior with a tempfs file system (so that
-   we do not have to fill up a regular file system to get the error).
-   This function runs in a subprocess, so that we do not change the
-   mount namespace of the actual test process.  */
-static void
-enospc_failure_1 (void *closure)
-{
-#ifdef CLONE_NEWNS
-  support_become_root ();
-
-  /* Make sure that we do not alter the file system mounts of the
-     parents.  */
-  if (! support_enter_mount_namespace ())
-    {
-      printf ("warning: ENOSPC test skipped\n");
-      return;
-    }
-
-  char *mountpoint = closure;
-  if (mount ("none", mountpoint, "tmpfs", MS_NODEV | MS_NOEXEC,
-             "size=500k") != 0)
-    {
-      printf ("warning: could not mount tmpfs at %s: %m\n", mountpoint);
-      return;
-    }
-
-  /* The source file must reside on the same file system.  */
-  char *intmpfsfile = xasprintf ("%s/%s", mountpoint, "in");
-  int intmpfsfd = xopen (intmpfsfile, O_RDWR | O_CREAT | O_LARGEFILE, 0600);
-  xwrite (intmpfsfd, random_data, sizeof (random_data));
-  xlseek (intmpfsfd, 1, SEEK_SET);
-  inoff = 1;
-
-  char *outtmpfsfile = xasprintf ("%s/%s", mountpoint, "out");
-  int outtmpfsfd = xopen (outtmpfsfile, O_RDWR | O_CREAT | O_LARGEFILE, 0600);
-
-  /* Fill the file with data until ENOSPC is reached.  */
-  while (true)
-    {
-      ssize_t ret = write (outtmpfsfd, random_data, sizeof (random_data));
-      if (ret < 0 && errno != ENOSPC)
-        FAIL_EXIT1 ("write to %s: %m", outtmpfsfile);
-      if (ret < sizeof (random_data))
-        break;
-    }
-  TEST_COMPARE (write (outtmpfsfd, "", 1), -1);
-  TEST_COMPARE (errno, ENOSPC);
-  off64_t maxsize = xlseek (outtmpfsfd, 0, SEEK_CUR);
-  TEST_VERIFY_EXIT (maxsize > sizeof (random_data));
-
-  /* Constructed the expected file contents.  */
-  char *expected = xmalloc (maxsize);
-  TEST_COMPARE (pread64 (outtmpfsfd, expected, maxsize, 0), maxsize);
-  /* Go back a little, so some bytes can be written.  */
-  enum { offset = 20000 };
-  TEST_VERIFY_EXIT (offset < maxsize);
-  TEST_VERIFY_EXIT (offset < sizeof (random_data));
-  memcpy (expected + maxsize - offset, random_data + 1, offset);
-
-  if (do_outoff)
-    {
-      outoff = maxsize - offset;
-      xlseek (outtmpfsfd, 2, SEEK_SET);
-    }
-  else
-    xlseek (outtmpfsfd, -offset, SEEK_CUR);
-
-  /* First call is expected to succeed because we made room for some
-     bytes.  */
-  TEST_COMPARE (copy_file_range (intmpfsfd, pinoff, outtmpfsfd, poutoff,
-                                 maximum_size, 0), offset);
-  if (do_inoff)
-    {
-      TEST_COMPARE (inoff, 1 + offset);
-      TEST_COMPARE (xlseek (intmpfsfd, 0, SEEK_CUR), 1);
-    }
-  else
-      TEST_COMPARE (xlseek (intmpfsfd, 0, SEEK_CUR), 1 + offset);
-  if (do_outoff)
-    {
-      TEST_COMPARE (outoff, maxsize);
-      TEST_COMPARE (xlseek (outtmpfsfd, 0, SEEK_CUR), 2);
-    }
-  else
-    TEST_COMPARE (xlseek (outtmpfsfd, 0, SEEK_CUR), maxsize);
-  struct stat64 st;
-  xfstat (outtmpfsfd, &st);
-  TEST_COMPARE (st.st_size, maxsize);
-  char *actual = xmalloc (st.st_size);
-  TEST_COMPARE (pread64 (outtmpfsfd, actual, st.st_size, 0), st.st_size);
-  TEST_VERIFY (memcmp (expected, actual, maxsize) == 0);
-
-  /* Second call should fail with ENOSPC.  */
-  TEST_COMPARE (copy_file_range (intmpfsfd, pinoff, outtmpfsfd, poutoff,
-                                 maximum_size, 0), -1);
-  TEST_COMPARE (errno, ENOSPC);
-
-  /* Offsets should be unchanged.  */
-  if (do_inoff)
-    {
-      TEST_COMPARE (inoff, 1 + offset);
-      TEST_COMPARE (xlseek (intmpfsfd, 0, SEEK_CUR), 1);
-    }
-  else
-    TEST_COMPARE (xlseek (intmpfsfd, 0, SEEK_CUR), 1 + offset);
-  if (do_outoff)
-    {
-      TEST_COMPARE (outoff, maxsize);
-      TEST_COMPARE (xlseek (outtmpfsfd, 0, SEEK_CUR), 2);
-    }
-  else
-    TEST_COMPARE (xlseek (outtmpfsfd, 0, SEEK_CUR), maxsize);
-  TEST_COMPARE (xlseek (outtmpfsfd, 0, SEEK_END), maxsize);
-  TEST_COMPARE (pread64 (outtmpfsfd, actual, maxsize, 0), maxsize);
-  TEST_VERIFY (memcmp (expected, actual, maxsize) == 0);
-
-  free (actual);
-  free (expected);
-
-  xclose (intmpfsfd);
-  xclose (outtmpfsfd);
-  free (intmpfsfile);
-  free (outtmpfsfile);
-
-#else /* !CLONE_NEWNS */
-  puts ("warning: ENOSPC test skipped (no mount namespaces)");
-#endif
-}
-
-/* Call enospc_failure_1 in a subprocess.  */
-static void
-enospc_failure (void)
-{
-  char *mountpoint
-    = support_create_temp_directory ("tst-copy_file_range-enospc-");
-  support_isolate_in_subprocess (enospc_failure_1, mountpoint);
-  free (mountpoint);
-}
-
-/* The target file descriptor must have O_APPEND enabled.  */
-static void
-oappend_failure (void)
-{
-  /* Add data, to make sure we do not fail because there is
-     insufficient input data.  */
-  xwrite (infd, random_data, current_size);
-  xlseek (infd, 0, SEEK_SET);
-
-  xclose (outfd);
-  outfd = xopen (outfile, O_RDWR | O_APPEND, 0);
-  TEST_COMPARE (copy_file_range (infd, pinoff, outfd, poutoff,
-                                 current_size, 0), -1);
-  TEST_COMPARE (errno, EBADF);
-}
-
 /* Test that a short input file results in a shortened copy.  */
 static void
 short_copy (void)
@@ -721,14 +228,6 @@ struct test_case
 static struct test_case tests[] =
   {
     { "simple_file_copy", simple_file_copy, .sizes = true },
-    { "pipe_as_source", pipe_as_source, },
-    { "pipe_as_destination", pipe_as_destination, },
-    { "delayed_write_failure_beginning", delayed_write_failure_beginning,
-      .sizes = true },
-    { "delayed_write_failure_end", delayed_write_failure_end, .sizes = true },
-    { "cross_device_failure", cross_device_failure, .sizes = true },
-    { "enospc_failure", enospc_failure, },
-    { "oappend_failure", oappend_failure, .sizes = true },
     { "short_copy", short_copy, .sizes = true },
   };
 
@@ -739,53 +238,18 @@ do_test (void)
     *p = rand () >> 24;
 
   infd = create_temp_file ("tst-copy_file_range-in-", &infile);
-  xclose (create_temp_file ("tst-copy_file_range-out-", &outfile));
-
-  /* Try to find a different directory from the default input/output
-     file.  */
+  outfd = create_temp_file ("tst-copy_file_range-out-", &outfile);
   {
-    struct stat64 instat;
-    xfstat (infd, &instat);
-    static const char *const candidates[] =
-      { NULL, "/var/tmp", "/dev/shm" };
-    for (const char *const *c = candidates; c < array_end (candidates); ++c)
-      {
-        const char *path = *c;
-        char *to_free = NULL;
-        if (path == NULL)
-          {
-            to_free = xreadlink ("/proc/self/exe");
-            path = dirname (to_free);
-          }
-
-        struct stat64 cstat;
-        xstat (path, &cstat);
-        if (cstat.st_dev == instat.st_dev)
-          {
-            free (to_free);
-            continue;
-          }
-
-        printf ("info: using alternate temporary files directory: %s\n", path);
-        xdevfile = xasprintf ("%s/tst-copy_file_range-xdev-XXXXXX", path);
-        free (to_free);
-        break;
-      }
-    if (xdevfile != NULL)
+    ssize_t ret = copy_file_range (infd, NULL, outfd, NULL, 0, 0);
+    if (ret != 0)
       {
-        int xdevfd = mkstemp (xdevfile);
-        if (xdevfd < 0)
-          FAIL_EXIT1 ("mkstemp (\"%s\"): %m", xdevfile);
-        struct stat64 xdevst;
-        xfstat (xdevfd, &xdevst);
-        TEST_VERIFY (xdevst.st_dev != instat.st_dev);
-        add_temp_file (xdevfile);
-        xclose (xdevfd);
+        if (errno == ENOSYS)
+          FAIL_UNSUPPORTED ("copy_file_range is not support on this system");
+        FAIL_EXIT1 ("copy_file_range probing call: %m");
       }
-    else
-      puts ("warning: no alternate directory on different file system found");
   }
   xclose (infd);
+  xclose (outfd);
 
   for (do_inoff = 0; do_inoff < 2; ++do_inoff)
     for (do_outoff = 0; do_outoff < 2; ++do_outoff)
@@ -827,7 +291,6 @@ do_test (void)
 
   free (infile);
   free (outfile);
-  free (xdevfile);
 
   return 0;
 }
diff --git a/libio/Makefile b/libio/Makefile
index 918a86bb74..2493a11ec2 100644
--- a/libio/Makefile
+++ b/libio/Makefile
@@ -63,11 +63,17 @@ tests = tst_swprintf tst_wprintf tst_swscanf tst_wscanf tst_getwc tst_putwc   \
 	bug-memstream1 bug-wmemstream1 \
 	tst-setvbuf1 tst-popen1 tst-fgetwc bug-wsetpos tst-fseek \
 	tst-fwrite-error tst-ftell-partial-wide tst-ftell-active-handler \
-	tst-ftell-append tst-fputws tst-bz22415
+	tst-ftell-append tst-fputws tst-bz22415 tst-wfile-sync
+
+tests-internal = tst-vtables tst-vtables-interposed
+
 ifeq (yes,$(build-shared))
 # Add test-fopenloc only if shared library is enabled since it depends on
 # shared localedata objects.
 tests += tst-fopenloc
+# Add tst-bz24228 only if shared library is enabled since it can never meet its
+# objective with static linking because the relevant code just is not there.
+tests += tst-bz24228
 endif
 test-srcs = test-freopen
 
@@ -148,11 +154,14 @@ CFLAGS-oldtmpfile.c += -fexceptions
 
 CFLAGS-tst_putwc.c += -DOBJPFX=\"$(objpfx)\"
 
+LDFLAGS-tst-bz24228 = -Wl,--version-script=tst-bz24228.map
+
 tst_wprintf2-ARGS = "Some Text"
 
 test-fmemopen-ENV = MALLOC_TRACE=$(objpfx)test-fmemopen.mtrace
 tst-fopenloc-ENV = MALLOC_TRACE=$(objpfx)tst-fopenloc.mtrace
 tst-bz22415-ENV = MALLOC_TRACE=$(objpfx)tst-bz22415.mtrace
+tst-bz24228-ENV = MALLOC_TRACE=$(objpfx)tst-bz24228.mtrace
 
 generated += test-fmemopen.mtrace test-fmemopen.check
 generated += tst-fopenloc.mtrace tst-fopenloc.check
@@ -161,6 +170,7 @@ generated += tst-bz22415.mtrace tst-bz22415.check
 aux	:= fileops genops stdfiles stdio strops
 
 ifeq ($(build-shared),yes)
+generated += tst-bz24228.mtrace tst-bz24228.check
 aux	+= oldfileops oldstdfiles
 endif
 
@@ -175,7 +185,8 @@ tests-special += $(objpfx)test-freopen.out $(objpfx)test-fmemopen-mem.out \
 ifeq (yes,$(build-shared))
 # Run tst-fopenloc-cmp.out and tst-openloc-mem.out only if shared
 # library is enabled since they depend on tst-fopenloc.out.
-tests-special += $(objpfx)tst-fopenloc-cmp.out $(objpfx)tst-fopenloc-mem.out
+tests-special += $(objpfx)tst-fopenloc-cmp.out $(objpfx)tst-fopenloc-mem.out \
+		 $(objpfx)tst-bz24228-mem.out
 endif
 endif
 
@@ -203,6 +214,7 @@ $(objpfx)tst-ungetwc1.out: $(gen-locales)
 $(objpfx)tst-ungetwc2.out: $(gen-locales)
 $(objpfx)tst-widetext.out: $(gen-locales)
 $(objpfx)tst_wprintf2.out: $(gen-locales)
+$(objpfx)tst-wfile-sync.out: $(gen-locales)
 endif
 
 $(objpfx)test-freopen.out: test-freopen.sh $(objpfx)test-freopen
@@ -226,3 +238,7 @@ $(objpfx)tst-fopenloc-mem.out: $(objpfx)tst-fopenloc.out
 $(objpfx)tst-bz22415-mem.out: $(objpfx)tst-bz22415.out
 	$(common-objpfx)malloc/mtrace $(objpfx)tst-bz22415.mtrace > $@; \
 	$(evaluate-test)
+
+$(objpfx)tst-bz24228-mem.out: $(objpfx)tst-bz24228.out
+	$(common-objpfx)malloc/mtrace $(objpfx)tst-bz24228.mtrace > $@; \
+	$(evaluate-test)
diff --git a/libio/genops.c b/libio/genops.c
index d6f8050669..32c7bfe2d0 100644
--- a/libio/genops.c
+++ b/libio/genops.c
@@ -852,9 +852,16 @@ _IO_unbuffer_all (void)
 
   for (fp = (_IO_FILE *) _IO_list_all; fp; fp = fp->_chain)
     {
+      int legacy = 0;
+
+#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)
+      if (__glibc_unlikely (_IO_vtable_offset (fp) != 0))
+	legacy = 1;
+#endif
+
       if (! (fp->_flags & _IO_UNBUFFERED)
 	  /* Iff stream is un-orientated, it wasn't used. */
-	  && fp->_mode != 0)
+	  && (legacy || fp->_mode != 0))
 	{
 #ifdef _IO_MTSAFE_IO
 	  int cnt;
@@ -868,7 +875,7 @@ _IO_unbuffer_all (void)
 	      __sched_yield ();
 #endif
 
-	  if (! dealloc_buffers && !(fp->_flags & _IO_USER_BUF))
+	  if (! legacy && ! dealloc_buffers && !(fp->_flags & _IO_USER_BUF))
 	    {
 	      fp->_flags |= _IO_USER_BUF;
 
@@ -879,7 +886,7 @@ _IO_unbuffer_all (void)
 
 	  _IO_SETBUF (fp, NULL, 0);
 
-	  if (fp->_mode > 0)
+	  if (! legacy && fp->_mode > 0)
 	    _IO_wsetb (fp, NULL, NULL, 0);
 
 #ifdef _IO_MTSAFE_IO
@@ -890,7 +897,8 @@ _IO_unbuffer_all (void)
 
       /* Make sure that never again the wide char functions can be
 	 used.  */
-      fp->_mode = -1;
+      if (! legacy)
+	fp->_mode = -1;
     }
 
 #ifdef _IO_MTSAFE_IO
diff --git a/libio/memstream.c b/libio/memstream.c
index d86befcc02..c5c7c2f6db 100644
--- a/libio/memstream.c
+++ b/libio/memstream.c
@@ -90,8 +90,8 @@ __open_memstream (char **bufloc, _IO_size_t *sizeloc)
   _IO_JUMPS_FILE_plus (&new_f->fp._sf._sbf) = &_IO_mem_jumps;
   _IO_str_init_static_internal (&new_f->fp._sf, buf, _IO_BUFSIZ, buf);
   new_f->fp._sf._sbf._f._flags &= ~_IO_USER_BUF;
-  new_f->fp._sf._s._allocate_buffer = (_IO_alloc_type) malloc;
-  new_f->fp._sf._s._free_buffer = (_IO_free_type) free;
+  new_f->fp._sf._s._allocate_buffer_unused = (_IO_alloc_type) malloc;
+  new_f->fp._sf._s._free_buffer_unused = (_IO_free_type) free;
 
   new_f->fp.bufloc = bufloc;
   new_f->fp.sizeloc = sizeloc;
diff --git a/libio/oldstdfiles.c b/libio/oldstdfiles.c
index 92d0f4a0d3..d6cbc9ffb7 100644
--- a/libio/oldstdfiles.c
+++ b/libio/oldstdfiles.c
@@ -87,6 +87,11 @@ _IO_check_libio (void)
 	stdout->_vtable_offset = stderr->_vtable_offset =
 	((int) sizeof (struct _IO_FILE)
 	 - (int) sizeof (struct _IO_FILE_complete));
+
+      if (_IO_stdin_.vtable != &_IO_old_file_jumps
+	  || _IO_stdout_.vtable != &_IO_old_file_jumps
+	  || _IO_stderr_.vtable != &_IO_old_file_jumps)
+	IO_set_accept_foreign_vtables (&_IO_vtable_check);
     }
 }
 
diff --git a/libio/strfile.h b/libio/strfile.h
index 68dfcbfe83..52a085e580 100644
--- a/libio/strfile.h
+++ b/libio/strfile.h
@@ -31,8 +31,11 @@ typedef void (*_IO_free_type) (void*);
 
 struct _IO_str_fields
 {
-  _IO_alloc_type _allocate_buffer;
-  _IO_free_type _free_buffer;
+  /* These members are preserved for ABI compatibility.  The glibc
+     implementation always calls malloc/free for user buffers if
+     _IO_USER_BUF or _IO_FLAGS2_USER_WBUF are not set.  */
+  _IO_alloc_type _allocate_buffer_unused;
+  _IO_free_type _free_buffer_unused;
 };
 
 /* This is needed for the Irix6 N32 ABI, which has a 64 bit off_t type,
@@ -52,10 +55,6 @@ typedef struct _IO_strfile_
   struct _IO_str_fields _s;
 } _IO_strfile;
 
-/* dynamic: set when the array object is allocated (or reallocated)  as
-   necessary to hold a character sequence that can change in length. */
-#define _IO_STR_DYNAMIC(FP) ((FP)->_s._allocate_buffer != (_IO_alloc_type)0)
-
 /* frozen: set when the program has requested that the array object not
    be altered, reallocated, or freed. */
 #define _IO_STR_FROZEN(FP) ((FP)->_f._IO_file_flags & _IO_USER_BUF)
diff --git a/libio/strops.c b/libio/strops.c
index ac995c830e..5fb38976e3 100644
--- a/libio/strops.c
+++ b/libio/strops.c
@@ -61,7 +61,7 @@ _IO_str_init_static_internal (_IO_strfile *sf, char *ptr, _IO_size_t size,
       fp->_IO_read_end = end;
     }
   /* A null _allocate_buffer function flags the strfile as being static. */
-  sf->_s._allocate_buffer = (_IO_alloc_type) 0;
+  sf->_s._allocate_buffer_unused = (_IO_alloc_type) 0;
 }
 
 void
@@ -103,8 +103,7 @@ _IO_str_overflow (_IO_FILE *fp, int c)
 	  _IO_size_t new_size = 2 * old_blen + 100;
 	  if (new_size < old_blen)
 	    return EOF;
-	  new_buf
-	    = (char *) (*((_IO_strfile *) fp)->_s._allocate_buffer) (new_size);
+	  new_buf = malloc (new_size);
 	  if (new_buf == NULL)
 	    {
 	      /*	  __ferror(fp) = 1; */
@@ -113,7 +112,7 @@ _IO_str_overflow (_IO_FILE *fp, int c)
 	  if (old_buf)
 	    {
 	      memcpy (new_buf, old_buf, old_blen);
-	      (*((_IO_strfile *) fp)->_s._free_buffer) (old_buf);
+	      free (old_buf);
 	      /* Make sure _IO_setb won't try to delete _IO_buf_base. */
 	      fp->_IO_buf_base = NULL;
 	    }
@@ -182,15 +181,14 @@ enlarge_userbuf (_IO_FILE *fp, _IO_off64_t offset, int reading)
 
   _IO_size_t newsize = offset + 100;
   char *oldbuf = fp->_IO_buf_base;
-  char *newbuf
-    = (char *) (*((_IO_strfile *) fp)->_s._allocate_buffer) (newsize);
+  char *newbuf = malloc (newsize);
   if (newbuf == NULL)
     return 1;
 
   if (oldbuf != NULL)
     {
       memcpy (newbuf, oldbuf, _IO_blen (fp));
-      (*((_IO_strfile *) fp)->_s._free_buffer) (oldbuf);
+      free (oldbuf);
       /* Make sure _IO_setb won't try to delete
 	 _IO_buf_base. */
       fp->_IO_buf_base = NULL;
@@ -346,7 +344,7 @@ void
 _IO_str_finish (_IO_FILE *fp, int dummy)
 {
   if (fp->_IO_buf_base && !(fp->_flags & _IO_USER_BUF))
-    (((_IO_strfile *) fp)->_s._free_buffer) (fp->_IO_buf_base);
+    free (fp->_IO_buf_base);
   fp->_IO_buf_base = NULL;
 
   _IO_default_finish (fp, 0);
diff --git a/libio/tst-bz24228.c b/libio/tst-bz24228.c
new file mode 100644
index 0000000000..6a74500d47
--- /dev/null
+++ b/libio/tst-bz24228.c
@@ -0,0 +1,29 @@
+/* BZ #24228 check for memory corruption in legacy libio
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <mcheck.h>
+#include <support/test-driver.h>
+
+static int
+do_test (void)
+{
+  mtrace ();
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/libio/tst-bz24228.map b/libio/tst-bz24228.map
new file mode 100644
index 0000000000..4383e0817d
--- /dev/null
+++ b/libio/tst-bz24228.map
@@ -0,0 +1,5 @@
+# Hide the symbol from libc.so.6 to switch to the libio/oldfileops.c
+# implementation when it is available for the architecture.
+{
+  local: _IO_stdin_used;
+};
diff --git a/libio/tst-vtables-common.c b/libio/tst-vtables-common.c
new file mode 100644
index 0000000000..dc8d89c195
--- /dev/null
+++ b/libio/tst-vtables-common.c
@@ -0,0 +1,511 @@
+/* Test for libio vtables and their validation.  Common code.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This test provides some coverage for how various stdio functions
+   use the vtables in FILE * objects.  The focus is mostly on which
+   functions call which methods, not so much on validating data
+   processing.  An initial series of tests check that custom vtables
+   do not work without activation through _IO_init.
+
+   Note: libio vtables are deprecated feature.  Do not use this test
+   as a documentation source for writing custom vtables.  See
+   fopencookie for a different way of creating custom stdio
+   streams.  */
+
+#include <stdbool.h>
+#include <string.h>
+#include <support/capture_subprocess.h>
+#include <support/check.h>
+#include <support/namespace.h>
+#include <support/support.h>
+#include <support/test-driver.h>
+#include <support/xunistd.h>
+
+/* Data shared between the test subprocess and the test driver in the
+   parent.  Note that *shared is reset at the start of the check_call
+   function.  */
+struct shared
+{
+  /* Expected file pointer for method calls.  */
+  FILE *fp;
+
+  /* If true, assume that a call to _IO_init is needed to enable
+     custom vtables.  */
+  bool initially_disabled;
+
+  /* Requested return value for the methods which have one.  */
+  int return_value;
+
+  /* A value (usually a character) recorded by some of the methods
+     below.  */
+  int value;
+
+  /* Likewise, for some data.  */
+  char buffer[16];
+  size_t buffer_length;
+
+  /* Total number of method calls.  */
+  unsigned int calls;
+
+  /* Individual method call counts.  */
+  unsigned int calls_finish;
+  unsigned int calls_overflow;
+  unsigned int calls_underflow;
+  unsigned int calls_uflow;
+  unsigned int calls_pbackfail;
+  unsigned int calls_xsputn;
+  unsigned int calls_xsgetn;
+  unsigned int calls_seekoff;
+  unsigned int calls_seekpos;
+  unsigned int calls_setbuf;
+  unsigned int calls_sync;
+  unsigned int calls_doallocate;
+  unsigned int calls_read;
+  unsigned int calls_write;
+  unsigned int calls_seek;
+  unsigned int calls_close;
+  unsigned int calls_stat;
+  unsigned int calls_showmanyc;
+  unsigned int calls_imbue;
+} *shared;
+
+/* Method implementations which increment the counters in *shared.  */
+
+static void
+log_method (FILE *fp, const char *name)
+{
+  if (test_verbose > 0)
+    printf ("info: %s (%p) called\n", name, fp);
+}
+
+static void
+method_finish (FILE *fp, int dummy)
+{
+  log_method (fp, __func__);
+  TEST_VERIFY (fp == shared->fp);
+  ++shared->calls;
+  ++shared->calls_finish;
+}
+
+static int
+method_overflow (FILE *fp, int ch)
+{
+  log_method (fp, __func__);
+  TEST_VERIFY (fp == shared->fp);
+  ++shared->calls;
+  ++shared->calls_overflow;
+  shared->value = ch;
+  return shared->return_value;
+}
+
+static int
+method_underflow (FILE *fp)
+{
+  log_method (fp, __func__);
+  TEST_VERIFY (fp == shared->fp);
+  ++shared->calls;
+  ++shared->calls_underflow;
+  return shared->return_value;
+}
+
+static int
+method_uflow (FILE *fp)
+{
+  log_method (fp, __func__);
+  TEST_VERIFY (fp == shared->fp);
+  ++shared->calls;
+  ++shared->calls_uflow;
+  return shared->return_value;
+}
+
+static int
+method_pbackfail (FILE *fp, int ch)
+{
+  log_method (fp, __func__);
+  TEST_VERIFY (fp == shared->fp);
+  ++shared->calls;
+  ++shared->calls_pbackfail;
+  shared->value = ch;
+  return shared->return_value;
+}
+
+static size_t
+method_xsputn (FILE *fp, const void *data, size_t n)
+{
+  log_method (fp, __func__);
+  TEST_VERIFY (fp == shared->fp);
+  ++shared->calls;
+  ++shared->calls_xsputn;
+
+  size_t to_copy = n;
+  if (n > sizeof (shared->buffer))
+    to_copy = sizeof (shared->buffer);
+  memcpy (shared->buffer, data, to_copy);
+  shared->buffer_length = to_copy;
+  return to_copy;
+}
+
+static size_t
+method_xsgetn (FILE *fp, void *data, size_t n)
+{
+  log_method (fp, __func__);
+  TEST_VERIFY (fp == shared->fp);
+  ++shared->calls;
+  ++shared->calls_xsgetn;
+  return 0;
+}
+
+static off64_t
+method_seekoff (FILE *fp, off64_t offset, int dir, int mode)
+{
+  log_method (fp, __func__);
+  TEST_VERIFY (fp == shared->fp);
+  ++shared->calls;
+  ++shared->calls_seekoff;
+  return shared->return_value;
+}
+
+static off64_t
+method_seekpos (FILE *fp, off64_t offset, int mode)
+{
+  log_method (fp, __func__);
+  TEST_VERIFY (fp == shared->fp);
+  ++shared->calls;
+  ++shared->calls_seekpos;
+  return shared->return_value;
+}
+
+static FILE *
+method_setbuf (FILE *fp, char *buffer, ssize_t length)
+{
+  log_method (fp, __func__);
+  TEST_VERIFY (fp == shared->fp);
+  ++shared->calls;
+  ++shared->calls_setbuf;
+  return fp;
+}
+
+static int
+method_sync (FILE *fp)
+{
+  log_method (fp, __func__);
+  TEST_VERIFY (fp == shared->fp);
+  ++shared->calls;
+  ++shared->calls_sync;
+  return shared->return_value;
+}
+
+static int
+method_doallocate (FILE *fp)
+{
+  log_method (fp, __func__);
+  TEST_VERIFY (fp == shared->fp);
+  ++shared->calls;
+  ++shared->calls_doallocate;
+  return shared->return_value;
+}
+
+static ssize_t
+method_read (FILE *fp, void *data, ssize_t length)
+{
+  log_method (fp, __func__);
+  TEST_VERIFY (fp == shared->fp);
+  ++shared->calls;
+  ++shared->calls_read;
+  return shared->return_value;
+}
+
+static ssize_t
+method_write (FILE *fp, const void *data, ssize_t length)
+{
+  log_method (fp, __func__);
+  TEST_VERIFY (fp == shared->fp);
+  ++shared->calls;
+  ++shared->calls_write;
+  return shared->return_value;
+}
+
+static off64_t
+method_seek (FILE *fp, off64_t offset, int mode)
+{
+  log_method (fp, __func__);
+  TEST_VERIFY (fp == shared->fp);
+  ++shared->calls;
+  ++shared->calls_seek;
+  return shared->return_value;
+}
+
+static int
+method_close (FILE *fp)
+{
+  log_method (fp, __func__);
+  TEST_VERIFY (fp == shared->fp);
+  ++shared->calls;
+  ++shared->calls_close;
+  return shared->return_value;
+}
+
+static int
+method_stat (FILE *fp, void *buffer)
+{
+  log_method (fp, __func__);
+  TEST_VERIFY (fp == shared->fp);
+  ++shared->calls;
+  ++shared->calls_stat;
+  return shared->return_value;
+}
+
+static int
+method_showmanyc (FILE *fp)
+{
+  log_method (fp, __func__);
+  TEST_VERIFY (fp == shared->fp);
+  ++shared->calls;
+  ++shared->calls_showmanyc;
+  return shared->return_value;
+}
+
+static void
+method_imbue (FILE *fp, void *locale)
+{
+  log_method (fp, __func__);
+  TEST_VERIFY (fp == shared->fp);
+  ++shared->calls;
+  ++shared->calls_imbue;
+}
+
+/* Our custom vtable.  */
+
+static const struct _IO_jump_t jumps =
+{
+  JUMP_INIT_DUMMY,
+  JUMP_INIT (finish, method_finish),
+  JUMP_INIT (overflow, method_overflow),
+  JUMP_INIT (underflow, method_underflow),
+  JUMP_INIT (uflow, method_uflow),
+  JUMP_INIT (pbackfail, method_pbackfail),
+  JUMP_INIT (xsputn, method_xsputn),
+  JUMP_INIT (xsgetn, method_xsgetn),
+  JUMP_INIT (seekoff, method_seekoff),
+  JUMP_INIT (seekpos, method_seekpos),
+  JUMP_INIT (setbuf, method_setbuf),
+  JUMP_INIT (sync, method_sync),
+  JUMP_INIT (doallocate, method_doallocate),
+  JUMP_INIT (read, method_read),
+  JUMP_INIT (write, method_write),
+  JUMP_INIT (seek, method_seek),
+  JUMP_INIT (close, method_close),
+  JUMP_INIT (stat, method_stat),
+  JUMP_INIT (showmanyc, method_showmanyc),
+  JUMP_INIT (imbue, method_imbue)
+};
+
+/* Our file implementation.  */
+
+struct my_file
+{
+  FILE f;
+  const struct _IO_jump_t *vtable;
+};
+
+struct my_file
+my_file_create (void)
+{
+  return (struct my_file)
+    {
+      /* Disable locking, so that we do not have to set up a lock
+         pointer.  */
+      .f._flags =  _IO_USER_LOCK,
+
+      /* Copy the offset from the an initialized handle, instead of
+         figuring it out from scratch.  */
+      .f._vtable_offset = stdin->_vtable_offset,
+
+      .vtable = &jumps,
+    };
+}
+
+/* Initial tests which do not enable vtable compatibility.  */
+
+/* Inhibit GCC optimization of fprintf.  */
+typedef int (*fprintf_type) (FILE *, const char *, ...);
+static const volatile fprintf_type fprintf_ptr = &fprintf;
+
+static void
+without_compatibility_fprintf (void *closure)
+{
+  /* This call should abort.  */
+  fprintf_ptr (shared->fp, " ");
+  _exit (1);
+}
+
+static void
+without_compatibility_fputc (void *closure)
+{
+  /* This call should abort.  */
+  fputc (' ', shared->fp);
+  _exit (1);
+}
+
+static void
+without_compatibility_fgetc (void *closure)
+{
+  /* This call should abort.  */
+  fgetc (shared->fp);
+  _exit (1);
+}
+
+static void
+without_compatibility_fflush (void *closure)
+{
+  /* This call should abort.  */
+  fflush (shared->fp);
+  _exit (1);
+}
+
+/* Exit status after abnormal termination.  */
+static int termination_status;
+
+static void
+init_termination_status (void)
+{
+  pid_t pid = xfork ();
+  if (pid == 0)
+    abort ();
+  xwaitpid (pid, &termination_status, 0);
+
+  TEST_VERIFY (WIFSIGNALED (termination_status));
+  TEST_COMPARE (WTERMSIG (termination_status), SIGABRT);
+}
+
+static void
+check_for_termination (const char *name, void (*callback) (void *))
+{
+  struct my_file file = my_file_create ();
+  shared->fp = &file.f;
+  shared->return_value = -1;
+  shared->calls = 0;
+  struct support_capture_subprocess proc
+    = support_capture_subprocess (callback, NULL);
+  support_capture_subprocess_check (&proc, name, termination_status,
+                                    sc_allow_stderr);
+  const char *message
+    = "Fatal error: glibc detected an invalid stdio handle\n";
+  TEST_COMPARE_BLOB (proc.err.buffer, proc.err.length,
+                     message, strlen (message));
+  TEST_COMPARE (shared->calls, 0);
+  support_capture_subprocess_free (&proc);
+}
+
+/* The test with vtable validation disabled.  */
+
+/* This function does not have a prototype in libioP.h to prevent
+   accidental use from within the library (which would disable vtable
+   verification).  */
+void _IO_init (FILE *fp, int flags);
+
+static void
+with_compatibility_fprintf (void *closure)
+{
+  TEST_COMPARE (fprintf_ptr (shared->fp, "A%sCD", "B"), 4);
+  TEST_COMPARE (shared->calls, 3);
+  TEST_COMPARE (shared->calls_xsputn, 3);
+  TEST_COMPARE_BLOB (shared->buffer, shared->buffer_length,
+                     "CD", 2);
+}
+
+static void
+with_compatibility_fputc (void *closure)
+{
+  shared->return_value = '@';
+  TEST_COMPARE (fputc ('@', shared->fp), '@');
+  TEST_COMPARE (shared->calls, 1);
+  TEST_COMPARE (shared->calls_overflow, 1);
+  TEST_COMPARE (shared->value, '@');
+}
+
+static void
+with_compatibility_fgetc (void *closure)
+{
+  shared->return_value = 'X';
+  TEST_COMPARE (fgetc (shared->fp), 'X');
+  TEST_COMPARE (shared->calls, 1);
+  TEST_COMPARE (shared->calls_uflow, 1);
+}
+
+static void
+with_compatibility_fflush (void *closure)
+{
+  TEST_COMPARE (fflush (shared->fp), 0);
+  TEST_COMPARE (shared->calls, 1);
+  TEST_COMPARE (shared->calls_sync, 1);
+}
+
+/* Call CALLBACK in a subprocess, after setting up a custom file
+   object and updating shared->fp.  */
+static void
+check_call (const char *name, void (*callback) (void *),
+            bool initially_disabled)
+{
+  *shared = (struct shared)
+    {
+     .initially_disabled = initially_disabled,
+    };
+
+  /* Set up a custom file object.  */
+  struct my_file file = my_file_create ();
+  shared->fp = &file.f;
+  if (shared->initially_disabled)
+    _IO_init (shared->fp, file.f._flags);
+
+  if (test_verbose > 0)
+    printf ("info: calling test %s\n", name);
+  support_isolate_in_subprocess (callback, NULL);
+}
+
+/* Run the tests.  INITIALLY_DISABLED indicates whether custom vtables
+   are disabled when the test starts.  */
+static int
+run_tests (bool initially_disabled)
+{
+  /* The test relies on fatal error messages being printed to standard
+     error.  */
+  setenv ("LIBC_FATAL_STDERR_", "1", 1);
+
+  shared = support_shared_allocate (sizeof (*shared));
+  shared->initially_disabled = initially_disabled;
+  init_termination_status ();
+
+  if (initially_disabled)
+    {
+      check_for_termination ("fprintf", without_compatibility_fprintf);
+      check_for_termination ("fputc", without_compatibility_fputc);
+      check_for_termination ("fgetc", without_compatibility_fgetc);
+      check_for_termination ("fflush", without_compatibility_fflush);
+    }
+
+  check_call ("fprintf", with_compatibility_fprintf, initially_disabled);
+  check_call ("fputc", with_compatibility_fputc, initially_disabled);
+  check_call ("fgetc", with_compatibility_fgetc, initially_disabled);
+  check_call ("fflush", with_compatibility_fflush, initially_disabled);
+
+  support_shared_free (shared);
+  shared = NULL;
+
+  return 0;
+}
diff --git a/libio/tst-vtables-interposed.c b/libio/tst-vtables-interposed.c
new file mode 100644
index 0000000000..c8f4e8c7c3
--- /dev/null
+++ b/libio/tst-vtables-interposed.c
@@ -0,0 +1,37 @@
+/* Test for libio vtables and their validation.  Enabled through interposition.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Provide an interposed definition of the standard file handles with
+   our own vtable.  stdout/stdin/stderr will not work as a result, but
+   a succesful test does not print anything, so this is fine.  */
+static const struct _IO_jump_t jumps;
+#define _IO_file_jumps jumps
+#include "stdfiles.c"
+
+#include "tst-vtables-common.c"
+
+static int
+do_test (void)
+{
+  return run_tests (false);
+}
+
+/* Calling setvbuf in the test driver is not supported with our
+   interposed file handles.  */
+#define TEST_NO_SETVBUF
+#include <support/test-driver.c>
diff --git a/libio/tst-vtables.c b/libio/tst-vtables.c
new file mode 100644
index 0000000000..f16acf5d23
--- /dev/null
+++ b/libio/tst-vtables.c
@@ -0,0 +1,29 @@
+/* Test for libio vtables and their validation.  Initially disabled case.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "libioP.h"
+
+#include "tst-vtables-common.c"
+
+static int
+do_test (void)
+{
+  return run_tests (true);
+}
+
+#include <support/test-driver.c>
diff --git a/libio/tst-wfile-sync.c b/libio/tst-wfile-sync.c
new file mode 100644
index 0000000000..618682064d
--- /dev/null
+++ b/libio/tst-wfile-sync.c
@@ -0,0 +1,39 @@
+/* Test that _IO_wfile_sync does not crash (bug 20568).
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <locale.h>
+#include <stdio.h>
+#include <wchar.h>
+#include <support/check.h>
+#include <support/xunistd.h>
+
+static int
+do_test (void)
+{
+  TEST_VERIFY_EXIT (setlocale (LC_ALL, "de_DE.UTF-8") != NULL);
+  /* Fill the stdio buffer and advance the read pointer.  */
+  TEST_VERIFY_EXIT (fgetwc (stdin) != WEOF);
+  /* This calls _IO_wfile_sync, it should not crash.  */
+  TEST_VERIFY_EXIT (setvbuf (stdin, NULL, _IONBF, 0) == 0);
+  /* Verify that the external file offset has been synchronized.  */
+  TEST_COMPARE (xlseek (0, 0, SEEK_CUR), 1);
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/libio/tst-wfile-sync.input b/libio/tst-wfile-sync.input
new file mode 100644
index 0000000000..12d0958f7a
--- /dev/null
+++ b/libio/tst-wfile-sync.input
@@ -0,0 +1 @@
+This is a test of _IO_wfile_sync.
diff --git a/libio/vasprintf.c b/libio/vasprintf.c
index 390a63d124..0bb217e46e 100644
--- a/libio/vasprintf.c
+++ b/libio/vasprintf.c
@@ -54,8 +54,8 @@ _IO_vasprintf (char **result_ptr, const char *format, _IO_va_list args)
   _IO_JUMPS (&sf._sbf) = &_IO_str_jumps;
   _IO_str_init_static_internal (&sf, string, init_string_size, string);
   sf._sbf._f._flags &= ~_IO_USER_BUF;
-  sf._s._allocate_buffer = (_IO_alloc_type) malloc;
-  sf._s._free_buffer = (_IO_free_type) free;
+  sf._s._allocate_buffer_unused = (_IO_alloc_type) malloc;
+  sf._s._free_buffer_unused = (_IO_free_type) free;
   ret = _IO_vfprintf (&sf._sbf._f, format, args);
   if (ret < 0)
     {
diff --git a/libio/vtables.c b/libio/vtables.c
index 9fd4ccf642..9df75668c8 100644
--- a/libio/vtables.c
+++ b/libio/vtables.c
@@ -71,3 +71,19 @@ _IO_vtable_check (void)
 
   __libc_fatal ("Fatal error: glibc detected an invalid stdio handle\n");
 }
+
+/* Some variants of libstdc++ interpose _IO_2_1_stdin_ etc. and
+   install their own vtables directly, without calling _IO_init or
+   other functions.  Detect this by looking at the vtables values
+   during startup, and disable vtable validation in this case.  */
+#ifdef SHARED
+__attribute__ ((constructor))
+static void
+check_stdfiles_vtables (void)
+{
+  if (_IO_2_1_stdin_.vtable != &_IO_file_jumps
+      || _IO_2_1_stdout_.vtable != &_IO_file_jumps
+      || _IO_2_1_stderr_.vtable != &_IO_file_jumps)
+    IO_set_accept_foreign_vtables (&_IO_vtable_check);
+}
+#endif
diff --git a/libio/wfileops.c b/libio/wfileops.c
index 2488821d54..dd010b4394 100644
--- a/libio/wfileops.c
+++ b/libio/wfileops.c
@@ -509,11 +509,12 @@ _IO_wfile_sync (_IO_FILE *fp)
 	     generate the wide characters up to the current reading
 	     position.  */
 	  int nread;
-
+	  size_t wnread = (fp->_wide_data->_IO_read_ptr
+			   - fp->_wide_data->_IO_read_base);
 	  fp->_wide_data->_IO_state = fp->_wide_data->_IO_last_state;
 	  nread = (*cv->__codecvt_do_length) (cv, &fp->_wide_data->_IO_state,
 					      fp->_IO_read_base,
-					      fp->_IO_read_end, delta);
+					      fp->_IO_read_end, wnread);
 	  fp->_IO_read_ptr = fp->_IO_read_base + nread;
 	  delta = -(fp->_IO_read_end - fp->_IO_read_base - nread);
 	}
diff --git a/libio/wmemstream.c b/libio/wmemstream.c
index c962071d26..f4c6e75246 100644
--- a/libio/wmemstream.c
+++ b/libio/wmemstream.c
@@ -92,8 +92,8 @@ open_wmemstream (wchar_t **bufloc, _IO_size_t *sizeloc)
   _IO_wstr_init_static (&new_f->fp._sf._sbf._f, buf,
 			_IO_BUFSIZ / sizeof (wchar_t), buf);
   new_f->fp._sf._sbf._f._flags2 &= ~_IO_FLAGS2_USER_WBUF;
-  new_f->fp._sf._s._allocate_buffer = (_IO_alloc_type) malloc;
-  new_f->fp._sf._s._free_buffer = (_IO_free_type) free;
+  new_f->fp._sf._s._allocate_buffer_unused = (_IO_alloc_type) malloc;
+  new_f->fp._sf._s._free_buffer_unused = (_IO_free_type) free;
 
   new_f->fp.bufloc = bufloc;
   new_f->fp.sizeloc = sizeloc;
diff --git a/libio/wstrops.c b/libio/wstrops.c
index a3374a7b15..0839a70bfb 100644
--- a/libio/wstrops.c
+++ b/libio/wstrops.c
@@ -63,7 +63,7 @@ _IO_wstr_init_static (_IO_FILE *fp, wchar_t *ptr, _IO_size_t size,
       fp->_wide_data->_IO_read_end = end;
     }
   /* A null _allocate_buffer function flags the strfile as being static. */
-  (((_IO_strfile *) fp)->_s._allocate_buffer) = (_IO_alloc_type)0;
+  (((_IO_strfile *) fp)->_s._allocate_buffer_unused) = (_IO_alloc_type)0;
 }
 
 _IO_wint_t
@@ -95,9 +95,7 @@ _IO_wstr_overflow (_IO_FILE *fp, _IO_wint_t c)
 	      || __glibc_unlikely (new_size > SIZE_MAX / sizeof (wchar_t)))
 	    return EOF;
 
-	  new_buf
-	    = (wchar_t *) (*((_IO_strfile *) fp)->_s._allocate_buffer) (new_size
-									* sizeof (wchar_t));
+	  new_buf = malloc (new_size * sizeof (wchar_t));
 	  if (new_buf == NULL)
 	    {
 	      /*	  __ferror(fp) = 1; */
@@ -106,7 +104,7 @@ _IO_wstr_overflow (_IO_FILE *fp, _IO_wint_t c)
 	  if (old_buf)
 	    {
 	      __wmemcpy (new_buf, old_buf, old_wblen);
-	      (*((_IO_strfile *) fp)->_s._free_buffer) (old_buf);
+	      free (old_buf);
 	      /* Make sure _IO_setb won't try to delete _IO_buf_base. */
 	      fp->_wide_data->_IO_buf_base = NULL;
 	    }
@@ -186,16 +184,14 @@ enlarge_userbuf (_IO_FILE *fp, _IO_off64_t offset, int reading)
     return 1;
 
   wchar_t *oldbuf = wd->_IO_buf_base;
-  wchar_t *newbuf
-    = (wchar_t *) (*((_IO_strfile *) fp)->_s._allocate_buffer) (newsize
-								* sizeof (wchar_t));
+  wchar_t *newbuf = malloc (newsize * sizeof (wchar_t));
   if (newbuf == NULL)
     return 1;
 
   if (oldbuf != NULL)
     {
       __wmemcpy (newbuf, oldbuf, _IO_wblen (fp));
-      (*((_IO_strfile *) fp)->_s._free_buffer) (oldbuf);
+      free (oldbuf);
       /* Make sure _IO_setb won't try to delete
 	 _IO_buf_base. */
       wd->_IO_buf_base = NULL;
@@ -357,7 +353,7 @@ void
 _IO_wstr_finish (_IO_FILE *fp, int dummy)
 {
   if (fp->_wide_data->_IO_buf_base && !(fp->_flags2 & _IO_FLAGS2_USER_WBUF))
-    (((_IO_strfile *) fp)->_s._free_buffer) (fp->_wide_data->_IO_buf_base);
+    free (fp->_wide_data->_IO_buf_base);
   fp->_wide_data->_IO_buf_base = NULL;
 
   _IO_wdefault_finish (fp, 0);
diff --git a/localedata/Makefile b/localedata/Makefile
index 34877c0713..b91d57f182 100644
--- a/localedata/Makefile
+++ b/localedata/Makefile
@@ -78,7 +78,7 @@ tests = $(locale_test_suite) tst-digits tst-setlocale bug-iconv-trans \
 	tst-leaks tst-mbswcs1 tst-mbswcs2 tst-mbswcs3 tst-mbswcs4 tst-mbswcs5 \
 	tst-mbswcs6 tst-xlocale1 tst-xlocale2 bug-usesetlocale \
 	tst-strfmon1 tst-sscanf bug-setlocale1 tst-setlocale2 tst-setlocale3 \
-	tst-wctype
+	tst-wctype tst-iconv-math-trans
 tests-static = bug-setlocale1-static
 tests += $(tests-static)
 ifeq (yes,$(build-shared))
@@ -113,6 +113,8 @@ LOCALES := de_DE.ISO-8859-1 de_DE.UTF-8 en_US.ANSI_X3.4-1968 \
 	   pl_PL.UTF-8 fr_CA.UTF-8 hr_HR.UTF-8 bs_BA.UTF-8 sr_RS.UTF-8 \
 	   is_IS.UTF-8 et_EE.UTF-8 hsb_DE.UTF-8 lt_LT.UTF-8
 include ../gen-locales.mk
+
+$(objpfx)tst-iconv-math-trans.out: $(gen-locales)
 endif
 
 include ../Rules
diff --git a/localedata/locales/ca_ES b/localedata/locales/ca_ES
index 914c066dab..f0d744d537 100644
--- a/localedata/locales/ca_ES
+++ b/localedata/locales/ca_ES
@@ -106,36 +106,67 @@ grouping             0;0
 END LC_NUMERIC
 
 LC_TIME
-abday   "dg";"dl";"dt";"dc";"dj";"dv";"ds"
-day     "diumenge";/
-        "dilluns";/
-        "dimarts";/
-        "dimecres";/
-        "dijous";/
-        "divendres";/
-        "dissabte"
-abmon   "gen";"feb";/
-        "mar";"abr";/
-        "mai";"jun";/
-        "jul";"ago";/
-        "set";"oct";/
-        "nov";"des"
-mon     "gener";/
-        "febrer";/
-        "mar<U00E7>";/
-        "abril";/
-        "maig";/
-        "juny";/
-        "juliol";/
-        "agost";/
-        "setembre";/
-        "octubre";/
-        "novembre";/
-        "desembre"
-d_t_fmt "%a %d %b %Y %T %Z"
-d_fmt   "%d//%m//%y"
-t_fmt   "%T"
-am_pm   "";""
+abday      "dg.";"dl.";"dt.";"dc.";"dj.";"dv.";"ds."
+day        "diumenge";/
+           "dilluns";/
+           "dimarts";/
+           "dimecres";/
+           "dijous";/
+           "divendres";/
+           "dissabte"
+ab_alt_mon "gen.";/
+           "febr.";/
+           "mar<U00E7>";/
+           "abr.";/
+           "maig";/
+           "juny";/
+           "jul.";/
+           "ag.";/
+           "set.";/
+           "oct.";/
+           "nov.";/
+           "des."
+abmon      "de gen.";/
+           "de febr.";/
+           "de mar<U00E7>";/
+           "d<U2019>abr.";/
+           "de maig";/
+           "de juny";/
+           "de jul.";/
+           "d<U2019>ag.";/
+           "de set.";/
+           "d<U2019>oct.";/
+           "de nov.";/
+           "de des."
+alt_mon    "gener";/
+           "febrer";/
+           "mar<U00E7>";/
+           "abril";/
+           "maig";/
+           "juny";/
+           "juliol";/
+           "agost";/
+           "setembre";/
+           "octubre";/
+           "novembre";/
+           "desembre"
+mon        "de gener";/
+           "de febrer";/
+           "de mar<U00E7>";/
+           "d<U2019>abril";/
+           "de maig";/
+           "de juny";/
+           "de juliol";/
+           "d<U2019>agost";/
+           "de setembre";/
+           "d<U2019>octubre";/
+           "de novembre";/
+           "de desembre"
+d_t_fmt    "%A, %-d %B de %Y, %T %Z"
+d_fmt      "%-d//%-m//%y"
+t_fmt      "%T"
+am_pm      "a. m.";/
+           "p. m."
 t_fmt_ampm ""
 week 7;19971130;4
 first_weekday 2
@@ -146,9 +177,9 @@ copy "i18n"
 END LC_PAPER
 
 LC_TELEPHONE
-tel_int_fmt    "+%c %a %l"
-int_prefix     "34"
-int_select     "00"
+tel_int_fmt  "+%c %a %l"
+int_prefix   "34"
+int_select   "00"
 END LC_TELEPHONE
 
 LC_MEASUREMENT
@@ -156,19 +187,19 @@ copy "i18n"
 END LC_MEASUREMENT
 
 LC_NAME
-name_fmt    "%d%t%g%t%m%t%f"
+name_fmt     "%d%t%g%t%m%t%f"
 END LC_NAME
 
 LC_ADDRESS
-postal_fmt    "%f%N%a%N%d%N%b%N%s %h %e %r%N%z %T%N%c%N"
+postal_fmt   "%f%N%a%N%d%N%b%N%s %h %e %r%N%z %T%N%c%N"
 country_name "Espanya"
-country_ab2 "ES"
-country_ab3 "ESP"
-country_num 724
-country_car    "E"
+country_ab2  "ES"
+country_ab3  "ESP"
+country_num  724
+country_car  "E"
 % català
 lang_name    "catal<U00E0>"
 lang_ab      "ca"
 lang_term    "cat"
-lang_lib    "cat"
+lang_lib     "cat"
 END LC_ADDRESS
diff --git a/localedata/locales/cs_CZ b/localedata/locales/cs_CZ
index f80d3e1b37..8f4c69e493 100644
--- a/localedata/locales/cs_CZ
+++ b/localedata/locales/cs_CZ
@@ -272,7 +272,7 @@ day		"Ned<U011B>le";/
 		"P<U00E1>tek";/
 		"Sobota"
 
-mon		"leden";/
+alt_mon		"leden";/
 		"<U00FA>nor";/
 		"b<U0159>ezen";/
 		"duben";/
@@ -334,6 +334,19 @@ abmon		"led";/
 %		"Nov";/
 %		"Dec"
 
+mon		"ledna";/
+		"<U00FA>nora";/
+		"b<U0159>ezna";/
+		"dubna";/
+		"kv<U011B>tna";/
+		"<U010D>ervna";/
+		"<U010D>ervence";/
+		"srpna";/
+		"z<U00E1><U0159><U00ED>";/
+		"<U0159><U00ED>jna";/
+		"listopadu";/
+		"prosince"
+
 week		7;19971130;4
 first_weekday	2
 
diff --git a/localedata/locales/el_CY b/localedata/locales/el_CY
index f27a74bb76..28055f335b 100644
--- a/localedata/locales/el_CY
+++ b/localedata/locales/el_CY
@@ -72,12 +72,18 @@ day     "<U039A><U03C5><U03C1><U03B9><U03B1><U03BA><U03AE>";/
         "<U03A0><U03AD><U03BC><U03C0><U03C4><U03B7>";/
         "<U03A0><U03B1><U03C1><U03B1><U03C3><U03BA><U03B5><U03C5><U03AE>";/
         "<U03A3><U03AC><U03B2><U03B2><U03B1><U03C4><U03BF>"
-abmon   "<U0399><U03B1><U03BD>";"<U03A6><U03B5><U03B2>";/
+ab_alt_mon "<U0399><U03B1><U03BD>";"<U03A6><U03B5><U03B2>";/
         "<U039C><U03AC><U03C1>";"<U0391><U03C0><U03C1>";/
         "<U039C><U03AC><U03B9>";"<U0399><U03BF><U03CD><U03BD>";/
         "<U0399><U03BF><U03CD><U03BB>";"<U0391><U03CD><U03B3>";/
         "<U03A3><U03B5><U03C0>";"<U039F><U03BA><U03C4>";/
         "<U039D><U03BF><U03AD>";"<U0394><U03B5><U03BA>"
+abmon   "<U0399><U03B1><U03BD>";"<U03A6><U03B5><U03B2>";/
+        "<U039C><U03B1><U03C1>";"<U0391><U03C0><U03C1>";/
+        "<U039C><U03B1><U0390>";"<U0399><U03BF><U03C5><U03BD>";/
+        "<U0399><U03BF><U03C5><U03BB>";"<U0391><U03C5><U03B3>";/
+        "<U03A3><U03B5><U03C0>";"<U039F><U03BA><U03C4>";/
+        "<U039D><U03BF><U03B5>";"<U0394><U03B5><U03BA>"
 alt_mon "<U0399><U03B1><U03BD><U03BF><U03C5><U03AC><U03C1><U03B9><U03BF><U03C2>";/
         "<U03A6><U03B5><U03B2><U03C1><U03BF><U03C5><U03AC><U03C1><U03B9><U03BF><U03C2>";/
         "<U039C><U03AC><U03C1><U03C4><U03B9><U03BF><U03C2>";/
diff --git a/localedata/locales/el_GR b/localedata/locales/el_GR
index a82ef8c6d9..7362492fbd 100644
--- a/localedata/locales/el_GR
+++ b/localedata/locales/el_GR
@@ -104,12 +104,18 @@ day     "<U039A><U03C5><U03C1><U03B9><U03B1><U03BA><U03AE>";/
         "<U03A0><U03AD><U03BC><U03C0><U03C4><U03B7>";/
         "<U03A0><U03B1><U03C1><U03B1><U03C3><U03BA><U03B5><U03C5><U03AE>";/
         "<U03A3><U03AC><U03B2><U03B2><U03B1><U03C4><U03BF>"
-abmon   "<U0399><U03B1><U03BD>";"<U03A6><U03B5><U03B2>";/
+ab_alt_mon "<U0399><U03B1><U03BD>";"<U03A6><U03B5><U03B2>";/
         "<U039C><U03AC><U03C1>";"<U0391><U03C0><U03C1>";/
         "<U039C><U03AC><U03B9>";"<U0399><U03BF><U03CD><U03BD>";/
         "<U0399><U03BF><U03CD><U03BB>";"<U0391><U03CD><U03B3>";/
         "<U03A3><U03B5><U03C0>";"<U039F><U03BA><U03C4>";/
         "<U039D><U03BF><U03AD>";"<U0394><U03B5><U03BA>"
+abmon   "<U0399><U03B1><U03BD>";"<U03A6><U03B5><U03B2>";/
+        "<U039C><U03B1><U03C1>";"<U0391><U03C0><U03C1>";/
+        "<U039C><U03B1><U0390>";"<U0399><U03BF><U03C5><U03BD>";/
+        "<U0399><U03BF><U03C5><U03BB>";"<U0391><U03C5><U03B3>";/
+        "<U03A3><U03B5><U03C0>";"<U039F><U03BA><U03C4>";/
+        "<U039D><U03BF><U03B5>";"<U0394><U03B5><U03BA>"
 alt_mon "<U0399><U03B1><U03BD><U03BF><U03C5><U03AC><U03C1><U03B9><U03BF><U03C2>";/
         "<U03A6><U03B5><U03B2><U03C1><U03BF><U03C5><U03AC><U03C1><U03B9><U03BF><U03C2>";/
         "<U039C><U03AC><U03C1><U03C4><U03B9><U03BF><U03C2>";/
diff --git a/localedata/locales/es_BO b/localedata/locales/es_BO
index 4202c5a0cf..5b6c6e2312 100644
--- a/localedata/locales/es_BO
+++ b/localedata/locales/es_BO
@@ -124,7 +124,7 @@ first_weekday 2
 END LC_TIME
 
 LC_PAPER
-copy "i18n"
+copy "en_US"
 END LC_PAPER
 
 LC_TELEPHONE
diff --git a/localedata/locales/et_EE b/localedata/locales/et_EE
index 9cb55b568f..bab7493c98 100644
--- a/localedata/locales/et_EE
+++ b/localedata/locales/et_EE
@@ -103,6 +103,8 @@ reorder-after <w>
 <U00FC> <u-diaresis>;<BAS>;<MIN>;IGNORE % ü
 <U00DC> <u-diaresis>;<BAS>;<CAP>;IGNORE % Ü
 
+reorder-end
+
 END LC_COLLATE
 
 LC_CTYPE
diff --git a/localedata/locales/gd_GB b/localedata/locales/gd_GB
index 676ee940c9..77d11e5977 100644
--- a/localedata/locales/gd_GB
+++ b/localedata/locales/gd_GB
@@ -66,12 +66,12 @@ mon           "Am Faoilleach";/
      "An D<U00E0>mhair";/
      "An t-Samhain";/
      "An D<U00F9>bhlachd"
-% Faoi, Gearr, Màrt, Gibl, Mhàrt, Ògmh, Iuch, Lùna, Sult, Dàmh, Samh, Dùbh
+% Faoi, Gearr, Màrt, Gibl, Cèit, Ògmh, Iuch, Lùna, Sult, Dàmh, Samh, Dùbh
 abmon         "Faoi";/
        "Gearr";/
        "M<U00E0>rt";/
        "Gibl";/
-       "Mh<U00E0>rt";/
+       "C<U00E8>it";/
        "<U00D2>gmh";/
        "Iuch";/
        "L<U00F9>na";/
diff --git a/localedata/locales/ja_JP b/localedata/locales/ja_JP
index 1fd2fee44b..30190b6248 100644
--- a/localedata/locales/ja_JP
+++ b/localedata/locales/ja_JP
@@ -14946,7 +14946,9 @@ am_pm	"<U5348><U524D>";"<U5348><U5F8C>"
 
 t_fmt_ampm "%p%I<U6642>%M<U5206>%S<U79D2>"
 
-era	"+:2:1990//01//01:+*:<U5E73><U6210>:%EC%Ey<U5E74>";/
+era	"+:2:2020//01//01:+*:<U4EE4><U548C>:%EC%Ey<U5E74>";/
+	"+:1:2019//05//01:2019//12//31:<U4EE4><U548C>:%EC<U5143><U5E74>";/
+	"+:2:1990//01//01:2019//04//30:<U5E73><U6210>:%EC%Ey<U5E74>";/
 	"+:1:1989//01//08:1989//12//31:<U5E73><U6210>:%EC<U5143><U5E74>";/
 	"+:2:1927//01//01:1989//01//07:<U662D><U548C>:%EC%Ey<U5E74>";/
 	"+:1:1926//12//25:1926//12//31:<U662D><U548C>:%EC<U5143><U5E74>";/
diff --git a/localedata/locales/lt_LT b/localedata/locales/lt_LT
index c935fcf75e..bec67726e9 100644
--- a/localedata/locales/lt_LT
+++ b/localedata/locales/lt_LT
@@ -201,12 +201,12 @@ day       "Sekmadienis";/
           "Ketvirtadienis";/
           "Penktadienis";/
           "<U0160>e<U0161>tadienis"
-abmon     "Sau";"Vas";/
-          "Kov";"Bal";/
-          "Geg";"Bir";/
-          "Lie";"Rgp";/
-          "Rgs";"Spa";/
-          "Lap";"Grd"
+abmon     "saus.";"vas.";/
+          "kov.";"bal.";/
+          "geg.";"bir<U017E>.";/
+          "liep.";"rugp.";/
+          "rugs.";"spal.";/
+          "lapkr.";"gruod."
 alt_mon   "sausis";/
           "vasaris";/
           "kovas";/
diff --git a/localedata/locales/translit_neutral b/localedata/locales/translit_neutral
index e3639c0a75..72f66220b7 100644
--- a/localedata/locales/translit_neutral
+++ b/localedata/locales/translit_neutral
@@ -743,10 +743,22 @@ include "translit_wide";""
 <U263A> "<U003A><U0029>"
 % BLACK SMILING FACE
 <U263B> "<U003A><U0029>"
-% MATHEMATICAL RIGHT DOUBLE ANGLE BRACKET⟫
-<U27EB> "<U003E><U003E>"
+% MATHEMATICAL LEFT WHITE SQUARE BRACKET
+<U27E6> "<U005B><U007C>"
+% MATHEMATICAL RIGHT WHITE SQUARE BRACKET
+<U27E7> "<U007C><U005D>"
+% MATHEMATICAL LEFT ANGLE BRACKET
+<U27E8> <U003C>
+% MATHEMATICAL RIGHT ANGLE BRACKET
+<U27E9> <U003E>
 % MATHEMATICAL LEFT DOUBLE ANGLE BRACKET
 <U27EA> "<U003C><U003C>"
+% MATHEMATICAL RIGHT DOUBLE ANGLE BRACKET
+<U27EB> "<U003E><U003E>"
+% MATHEMATICAL LEFT WHITE TORTOISE SHELL BRACKET
+<U27EC> "<U0028><U0028>"
+% MATHEMATICAL RIGHT WHITE TORTOISE SHELL BRACKET
+<U27ED> "<U0029><U0029>"
 % MATHEMATICAL LEFT FLATTENED PARENTHESIS
 <U27EE> <U0028>
 % MATHEMATICAL RIGHT FLATTENED PARENTHESIS
@@ -755,6 +767,42 @@ include "translit_wide";""
 <U27CB> <U002F>
 % MATHEMATICAL FALLING DIAGONAL
 <U27CD> <U005C>
+% TRIPLE VERTICAL BAR DELIMITER
+<U2980> "<U007C><U007C><U007C>"
+% LEFT WHITE CURLY BRACKET
+<U2983> "<U007B><U007C>"
+% RIGHT WHITE CURLY BRACKET
+<U2984> "<U007C><U007D>"
+% LEFT WHITE PARENTHESIS
+<U2985> "<U0028><U0028>"
+% RIGHT WHITE PARENTHESIS
+<U2986> "<U0029><U0029>"
+% Z NOTATION LEFT IMAGE BRACKET
+<U2987> "<U0028><U007C>"
+% Z NOTATION RIGHT IMAGE BRACKET
+<U2988> "<U007C><U0029>"
+% Z NOTATION LEFT BINDING BRACKET
+<U2989> "<U003C><U007C>"
+% Z NOTATION RIGHT BINDING BRACKET
+<U298A> "<U007C><U003E>"
+% EQUALS SIGN AND SLANTED PARALLEL
+<U29E3> <U0023>
+% IDENTICAL TO AND SLANTED PARALLEL
+<U29E5> <U0023>
+% REVERSE SOLIDUS OPERATOR
+<U29F5> <U005C>
+% BIG SOLIDUS
+<U29F8> <U002F>
+% BIG REVERSE SOLIDUS
+<U29F9> <U005C>
+% LEFT-POINTING CURVED ANGLE BRACKET
+<U29FC> <U003C>
+% RIGHT-POINTING CURVED ANGLE BRACKET
+<U29FD> <U003E>
+% TINY
+<U29FE> <U002B>
+% MINY
+<U29FF> <U002D>
 % LEFT ANGLE BRACKET
 <U3008> <U003C>
 % RIGHT ANGLE BRACKET
diff --git a/localedata/tst-iconv-math-trans.c b/localedata/tst-iconv-math-trans.c
new file mode 100644
index 0000000000..32473bbe3e
--- /dev/null
+++ b/localedata/tst-iconv-math-trans.c
@@ -0,0 +1,104 @@
+/* Test some mathematical operator transliterations (BZ #23132)
+
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <iconv.h>
+#include <locale.h>
+#include <stdio.h>
+#include <string.h>
+#include <support/check.h>
+
+static int
+do_test (void)
+{
+  iconv_t cd;
+
+  /* str[] = "⟦ ⟧ ⟨ ⟩"
+             " ⟬ ⟭ ⦀"
+             " ⦃ ⦄ ⦅ ⦆"
+             " ⦇ ⦈ ⦉ ⦊"
+             " ⧣ ⧥ ⧵ ⧸ ⧹"
+             " ⧼ ⧽ ⧾ ⧿";  */
+
+  const char str[] = "\u27E6 \u27E7 \u27E8 \u27E9"
+                     " \u27EC \u27ED \u2980"
+                     " \u2983 \u2984 \u2985 \u2986"
+                     " \u2987 \u2988 \u2989 \u298A"
+                     " \u29E3 \u29E5 \u29F5 \u29F8 \u29F9"
+                     " \u29FC \u29FD \u29FE \u29FF";
+
+  const char expected[] = "[| |] < >"
+                          " (( )) |||"
+                          " {| |} (( ))"
+                          " (| |) <| |>"
+                          " # # \\ / \\"
+                          " < > + -";
+
+  char *inptr = (char *) str;
+  size_t inlen = strlen (str) + 1;
+  char outbuf[500];
+  char *outptr = outbuf;
+  size_t outlen = sizeof (outbuf);
+  int result = 0;
+  size_t n;
+
+  if (setlocale (LC_ALL, "en_US.UTF-8") == NULL)
+    FAIL_EXIT1 ("setlocale failed");
+
+  cd = iconv_open ("ASCII//TRANSLIT", "UTF-8");
+  if (cd == (iconv_t) -1)
+    FAIL_EXIT1 ("iconv_open failed");
+
+  n = iconv (cd, &inptr, &inlen, &outptr, &outlen);
+  if (n != 24)
+    {
+      if (n == (size_t) -1)
+        printf ("iconv() returned error: %m\n");
+      else
+        printf ("iconv() returned %Zd, expected 24\n", n);
+      result = 1;
+    }
+  if (inlen != 0)
+    {
+      puts ("not all input consumed");
+      result = 1;
+    }
+  else if (inptr - str != strlen (str) + 1)
+    {
+      printf ("inptr wrong, advanced by %td\n", inptr - str);
+      result = 1;
+    }
+  if (memcmp (outbuf, expected, sizeof (expected)) != 0)
+    {
+      printf ("result wrong: \"%.*s\", expected: \"%s\"\n",
+              (int) (sizeof (outbuf) - outlen), outbuf, expected);
+      result = 1;
+    }
+  else if (outlen != sizeof (outbuf) - sizeof (expected))
+    {
+      printf ("outlen wrong: %Zd, expected %Zd\n", outlen,
+              sizeof (outbuf) - 15);
+      result = 1;
+    }
+  else
+    printf ("output is \"%s\" which is OK\n", outbuf);
+
+  return result;
+}
+
+#include <support/test-driver.c>
diff --git a/malloc/Makefile b/malloc/Makefile
index 17873e67c4..a23d370ff3 100644
--- a/malloc/Makefile
+++ b/malloc/Makefile
@@ -37,6 +37,7 @@ tests := mallocbug tst-malloc tst-valloc tst-calloc tst-obstack \
 	 tst-malloc-tcache-leak \
 	 tst-malloc_info \
 	 tst-malloc-too-large \
+	 tst-tcfree1 tst-tcfree2 tst-tcfree3 \
 
 tests-static := \
 	 tst-interpose-static-nothread \
diff --git a/malloc/malloc.c b/malloc/malloc.c
index f8e7250f70..6d6983d060 100644
--- a/malloc/malloc.c
+++ b/malloc/malloc.c
@@ -2904,6 +2904,8 @@ mremap_chunk (mchunkptr p, size_t new_size)
 typedef struct tcache_entry
 {
   struct tcache_entry *next;
+  /* This field exists to detect double frees.  */
+  struct tcache_perthread_struct *key;
 } tcache_entry;
 
 /* There is one of these for each thread, which contains the
@@ -2917,6 +2919,8 @@ typedef struct tcache_perthread_struct
   tcache_entry *entries[TCACHE_MAX_BINS];
 } tcache_perthread_struct;
 
+#define MAX_TCACHE_COUNT 127	/* Maximum value of counts[] entries.  */
+
 static __thread bool tcache_shutting_down = false;
 static __thread tcache_perthread_struct *tcache = NULL;
 
@@ -2927,6 +2931,11 @@ tcache_put (mchunkptr chunk, size_t tc_idx)
 {
   tcache_entry *e = (tcache_entry *) chunk2mem (chunk);
   assert (tc_idx < TCACHE_MAX_BINS);
+
+  /* Mark this chunk as "in the tcache" so the test in _int_free will
+     detect a double free.  */
+  e->key = tcache;
+
   e->next = tcache->entries[tc_idx];
   tcache->entries[tc_idx] = e;
   ++(tcache->counts[tc_idx]);
@@ -2942,6 +2951,7 @@ tcache_get (size_t tc_idx)
   assert (tcache->entries[tc_idx] > 0);
   tcache->entries[tc_idx] = e->next;
   --(tcache->counts[tc_idx]);
+  e->key = NULL;
   return (void *) e;
 }
 
@@ -4165,13 +4175,33 @@ _int_free (mstate av, mchunkptr p, int have_lock)
 #if USE_TCACHE
   {
     size_t tc_idx = csize2tidx (size);
-
-    if (tcache
-	&& tc_idx < mp_.tcache_bins
-	&& tcache->counts[tc_idx] < mp_.tcache_count)
+    if (tcache != NULL && tc_idx < mp_.tcache_bins)
       {
-	tcache_put (p, tc_idx);
-	return;
+	/* Check to see if it's already in the tcache.  */
+	tcache_entry *e = (tcache_entry *) chunk2mem (p);
+
+	/* This test succeeds on double free.  However, we don't 100%
+	   trust it (it also matches random payload data at a 1 in
+	   2^<size_t> chance), so verify it's not an unlikely
+	   coincidence before aborting.  */
+	if (__glibc_unlikely (e->key == tcache))
+	  {
+	    tcache_entry *tmp;
+	    LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);
+	    for (tmp = tcache->entries[tc_idx];
+		 tmp;
+		 tmp = tmp->next)
+	      if (tmp == e)
+		malloc_printerr ("free(): double free detected in tcache 2");
+	    /* If we get here, it was a coincidence.  We've wasted a
+	       few cycles, but don't abort.  */
+	  }
+
+	if (tcache->counts[tc_idx] < mp_.tcache_count)
+	  {
+	    tcache_put (p, tc_idx);
+	    return;
+	  }
       }
   }
 #endif
@@ -4512,11 +4542,6 @@ _int_realloc(mstate av, mchunkptr oldp, INTERNAL_SIZE_T oldsize,
   mchunkptr        bck;             /* misc temp for linking */
   mchunkptr        fwd;             /* misc temp for linking */
 
-  unsigned long    copysize;        /* bytes to copy */
-  unsigned int     ncopies;         /* INTERNAL_SIZE_T words to copy */
-  INTERNAL_SIZE_T* s;               /* copy source */
-  INTERNAL_SIZE_T* d;               /* copy destination */
-
   /* oldmem size */
   if (__builtin_expect (chunksize_nomask (oldp) <= 2 * SIZE_SZ, 0)
       || __builtin_expect (oldsize >= av->system_mem, 0))
@@ -4584,43 +4609,7 @@ _int_realloc(mstate av, mchunkptr oldp, INTERNAL_SIZE_T oldsize,
             }
           else
             {
-              /*
-                 Unroll copy of <= 36 bytes (72 if 8byte sizes)
-                 We know that contents have an odd number of
-                 INTERNAL_SIZE_T-sized words; minimally 3.
-               */
-
-              copysize = oldsize - SIZE_SZ;
-              s = (INTERNAL_SIZE_T *) (chunk2mem (oldp));
-              d = (INTERNAL_SIZE_T *) (newmem);
-              ncopies = copysize / sizeof (INTERNAL_SIZE_T);
-              assert (ncopies >= 3);
-
-              if (ncopies > 9)
-                memcpy (d, s, copysize);
-
-              else
-                {
-                  *(d + 0) = *(s + 0);
-                  *(d + 1) = *(s + 1);
-                  *(d + 2) = *(s + 2);
-                  if (ncopies > 4)
-                    {
-                      *(d + 3) = *(s + 3);
-                      *(d + 4) = *(s + 4);
-                      if (ncopies > 6)
-                        {
-                          *(d + 5) = *(s + 5);
-                          *(d + 6) = *(s + 6);
-                          if (ncopies > 8)
-                            {
-                              *(d + 7) = *(s + 7);
-                              *(d + 8) = *(s + 8);
-                            }
-                        }
-                    }
-                }
-
+	      memcpy (newmem, chunk2mem (oldp), oldsize - SIZE_SZ);
               _int_free (av, oldp, 1);
               check_inuse_chunk (av, newp);
               return chunk2mem (newp);
@@ -5118,8 +5107,11 @@ static inline int
 __always_inline
 do_set_tcache_count (size_t value)
 {
-  LIBC_PROBE (memory_tunable_tcache_count, 2, value, mp_.tcache_count);
-  mp_.tcache_count = value;
+  if (value <= MAX_TCACHE_COUNT)
+    {
+      LIBC_PROBE (memory_tunable_tcache_count, 2, value, mp_.tcache_count);
+      mp_.tcache_count = value;
+    }
   return 1;
 }
 
diff --git a/malloc/tst-tcfree1.c b/malloc/tst-tcfree1.c
new file mode 100644
index 0000000000..bc29375ce7
--- /dev/null
+++ b/malloc/tst-tcfree1.c
@@ -0,0 +1,42 @@
+/* Test that malloc tcache catches double free.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <error.h>
+#include <limits.h>
+#include <malloc.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <sys/signal.h>
+
+static int
+do_test (void)
+{
+  /* Do one allocation of any size that fits in tcache.  */
+  char * volatile x = malloc (32);
+
+  free (x); // puts in tcache
+  free (x); // should abort
+
+  printf("FAIL: tcache double free not detected\n");
+  return 1;
+}
+
+#define TEST_FUNCTION do_test
+#define EXPECTED_SIGNAL SIGABRT
+#include <support/test-driver.c>
diff --git a/malloc/tst-tcfree2.c b/malloc/tst-tcfree2.c
new file mode 100644
index 0000000000..17f06bacd4
--- /dev/null
+++ b/malloc/tst-tcfree2.c
@@ -0,0 +1,48 @@
+/* Test that malloc tcache catches double free.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <error.h>
+#include <limits.h>
+#include <malloc.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <sys/signal.h>
+
+static int
+do_test (void)
+{
+  char * volatile ptrs[20];
+  int i;
+
+  /* Allocate enough small chunks so that when we free them all, the tcache
+     is full, and the first one we freed is at the end of its linked list.  */
+#define COUNT 20
+  for (i=0; i<COUNT; i++)
+    ptrs[i] = malloc (20);
+  for (i=0; i<COUNT; i++)
+    free (ptrs[i]);
+  free (ptrs[0]);
+
+  printf("FAIL: tcache double free\n");
+  return 1;
+}
+
+#define TEST_FUNCTION do_test
+#define EXPECTED_SIGNAL SIGABRT
+#include <support/test-driver.c>
diff --git a/malloc/tst-tcfree3.c b/malloc/tst-tcfree3.c
new file mode 100644
index 0000000000..016d30ddd8
--- /dev/null
+++ b/malloc/tst-tcfree3.c
@@ -0,0 +1,56 @@
+/* Test that malloc tcache catches double free.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <malloc.h>
+#include <string.h>
+
+/* Prevent GCC from optimizing away any malloc/free pairs.  */
+#pragma GCC optimize ("O0")
+
+static int
+do_test (void)
+{
+  /* Do two allocation of any size that fit in tcache, and one that
+     doesn't.  */
+  int ** volatile a = malloc (32);
+  int ** volatile b = malloc (32);
+  /* This is just under the mmap threshold.  */
+  int ** volatile c = malloc (127 * 1024);
+
+  /* The invalid "tcache bucket" we might dereference will likely end
+     up somewhere within this memory block, so make all the accidental
+     "next" pointers cause segfaults.  BZ #23907.  */
+  memset (c, 0xff, 127 * 1024);
+
+  free (a); // puts in tcache
+
+  /* A is now free and contains the key we use to detect in-tcache.
+     Copy the key to the other chunks.  */
+  memcpy (b, a, 32);
+  memcpy (c, a, 32);
+
+  /* This free tests the "are we in the tcache already" loop with a
+     VALID bin but "coincidental" matching key.  */
+  free (b); // should NOT abort
+  /* This free tests the "is it a valid tcache bin" test.  */
+  free (c); // should NOT abort
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/manual/charset.texi b/manual/charset.texi
index 1867ace485..f6a980f6cb 100644
--- a/manual/charset.texi
+++ b/manual/charset.texi
@@ -643,8 +643,8 @@ and they also do not require it to be in the initial state.
 @cindex stateful
 The @code{mbrtowc} function (``multibyte restartable to wide
 character'') converts the next multibyte character in the string pointed
-to by @var{s} into a wide character and stores it in the wide character
-string pointed to by @var{pwc}.  The conversion is performed according
+to by @var{s} into a wide character and stores it in the location
+pointed to by @var{pwc}.  The conversion is performed according
 to the locale currently selected for the @code{LC_CTYPE} category.  If
 the conversion for the character set used in the locale requires a state,
 the multibyte string is interpreted in the state represented by the
@@ -652,7 +652,7 @@ object pointed to by @var{ps}.  If @var{ps} is a null pointer, a static,
 internal state variable used only by the @code{mbrtowc} function is
 used.
 
-If the next multibyte character corresponds to the NUL wide character,
+If the next multibyte character corresponds to the null wide character,
 the return value of the function is @math{0} and the state object is
 afterwards in the initial state.  If the next @var{n} or fewer bytes
 form a correct multibyte character, the return value is the number of
@@ -665,71 +665,59 @@ by @var{pwc} if @var{pwc} is not null.
 If the first @var{n} bytes of the multibyte string possibly form a valid
 multibyte character but there are more than @var{n} bytes needed to
 complete it, the return value of the function is @code{(size_t) -2} and
-no value is stored.  Please note that this can happen even if @var{n}
-has a value greater than or equal to @code{MB_CUR_MAX} since the input
-might contain redundant shift sequences.
+no value is stored in @code{*@var{pwc}}.  The conversion state is
+updated and all @var{n} input bytes are consumed and should not be
+submitted again.  Please note that this can happen even if @var{n} has a
+value greater than or equal to @code{MB_CUR_MAX} since the input might
+contain redundant shift sequences.
 
 If the first @code{n} bytes of the multibyte string cannot possibly form
 a valid multibyte character, no value is stored, the global variable
 @code{errno} is set to the value @code{EILSEQ}, and the function returns
 @code{(size_t) -1}.  The conversion state is afterwards undefined.
 
+As specified, the @code{mbrtowc} function could deal with multibyte
+sequences which contain embedded null bytes (which happens in Unicode
+encodings such as UTF-16), but @theglibc{} does not support such
+multibyte encodings.  When encountering a null input byte, the function
+will either return zero, or return @code{(size_t) -1)} and report a
+@code{EILSEQ} error.  The @code{iconv} function can be used for
+converting between arbitrary encodings.  @xref{Generic Conversion
+Interface}.
+
 @pindex wchar.h
 @code{mbrtowc} was introduced in @w{Amendment 1} to @w{ISO C90} and
 is declared in @file{wchar.h}.
 @end deftypefun
 
-Use of @code{mbrtowc} is straightforward.  A function that copies a
-multibyte string into a wide character string while at the same time
-converting all lowercase characters into uppercase could look like this
-(this is not the final version, just an example; it has no error
-checking, and sometimes leaks memory):
+A function that copies a multibyte string into a wide character string
+while at the same time converting all lowercase characters into
+uppercase could look like this:
 
 @smallexample
-wchar_t *
-mbstouwcs (const char *s)
-@{
-  size_t len = strlen (s);
-  wchar_t *result = malloc ((len + 1) * sizeof (wchar_t));
-  wchar_t *wcp = result;
-  wchar_t tmp[1];
-  mbstate_t state;
-  size_t nbytes;
-
-  memset (&state, '\0', sizeof (state));
-  while ((nbytes = mbrtowc (tmp, s, len, &state)) > 0)
-    @{
-      if (nbytes >= (size_t) -2)
-        /* Invalid input string.  */
-        return NULL;
-      *wcp++ = towupper (tmp[0]);
-      len -= nbytes;
-      s += nbytes;
-    @}
-  return result;
-@}
+@include mbstouwcs.c.texi
 @end smallexample
 
-The use of @code{mbrtowc} should be clear.  A single wide character is
-stored in @code{@var{tmp}[0]}, and the number of consumed bytes is stored
-in the variable @var{nbytes}.  If the conversion is successful, the
-uppercase variant of the wide character is stored in the @var{result}
-array and the pointer to the input string and the number of available
-bytes is adjusted.
-
-The only non-obvious thing about @code{mbrtowc} might be the way memory
-is allocated for the result.  The above code uses the fact that there
-can never be more wide characters in the converted result than there are
-bytes in the multibyte input string.  This method yields a pessimistic
-guess about the size of the result, and if many wide character strings
-have to be constructed this way or if the strings are long, the extra
-memory required to be allocated because the input string contains
-multibyte characters might be significant.  The allocated memory block can
-be resized to the correct size before returning it, but a better solution
-might be to allocate just the right amount of space for the result right
-away.  Unfortunately there is no function to compute the length of the wide
-character string directly from the multibyte string.  There is, however, a
-function that does part of the work.
+In the inner loop, a single wide character is stored in @code{wc}, and
+the number of consumed bytes is stored in the variable @code{nbytes}.
+If the conversion is successful, the uppercase variant of the wide
+character is stored in the @code{result} array and the pointer to the
+input string and the number of available bytes is adjusted.  If the
+@code{mbrtowc} function returns zero, the null input byte has not been
+converted, so it must be stored explicitly in the result.
+
+The above code uses the fact that there can never be more wide
+characters in the converted result than there are bytes in the multibyte
+input string.  This method yields a pessimistic guess about the size of
+the result, and if many wide character strings have to be constructed
+this way or if the strings are long, the extra memory required to be
+allocated because the input string contains multibyte characters might
+be significant.  The allocated memory block can be resized to the
+correct size before returning it, but a better solution might be to
+allocate just the right amount of space for the result right away.
+Unfortunately there is no function to compute the length of the wide
+character string directly from the multibyte string.  There is, however,
+a function that does part of the work.
 
 @deftypefun size_t mbrlen (const char *restrict @var{s}, size_t @var{n}, mbstate_t *@var{ps})
 @standards{ISO, wchar.h}
diff --git a/manual/creature.texi b/manual/creature.texi
index 96f8ee0a0c..fe7a7790a2 100644
--- a/manual/creature.texi
+++ b/manual/creature.texi
@@ -8,7 +8,7 @@ is controlled by which @dfn{feature test macros} you define.
 If you compile your programs using @samp{gcc -ansi}, you get only the
 @w{ISO C} library features, unless you explicitly request additional
 features by defining one or more of the feature macros.
-@xref{Invoking GCC,, GNU CC Command Options, gcc.info, The GNU CC Manual},
+@xref{Invoking GCC,, GNU CC Command Options, gcc, The GNU CC Manual},
 for more information about GCC options.@refill
 
 You should define these macros by using @samp{#define} preprocessor
@@ -61,13 +61,27 @@ If you define this macro to a value greater than or equal to @code{199309L},
 then the functionality from the 1993 edition of the POSIX.1b standard
 (IEEE Standard 1003.1b-1993) is made available.
 
+If you define this macro to a value greater than or equal to
+@code{199506L}, then the functionality from the 1995 edition of the
+POSIX.1c standard (IEEE Standard 1003.1c-1995) is made available.
+
+If you define this macro to a value greater than or equal to
+@code{200112L}, then the functionality from the 2001 edition of the
+POSIX standard (IEEE Standard 1003.1-2001) is made available.
+
+If you define this macro to a value greater than or equal to
+@code{200809L}, then the functionality from the 2008 edition of the
+POSIX standard (IEEE Standard 1003.1-2008) is made available.
+
 Greater values for @code{_POSIX_C_SOURCE} will enable future extensions.
 The POSIX standards process will define these values as necessary, and
 @theglibc{} should support them some time after they become standardized.
 The 1996 edition of POSIX.1 (ISO/IEC 9945-1: 1996) states that
 if you define @code{_POSIX_C_SOURCE} to a value greater than
 or equal to @code{199506L}, then the functionality from the 1996
-edition is made available.
+edition is made available.  In general, in @theglibc{}, bugfixes to
+the standards are included when specifying the base version; e.g.,
+POSIX.1-2004 will always be included with a value of @code{200112L}.
 @end defvr
 
 @defvr Macro _XOPEN_SOURCE
@@ -87,7 +101,10 @@ available which are necessary for the X/Open Unix brand.
 
 If the macro @code{_XOPEN_SOURCE} has the value @math{500} this includes
 all functionality described so far plus some new definitions from the
-Single Unix Specification, @w{version 2}.
+Single Unix Specification, @w{version 2}.  The value @math{600}
+(corresponding to the sixth revision) includes definitions from SUSv3,
+and using @math{700} (the seventh revision) includes definitions from
+SUSv4.
 @end defvr
 
 @defvr Macro _LARGEFILE_SOURCE
@@ -150,10 +167,14 @@ This macro was introduced as part of the Large File Support extension
 
 @defvr Macro _ISOC99_SOURCE
 @standards{GNU, (none)}
-Until the revised @w{ISO C} standard is widely adopted the new features
-are not automatically enabled.  @Theglibc{} nevertheless has a complete
-implementation of the new standard and to enable the new features the
-macro @code{_ISOC99_SOURCE} should be defined.
+If this macro is defined, features from ISO C99 are included.  Since
+these features are included by default, this macro is mostly relevant
+when the compiler uses an earlier language version.
+@end defvr
+
+@defvr Macro _ISOC11_SOURCE
+@standards{C11, (none)}
+If this macro is defined, ISO C11 extensions to ISO C99 are included.
 @end defvr
 
 @defvr Macro __STDC_WANT_LIB_EXT2__
@@ -209,6 +230,19 @@ enables those features even when the other options would otherwise
 cause them to be disabled.
 @end defvr
 
+@defvr Macro _ATFILE_SOURCE
+@standards{GNU, (none)}
+If this macro is defined, additional @code{*at} interfaces are
+included.
+@end defvr
+
+@defvr Macro _FORTIFY_SOURCE
+@standards{GNU, (none)}
+If this macro is defined to @math{1}, security hardening is added to
+various library functions.  If defined to @math{2}, even stricter
+checks are applied.
+@end defvr
+
 @defvr Macro _REENTRANT
 @defvrx Macro _THREAD_SAFE
 @standards{Obsolete, (none)}
diff --git a/manual/examples/mbstouwcs.c b/manual/examples/mbstouwcs.c
new file mode 100644
index 0000000000..c94e1fa790
--- /dev/null
+++ b/manual/examples/mbstouwcs.c
@@ -0,0 +1,53 @@
+#include <stdbool.h>
+#include <stdlib.h>
+#include <string.h>
+#include <wchar.h>
+
+/* Do not include the above headers in the example.
+*/
+wchar_t *
+mbstouwcs (const char *s)
+{
+  /* Include the null terminator in the conversion.  */
+  size_t len = strlen (s) + 1;
+  wchar_t *result = reallocarray (NULL, len, sizeof (wchar_t));
+  if (result == NULL)
+    return NULL;
+
+  wchar_t *wcp = result;
+  mbstate_t state;
+  memset (&state, '\0', sizeof (state));
+
+  while (true)
+    {
+      wchar_t wc;
+      size_t nbytes = mbrtowc (&wc, s, len, &state);
+      if (nbytes == 0)
+        {
+          /* Terminate the result string.  */
+          *wcp = L'\0';
+          break;
+        }
+      else if (nbytes == (size_t) -2)
+        {
+          /* Truncated input string.  */
+          errno = EILSEQ;
+          free (result);
+          return NULL;
+        }
+      else if (nbytes == (size_t) -1)
+        {
+          /* Some other error (including EILSEQ).  */
+          free (result);
+          return NULL;
+        }
+      else
+        {
+          /* A character was converted.  */
+          *wcp++ = towupper (wc);
+          len -= nbytes;
+          s += nbytes;
+        }
+    }
+  return result;
+}
diff --git a/manual/filesys.texi b/manual/filesys.texi
index ca77996902..cc70a6b7ee 100644
--- a/manual/filesys.texi
+++ b/manual/filesys.texi
@@ -147,19 +147,20 @@ necessarily enough space to contain the directory name.  That is why
 this function is deprecated.
 @end deftypefn
 
+@vindex PWD
 @deftypefun {char *} get_current_dir_name (void)
 @standards{GNU, unistd.h}
 @safety{@prelim{}@mtsafe{@mtsenv{}}@asunsafe{@ascuheap{}}@acunsafe{@acsmem{} @acsfd{}}}
 @c Besides getcwd, which this function calls as a fallback, it calls
 @c getenv, with the potential thread-safety issues that brings about.
-@vindex PWD
-This @code{get_current_dir_name} function is basically equivalent to
-@w{@code{getcwd (NULL, 0)}}.  The only difference is that the value of
-the @code{PWD} variable is returned if this value is correct.  This is a
-subtle difference which is visible if the path described by the
-@code{PWD} value is using one or more symbol links in which case the
-value returned by @code{getcwd} can resolve the symbol links and
-therefore yield a different result.
+The @code{get_current_dir_name} function is basically equivalent to
+@w{@code{getcwd (NULL, 0)}}, except the value of the @env{PWD}
+environment variable is first examined, and if it does in fact
+correspond to the current directory, that value is returned.  This is
+a subtle difference which is visible if the path described by the
+value in @env{PWD} is using one or more symbolic links, in which case
+the value returned by @code{getcwd} would resolve the symbolic links
+and therefore yield a different result.
 
 This function is a GNU extension.
 @end deftypefun
diff --git a/manual/llio.texi b/manual/llio.texi
index 642e56e710..20bf8af6ac 100644
--- a/manual/llio.texi
+++ b/manual/llio.texi
@@ -1251,9 +1251,13 @@ When the source file is compiled using @code{_FILE_OFFSET_BITS == 64} on a
 @c This is a syscall for Linux v4.6.  The sysdeps/posix fallback emulation
 @c is also MT-Safe since it calls preadv.
 
-This function is similar to the @code{preadv} function, with the difference
-it adds an extra @var{flags} parameter of type @code{int}.  The supported
-@var{flags} are dependent of the underlying system.  For Linux it supports:
+This function is similar to the @code{preadv} function, with the
+difference it adds an extra @var{flags} parameter of type @code{int}.
+Additionally, if @var{offset} is @math{-1}, the current file position
+is used and updated (like the @code{readv} function).
+
+The supported @var{flags} are dependent of the underlying system.  For
+Linux it supports:
 
 @vtable @code
 @item RWF_HIPRI
@@ -1271,6 +1275,9 @@ Per-IO synchronization as if the file was opened with @code{O_SYNC} flag.
 @item RWF_NOWAIT
 Use nonblocking mode for this operation; that is, this call to @code{preadv2}
 will fail and set @code{errno} to @code{EAGAIN} if the operation would block.
+
+@item RWF_APPEND
+Per-IO synchronization as if the file was opened with @code{O_APPEND} flag.
 @end vtable
 
 When the source file is compiled with @code{_FILE_OFFSET_BITS == 64} the
@@ -1320,10 +1327,13 @@ When the source file is compiled using @code{_FILE_OFFSET_BITS == 64} on a
 @c This is a syscall for Linux v4.6.  The sysdeps/posix fallback emulation
 @c is also MT-Safe since it calls pwritev.
 
-This function is similar to the @code{pwritev} function, with the difference
-it adds an extra @var{flags} parameter of type @code{int}.  The supported
-@var{flags} are dependent of the underlying system and for Linux it supports
-the same ones as for @code{preadv2}.
+This function is similar to the @code{pwritev} function, with the
+difference it adds an extra @var{flags} parameter of type @code{int}.
+Additionally, if @var{offset} is @math{-1}, the current file position
+should is used and updated (like the @code{writev} function).
+
+The supported @var{flags} are dependent of the underlying system.  For
+Linux, the supported flags are the same as those for @code{preadv2}.
 
 When the source file is compiled with @code{_FILE_OFFSET_BITS == 64} the
 @code{pwritev2} function is in fact @code{pwritev64v2} and the type
@@ -1394,10 +1404,13 @@ failure occurs.  The return value is zero if the end of the input file
 is encountered immediately.
 
 If no bytes can be copied, to report an error, @code{copy_file_range}
-returns the value @math{-1} and sets @code{errno}.  The following
-@code{errno} error conditions are specific to this function:
+returns the value @math{-1} and sets @code{errno}.  The table below
+lists some of the error conditions for this function.
 
 @table @code
+@item ENOSYS
+The kernel does not implement the required functionality.
+
 @item EISDIR
 At least one of the descriptors @var{inputfd} or @var{outputfd} refers
 to a directory.
@@ -1427,9 +1440,6 @@ reading.
 
 The argument @var{outputfd} is not a valid file descriptor open for
 writing, or @var{outputfd} has been opened with @code{O_APPEND}.
-
-@item EXDEV
-The input and output files reside on different file systems.
 @end table
 
 In addition, @code{copy_file_range} can fail with the error codes
diff --git a/manual/platform.texi b/manual/platform.texi
index b8721a0712..504addc956 100644
--- a/manual/platform.texi
+++ b/manual/platform.texi
@@ -123,7 +123,7 @@ when it is not allowed, the priority is set to medium.
 Cache management facilities specific to RISC-V systems that implement the Linux
 ABI are declared in @file{sys/cachectl.h}.
 
-@deftypefun {void} __riscv_flush_icache(void *@var{start}, void *@var{end}, unsigned long int @var{flags})
+@deftypefun {void} __riscv_flush_icache (void *@var{start}, void *@var{end}, unsigned long int @var{flags})
 @safety{@prelim{}@mtsafe{}@assafe{}@acsafe{}}
 Enforce ordering between stores and instruction cache fetches.  The range of
 addresses over which ordering is enforced is specified by @var{start} and
diff --git a/manual/probes.texi b/manual/probes.texi
index 8ab67562d7..4742cdbd47 100644
--- a/manual/probes.texi
+++ b/manual/probes.texi
@@ -243,6 +243,18 @@ This probe is triggered when the
 value of this tunable.
 @end deftp
 
+@deftp Probe memory_tcache_double_free (void *@var{$arg1}, int @var{$arg2})
+This probe is triggered when @code{free} determines that the memory
+being freed has probably already been freed, and resides in the
+per-thread cache.  Note that there is an extremely unlikely chance
+that this probe will trigger due to random payload data remaining in
+the allocated memory matching the key used to detect double frees.
+This probe actually indicates that an expensive linear search of the
+tcache, looking for a double free, has happened.  Argument @var{$arg1}
+is the memory location as passed to @code{free}, Argument @var{$arg2}
+is the tcache bin it resides in.
+@end deftp
+
 @node Mathematical Function Probes
 @section Mathematical Function Probes
 
diff --git a/manual/stdio.texi b/manual/stdio.texi
index 5d7b50c442..38be236991 100644
--- a/manual/stdio.texi
+++ b/manual/stdio.texi
@@ -1808,7 +1808,7 @@ verifies that the correct number and types of arguments are supplied.
 There is also a GNU C syntax to tell the compiler that a function you
 write uses a @code{printf}-style format string.
 @xref{Function Attributes, , Declaring Attributes of Functions,
-gcc.info, Using GNU CC}, for more information.
+gcc, Using GNU CC}, for more information.
 
 @node Table of Output Conversions
 @subsection Table of Output Conversions
@@ -2730,7 +2730,7 @@ This tells the compiler that @code{eprintf} uses a format string like
 the format string appears as the first argument;
 and the arguments to satisfy the format begin with the second.
 @xref{Function Attributes, , Declaring Attributes of Functions,
-gcc.info, Using GNU CC}, for more information.
+gcc, Using GNU CC}, for more information.
 
 @node Parsing a Template String
 @subsection Parsing a Template String
@@ -3478,7 +3478,7 @@ verifies that the correct number and types of arguments are supplied.
 There is also a GNU C syntax to tell the compiler that a function you
 write uses a @code{scanf}-style format string.
 @xref{Function Attributes, , Declaring Attributes of Functions,
-gcc.info, Using GNU CC}, for more information.
+gcc, Using GNU CC}, for more information.
 
 @node Table of Input Conversions
 @subsection Table of Input Conversions
@@ -4033,7 +4033,7 @@ know that a function uses a @code{scanf}-style format string.  Then it
 can check the number and types of arguments in each call to the
 function, and warn you when they do not match the format string.
 For details, see @ref{Function Attributes, , Declaring Attributes of Functions,
-gcc.info, Using GNU CC}.
+gcc, Using GNU CC}.
 
 @node EOF and Errors
 @section End-Of-File and Errors
diff --git a/manual/string.texi b/manual/string.texi
index ac02c6d85e..b07cfb4550 100644
--- a/manual/string.texi
+++ b/manual/string.texi
@@ -1087,7 +1087,7 @@ are often easier and safer automatic techniques that cause buffer
 overruns to reliably terminate a program, such as GCC's
 @option{-fcheck-pointer-bounds} and @option{-fsanitize=address}
 options.  @xref{Debugging Options,, Options for Debugging Your Program
-or GCC, gcc.info, Using GCC}.  Because truncation functions can mask
+or GCC, gcc, Using GCC}.  Because truncation functions can mask
 application bugs that would otherwise be caught by the automatic
 techniques, these functions should be used only when the application's
 underlying logic requires truncation.
diff --git a/manual/tunables.texi b/manual/tunables.texi
index be33c9fc79..8506833c37 100644
--- a/manual/tunables.texi
+++ b/manual/tunables.texi
@@ -188,8 +188,8 @@ per-thread cache.  The default (and maximum) value is 1032 bytes on
 
 @deftp Tunable glibc.malloc.tcache_count
 The maximum number of chunks of each size to cache. The default is 7.
-There is no upper limit, other than available system memory.  If set
-to zero, the per-thread cache is effectively disabled.
+The upper limit is 127.  If set to zero, the per-thread cache is effectively
+disabled.
 
 The approximate maximum overhead of the per-thread cache is thus equal
 to the number of bins times the chunk count in each bin times the size
@@ -333,7 +333,7 @@ This tunable is specific to powerpc, powerpc64 and powerpc64le.
 The @code{glibc.tune.cpu=xxx} tunable allows the user to tell @theglibc{} to
 assume that the CPU is @code{xxx} where xxx may have one of these values:
 @code{generic}, @code{falkor}, @code{thunderxt88}, @code{thunderx2t99},
-@code{thunderx2t99p1}.
+@code{thunderx2t99p1}, @code{ares}.
 
 This tunable is specific to aarch64.
 @end deftp
diff --git a/math/math.h b/math/math.h
index 3c515f817f..0fcbd91366 100644
--- a/math/math.h
+++ b/math/math.h
@@ -1223,7 +1223,7 @@ template<> struct __iseqsig_type<double>
 
 template<> struct __iseqsig_type<long double>
 {
-  static int __call (double __x, double __y) throw ()
+  static int __call (long double __x, long double __y) throw ()
   {
 #  ifndef __NO_LONG_DOUBLE_MATH
     return __iseqsigl (__x, __y);
diff --git a/misc/tst-preadvwritev-common.c b/misc/tst-preadvwritev-common.c
index 560c8f89b6..b59a3de465 100644
--- a/misc/tst-preadvwritev-common.c
+++ b/misc/tst-preadvwritev-common.c
@@ -16,6 +16,7 @@
    License along with the GNU C Library; if not, see
    <http://www.gnu.org/licenses/>.  */
 
+#include <array_length.h>
 #include <stdio.h>
 #include <stdint.h>
 #include <errno.h>
@@ -25,6 +26,7 @@
 
 #include <support/check.h>
 #include <support/temp_file.h>
+#include <support/xunistd.h>
 
 static char *temp_filename;
 static int temp_fd;
@@ -50,6 +52,42 @@ do_prepare (int argc, char **argv)
   pwritev (__fd, __iov, __iovcnt, __offset)
 #endif
 
+static __attribute__ ((unused)) void
+do_test_without_offset (void)
+{
+  xftruncate (temp_fd, 0);
+
+  xwrite (temp_fd, "123", 3);
+  xlseek (temp_fd, 2, SEEK_SET);
+  {
+    struct iovec iov[] =
+      {
+        { (void *) "abc", 3 },
+        { (void *) "xyzt", 4 },
+      };
+    TEST_COMPARE (PWRITEV (temp_fd, iov, array_length (iov), -1), 7);
+  }
+  TEST_COMPARE (xlseek (temp_fd, 0, SEEK_CUR), 9);
+
+  xlseek (temp_fd, 1, SEEK_SET);
+  char buf1[3];
+  char buf2[2];
+  {
+    struct iovec iov[] =
+      {
+        { buf1, sizeof (buf1) },
+        { buf2, sizeof (buf2) },
+      };
+    TEST_COMPARE (PREADV (temp_fd, iov, array_length (iov), -1),
+                  sizeof (buf1) + sizeof (buf2));
+    TEST_COMPARE (memcmp ("2ab", buf1, sizeof (buf1)), 0);
+    TEST_COMPARE (memcmp ("cx", buf2, sizeof (buf2)), 0);
+    TEST_COMPARE (xlseek (temp_fd, 0, SEEK_CUR), 6);
+  }
+
+  xftruncate (temp_fd, 0);
+}
+
 static int
 do_test_with_offset (off_t offset)
 {
diff --git a/misc/tst-preadvwritev2-common.c b/misc/tst-preadvwritev2-common.c
index 89fd0a3ff5..50b9da3fea 100644
--- a/misc/tst-preadvwritev2-common.c
+++ b/misc/tst-preadvwritev2-common.c
@@ -19,9 +19,6 @@
 #include <limits.h>
 #include <support/check.h>
 
-static void
-do_test_with_invalid_flags (void)
-{
 #ifndef RWF_HIPRI
 # define RWF_HIPRI 0
 #endif
@@ -34,7 +31,73 @@ do_test_with_invalid_flags (void)
 #ifndef RWF_NOWAIT
 # define RWF_NOWAIT 0
 #endif
-#define RWF_SUPPORTED	(RWF_HIPRI | RWF_DSYNC | RWF_SYNC | RWF_NOWAIT)
+#ifndef RWF_APPEND
+# define RWF_APPEND 0
+#endif
+#define RWF_SUPPORTED	(RWF_HIPRI | RWF_DSYNC | RWF_SYNC | RWF_NOWAIT \
+			 | RWF_APPEND)
+
+static void
+do_test_with_invalid_fd (void)
+{
+  char buf[256];
+  struct iovec iov = { buf, sizeof buf };
+
+  /* Check with flag being 0 to use the fallback code which calls pwritev
+     or writev.  */
+  TEST_VERIFY (preadv2 (-1, &iov, 1, -1, 0) == -1);
+  TEST_COMPARE (errno, EBADF);
+  TEST_VERIFY (pwritev2 (-1, &iov, 1, -1, 0) == -1);
+  TEST_COMPARE (errno, EBADF);
+
+  /* Same tests as before but with flags being different than 0.  Since
+     there is no emulation for any flag value, fallback code returns
+     ENOTSUP.  This is different running on a kernel with preadv2/pwritev2
+     support, where EBADF is returned).  */
+  TEST_VERIFY (preadv2 (-1, &iov, 1, 0, RWF_HIPRI) == -1);
+  TEST_VERIFY (errno == EBADF || errno == ENOTSUP);
+  TEST_VERIFY (pwritev2 (-1, &iov, 1, 0, RWF_HIPRI) == -1);
+  TEST_VERIFY (errno == EBADF || errno == ENOTSUP);
+}
+
+static void
+do_test_with_invalid_iov (void)
+{
+  {
+    char buf[256];
+    struct iovec iov;
+
+    iov.iov_base = buf;
+    iov.iov_len = (size_t)SSIZE_MAX + 1;
+
+    TEST_VERIFY (preadv2 (temp_fd, &iov, 1, 0, 0) == -1);
+    TEST_COMPARE (errno, EINVAL);
+    TEST_VERIFY (pwritev2 (temp_fd, &iov, 1, 0, 0) == -1);
+    TEST_COMPARE (errno, EINVAL);
+
+    /* Same as for invalid file descriptor tests, emulation fallback
+       first checks for flag value and return ENOTSUP.  */
+    TEST_VERIFY (preadv2 (temp_fd, &iov, 1, 0, RWF_HIPRI) == -1);
+    TEST_VERIFY (errno == EINVAL || errno == ENOTSUP);
+    TEST_VERIFY (pwritev2 (temp_fd, &iov, 1, 0, RWF_HIPRI) == -1);
+    TEST_VERIFY (errno == EINVAL || errno == ENOTSUP);
+  }
+
+  {
+    /* An invalid iovec buffer should trigger an invalid memory access
+       or an error (Linux for instance returns EFAULT).  */
+    struct iovec iov[IOV_MAX+1] = { 0 };
+
+    TEST_VERIFY (preadv2 (temp_fd, iov, IOV_MAX + 1, 0, RWF_HIPRI) == -1);
+    TEST_VERIFY (errno == EINVAL || errno == ENOTSUP);
+    TEST_VERIFY (pwritev2 (temp_fd, iov, IOV_MAX + 1, 0, RWF_HIPRI) == -1);
+    TEST_VERIFY (errno == EINVAL || errno == ENOTSUP);
+  }
+}
+
+static void
+do_test_with_invalid_flags (void)
+{
   /* Set the next bit from the mask of all supported flags.  */
   int invalid_flag = RWF_SUPPORTED != 0 ? __builtin_clz (RWF_SUPPORTED) : 2;
   invalid_flag = 0x1 << ((sizeof (int) * CHAR_BIT) - invalid_flag);
diff --git a/misc/tst-preadvwritev2.c b/misc/tst-preadvwritev2.c
index d8a9daf66a..cb58cbe41e 100644
--- a/misc/tst-preadvwritev2.c
+++ b/misc/tst-preadvwritev2.c
@@ -29,6 +29,9 @@ static int
 do_test (void)
 {
   do_test_with_invalid_flags ();
+  do_test_without_offset ();
+  do_test_with_invalid_fd ();
+  do_test_with_invalid_iov ();
 
   return do_test_with_offset (0);
 }
diff --git a/misc/tst-preadvwritev64v2.c b/misc/tst-preadvwritev64v2.c
index 2c656ae3d7..6a9de54c78 100644
--- a/misc/tst-preadvwritev64v2.c
+++ b/misc/tst-preadvwritev64v2.c
@@ -31,6 +31,9 @@ static int
 do_test (void)
 {
   do_test_with_invalid_flags ();
+  do_test_without_offset ();
+  do_test_with_invalid_fd ();
+  do_test_with_invalid_iov ();
 
   return do_test_with_offset (0);
 }
diff --git a/nptl/Makefile b/nptl/Makefile
index 6fc2c8bb6a..8d88bf2514 100644
--- a/nptl/Makefile
+++ b/nptl/Makefile
@@ -235,9 +235,9 @@ LDLIBS-tst-minstack-throw = -lstdc++
 
 tests = tst-attr1 tst-attr2 tst-attr3 tst-default-attr \
 	tst-mutex1 tst-mutex2 tst-mutex3 tst-mutex4 tst-mutex5 tst-mutex6 \
-	tst-mutex7 tst-mutex9 tst-mutex5a tst-mutex7a tst-mutex7robust \
-	tst-mutexpi1 tst-mutexpi2 tst-mutexpi3 tst-mutexpi4 tst-mutexpi5 \
-	tst-mutexpi5a tst-mutexpi6 tst-mutexpi7 tst-mutexpi7a \
+	tst-mutex7 tst-mutex9 tst-mutex10 tst-mutex5a tst-mutex7a \
+	tst-mutex7robust tst-mutexpi1 tst-mutexpi2 tst-mutexpi3 tst-mutexpi4 \
+	tst-mutexpi5 tst-mutexpi5a tst-mutexpi6 tst-mutexpi7 tst-mutexpi7a \
 	tst-mutexpi9 \
 	tst-spin1 tst-spin2 tst-spin3 tst-spin4 \
 	tst-cond1 tst-cond2 tst-cond3 tst-cond4 tst-cond5 tst-cond6 tst-cond7 \
@@ -309,7 +309,8 @@ tests = tst-attr1 tst-attr2 tst-attr3 tst-default-attr \
 	tst-thread_local1 tst-mutex-errorcheck tst-robust10 \
 	tst-robust-fork tst-create-detached tst-memstream \
 	tst-thread-exit-clobber tst-minstack-cancel tst-minstack-exit \
-	tst-minstack-throw
+	tst-minstack-throw \
+	tst-rwlock-pwn
 
 tests-internal := tst-rwlock19 tst-rwlock20 \
 		  tst-sem11 tst-sem12 tst-sem13 \
@@ -373,7 +374,8 @@ tests += tst-cancelx2 tst-cancelx3 tst-cancelx4 tst-cancelx5 \
 	 tst-cleanupx0 tst-cleanupx1 tst-cleanupx2 tst-cleanupx3 tst-cleanupx4 \
 	 tst-oncex3 tst-oncex4
 ifeq ($(build-shared),yes)
-tests += tst-atfork2 tst-tls4 tst-_res1 tst-fini1 tst-compat-forwarder
+tests += tst-atfork2 tst-tls4 tst-_res1 tst-fini1 tst-compat-forwarder \
+	 tst-audit-threads
 tests-internal += tst-tls3 tst-tls3-malloc tst-tls5 tst-stackguard1
 tests-nolibpthread += tst-fini1
 ifeq ($(have-z-execstack),yes)
@@ -385,7 +387,8 @@ modules-names = tst-atfork2mod tst-tls3mod tst-tls4moda tst-tls4modb \
 		tst-tls5mod tst-tls5moda tst-tls5modb tst-tls5modc \
 		tst-tls5modd tst-tls5mode tst-tls5modf tst-stack4mod \
 		tst-_res1mod1 tst-_res1mod2 tst-execstack-mod tst-fini1mod \
-		tst-join7mod tst-compat-forwarder-mod
+		tst-join7mod tst-compat-forwarder-mod tst-audit-threads-mod1 \
+		tst-audit-threads-mod2
 extra-test-objs += $(addsuffix .os,$(strip $(modules-names))) \
 		   tst-cleanup4aux.o tst-cleanupx4aux.o
 test-extras += tst-cleanup4aux tst-cleanupx4aux
@@ -730,6 +733,16 @@ $(objpfx)tst-compat-forwarder: $(objpfx)tst-compat-forwarder-mod.so
 # destroying a mutex.
 tst-mutex8-ENV = GLIBC_TUNABLES=glibc.elision.enable=0
 
+tst-mutex10-ENV = GLIBC_TUNABLES=glibc.elision.enable=1
+
+# Protect against a build using -Wl,-z,now.
+LDFLAGS-tst-audit-threads-mod1.so = -Wl,-z,lazy
+LDFLAGS-tst-audit-threads-mod2.so = -Wl,-z,lazy
+LDFLAGS-tst-audit-threads = -Wl,-z,lazy
+$(objpfx)tst-audit-threads: $(objpfx)tst-audit-threads-mod2.so
+$(objpfx)tst-audit-threads.out: $(objpfx)tst-audit-threads-mod1.so
+tst-audit-threads-ENV = LD_AUDIT=$(objpfx)tst-audit-threads-mod1.so
+
 # The tests here better do not run in parallel
 ifneq ($(filter %tests,$(MAKECMDGOALS)),)
 .NOTPARALLEL:
diff --git a/nptl/pthreadP.h b/nptl/pthreadP.h
index 583515ff48..ff51f452c6 100644
--- a/nptl/pthreadP.h
+++ b/nptl/pthreadP.h
@@ -110,19 +110,23 @@ enum
 };
 #define PTHREAD_MUTEX_PSHARED_BIT 128
 
+/* See concurrency notes regarding __kind in struct __pthread_mutex_s
+   in sysdeps/nptl/bits/thread-shared-types.h.  */
 #define PTHREAD_MUTEX_TYPE(m) \
-  ((m)->__data.__kind & 127)
+  (atomic_load_relaxed (&((m)->__data.__kind)) & 127)
 /* Don't include NO_ELISION, as that type is always the same
    as the underlying lock type.  */
 #define PTHREAD_MUTEX_TYPE_ELISION(m) \
-  ((m)->__data.__kind & (127|PTHREAD_MUTEX_ELISION_NP))
+  (atomic_load_relaxed (&((m)->__data.__kind))	\
+   & (127 | PTHREAD_MUTEX_ELISION_NP))
 
 #if LLL_PRIVATE == 0 && LLL_SHARED == 128
 # define PTHREAD_MUTEX_PSHARED(m) \
-  ((m)->__data.__kind & 128)
+  (atomic_load_relaxed (&((m)->__data.__kind)) & 128)
 #else
 # define PTHREAD_MUTEX_PSHARED(m) \
-  (((m)->__data.__kind & 128) ? LLL_SHARED : LLL_PRIVATE)
+  ((atomic_load_relaxed (&((m)->__data.__kind)) & 128)	\
+   ? LLL_SHARED : LLL_PRIVATE)
 #endif
 
 /* The kernel when waking robust mutexes on exit never uses
diff --git a/nptl/pthread_cond_common.c b/nptl/pthread_cond_common.c
index 8e425eb01e..479e54febb 100644
--- a/nptl/pthread_cond_common.c
+++ b/nptl/pthread_cond_common.c
@@ -405,8 +405,12 @@ __condvar_quiesce_and_switch_g1 (pthread_cond_t *cond, uint64_t wseq,
 	{
 	  /* There is still a waiter after spinning.  Set the wake-request
 	     flag and block.  Relaxed MO is fine because this is just about
-	     this futex word.  */
-	  r = atomic_fetch_or_relaxed (cond->__data.__g_refs + g1, 1);
+	     this futex word.
+
+	     Update r to include the set wake-request flag so that the upcoming
+	     futex_wait only blocks if the flag is still set (otherwise, we'd
+	     violate the basic client-side futex protocol).  */
+	  r = atomic_fetch_or_relaxed (cond->__data.__g_refs + g1, 1) | 1;
 
 	  if ((r >> 1) > 0)
 	    futex_wait_simple (cond->__data.__g_refs + g1, r, private);
diff --git a/nptl/pthread_mutex_consistent.c b/nptl/pthread_mutex_consistent.c
index 85b8e1a6cb..4fbd875430 100644
--- a/nptl/pthread_mutex_consistent.c
+++ b/nptl/pthread_mutex_consistent.c
@@ -23,8 +23,11 @@
 int
 pthread_mutex_consistent (pthread_mutex_t *mutex)
 {
-  /* Test whether this is a robust mutex with a dead owner.  */
-  if ((mutex->__data.__kind & PTHREAD_MUTEX_ROBUST_NORMAL_NP) == 0
+  /* Test whether this is a robust mutex with a dead owner.
+     See concurrency notes regarding __kind in struct __pthread_mutex_s
+     in sysdeps/nptl/bits/thread-shared-types.h.  */
+  if ((atomic_load_relaxed (&(mutex->__data.__kind))
+       & PTHREAD_MUTEX_ROBUST_NORMAL_NP) == 0
       || mutex->__data.__owner != PTHREAD_MUTEX_INCONSISTENT)
     return EINVAL;
 
diff --git a/nptl/pthread_mutex_destroy.c b/nptl/pthread_mutex_destroy.c
index 5a22611541..713ea68496 100644
--- a/nptl/pthread_mutex_destroy.c
+++ b/nptl/pthread_mutex_destroy.c
@@ -27,12 +27,17 @@ __pthread_mutex_destroy (pthread_mutex_t *mutex)
 {
   LIBC_PROBE (mutex_destroy, 1, mutex);
 
-  if ((mutex->__data.__kind & PTHREAD_MUTEX_ROBUST_NORMAL_NP) == 0
+  /* See concurrency notes regarding __kind in struct __pthread_mutex_s
+     in sysdeps/nptl/bits/thread-shared-types.h.  */
+  if ((atomic_load_relaxed (&(mutex->__data.__kind))
+       & PTHREAD_MUTEX_ROBUST_NORMAL_NP) == 0
       && mutex->__data.__nusers != 0)
     return EBUSY;
 
-  /* Set to an invalid value.  */
-  mutex->__data.__kind = -1;
+  /* Set to an invalid value.  Relaxed MO is enough as it is undefined behavior
+     if the mutex is used after it has been destroyed.  But you can reinitialize
+     it with pthread_mutex_init.  */
+  atomic_store_relaxed (&(mutex->__data.__kind), -1);
 
   return 0;
 }
diff --git a/nptl/pthread_mutex_getprioceiling.c b/nptl/pthread_mutex_getprioceiling.c
index efa37b0d99..ee85949578 100644
--- a/nptl/pthread_mutex_getprioceiling.c
+++ b/nptl/pthread_mutex_getprioceiling.c
@@ -24,7 +24,9 @@
 int
 pthread_mutex_getprioceiling (const pthread_mutex_t *mutex, int *prioceiling)
 {
-  if (__builtin_expect ((mutex->__data.__kind
+  /* See concurrency notes regarding __kind in struct __pthread_mutex_s
+     in sysdeps/nptl/bits/thread-shared-types.h.  */
+  if (__builtin_expect ((atomic_load_relaxed (&(mutex->__data.__kind))
 			 & PTHREAD_MUTEX_PRIO_PROTECT_NP) == 0, 0))
     return EINVAL;
 
diff --git a/nptl/pthread_mutex_init.c b/nptl/pthread_mutex_init.c
index d8fe473728..5cf290c272 100644
--- a/nptl/pthread_mutex_init.c
+++ b/nptl/pthread_mutex_init.c
@@ -101,7 +101,7 @@ __pthread_mutex_init (pthread_mutex_t *mutex,
   memset (mutex, '\0', __SIZEOF_PTHREAD_MUTEX_T);
 
   /* Copy the values from the attribute.  */
-  mutex->__data.__kind = imutexattr->mutexkind & ~PTHREAD_MUTEXATTR_FLAG_BITS;
+  int mutex_kind = imutexattr->mutexkind & ~PTHREAD_MUTEXATTR_FLAG_BITS;
 
   if ((imutexattr->mutexkind & PTHREAD_MUTEXATTR_FLAG_ROBUST) != 0)
     {
@@ -111,17 +111,17 @@ __pthread_mutex_init (pthread_mutex_t *mutex,
 	return ENOTSUP;
 #endif
 
-      mutex->__data.__kind |= PTHREAD_MUTEX_ROBUST_NORMAL_NP;
+      mutex_kind |= PTHREAD_MUTEX_ROBUST_NORMAL_NP;
     }
 
   switch (imutexattr->mutexkind & PTHREAD_MUTEXATTR_PROTOCOL_MASK)
     {
     case PTHREAD_PRIO_INHERIT << PTHREAD_MUTEXATTR_PROTOCOL_SHIFT:
-      mutex->__data.__kind |= PTHREAD_MUTEX_PRIO_INHERIT_NP;
+      mutex_kind |= PTHREAD_MUTEX_PRIO_INHERIT_NP;
       break;
 
     case PTHREAD_PRIO_PROTECT << PTHREAD_MUTEXATTR_PROTOCOL_SHIFT:
-      mutex->__data.__kind |= PTHREAD_MUTEX_PRIO_PROTECT_NP;
+      mutex_kind |= PTHREAD_MUTEX_PRIO_PROTECT_NP;
 
       int ceiling = (imutexattr->mutexkind
 		     & PTHREAD_MUTEXATTR_PRIO_CEILING_MASK)
@@ -145,7 +145,11 @@ __pthread_mutex_init (pthread_mutex_t *mutex,
      FUTEX_PRIVATE_FLAG FUTEX_WAKE.  */
   if ((imutexattr->mutexkind & (PTHREAD_MUTEXATTR_FLAG_PSHARED
 				| PTHREAD_MUTEXATTR_FLAG_ROBUST)) != 0)
-    mutex->__data.__kind |= PTHREAD_MUTEX_PSHARED_BIT;
+    mutex_kind |= PTHREAD_MUTEX_PSHARED_BIT;
+
+  /* See concurrency notes regarding __kind in struct __pthread_mutex_s
+     in sysdeps/nptl/bits/thread-shared-types.h.  */
+  atomic_store_relaxed (&(mutex->__data.__kind), mutex_kind);
 
   /* Default values: mutex not used yet.  */
   // mutex->__count = 0;	already done by memset
diff --git a/nptl/pthread_mutex_lock.c b/nptl/pthread_mutex_lock.c
index 1519c142bd..29cc143e6c 100644
--- a/nptl/pthread_mutex_lock.c
+++ b/nptl/pthread_mutex_lock.c
@@ -62,6 +62,8 @@ static int __pthread_mutex_lock_full (pthread_mutex_t *mutex)
 int
 __pthread_mutex_lock (pthread_mutex_t *mutex)
 {
+  /* See concurrency notes regarding mutex type which is loaded from __kind
+     in struct __pthread_mutex_s in sysdeps/nptl/bits/thread-shared-types.h.  */
   unsigned int type = PTHREAD_MUTEX_TYPE_ELISION (mutex);
 
   LIBC_PROBE (mutex_entry, 1, mutex);
@@ -350,8 +352,14 @@ __pthread_mutex_lock_full (pthread_mutex_t *mutex)
     case PTHREAD_MUTEX_PI_ROBUST_NORMAL_NP:
     case PTHREAD_MUTEX_PI_ROBUST_ADAPTIVE_NP:
       {
-	int kind = mutex->__data.__kind & PTHREAD_MUTEX_KIND_MASK_NP;
-	int robust = mutex->__data.__kind & PTHREAD_MUTEX_ROBUST_NORMAL_NP;
+	int kind, robust;
+	{
+	  /* See concurrency notes regarding __kind in struct __pthread_mutex_s
+	     in sysdeps/nptl/bits/thread-shared-types.h.  */
+	  int mutex_kind = atomic_load_relaxed (&(mutex->__data.__kind));
+	  kind = mutex_kind & PTHREAD_MUTEX_KIND_MASK_NP;
+	  robust = mutex_kind & PTHREAD_MUTEX_ROBUST_NORMAL_NP;
+	}
 
 	if (robust)
 	  {
@@ -502,7 +510,10 @@ __pthread_mutex_lock_full (pthread_mutex_t *mutex)
     case PTHREAD_MUTEX_PP_NORMAL_NP:
     case PTHREAD_MUTEX_PP_ADAPTIVE_NP:
       {
-	int kind = mutex->__data.__kind & PTHREAD_MUTEX_KIND_MASK_NP;
+	/* See concurrency notes regarding __kind in struct __pthread_mutex_s
+	   in sysdeps/nptl/bits/thread-shared-types.h.  */
+	int kind = atomic_load_relaxed (&(mutex->__data.__kind))
+	  & PTHREAD_MUTEX_KIND_MASK_NP;
 
 	oldval = mutex->__data.__lock;
 
@@ -607,15 +618,18 @@ hidden_def (__pthread_mutex_lock)
 void
 __pthread_mutex_cond_lock_adjust (pthread_mutex_t *mutex)
 {
-  assert ((mutex->__data.__kind & PTHREAD_MUTEX_PRIO_INHERIT_NP) != 0);
-  assert ((mutex->__data.__kind & PTHREAD_MUTEX_ROBUST_NORMAL_NP) == 0);
-  assert ((mutex->__data.__kind & PTHREAD_MUTEX_PSHARED_BIT) == 0);
+  /* See concurrency notes regarding __kind in struct __pthread_mutex_s
+     in sysdeps/nptl/bits/thread-shared-types.h.  */
+  int mutex_kind = atomic_load_relaxed (&(mutex->__data.__kind));
+  assert ((mutex_kind & PTHREAD_MUTEX_PRIO_INHERIT_NP) != 0);
+  assert ((mutex_kind & PTHREAD_MUTEX_ROBUST_NORMAL_NP) == 0);
+  assert ((mutex_kind & PTHREAD_MUTEX_PSHARED_BIT) == 0);
 
   /* Record the ownership.  */
   pid_t id = THREAD_GETMEM (THREAD_SELF, tid);
   mutex->__data.__owner = id;
 
-  if (mutex->__data.__kind == PTHREAD_MUTEX_PI_RECURSIVE_NP)
+  if (mutex_kind == PTHREAD_MUTEX_PI_RECURSIVE_NP)
     ++mutex->__data.__count;
 }
 #endif
diff --git a/nptl/pthread_mutex_setprioceiling.c b/nptl/pthread_mutex_setprioceiling.c
index 8594874f85..8306cabcf4 100644
--- a/nptl/pthread_mutex_setprioceiling.c
+++ b/nptl/pthread_mutex_setprioceiling.c
@@ -27,9 +27,10 @@ int
 pthread_mutex_setprioceiling (pthread_mutex_t *mutex, int prioceiling,
 			      int *old_ceiling)
 {
-  /* The low bits of __kind aren't ever changed after pthread_mutex_init,
-     so we don't need a lock yet.  */
-  if ((mutex->__data.__kind & PTHREAD_MUTEX_PRIO_PROTECT_NP) == 0)
+  /* See concurrency notes regarding __kind in struct __pthread_mutex_s
+     in sysdeps/nptl/bits/thread-shared-types.h.  */
+  if ((atomic_load_relaxed (&(mutex->__data.__kind))
+       & PTHREAD_MUTEX_PRIO_PROTECT_NP) == 0)
     return EINVAL;
 
   /* See __init_sched_fifo_prio.  */
diff --git a/nptl/pthread_mutex_timedlock.c b/nptl/pthread_mutex_timedlock.c
index 66efd3989f..40b559f517 100644
--- a/nptl/pthread_mutex_timedlock.c
+++ b/nptl/pthread_mutex_timedlock.c
@@ -53,6 +53,8 @@ __pthread_mutex_timedlock (pthread_mutex_t *mutex,
   /* We must not check ABSTIME here.  If the thread does not block
      abstime must not be checked for a valid value.  */
 
+  /* See concurrency notes regarding mutex type which is loaded from __kind
+     in struct __pthread_mutex_s in sysdeps/nptl/bits/thread-shared-types.h.  */
   switch (__builtin_expect (PTHREAD_MUTEX_TYPE_ELISION (mutex),
 			    PTHREAD_MUTEX_TIMED_NP))
     {
@@ -338,8 +340,14 @@ __pthread_mutex_timedlock (pthread_mutex_t *mutex,
     case PTHREAD_MUTEX_PI_ROBUST_NORMAL_NP:
     case PTHREAD_MUTEX_PI_ROBUST_ADAPTIVE_NP:
       {
-	int kind = mutex->__data.__kind & PTHREAD_MUTEX_KIND_MASK_NP;
-	int robust = mutex->__data.__kind & PTHREAD_MUTEX_ROBUST_NORMAL_NP;
+	int kind, robust;
+	{
+	  /* See concurrency notes regarding __kind in struct __pthread_mutex_s
+	     in sysdeps/nptl/bits/thread-shared-types.h.  */
+	  int mutex_kind = atomic_load_relaxed (&(mutex->__data.__kind));
+	  kind = mutex_kind & PTHREAD_MUTEX_KIND_MASK_NP;
+	  robust = mutex_kind & PTHREAD_MUTEX_ROBUST_NORMAL_NP;
+	}
 
 	if (robust)
 	  {
@@ -509,7 +517,10 @@ __pthread_mutex_timedlock (pthread_mutex_t *mutex,
     case PTHREAD_MUTEX_PP_NORMAL_NP:
     case PTHREAD_MUTEX_PP_ADAPTIVE_NP:
       {
-	int kind = mutex->__data.__kind & PTHREAD_MUTEX_KIND_MASK_NP;
+	/* See concurrency notes regarding __kind in struct __pthread_mutex_s
+	   in sysdeps/nptl/bits/thread-shared-types.h.  */
+	int kind = atomic_load_relaxed (&(mutex->__data.__kind))
+	  & PTHREAD_MUTEX_KIND_MASK_NP;
 
 	oldval = mutex->__data.__lock;
 
diff --git a/nptl/pthread_mutex_trylock.c b/nptl/pthread_mutex_trylock.c
index 7de61f4f68..8e01113b0f 100644
--- a/nptl/pthread_mutex_trylock.c
+++ b/nptl/pthread_mutex_trylock.c
@@ -36,6 +36,8 @@ __pthread_mutex_trylock (pthread_mutex_t *mutex)
   int oldval;
   pid_t id = THREAD_GETMEM (THREAD_SELF, tid);
 
+  /* See concurrency notes regarding mutex type which is loaded from __kind
+     in struct __pthread_mutex_s in sysdeps/nptl/bits/thread-shared-types.h.  */
   switch (__builtin_expect (PTHREAD_MUTEX_TYPE_ELISION (mutex),
 			    PTHREAD_MUTEX_TIMED_NP))
     {
@@ -92,6 +94,9 @@ __pthread_mutex_trylock (pthread_mutex_t *mutex)
     case PTHREAD_MUTEX_ROBUST_ADAPTIVE_NP:
       THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending,
 		     &mutex->__data.__list.__next);
+      /* We need to set op_pending before starting the operation.  Also
+	 see comments at ENQUEUE_MUTEX.  */
+      __asm ("" ::: "memory");
 
       oldval = mutex->__data.__lock;
       do
@@ -117,7 +122,12 @@ __pthread_mutex_trylock (pthread_mutex_t *mutex)
 	      /* But it is inconsistent unless marked otherwise.  */
 	      mutex->__data.__owner = PTHREAD_MUTEX_INCONSISTENT;
 
+	      /* We must not enqueue the mutex before we have acquired it.
+		 Also see comments at ENQUEUE_MUTEX.  */
+	      __asm ("" ::: "memory");
 	      ENQUEUE_MUTEX (mutex);
+	      /* We need to clear op_pending after we enqueue the mutex.  */
+	      __asm ("" ::: "memory");
 	      THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, NULL);
 
 	      /* Note that we deliberately exist here.  If we fall
@@ -133,6 +143,8 @@ __pthread_mutex_trylock (pthread_mutex_t *mutex)
 	      int kind = PTHREAD_MUTEX_TYPE (mutex);
 	      if (kind == PTHREAD_MUTEX_ROBUST_ERRORCHECK_NP)
 		{
+		  /* We do not need to ensure ordering wrt another memory
+		     access.  Also see comments at ENQUEUE_MUTEX. */
 		  THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending,
 				 NULL);
 		  return EDEADLK;
@@ -140,6 +152,8 @@ __pthread_mutex_trylock (pthread_mutex_t *mutex)
 
 	      if (kind == PTHREAD_MUTEX_ROBUST_RECURSIVE_NP)
 		{
+		  /* We do not need to ensure ordering wrt another memory
+		     access.  */
 		  THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending,
 				 NULL);
 
@@ -158,6 +172,9 @@ __pthread_mutex_trylock (pthread_mutex_t *mutex)
 							id, 0);
 	  if (oldval != 0 && (oldval & FUTEX_OWNER_DIED) == 0)
 	    {
+	      /* We haven't acquired the lock as it is already acquired by
+		 another owner.  We do not need to ensure ordering wrt another
+		 memory access.  */
 	      THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, NULL);
 
 	      return EBUSY;
@@ -171,13 +188,20 @@ __pthread_mutex_trylock (pthread_mutex_t *mutex)
 	      if (oldval == id)
 		lll_unlock (mutex->__data.__lock,
 			    PTHREAD_ROBUST_MUTEX_PSHARED (mutex));
+	      /* FIXME This violates the mutex destruction requirements.  See
+		 __pthread_mutex_unlock_full.  */
 	      THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, NULL);
 	      return ENOTRECOVERABLE;
 	    }
 	}
       while ((oldval & FUTEX_OWNER_DIED) != 0);
 
+      /* We must not enqueue the mutex before we have acquired it.
+	 Also see comments at ENQUEUE_MUTEX.  */
+      __asm ("" ::: "memory");
       ENQUEUE_MUTEX (mutex);
+      /* We need to clear op_pending after we enqueue the mutex.  */
+      __asm ("" ::: "memory");
       THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, NULL);
 
       mutex->__data.__owner = id;
@@ -199,14 +223,25 @@ __pthread_mutex_trylock (pthread_mutex_t *mutex)
     case PTHREAD_MUTEX_PI_ROBUST_NORMAL_NP:
     case PTHREAD_MUTEX_PI_ROBUST_ADAPTIVE_NP:
       {
-	int kind = mutex->__data.__kind & PTHREAD_MUTEX_KIND_MASK_NP;
-	int robust = mutex->__data.__kind & PTHREAD_MUTEX_ROBUST_NORMAL_NP;
+	int kind, robust;
+	{
+	  /* See concurrency notes regarding __kind in struct __pthread_mutex_s
+	     in sysdeps/nptl/bits/thread-shared-types.h.  */
+	  int mutex_kind = atomic_load_relaxed (&(mutex->__data.__kind));
+	  kind = mutex_kind & PTHREAD_MUTEX_KIND_MASK_NP;
+	  robust = mutex_kind & PTHREAD_MUTEX_ROBUST_NORMAL_NP;
+	}
 
 	if (robust)
-	  /* Note: robust PI futexes are signaled by setting bit 0.  */
-	  THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending,
-			 (void *) (((uintptr_t) &mutex->__data.__list.__next)
-				   | 1));
+	  {
+	    /* Note: robust PI futexes are signaled by setting bit 0.  */
+	    THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending,
+			   (void *) (((uintptr_t) &mutex->__data.__list.__next)
+				     | 1));
+	    /* We need to set op_pending before starting the operation.  Also
+	       see comments at ENQUEUE_MUTEX.  */
+	    __asm ("" ::: "memory");
+	  }
 
 	oldval = mutex->__data.__lock;
 
@@ -215,12 +250,16 @@ __pthread_mutex_trylock (pthread_mutex_t *mutex)
 	  {
 	    if (kind == PTHREAD_MUTEX_ERRORCHECK_NP)
 	      {
+		/* We do not need to ensure ordering wrt another memory
+		   access.  */
 		THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, NULL);
 		return EDEADLK;
 	      }
 
 	    if (kind == PTHREAD_MUTEX_RECURSIVE_NP)
 	      {
+		/* We do not need to ensure ordering wrt another memory
+		   access.  */
 		THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, NULL);
 
 		/* Just bump the counter.  */
@@ -242,6 +281,9 @@ __pthread_mutex_trylock (pthread_mutex_t *mutex)
 	  {
 	    if ((oldval & FUTEX_OWNER_DIED) == 0)
 	      {
+		/* We haven't acquired the lock as it is already acquired by
+		   another owner.  We do not need to ensure ordering wrt another
+		   memory access.  */
 		THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, NULL);
 
 		return EBUSY;
@@ -262,6 +304,9 @@ __pthread_mutex_trylock (pthread_mutex_t *mutex)
 	    if (INTERNAL_SYSCALL_ERROR_P (e, __err)
 		&& INTERNAL_SYSCALL_ERRNO (e, __err) == EWOULDBLOCK)
 	      {
+		/* The kernel has not yet finished the mutex owner death.
+		   We do not need to ensure ordering wrt another memory
+		   access.  */
 		THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, NULL);
 
 		return EBUSY;
@@ -279,7 +324,12 @@ __pthread_mutex_trylock (pthread_mutex_t *mutex)
 	    /* But it is inconsistent unless marked otherwise.  */
 	    mutex->__data.__owner = PTHREAD_MUTEX_INCONSISTENT;
 
+	    /* We must not enqueue the mutex before we have acquired it.
+	       Also see comments at ENQUEUE_MUTEX.  */
+	    __asm ("" ::: "memory");
 	    ENQUEUE_MUTEX (mutex);
+	    /* We need to clear op_pending after we enqueue the mutex.  */
+	    __asm ("" ::: "memory");
 	    THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, NULL);
 
 	    /* Note that we deliberately exit here.  If we fall
@@ -302,13 +352,20 @@ __pthread_mutex_trylock (pthread_mutex_t *mutex)
 						  PTHREAD_ROBUST_MUTEX_PSHARED (mutex)),
 			      0, 0);
 
+	    /* To the kernel, this will be visible after the kernel has
+	       acquired the mutex in the syscall.  */
 	    THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, NULL);
 	    return ENOTRECOVERABLE;
 	  }
 
 	if (robust)
 	  {
+	    /* We must not enqueue the mutex before we have acquired it.
+	       Also see comments at ENQUEUE_MUTEX.  */
+	    __asm ("" ::: "memory");
 	    ENQUEUE_MUTEX_PI (mutex);
+	    /* We need to clear op_pending after we enqueue the mutex.  */
+	    __asm ("" ::: "memory");
 	    THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending, NULL);
 	  }
 
@@ -325,7 +382,10 @@ __pthread_mutex_trylock (pthread_mutex_t *mutex)
     case PTHREAD_MUTEX_PP_NORMAL_NP:
     case PTHREAD_MUTEX_PP_ADAPTIVE_NP:
       {
-	int kind = mutex->__data.__kind & PTHREAD_MUTEX_KIND_MASK_NP;
+	/* See concurrency notes regarding __kind in struct __pthread_mutex_s
+	   in sysdeps/nptl/bits/thread-shared-types.h.  */
+	int kind = atomic_load_relaxed (&(mutex->__data.__kind))
+	  & PTHREAD_MUTEX_KIND_MASK_NP;
 
 	oldval = mutex->__data.__lock;
 
diff --git a/nptl/pthread_mutex_unlock.c b/nptl/pthread_mutex_unlock.c
index 9ea62943b7..68d04d5395 100644
--- a/nptl/pthread_mutex_unlock.c
+++ b/nptl/pthread_mutex_unlock.c
@@ -35,6 +35,8 @@ int
 attribute_hidden
 __pthread_mutex_unlock_usercnt (pthread_mutex_t *mutex, int decr)
 {
+  /* See concurrency notes regarding mutex type which is loaded from __kind
+     in struct __pthread_mutex_s in sysdeps/nptl/bits/thread-shared-types.h.  */
   int type = PTHREAD_MUTEX_TYPE_ELISION (mutex);
   if (__builtin_expect (type &
 		~(PTHREAD_MUTEX_KIND_MASK_NP|PTHREAD_MUTEX_ELISION_FLAGS_NP), 0))
@@ -222,13 +224,19 @@ __pthread_mutex_unlock_full (pthread_mutex_t *mutex, int decr)
       /* If the previous owner died and the caller did not succeed in
 	 making the state consistent, mark the mutex as unrecoverable
 	 and make all waiters.  */
-      if ((mutex->__data.__kind & PTHREAD_MUTEX_ROBUST_NORMAL_NP) != 0
+      /* See concurrency notes regarding __kind in struct __pthread_mutex_s
+	 in sysdeps/nptl/bits/thread-shared-types.h.  */
+      if ((atomic_load_relaxed (&(mutex->__data.__kind))
+	   & PTHREAD_MUTEX_ROBUST_NORMAL_NP) != 0
 	  && __builtin_expect (mutex->__data.__owner
 			       == PTHREAD_MUTEX_INCONSISTENT, 0))
       pi_notrecoverable:
        newowner = PTHREAD_MUTEX_NOTRECOVERABLE;
 
-      if ((mutex->__data.__kind & PTHREAD_MUTEX_ROBUST_NORMAL_NP) != 0)
+      /* See concurrency notes regarding __kind in struct __pthread_mutex_s
+	 in sysdeps/nptl/bits/thread-shared-types.h.  */
+      if ((atomic_load_relaxed (&(mutex->__data.__kind))
+	   & PTHREAD_MUTEX_ROBUST_NORMAL_NP) != 0)
 	{
 	continue_pi_robust:
 	  /* Remove mutex from the list.
@@ -251,7 +259,10 @@ __pthread_mutex_unlock_full (pthread_mutex_t *mutex, int decr)
       /* Unlock.  Load all necessary mutex data before releasing the mutex
 	 to not violate the mutex destruction requirements (see
 	 lll_unlock).  */
-      int robust = mutex->__data.__kind & PTHREAD_MUTEX_ROBUST_NORMAL_NP;
+      /* See concurrency notes regarding __kind in struct __pthread_mutex_s
+	 in sysdeps/nptl/bits/thread-shared-types.h.  */
+      int robust = atomic_load_relaxed (&(mutex->__data.__kind))
+	& PTHREAD_MUTEX_ROBUST_NORMAL_NP;
       private = (robust
 		 ? PTHREAD_ROBUST_MUTEX_PSHARED (mutex)
 		 : PTHREAD_MUTEX_PSHARED (mutex));
diff --git a/nptl/pthread_rwlock_common.c b/nptl/pthread_rwlock_common.c
index a290d08332..9ce36d1026 100644
--- a/nptl/pthread_rwlock_common.c
+++ b/nptl/pthread_rwlock_common.c
@@ -314,8 +314,8 @@ __pthread_rwlock_rdlock_full (pthread_rwlock_t *rwlock,
 		 harmless because the flag is just about the state of
 		 __readers, and all threads set the flag under the same
 		 conditions.  */
-	      while ((atomic_load_relaxed (&rwlock->__data.__readers)
-		  & PTHREAD_RWLOCK_RWAITING) != 0)
+	      while (((r = atomic_load_relaxed (&rwlock->__data.__readers))
+		      & PTHREAD_RWLOCK_RWAITING) != 0)
 		{
 		  int private = __pthread_rwlock_get_private (rwlock);
 		  int err = futex_abstimed_wait (&rwlock->__data.__readers,
diff --git a/nptl/tst-audit-threads-mod1.c b/nptl/tst-audit-threads-mod1.c
new file mode 100644
index 0000000000..615d5ee512
--- /dev/null
+++ b/nptl/tst-audit-threads-mod1.c
@@ -0,0 +1,74 @@
+/* Dummy audit library for test-audit-threads.
+
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <elf.h>
+#include <link.h>
+#include <stdio.h>
+#include <assert.h>
+#include <string.h>
+
+/* We must use a dummy LD_AUDIT module to force the dynamic loader to
+   *not* update the real PLT, and instead use a cached value for the
+   lazy resolution result.  It is the update of that cached value that
+   we are testing for correctness by doing this.  */
+
+/* Library to be audited.  */
+#define LIB "tst-audit-threads-mod2.so"
+/* CALLNUM is the number of retNum functions.  */
+#define CALLNUM 7999
+
+#define CONCATX(a, b) __CONCAT (a, b)
+
+static int previous = 0;
+
+unsigned int
+la_version (unsigned int ver)
+{
+  return 1;
+}
+
+unsigned int
+la_objopen (struct link_map *map, Lmid_t lmid, uintptr_t *cookie)
+{
+  return LA_FLG_BINDTO | LA_FLG_BINDFROM;
+}
+
+uintptr_t
+CONCATX(la_symbind, __ELF_NATIVE_CLASS) (ElfW(Sym) *sym,
+					unsigned int ndx,
+					uintptr_t *refcook,
+					uintptr_t *defcook,
+					unsigned int *flags,
+					const char *symname)
+{
+  const char * retnum = "retNum";
+  char * num = strstr (symname, retnum);
+  int n;
+  /* Validate if the symbols are getting called in the correct order.
+     This code is here to verify binutils does not optimize out the PLT
+     entries that require the symbol binding.  */
+  if (num != NULL)
+    {
+      n = atoi (num);
+      assert (n >= previous);
+      assert (n <= CALLNUM);
+      previous = n;
+    }
+  return sym->st_value;
+}
diff --git a/nptl/tst-audit-threads-mod2.c b/nptl/tst-audit-threads-mod2.c
new file mode 100644
index 0000000000..f9817dd3dc
--- /dev/null
+++ b/nptl/tst-audit-threads-mod2.c
@@ -0,0 +1,22 @@
+/* Shared object with a huge number of functions for test-audit-threads.
+
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Define all the retNumN functions in a library.  */
+#define definenum
+#include "tst-audit-threads.h"
diff --git a/nptl/tst-audit-threads.c b/nptl/tst-audit-threads.c
new file mode 100644
index 0000000000..e4bf433bd8
--- /dev/null
+++ b/nptl/tst-audit-threads.c
@@ -0,0 +1,97 @@
+/* Test multi-threading using LD_AUDIT.
+
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This test uses a dummy LD_AUDIT library (test-audit-threads-mod1) and a
+   library with a huge number of functions in order to validate lazy symbol
+   binding with an audit library.  We use one thread per CPU to test that
+   concurrent lazy resolution does not have any defects which would cause
+   the process to fail.  We use an LD_AUDIT library to force the testing of
+   the relocation resolution caching code in the dynamic loader i.e.
+   _dl_runtime_profile and _dl_profile_fixup.  */
+
+#include <support/xthread.h>
+#include <strings.h>
+#include <stdlib.h>
+#include <sys/sysinfo.h>
+
+static int do_test (void);
+
+/* This test usually takes less than 3s to run.  However, there are cases that
+   take up to 30s.  */
+#define TIMEOUT 60
+#define TEST_FUNCTION do_test ()
+#include "../test-skeleton.c"
+
+/* Declare the functions we are going to call.  */
+#define externnum
+#include "tst-audit-threads.h"
+#undef externnum
+
+int num_threads;
+pthread_barrier_t barrier;
+
+void
+sync_all (int num)
+{
+  pthread_barrier_wait (&barrier);
+}
+
+void
+call_all_ret_nums (void)
+{
+  /* Call each function one at a time from all threads.  */
+#define callnum
+#include "tst-audit-threads.h"
+#undef callnum
+}
+
+void *
+thread_main (void *unused)
+{
+  call_all_ret_nums ();
+  return NULL;
+}
+
+#define STR2(X) #X
+#define STR(X) STR2(X)
+
+static int
+do_test (void)
+{
+  int i;
+  pthread_t *threads;
+
+  num_threads = get_nprocs ();
+  if (num_threads <= 1)
+    num_threads = 2;
+
+  /* Used to synchronize all the threads after calling each retNumN.  */
+  xpthread_barrier_init (&barrier, NULL, num_threads);
+
+  threads = (pthread_t *) xcalloc (num_threads, sizeof(pthread_t));
+  for (i = 0; i < num_threads; i++)
+    threads[i] = xpthread_create(NULL, thread_main, NULL);
+
+  for (i = 0; i < num_threads; i++)
+    xpthread_join(threads[i]);
+
+  free (threads);
+
+  return 0;
+}
diff --git a/nptl/tst-audit-threads.h b/nptl/tst-audit-threads.h
new file mode 100644
index 0000000000..1c9ecc08df
--- /dev/null
+++ b/nptl/tst-audit-threads.h
@@ -0,0 +1,92 @@
+/* Helper header for test-audit-threads.
+
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* We use this helper to create a large number of functions, all of
+   which will be resolved lazily and thus have their PLT updated.
+   This is done to provide enough functions that we can statistically
+   observe a thread vs. PLT resolution failure if one exists.  */
+
+#define CONCAT(a, b) a ## b
+#define NUM(x, y) CONCAT (x, y)
+
+#define FUNC10(x)	\
+  FUNC (NUM (x, 0));	\
+  FUNC (NUM (x, 1));	\
+  FUNC (NUM (x, 2));	\
+  FUNC (NUM (x, 3));	\
+  FUNC (NUM (x, 4));	\
+  FUNC (NUM (x, 5));	\
+  FUNC (NUM (x, 6));	\
+  FUNC (NUM (x, 7));	\
+  FUNC (NUM (x, 8));	\
+  FUNC (NUM (x, 9))
+
+#define FUNC100(x)	\
+  FUNC10 (NUM (x, 0));	\
+  FUNC10 (NUM (x, 1));	\
+  FUNC10 (NUM (x, 2));	\
+  FUNC10 (NUM (x, 3));	\
+  FUNC10 (NUM (x, 4));	\
+  FUNC10 (NUM (x, 5));	\
+  FUNC10 (NUM (x, 6));	\
+  FUNC10 (NUM (x, 7));	\
+  FUNC10 (NUM (x, 8));	\
+  FUNC10 (NUM (x, 9))
+
+#define FUNC1000(x)		\
+  FUNC100 (NUM (x, 0));		\
+  FUNC100 (NUM (x, 1));		\
+  FUNC100 (NUM (x, 2));		\
+  FUNC100 (NUM (x, 3));		\
+  FUNC100 (NUM (x, 4));		\
+  FUNC100 (NUM (x, 5));		\
+  FUNC100 (NUM (x, 6));		\
+  FUNC100 (NUM (x, 7));		\
+  FUNC100 (NUM (x, 8));		\
+  FUNC100 (NUM (x, 9))
+
+#define FUNC7000()	\
+  FUNC1000 (1);		\
+  FUNC1000 (2);		\
+  FUNC1000 (3);		\
+  FUNC1000 (4);		\
+  FUNC1000 (5);		\
+  FUNC1000 (6);		\
+  FUNC1000 (7);
+
+#ifdef FUNC
+# undef FUNC
+#endif
+
+#ifdef externnum
+# define FUNC(x) extern int CONCAT (retNum, x) (void)
+#endif
+
+#ifdef definenum
+# define FUNC(x) int CONCAT (retNum, x) (void) { return x; }
+#endif
+
+#ifdef callnum
+# define FUNC(x) CONCAT (retNum, x) (); sync_all (x)
+#endif
+
+/* A value of 7000 functions is chosen as an arbitrarily large
+   number of functions that will allow us enough attempts to
+   verify lazy resolution operation.  */
+FUNC7000 ();
diff --git a/nptl/tst-mutex10.c b/nptl/tst-mutex10.c
new file mode 100644
index 0000000000..e1113ca60a
--- /dev/null
+++ b/nptl/tst-mutex10.c
@@ -0,0 +1,109 @@
+/* Testing race while enabling lock elision.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <pthread.h>
+#include <unistd.h>
+#include <getopt.h>
+#include <support/support.h>
+#include <support/xthread.h>
+
+static pthread_barrier_t barrier;
+static pthread_mutex_t mutex;
+static long long int iteration_count = 1000000;
+static unsigned int thread_count = 3;
+
+static void *
+thr_func (void *arg)
+{
+  long long int i;
+  for (i = 0; i < iteration_count; i++)
+    {
+      if ((uintptr_t) arg == 0)
+	{
+	  xpthread_mutex_destroy (&mutex);
+	  xpthread_mutex_init (&mutex, NULL);
+	}
+
+      xpthread_barrier_wait (&barrier);
+
+      /* Test if enabling lock elision works if it is enabled concurrently.
+	 There was a race in FORCE_ELISION macro which leads to either
+	 pthread_mutex_destroy returning EBUSY as the owner was recorded
+	 by pthread_mutex_lock - in "normal mutex" code path - but was not
+	 resetted in pthread_mutex_unlock - in "elision" code path.
+	 Or it leads to the assertion in nptl/pthread_mutex_lock.c:
+	 assert (mutex->__data.__owner == 0);
+	 Please ensure that the test is run with lock elision:
+	 export GLIBC_TUNABLES=glibc.elision.enable=1  */
+      xpthread_mutex_lock (&mutex);
+      xpthread_mutex_unlock (&mutex);
+
+      xpthread_barrier_wait (&barrier);
+    }
+  return NULL;
+}
+
+static int
+do_test (void)
+{
+  unsigned int i;
+  printf ("Starting %d threads to run %lld iterations.\n",
+	  thread_count, iteration_count);
+
+  pthread_t *threads = xmalloc (thread_count * sizeof (pthread_t));
+  xpthread_barrier_init (&barrier, NULL, thread_count);
+  xpthread_mutex_init (&mutex, NULL);
+
+  for (i = 0; i < thread_count; i++)
+    threads[i] = xpthread_create (NULL, thr_func, (void *) (uintptr_t) i);
+
+  for (i = 0; i < thread_count; i++)
+    xpthread_join (threads[i]);
+
+  xpthread_barrier_destroy (&barrier);
+  free (threads);
+
+  return EXIT_SUCCESS;
+}
+
+#define OPT_ITERATIONS	10000
+#define OPT_THREADS	10001
+#define CMDLINE_OPTIONS						\
+  { "iterations", required_argument, NULL, OPT_ITERATIONS },	\
+  { "threads", required_argument, NULL, OPT_THREADS },
+static void
+cmdline_process (int c)
+{
+  long long int arg = strtoll (optarg, NULL, 0);
+  switch (c)
+    {
+    case OPT_ITERATIONS:
+      if (arg > 0)
+	iteration_count = arg;
+      break;
+    case OPT_THREADS:
+      if (arg > 0 && arg < 100)
+	thread_count = arg;
+      break;
+    }
+}
+#define CMDLINE_PROCESS cmdline_process
+#define TIMEOUT 50
+#include <support/test-driver.c>
diff --git a/nptl/tst-rwlock-pwn.c b/nptl/tst-rwlock-pwn.c
new file mode 100644
index 0000000000..c39dd70973
--- /dev/null
+++ b/nptl/tst-rwlock-pwn.c
@@ -0,0 +1,87 @@
+/* Test rwlock with PREFER_WRITER_NONRECURSIVE_NP (bug 23861).
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <support/xthread.h>
+
+/* We choose 10 iterations because this happens to be able to trigger the
+   stall on contemporary hardware.  */
+#define LOOPS 10
+/* We need 3 threads to trigger bug 23861.  One thread as a writer, and
+   two reader threads.  The test verifies that the second-to-last reader
+   is able to notify the *last* reader that it should be done waiting.
+   If the second-to-last reader fails to notify the last reader or does
+   so incorrectly then the last reader may stall indefinitely.  */
+#define NTHREADS 3
+
+_Atomic int do_exit;
+pthread_rwlockattr_t mylock_attr;
+pthread_rwlock_t mylock;
+
+void *
+run_loop (void *a)
+{
+  while (!do_exit)
+    {
+      if (random () & 1)
+	{
+	  xpthread_rwlock_wrlock (&mylock);
+	  xpthread_rwlock_unlock (&mylock);
+	}
+      else
+	{
+	  xpthread_rwlock_rdlock (&mylock);
+	  xpthread_rwlock_unlock (&mylock);
+	}
+    }
+  return NULL;
+}
+
+int
+do_test (void)
+{
+  xpthread_rwlockattr_init (&mylock_attr);
+  xpthread_rwlockattr_setkind_np (&mylock_attr,
+				  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);
+  xpthread_rwlock_init (&mylock, &mylock_attr);
+
+  for (int n = 0; n < LOOPS; n++)
+    {
+      pthread_t tids[NTHREADS];
+      do_exit = 0;
+      for (int i = 0; i < NTHREADS; i++)
+	tids[i] = xpthread_create (NULL, run_loop, NULL);
+      /* Let the threads run for some time.  */
+      sleep (1);
+      printf ("Exiting...");
+      fflush (stdout);
+      do_exit = 1;
+      for (int i = 0; i < NTHREADS; i++)
+	xpthread_join (tids[i]);
+      printf ("done.\n");
+    }
+  pthread_rwlock_destroy (&mylock);
+  pthread_rwlockattr_destroy (&mylock_attr);
+  return 0;
+}
+
+#define TIMEOUT (DEFAULT_TIMEOUT + 3 * LOOPS)
+#include <support/test-driver.c>
diff --git a/nscd/gai.c b/nscd/gai.c
index d081747797..576fd0045b 100644
--- a/nscd/gai.c
+++ b/nscd/gai.c
@@ -45,3 +45,6 @@
 #ifdef HAVE_LIBIDN
 # include <libidn/idn-stub.c>
 #endif
+
+/* Some variables normally defined in libc.  */
+service_user *__nss_hosts_database attribute_hidden;
diff --git a/nscd/netgroupcache.c b/nscd/netgroupcache.c
index b832c9315f..e75cbc0573 100644
--- a/nscd/netgroupcache.c
+++ b/nscd/netgroupcache.c
@@ -113,7 +113,8 @@ do_notfound (struct database_dyn *db, int fd, request_header *req,
 static time_t
 addgetnetgrentX (struct database_dyn *db, int fd, request_header *req,
 		 const char *key, uid_t uid, struct hashentry *he,
-		 struct datahead *dh, struct dataset **resultp)
+		 struct datahead *dh, struct dataset **resultp,
+		 void **tofreep)
 {
   if (__glibc_unlikely (debug_level > 0))
     {
@@ -139,6 +140,7 @@ addgetnetgrentX (struct database_dyn *db, int fd, request_header *req,
   size_t group_len = strlen (key) + 1;
   struct name_list *first_needed
     = alloca (sizeof (struct name_list) + group_len);
+  *tofreep = NULL;
 
   if (netgroup_database == NULL
       && __nss_database_lookup ("netgroup", NULL, NULL, &netgroup_database))
@@ -151,6 +153,7 @@ addgetnetgrentX (struct database_dyn *db, int fd, request_header *req,
 
   memset (&data, '\0', sizeof (data));
   buffer = xmalloc (buflen);
+  *tofreep = buffer;
   first_needed->next = first_needed;
   memcpy (first_needed->name, key, group_len);
   data.needed_groups = first_needed;
@@ -245,7 +248,7 @@ addgetnetgrentX (struct database_dyn *db, int fd, request_header *req,
 					     : NULL);
 				    ndomain = (ndomain ? newbuf + ndomaindiff
 					       : NULL);
-				    buffer = newbuf;
+				    *tofreep = buffer = newbuf;
 				  }
 
 				nhost = memcpy (buffer + bufused,
@@ -316,7 +319,7 @@ addgetnetgrentX (struct database_dyn *db, int fd, request_header *req,
 		    else if (status == NSS_STATUS_TRYAGAIN && e == ERANGE)
 		      {
 			buflen *= 2;
-			buffer = xrealloc (buffer, buflen);
+			*tofreep = buffer = xrealloc (buffer, buflen);
 		      }
 		    else if (status == NSS_STATUS_RETURN
 			     || status == NSS_STATUS_NOTFOUND
@@ -465,8 +468,6 @@ addgetnetgrentX (struct database_dyn *db, int fd, request_header *req,
     }
 
  out:
-  free (buffer);
-
   *resultp = dataset;
 
   return timeout;
@@ -480,7 +481,7 @@ addinnetgrX (struct database_dyn *db, int fd, request_header *req,
 {
   const char *group = key;
   key = (char *) rawmemchr (key, '\0') + 1;
-  size_t group_len = key - group - 1;
+  size_t group_len = key - group;
   const char *host = *key++ ? key : NULL;
   if (host != NULL)
     key = (char *) rawmemchr (key, '\0') + 1;
@@ -503,8 +504,12 @@ addinnetgrX (struct database_dyn *db, int fd, request_header *req,
 							    group, group_len,
 							    db, uid);
   time_t timeout;
+  void *tofree;
   if (result != NULL)
-    timeout = result->head.timeout;
+    {
+      timeout = result->head.timeout;
+      tofree = NULL;
+    }
   else
     {
       request_header req_get =
@@ -513,7 +518,7 @@ addinnetgrX (struct database_dyn *db, int fd, request_header *req,
 	  .key_len = group_len
 	};
       timeout = addgetnetgrentX (db, -1, &req_get, group, uid, NULL, NULL,
-				 &result);
+				 &result, &tofree);
     }
 
   struct indataset
@@ -586,7 +591,7 @@ addinnetgrX (struct database_dyn *db, int fd, request_header *req,
       ++dh->nreloads;
       if (cacheable)
         pthread_rwlock_unlock (&db->lock);
-      return timeout;
+      goto out;
     }
 
   if (he == NULL)
@@ -649,17 +654,30 @@ addinnetgrX (struct database_dyn *db, int fd, request_header *req,
 	dh->usable = false;
     }
 
+ out:
+  free (tofree);
   return timeout;
 }
 
 
+static time_t
+addgetnetgrentX_ignore (struct database_dyn *db, int fd, request_header *req,
+			const char *key, uid_t uid, struct hashentry *he,
+			struct datahead *dh)
+{
+  struct dataset *ignore;
+  void *tofree;
+  time_t timeout = addgetnetgrentX (db, fd, req, key, uid, he, dh,
+				    &ignore, &tofree);
+  free (tofree);
+  return timeout;
+}
+
 void
 addgetnetgrent (struct database_dyn *db, int fd, request_header *req,
 		void *key, uid_t uid)
 {
-  struct dataset *ignore;
-
-  addgetnetgrentX (db, fd, req, key, uid, NULL, NULL, &ignore);
+  addgetnetgrentX_ignore (db, fd, req, key, uid, NULL, NULL);
 }
 
 
@@ -672,10 +690,8 @@ readdgetnetgrent (struct database_dyn *db, struct hashentry *he,
       .type = GETNETGRENT,
       .key_len = he->len
     };
-  struct dataset *ignore;
-
-  return addgetnetgrentX (db, -1, &req, db->data + he->key, he->owner, he, dh,
-			  &ignore);
+  return addgetnetgrentX_ignore
+    (db, -1, &req, db->data + he->key, he->owner, he, dh);
 }
 
 
diff --git a/nss/nsswitch.c b/nss/nsswitch.c
index d5e655974f..b0f0c11a3e 100644
--- a/nss/nsswitch.c
+++ b/nss/nsswitch.c
@@ -62,7 +62,7 @@ static service_library *nss_new_service (name_database *database,
 
 /* Declare external database variables.  */
 #define DEFINE_DATABASE(name)						      \
-  extern service_user *__nss_##name##_database attribute_hidden;	      \
+  service_user *__nss_##name##_database attribute_hidden;		      \
   weak_extern (__nss_##name##_database)
 #include "databases.def"
 #undef DEFINE_DATABASE
diff --git a/nss/nsswitch.h b/nss/nsswitch.h
index eccb535ef5..63573b9ebc 100644
--- a/nss/nsswitch.h
+++ b/nss/nsswitch.h
@@ -226,10 +226,10 @@ libc_hidden_proto (__nss_hostname_digits_dots)
 #define MAX_NR_ADDRS    48
 
 /* Prototypes for __nss_*_lookup2 functions.  */
-#define DEFINE_DATABASE(arg)				    \
-  service_user *__nss_##arg##_database attribute_hidden;    \
-  int __nss_##arg##_lookup2 (service_user **, const char *, \
-			     const char *, void **);	    \
+#define DEFINE_DATABASE(arg)						      \
+  extern service_user *__nss_##arg##_database attribute_hidden;		      \
+  int __nss_##arg##_lookup2 (service_user **, const char *,		      \
+			     const char *, void **);			      \
   libc_hidden_proto (__nss_##arg##_lookup2)
 #include "databases.def"
 #undef DEFINE_DATABASE
diff --git a/po/pt_BR.po b/po/pt_BR.po
index b7c1650957..d49d6ec279 100644
--- a/po/pt_BR.po
+++ b/po/pt_BR.po
@@ -1,4283 +1,7213 @@
-# Brazilian portuguese messages for glibc.
-# Copyright  1998, 1999 Free Software Foundation, Inc.
+# Brazilian Portuguese translation for glibc.
+# Copyright © 2018 Free Software Foundation, Inc.
+# This file is distributed under the same license as the glibc package.
 # Fabio Dorival Victorelli <fabio@conectiva.com.br>, 1998.
-# Mrcio Macedo <marciom@conectiva.com.br>, 1998.
+# Márcio Macedo <marciom@conectiva.com.br>, 1998.
 # Arnaldo Carvalho de Mello <acme@conectiva.com.br>, 1998.
 # Sandro Nunes Henrique <sandro@conectiva.com.br>, 1998.
 # Rodrigo Stulzer Lopes <rodrigo@conectiva.com.br>, 1999.
-#
+# Rafael Fontenelle <rafaelff@gnome.org>, 2018.
 msgid ""
 msgstr ""
-"Project-Id-Version: libc 2.1\n"
-"POT-Creation-Date: 1998-11-28 09:29-0800\n"
-"PO-Revision-Date: 1999-06-29 18:07-0300\n"
-"Last-Translator: Rodrigo Parra Novo <rodarvus@conectiva.com.br>\n"
-"Language-Team: Brazilian Portuguese <ldp-br@bazar.conectiva.com.br>\n"
-"X-Bugs: Report translation errors to the Language-Team address.\n"
+"Project-Id-Version: libc 2.26.9000\n"
+"POT-Creation-Date: 2018-01-10 15:00+0000\n"
+"PO-Revision-Date: 2018-03-11 11:16-0300\n"
+"Last-Translator: Rafael Fontenelle <rafaelff@gnome.org>\n"
+"Language-Team: Brazilian Portuguese <ldpbr-translation@lists.sourceforge.net>\n"
+"Language: pt_BR\n"
 "MIME-Version: 1.0\n"
-"Content-Type: text/plain; charset=ISO-8859-1\n"
-"Content-Transfer-Encoding: 8-bit\n"
-
-#: nis/nis_print.c:273
-msgid "\t\tAccess Rights : "
-msgstr "\t\tDireitos de Acesso: "
-
-#: nis/nis_print.c:271
-msgid "\t\tAttributes    : "
-msgstr "\t\tAtributos         : "
-
-#: sunrpc/rpc_main.c:1416
-#, c-format
-msgid "\t%s [-abkCLNTM][-Dname[=value]] [-i size] [-I [-K seconds]] [-Y path] infile\n"
-msgstr "%s [-abkCLNTM][-Dname[=valor]] [-i tamanho] [-I [-K segundos]] [-Y rota] arquivo_entrada\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"X-Bugs: Report translation errors to the Language-Team address.\n"
+"Plural-Forms: nplurals=2; plural=(n > 1);\n"
+"X-Generator: Virtaal 1.0.0-beta1\n"
 
-#: sunrpc/rpc_main.c:1418
+#: argp/argp-help.c:227
 #, c-format
-msgid "\t%s [-c | -h | -l | -m | -t | -Sc | -Ss | -Sm] [-o outfile] [infile]\n"
-msgstr "\t%s [-c | -h | -l | -m | -t | -Sc | -Ss | -Sm] [-o arquivo-sada] [arquivo-entrada]\n"
+msgid "%.*s: ARGP_HELP_FMT parameter requires a value"
+msgstr "%.*s: ARGP_HELP_FMT parâmetro requer um valor"
 
-#: sunrpc/rpc_main.c:1421
+#: argp/argp-help.c:237
 #, c-format
-msgid "\t%s [-n netid]* [-o outfile] [infile]\n"
-msgstr "\t%s [-n id-rede]* [-o arquivo-sada] [arquivo-entrada]\n"
+msgid "%.*s: Unknown ARGP_HELP_FMT parameter"
+msgstr "%.*s: Parâmetro ARGP_HELP_FMT desconhecido"
 
-#: sunrpc/rpc_main.c:1420
+#: argp/argp-help.c:250
 #, c-format
-msgid "\t%s [-s nettype]* [-o outfile] [infile]\n"
-msgstr "\t%s [-s tipo-rede]* [-o arquivo-sada] [arquivo-entrada]\n"
+msgid "Garbage in ARGP_HELP_FMT: %s"
+msgstr "Lixo em ARGP_HELP_FMT: %s"
 
-#: nis/nis_print.c:235
-msgid "\tAccess rights: "
-msgstr "\tDireitos acesso: "
+#: argp/argp-help.c:1214
+msgid "Mandatory or optional arguments to long options are also mandatory or optional for any corresponding short options."
+msgstr "Parâmetros obrigatórios ou opcionais para opções longas são também obrigatórios ou opcionais para qualquer opção curta correspondente."
 
-#: nis/nis_print.c:293
-#, c-format
-msgid "\tEntry data of type %s\n"
-msgstr "\tEntrada de dados de tipo %s\n"
+#: argp/argp-help.c:1600
+msgid "Usage:"
+msgstr "Uso:"
 
-#: nis/nis_print.c:171
-#, c-format
-msgid "\tName       : %s\n"
-msgstr "\tNome         : %s\n"
+#: argp/argp-help.c:1604
+msgid "  or: "
+msgstr "  ou: "
 
-#: nis/nis_print.c:172
-msgid "\tPublic Key : "
-msgstr "\tChave pblica: "
+#: argp/argp-help.c:1616
+msgid " [OPTION...]"
+msgstr " [OPÇÃO...]"
 
-#: nis/nis_print.c:234
+#: argp/argp-help.c:1643
 #, c-format
-msgid "\tType         : %s\n"
-msgstr "\tTipo           : %s\n"
+msgid "Try `%s --help' or `%s --usage' for more information.\n"
+msgstr "Tente “%s --help” ou “%s --usage” para mais informações.\n"
 
-#: nis/nis_print.c:201
+#: argp/argp-help.c:1671
 #, c-format
-msgid "\tUniversal addresses (%u)\n"
-msgstr "\tEndereo universal (%u)\n"
+msgid "Report bugs to %s.\n"
+msgstr "Relate erros para %s.\n"
 
-#: nis/nis_print.c:269
-#, c-format
-msgid "\t[%d]\tName          : %s\n"
-msgstr "\t[%d]\tNome          : %s\n"
+#: argp/argp-parse.c:101
+msgid "Give this help list"
+msgstr "Retorna este arquivo de ajuda"
 
-#: nis/nis_print.c:296
-#, c-format
-msgid "\t[%u] - [%u bytes] "
-msgstr "\t[%u] - [%u bytes] "
+#: argp/argp-parse.c:102
+msgid "Give a short usage message"
+msgstr "Retorna uma mensagem de uso curta"
 
-#: nscd/nscd_stat.c:153
-msgid ""
-"\n"
-"%s cache:\n"
-"\n"
-"%15s  cache is enabled\n"
-"%15Zd  suggested size\n"
-"%15ld  seconds time to live for positive entries\n"
-"%15ld  seconds time to live for negative entries\n"
-"%15ld  cache hits on positive entries\n"
-"%15ld  cache hits on negative entries\n"
-"%15ld  cache misses on positive entries\n"
-"%15ld  cache misses on negative entries\n"
-"%15ld%% cache hit rate\n"
-"%15s  check /etc/%s for changes\n"
-msgstr ""
-"\n"
-"cache %s:\n"
-"\n"
-"%15s  cache est habilitado\n"
-"%15Zd  tamanho sugerido%15ld  segundos de vida para entradas positivas\n"
-"%15ld  segundos de vida para entradas negativas\n"
-"%15ld  hits do cache para entradas positivas\n"
-"%15ld  hits do cache para entradas negativas\n"
-"%15ld%% quantidade de hits no cache\n"
-"%15s  verifique o arquivo /etc/%s para mudanas\n"
+#: argp/argp-parse.c:103 catgets/gencat.c:109 catgets/gencat.c:113
+#: iconv/iconv_prog.c:60 iconv/iconv_prog.c:61 nscd/nscd.c:105
+#: nss/makedb.c:120
+msgid "NAME"
+msgstr "NOME"
 
-#: nis/nis_print.c:251
-msgid "\nGroup Members :\n"
-msgstr "\nMembros do Grupo : \n"
+#: argp/argp-parse.c:104
+msgid "Set the program name"
+msgstr "Configura o nome do programa"
 
-#: nis/nis_print.c:320
-msgid "\nTime to Live  : "
-msgstr "\nTempo de Vida  : "
+#: argp/argp-parse.c:105
+msgid "SECS"
+msgstr "SEG"
 
-#: sunrpc/rpcinfo.c:679
-msgid "       rpcinfo -b prognum versnum\n"
-msgstr "       rpcinfo -b nmprog nmvers\n"
+#: argp/argp-parse.c:106
+msgid "Hang for SECS seconds (default 3600)"
+msgstr "Retém por SEG segundos (o padrão é 3600)"
 
-#: sunrpc/rpcinfo.c:680
-msgid "       rpcinfo -d prognum versnum\n"
-msgstr "       rpcinfo -b nmprog nmvers\n"
+#: argp/argp-parse.c:167
+msgid "Print program version"
+msgstr "Mostra versão do programa"
 
-#: sunrpc/rpcinfo.c:678
-msgid "       rpcinfo -p [ host ]\n"
-msgstr "       rpcinfo -p [ host ]\n"
+#: argp/argp-parse.c:183
+msgid "(PROGRAM ERROR) No version known!?"
+msgstr "(ERRO DE PROGRAMA) Versão desconhecida!?"
 
-#: sunrpc/rpcinfo.c:676
-msgid "       rpcinfo [ -n portnum ] -t host prognum [ versnum ]\n"
-msgstr "       rpcinfo [ -n nmporta ] -t host nmprog [ nmvers ]\n"
+#: argp/argp-parse.c:623
+#, c-format
+msgid "%s: Too many arguments\n"
+msgstr "%s: Argumentos demais\n"
 
-#: nscd/nscd_stat.c:145 nscd/nscd_stat.c:147
-msgid "      no"
-msgstr "    no"
+#: argp/argp-parse.c:766
+msgid "(PROGRAM ERROR) Option should have been recognized!?"
+msgstr "(ERRO DE PROGRAMA) Opção deveria ter sido reconhecida!?"
 
-#: nscd/nscd_stat.c:145 nscd/nscd_stat.c:147
-msgid "     yes"
-msgstr "    sim"
+#: assert/assert-perr.c:35
+#, c-format
+msgid "%s%s%s:%u: %s%sUnexpected error: %s.\n"
+msgstr "%s%s%s:%u: %s%sErro inesperado: %s.\n"
 
-#: nis/nis_print.c:344
+#: assert/assert.c:101
 #, c-format
-msgid "    Data Length = %u\n"
-msgstr "  Tamanho dados = %u\n"
+msgid ""
+"%s%s%s:%u: %s%sAssertion `%s' failed.\n"
+"%n"
+msgstr ""
+"%s%s%s:%u: %s%sAssertiva “%s” falhou.\n"
+"%n"
 
-#: nis/nis_print_group_entry.c:121
-msgid "    Explicit members:\n"
-msgstr "  Membros explcitos:\n"
+#: catgets/gencat.c:110
+msgid "Create C header file NAME containing symbol definitions"
+msgstr "Cria arquivo NOME com cabeçalho C contendo definições de símbolos"
 
-#: nis/nis_print_group_entry.c:145 nis/nis_print_group_entry.c:161
-msgid "    Explicit nonmembers:\n"
-msgstr " No-membros explcitos:\n"
+#: catgets/gencat.c:112
+msgid "Do not use existing catalog, force new output file"
+msgstr "Não usa catálogo existente, força um novo arquivo de saída"
 
-#: nis/nis_print_group_entry.c:129
-msgid "    Implicit members:\n"
-msgstr "  Membros implcitos:\n"
+#: catgets/gencat.c:113 nss/makedb.c:120
+msgid "Write output to file NAME"
+msgstr "Escreve a saída para o arquivo NOME"
 
-#: nis/nis_print_group_entry.c:153
-msgid "    Implicit nonmembers:\n"
-msgstr " No-membros implcitos:\n"
+#: catgets/gencat.c:118
+msgid ""
+"Generate message catalog.\vIf INPUT-FILE is -, input is read from standard input.  If OUTPUT-FILE\n"
+"is -, output is written to standard output.\n"
+msgstr ""
+"Gera catálogo de mensagens.\\vSe ARQUIVO-DE-ENTRADA for -, a entrada é lida da entrada padrão.\n"
+"Se ARQUIVO-DE-SAÍDA for -, a saída é escrita para a saída padrão.\n"
 
-#: nis/nis_print_group_entry.c:126
-msgid "    No explicit members\n"
-msgstr " Membros no explcitos\n"
+#: catgets/gencat.c:123
+msgid ""
+"-o OUTPUT-FILE [INPUT-FILE]...\n"
+"[OUTPUT-FILE [INPUT-FILE]...]"
+msgstr ""
+"-o ARQUIVO-SAÍDA [ARQUIVO-ENTRADA]...\n"
+"[ARQUIVO-SAÍDA [ARQUIVO-ENTRADA...]"
 
-#: nis/nis_print_group_entry.c:150
-msgid "    No explicit nonmembers\n"
-msgstr "No-membros no explcitos\n"
+#: catgets/gencat.c:229 debug/pcprofiledump.c:209 elf/ldconfig.c:308
+#: elf/pldd.c:252 elf/sln.c:77 elf/sprof.c:372 iconv/iconv_prog.c:405
+#: iconv/iconvconfig.c:379 locale/programs/locale.c:275
+#: locale/programs/localedef.c:427 login/programs/pt_chown.c:89
+#: malloc/memusagestat.c:563 nss/getent.c:913 nss/makedb.c:369
+#: posix/getconf.c:503 sysdeps/unix/sysv/linux/lddlibc4.c:61
+#, c-format
+msgid ""
+"For bug reporting instructions, please see:\n"
+"%s.\n"
+msgstr ""
+"Para instruções sobre como relatar erros, por favor veja:\n"
+"%s.\n"
 
-#: nis/nis_print_group_entry.c:134
-msgid "    No implicit members\n"
-msgstr " Membros no implcitos\n"
+#: catgets/gencat.c:245 debug/pcprofiledump.c:225 debug/xtrace.sh:64
+#: elf/ldconfig.c:324 elf/ldd.bash.in:38 elf/pldd.c:268 elf/sotruss.sh:75
+#: elf/sprof.c:389 iconv/iconv_prog.c:422 iconv/iconvconfig.c:396
+#: locale/programs/locale.c:292 locale/programs/localedef.c:453
+#: login/programs/pt_chown.c:63 malloc/memusage.sh:71
+#: malloc/memusagestat.c:581 nscd/nscd.c:509 nss/getent.c:86 nss/makedb.c:385
+#: posix/getconf.c:485 sysdeps/unix/sysv/linux/lddlibc4.c:68
+#, c-format
+msgid ""
+"Copyright (C) %s Free Software Foundation, Inc.\n"
+"This is free software; see the source for copying conditions.  There is NO\n"
+"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"
+msgstr ""
+"Copyright (C) %s Free Software Foundation, Inc.\n"
+"Este é um software livre; leia os fontes para condições de cópia. NÃO HÁ\n"
+"QUALQUER GARANTIA; nem para COMERCIALIZAÇÃO ou ADEQUAÇÃO A QUALQUER\n"
+"PROPÓSITO EME PARTICULAR.\n"
 
-#: nis/nis_print_group_entry.c:158
-msgid "    No implicit nonmembers\n"
-msgstr "No-membros no implcitos\n"
+#: catgets/gencat.c:250 debug/pcprofiledump.c:230 debug/xtrace.sh:68
+#: elf/ldconfig.c:329 elf/pldd.c:273 elf/sprof.c:395 iconv/iconv_prog.c:427
+#: iconv/iconvconfig.c:401 locale/programs/locale.c:297
+#: locale/programs/localedef.c:458 malloc/memusage.sh:75
+#: malloc/memusagestat.c:586 nscd/nscd.c:514 nss/getent.c:91 nss/makedb.c:390
+#: posix/getconf.c:490
+#, c-format
+msgid "Written by %s.\n"
+msgstr "Escrito por %s.\n"
 
-#: nis/nis_print_group_entry.c:142
-msgid "    No recursive members\n"
-msgstr "Membros no recursivos\n"
+#: catgets/gencat.c:281
+msgid "*standard input*"
+msgstr "*entrada padrão*"
 
-#: nis/nis_print_group_entry.c:166
-msgid "    No recursive nonmembers\n"
-msgstr "No-membros no recursivos\n"
+#: catgets/gencat.c:287 iconv/iconv_charmap.c:167 iconv/iconv_prog.c:290
+#: nss/makedb.c:246
+#, c-format
+msgid "cannot open input file `%s'"
+msgstr "não é possível abrir arquivo de entrada “%s”"
 
-#: nis/nis_print_group_entry.c:137
-msgid "    Recursive members:\n"
-msgstr "   Membros recursivos:\n"
+#: catgets/gencat.c:416 catgets/gencat.c:491
+msgid "illegal set number"
+msgstr "número de conjunto ilegal"
 
-#: sunrpc/rpcinfo.c:574
-msgid "   program vers proto   port\n"
-msgstr "   programa verso protocolo   porta\n"
+#: catgets/gencat.c:443
+msgid "duplicate set definition"
+msgstr "definição de conjunto duplicada"
 
-#: argp/argp-help.c:1571
-msgid "  or: "
-msgstr "  ou: "
+#: catgets/gencat.c:445 catgets/gencat.c:617 catgets/gencat.c:669
+msgid "this is the first definition"
+msgstr "esta é a primeira definição"
 
-#: timezone/zic.c:421
+#: catgets/gencat.c:516
 #, c-format
-msgid " (rule from \"%s\", line %d)"
-msgstr " (regra de \"%s\", linha %d)"
-
-#: argp/argp-help.c:1583
-msgid " [OPTION...]"
-msgstr " [OPO...]"
+msgid "unknown set `%s'"
+msgstr "conjunto desconhecido “%s”"
 
-#: locale/programs/ld-collate.c:370 locale/programs/ld-ctype.c:1291
-msgid " done\n"
-msgstr " feito\n"
+#: catgets/gencat.c:557
+msgid "invalid quote character"
+msgstr "caractere de aspas inválido"
 
-#: timezone/zic.c:418
+#: catgets/gencat.c:570
 #, c-format
-msgid "\"%s\", line %d: %s"
-msgstr "\"%s\", linha %d: %s"
+msgid "unknown directive `%s': line ignored"
+msgstr "diretiva desconhecida “%s”: linha ignorada"
 
-#: timezone/zic.c:958
-#, c-format
-msgid "\"Zone %s\" line and -l option are mutually exclusive"
-msgstr "A linha \"Zone %s\" e a opo -l so mutuamente exclusivas"
+#: catgets/gencat.c:615
+msgid "duplicated message number"
+msgstr "número de mensagem duplicado"
 
-#: timezone/zic.c:966
-#, c-format
-msgid "\"Zone %s\" line and -p option are mutually exclusive"
-msgstr "A linha \"Zone %s\" e a opo -p so mutuamente exclusivas"
+#: catgets/gencat.c:666
+msgid "duplicated message identifier"
+msgstr "identificador de mensagens duplicado"
 
-#: sunrpc/rpc_main.c:1401
-msgid "\"infile\" is required for template generation flags.\n"
-msgstr "\"arquivo-entrada\"  necessrio para gerao de indicadores do modelo.\n"
+#: catgets/gencat.c:723
+msgid "invalid character: message ignored"
+msgstr "caractere inválido: mensagem ignorada"
 
-#: argp/argp-help.c:210
-#, c-format
-msgid "%.*s: ARGP_HELP_FMT parameter requires a value"
-msgstr "%.*s: ARGP_HELP_FMT parmetro requer um valor"
+#: catgets/gencat.c:766
+msgid "invalid line"
+msgstr "linha inválida"
 
-#: argp/argp-help.c:219
-#, c-format
-msgid "%.*s: Unknown ARGP_HELP_FMT parameter"
-msgstr "%.*s: Parmetro ARGP_HELP_FMT desconhecido"
+#: catgets/gencat.c:820
+msgid "malformed line ignored"
+msgstr "linha inválida ignorada"
 
-#: timezone/zic.c:768
+#: catgets/gencat.c:984 catgets/gencat.c:1025
 #, c-format
-msgid "%s in ruleless zone"
-msgstr "%s em uma zona sem regras"
+msgid "cannot open output file `%s'"
+msgstr "não é possível abrir arquivo de saída “%s”"
 
-#: assert/assert.c:51
-#, c-format
-msgid "%s%s%s:%u: %s%sAssertion `%s' failed.\n"
-msgstr "%s%s%s:%u: %s%sAssertiva `%s' falhou.\n"
+#: catgets/gencat.c:1187 locale/programs/linereader.c:560
+msgid "invalid escape sequence"
+msgstr "sequência de escape inválida"
 
-#: assert/assert-perr.c:52
-#, c-format
-msgid "%s%s%s:%u: %s%sUnexpected error: %s.\n"
-msgstr "%s%s%s:%u: %s%sErro inesperado: %s.\n"
+#: catgets/gencat.c:1209
+msgid "unterminated message"
+msgstr "mensagem não terminada"
 
-#: stdio-common/psignal.c:47
+#: catgets/gencat.c:1233
 #, c-format
-msgid "%s%sUnknown signal %d\n"
-msgstr "%s%sSinal desconhecido %d\n"
+msgid "while opening old catalog file"
+msgstr "enquanto abrindo antigo arquivo de catálogo"
 
-#: timezone/zic.c:2201
+#: catgets/gencat.c:1324
 #, c-format
-msgid "%s: %d did not sign extend correctly\n"
-msgstr "%s: %d no fez extenso de sinal corretamente\n"
+msgid "conversion modules not available"
+msgstr "módulos de conversão não estão disponíveis"
 
-#: locale/programs/charmap.c:261
+#: catgets/gencat.c:1350
 #, c-format
-msgid "%s: <mb_cur_max> must be greater than <mb_cur_min>\n"
-msgstr "%s: <mb_cur_max> deve ser maior que <mb_cur_min>\n"
+msgid "cannot determine escape character"
+msgstr "não é possível determinar caractere de escape"
 
-#: sunrpc/rpc_main.c:422
-#, c-format
-msgid "%s: C preprocessor failed with exit code %d\n"
-msgstr "%s: Pr-processador C falhou com cdigo de sada %d\n"
+#: debug/pcprofiledump.c:53
+msgid "Don't buffer output"
+msgstr "Não usa buffer para a saída"
 
-#: sunrpc/rpc_main.c:419
-#, c-format
-msgid "%s: C preprocessor failed with signal %d\n"
-msgstr "%s: Pr-processador C falhou com sinal %d\n"
+#: debug/pcprofiledump.c:58
+msgid "Dump information generated by PC profiling."
+msgstr "Despeja a informação gerada pelo perfilador de PC."
 
-#: timezone/zic.c:1469
-#, c-format
-msgid "%s: Can't create %s: %s\n"
-msgstr "%s: No  possvel criar %s: %s\n"
+#: debug/pcprofiledump.c:61
+msgid "[FILE]"
+msgstr "[ARQUIVO]"
 
-#: timezone/zic.c:2179
+#: debug/pcprofiledump.c:108
 #, c-format
-msgid "%s: Can't create directory %s: %s\n"
-msgstr "%s: No  possvel criar o diretrio %s: %s\n"
+msgid "cannot open input file"
+msgstr "não foi possível abrir arquivo de entrada"
 
-#: timezone/zic.c:620
+#: debug/pcprofiledump.c:115
 #, c-format
-msgid "%s: Can't link from %s to %s: %s\n"
-msgstr "%s: No  possvel criar um link de %s para %s: %s\n"
+msgid "cannot read header"
+msgstr "não foi possível ler cabeçalho"
 
-#: timezone/zic.c:794
+#: debug/pcprofiledump.c:179
 #, c-format
-msgid "%s: Can't open %s: %s\n"
-msgstr "%s: No  possvel abrir %s: %s\n"
+msgid "invalid pointer size"
+msgstr "tamanho de ponteiro inválido"
 
-#: timezone/zic.c:1459
-#, c-format
-msgid "%s: Can't remove %s: %s\n"
-msgstr "%s: No  possvel remover %s: %s\n"
+#: debug/xtrace.sh:26 debug/xtrace.sh:44
+msgid "Usage: xtrace [OPTION]... PROGRAM [PROGRAMOPTION]...\\n"
+msgstr "Uso: xtrace [OPÇÃO]... PROGRAMA [OPÇÃOPROGRAMA]...\\n"
 
-#: timezone/zic.c:863
-#, c-format
-msgid "%s: Error closing %s: %s\n"
-msgstr "%s: Erro fechando %s: %s\n"
+#: debug/xtrace.sh:32 elf/sotruss.sh:56 elf/sotruss.sh:67 elf/sotruss.sh:135
+#: malloc/memusage.sh:26
+msgid "Try \\`%s --help' or \\`%s --usage' for more information.\\n"
+msgstr "Tente “%s --help” ou “%s --usage” para mais informações.\\n"
 
-#: timezone/zic.c:856
-#, c-format
-msgid "%s: Error reading %s\n"
-msgstr "%s: Erro lendo %s\n"
+#: debug/xtrace.sh:38
+msgid "%s: option '%s' requires an argument.\\n"
+msgstr "%s: opção “%s” requer um argumento.\\n"
 
-#: timezone/zic.c:1535
-#, c-format
-msgid "%s: Error writing %s\n"
-msgstr "%s: Erro escrevendo %s\n"
+#: debug/xtrace.sh:45
+msgid ""
+"Trace execution of program by printing currently executed function.\n"
+"\n"
+"     --data=FILE          Don't run the program, just print the data from FILE.\n"
+"\n"
+"   -?,--help              Print this help and exit\n"
+"      --usage             Give a short usage message\n"
+"   -V,--version           Print version information and exit\n"
+"\n"
+"Mandatory arguments to long options are also mandatory for any corresponding\n"
+"short options.\n"
+"\n"
+msgstr ""
+"Rastreia a execução do programa exibindo a função atualmente executada.\n"
+"\n"
+"     --data=ARQUIVO       Não executa o programa, apenas exibe os dados\n"
+"                            do ARQUIVO.\n"
+"\n"
+"   -?,--help              Exibe essa ajuda e sai\n"
+"      --usage             Fornece uma curta mensagem de uso\n"
+"   -V,--version           Exibe informação da versão e sai\n"
+"\n"
+"Argumentos obrigatórios para opções longas são também obrigatórias para opções curtas correspondentes.\n"
+"\n"
 
-#: timezone/zdump.c:266
-#, c-format
-msgid "%s: Error writing standard output "
-msgstr "%s: Erro escrevendo para sada padro "
+#: debug/xtrace.sh:57 elf/ldd.bash.in:55 elf/sotruss.sh:49
+#: malloc/memusage.sh:64
+msgid "For bug reporting instructions, please see:\\\\n%s.\\\\n"
+msgstr "Para instruções sobre como relatar erros, por favor veja:\\\\n%s.\\\\n"
 
-#: timezone/zic.c:841
-#, c-format
-msgid "%s: Leap line in non leap seconds file %s\n"
-msgstr "%s: linha Leap no arquivo %s, que no  arquivo de ajuste\n"
+#: debug/xtrace.sh:125
+msgid "xtrace: unrecognized option \\`$1'\\n"
+msgstr "xtrace: opção não reconhecida “$1”\\n"
 
-#: timezone/zic.c:359
-#, c-format
-msgid "%s: Memory exhausted: %s\n"
-msgstr "%s: Memria esgotada: %s\n"
+#: debug/xtrace.sh:138
+msgid "No program name given\\n"
+msgstr "Nenhum nome de programa dado\\n"
 
-#: timezone/zic.c:524
-#, c-format
-msgid "%s: More than one -L option specified\n"
-msgstr "%s: Mais que uma opo -L foi especificada\n"
+#: debug/xtrace.sh:146
+#, sh-format
+msgid "executable \\`$program' not found\\n"
+msgstr "“$program” executável não foi encontrado\\n"
 
-#: timezone/zic.c:484
-#, c-format
-msgid "%s: More than one -d option specified\n"
-msgstr "%s: Mais que uma opo -d foi especificada\n"
+#: debug/xtrace.sh:150
+#, sh-format
+msgid "\\`$program' is no executable\\n"
+msgstr "“$program” não é um executável\\n"
 
-#: timezone/zic.c:494
-#, c-format
-msgid "%s: More than one -l option specified\n"
-msgstr "%s: Mais que uma opo -l especificada\n"
+#: dlfcn/dlinfo.c:63
+msgid "RTLD_SELF used in code not dynamically loaded"
+msgstr "RTLD_SELF usado em código não carregado dinamicamente"
 
-#: timezone/zic.c:504
-#, c-format
-msgid "%s: More than one -p option specified\n"
-msgstr "%s: Mais que uma opo -p especificada\n"
+#: dlfcn/dlinfo.c:72
+msgid "unsupported dlinfo request"
+msgstr "requisição dlinfo sem suporte"
 
-#: timezone/zic.c:514
-#, c-format
-msgid "%s: More than one -y option specified\n"
-msgstr "%s: Mais que uma opo -y especificada\n"
+#: dlfcn/dlmopen.c:63
+msgid "invalid namespace"
+msgstr "espaço de nome inválido"
 
-#: argp/argp-parse.c:640
-#, c-format
-msgid "%s: Too many arguments\n"
-msgstr "%s: Muitos parmetros\n"
+#: dlfcn/dlmopen.c:68
+msgid "invalid mode"
+msgstr "modo inválido"
 
-#: login/programs/database.c:129
-#, c-format
-msgid "%s: cannot get modification time"
-msgstr "%s: no  possvel processar modificaes de horrio"
+#: dlfcn/dlopen.c:64
+msgid "invalid mode parameter"
+msgstr "parâmetro de modo inválido"
 
-#: timezone/zic.c:1900
-#, c-format
-msgid "%s: command was '%s', result was %d\n"
-msgstr "%s: comando era '%s', resultado era %d\n"
+#: elf/cache.c:69
+msgid "unknown"
+msgstr "desconhecido"
 
-#: locale/programs/charmap.c:677 locale/programs/locfile.c:1008
-#, c-format
-msgid "%s: error in state machine"
-msgstr "%s: erro na mquina de estados"
+# Operating System (OS) = Sistema Operacional (SO)
+#: elf/cache.c:135
+msgid "Unknown OS"
+msgstr "SO desconhecido"
 
-#: posix/getopt.c:784
+#: elf/cache.c:140
 #, c-format
-msgid "%s: illegal option -- %c\n"
-msgstr "%s: opo ilegal -- %c\n"
+msgid ", OS ABI: %s %d.%d.%d"
+msgstr ", ABI de SO: %s %d.%d.%d"
 
-#: posix/getopt.c:787
+#: elf/cache.c:157 elf/ldconfig.c:1332
 #, c-format
-msgid "%s: invalid option -- %c\n"
-msgstr "%s: opo invlida -- %c\n"
+msgid "Can't open cache file %s\n"
+msgstr "Não foi possível abrir arquivo de cache %s\n"
 
-#: posix/getopt.c:707
+#: elf/cache.c:171
 #, c-format
-msgid "%s: option `%c%s' doesn't allow an argument\n"
-msgstr "%s: opo `%c%s' no permite um argumento\n"
+msgid "mmap of cache file failed.\n"
+msgstr "mmap de arquivo de cache falhou.\n"
 
-#: posix/getopt.c:677
+#: elf/cache.c:175 elf/cache.c:189
 #, c-format
-msgid "%s: option `%s' is ambiguous\n"
-msgstr "%s: opo `%s'  ambgua\n"
+msgid "File is not a cache file.\n"
+msgstr "Arquivo não é um arquivo de cache.\n"
 
-#: posix/getopt.c:725 posix/getopt.c:898
+# %d = número (quantidade) de bibliotecas
+#: elf/cache.c:222 elf/cache.c:232
 #, c-format
-msgid "%s: option `%s' requires an argument\n"
-msgstr "%s: opo `%s' requer um argumento\n"
+msgid "%d libs found in cache `%s'\n"
+msgstr "%d bibliotecas localizadas no cache “%s”\n"
 
-#: posix/getopt.c:702
+#: elf/cache.c:426
 #, c-format
-msgid "%s: option `--%s' doesn't allow an argument\n"
-msgstr "%s: opo `--%s' no permite um argumento\n"
+msgid "Can't create temporary cache file %s"
+msgstr "Não foi possível criar arquivo temporário de cache %s"
 
-#: posix/getopt.c:882
+#: elf/cache.c:434 elf/cache.c:444 elf/cache.c:448 elf/cache.c:453
 #, c-format
-msgid "%s: option `-W %s' doesn't allow an argument\n"
-msgstr "%s: opo `-W %s' no permite um argumento\n"
+msgid "Writing of cache data failed"
+msgstr "Escrita de dados de cache falhou"
 
-#: posix/getopt.c:864
+#: elf/cache.c:458
 #, c-format
-msgid "%s: option `-W %s' is ambiguous\n"
-msgstr "%s: opo `-W %s'  ambgua\n"
+msgid "Changing access rights of %s to %#o failed"
+msgstr "Mudança de direitos de acesso de %s para %#o falhou"
 
-#: posix/getopt.c:817 posix/getopt.c:947
+#: elf/cache.c:463
 #, c-format
-msgid "%s: option requires an argument -- %c\n"
-msgstr "%s: opo requer um argumento -- %c\n"
+msgid "Renaming of %s to %s failed"
+msgstr "Renomeio de %s para %s falhou"
 
-#: sunrpc/rpc_main.c:287
-#, c-format
-msgid "%s: output would overwrite %s\n"
-msgstr "%s: sada poder sobrescrever %s\n"
+#: elf/dl-close.c:399 elf/dl-open.c:425
+msgid "cannot create scope list"
+msgstr "não é possível criar lista de escopo"
 
-#: timezone/zic.c:848 timezone/zic.c:1262 timezone/zic.c:1287
-#, c-format
-msgid "%s: panic: Invalid l_value %d\n"
-msgstr "%s: pnico: l_value invlido %d\n"
+#: elf/dl-close.c:839
+msgid "shared object not open"
+msgstr "objeto compartilhado não está aberto"
 
-#: locale/programs/charmap.c:684 locale/programs/repertoire.c:289
-#, c-format
-msgid "%s: premature end of file"
-msgstr "%s: fim de arquivo prematuro"
+#: elf/dl-deps.c:111
+msgid "DST not allowed in SUID/SGID programs"
+msgstr "DST não permitido em programas SUID/SGID"
 
-#: sunrpc/rpc_main.c:294
-#, c-format
-msgid "%s: unable to open "
-msgstr "%s: No foi possvel abrir "
+#: elf/dl-deps.c:124
+msgid "empty dynamic string token substitution"
+msgstr "substituição de token de string dinâmica vazia"
 
-#: posix/getopt.c:758
+#: elf/dl-deps.c:130
 #, c-format
-msgid "%s: unrecognized option `%c%s'\n"
-msgstr "%s: opo no reconhecida `%c%s'\n"
+msgid "cannot load auxiliary `%s' because of empty dynamic string token substitution\n"
+msgstr "não foi possível carregar “%s” auxiliar por causa de substituição de token de string dinâmica vazia\n"
 
-#: posix/getopt.c:754
-#, c-format
-msgid "%s: unrecognized option `--%s'\n"
-msgstr "%s: opo no reconhecida `--%s'\n"
+#: elf/dl-deps.c:442
+msgid "cannot allocate dependency list"
+msgstr "não foi possível alocar lista de dependências"
 
-#: timezone/zic.c:443
-#, c-format
-msgid ""
-"%s: usage is %s [ -s ] [ -v ] [ -l localtime ] [ -p posixrules ] [ -d directory ]\n"
-"\t[ -L leapseconds ] [ -y yearistype ] [ filename ... ]\n"
-msgstr ""
-"%s: uso  %s [ -s ] [ -v ] [ -l tempolocal ] [ -p regrasposix ] [ -d diretrio ]\n"
-"\t[ -L segundosajuste ] [ -y tipoano ] [ nome do arquivo ... ]\n"
+#: elf/dl-deps.c:479 elf/dl-deps.c:539
+msgid "cannot allocate symbol search list"
+msgstr "não foi possível alocar lista de pesquisa de símbolos"
 
-#: timezone/zdump.c:174
-#, c-format
-msgid "%s: usage is %s [ -v ] [ -c cutoff ] zonename ...\n"
-msgstr "%s: uso  %s [ -v ] [ -c cutoff ] nomezona ...\n"
+#: elf/dl-deps.c:519
+msgid "Filters not supported with LD_TRACE_PRELINKING"
+msgstr "Filtros sem suporte com LD_TRACE_PRELINKING"
 
-#: sunrpc/rpc_main.c:307
-#, c-format
-msgid "%s: while writing output: "
-msgstr "%s: enquanto escrevendo sada: "
+#: elf/dl-error-skeleton.c:80
+msgid "error while loading shared libraries"
+msgstr "erro ao carregar bibliotecas compartilhadas"
 
-#: argp/argp-parse.c:164
-msgid "(PROGRAM ERROR) No version known!?"
-msgstr "(ERRO DE PROGRAMA) Verso desconhecida!?"
+#: elf/dl-error-skeleton.c:113
+msgid "DYNAMIC LINKER BUG!!!"
+msgstr "ERRO NO VINCULADOR DINÂMICO!!!"
 
-#: argp/argp-parse.c:781
-msgid "(PROGRAM ERROR) Option should have been recognized!?"
-msgstr "(ERRO DE PROGRAMA) Opo deveria ter sido reconhecida!?"
+#: elf/dl-fptr.c:88 sysdeps/hppa/dl-fptr.c:95
+msgid "cannot map pages for fdesc table"
+msgstr "não foi possível mapear as páginas para tabela de fdesc"
 
-#: nis/nis_print.c:129
-msgid "(Unknown object)\n"
-msgstr "(Objeto  desconhecido)\n"
+#: elf/dl-fptr.c:192 sysdeps/hppa/dl-fptr.c:213
+msgid "cannot map pages for fptr table"
+msgstr "não foi possível mapear as páginas para tabela de fptr"
 
-#: sunrpc/clnt_perr.c:124
-#, c-format
-msgid "(unknown authentication error - %d)"
-msgstr "(erro de autenticao desconhecido - %d)"
+#: elf/dl-fptr.c:221 sysdeps/hppa/dl-fptr.c:242
+msgid "internal error: symidx out of range of fptr table"
+msgstr "erro interno: symidx fora de alcance da tabela fptr"
 
-#: sunrpc/rpcinfo.c:613
-msgid "(unknown)"
-msgstr "(desconhecido)"
+#: elf/dl-hwcaps.c:202 elf/dl-hwcaps.c:214
+msgid "cannot create capability list"
+msgstr "não foi possível criar lista de capacidades"
 
-#: elf/sprof.c:574
-#, c-format
-msgid "*** The file `%s' is stripped: no detailed analysis possible\n"
-msgstr "*** O arquivo  `%s' est sem smbolos (stripped): a anlise detalhada  impossvel\n"
+#: elf/dl-load.c:369
+msgid "cannot allocate name record"
+msgstr "não foi possível alocar registro de nome"
 
-#: catgets/gencat.c:266
-msgid "*standard input*"
-msgstr "*entrada padro*"
+#: elf/dl-load.c:455 elf/dl-load.c:568 elf/dl-load.c:657 elf/dl-load.c:753
+msgid "cannot create cache for search path"
+msgstr "não foi possível criar socket para caminho de pesquisa"
 
-#: catgets/gencat.c:120
-msgid ""
-"-o OUTPUT-FILE [INPUT-FILE]...\n"
-"[OUTPUT-FILE [INPUT-FILE]...]"
-msgstr ""
-"-o ARQUIVO-SADA [ARQUIVO-ENTRADA]...\n"
-"[ARQUIVO-SADA [ARQUIVO-ENTRADA...]"
+#: elf/dl-load.c:551
+msgid "cannot create RUNPATH/RPATH copy"
+msgstr "não foi possível criar cópia de RUNPATH/RPATH"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:778
-msgid ".lib section in a.out corrupted"
-msgstr "seo .lib corrompida em a.out"
+#: elf/dl-load.c:644
+msgid "cannot create search path array"
+msgstr "não foi possível criar vetor de caminho de pesquisa"
 
-#: sunrpc/clnt_perr.c:110 sunrpc/clnt_perr.c:131
-#, c-format
-msgid "; low version = %lu, high version = %lu"
-msgstr "; verso baixa = %lu, verso alta = %lu"
+#: elf/dl-load.c:825
+msgid "cannot stat shared object"
+msgstr "não foi possível obter estado do objeto compartilhado"
 
-#: sunrpc/clnt_perr.c:117
-msgid "; why = "
-msgstr "; porque = "
+#: elf/dl-load.c:902
+msgid "cannot open zero fill device"
+msgstr "não foi possível abrir dispositivo preenchido com zero"
 
-#: locale/programs/charset.c:98
-#, c-format
-msgid "<%s> and <%s> are illegal names for range"
-msgstr "<%s> e <%s> so nomes ilegais para faixa de caracteres"
+#: elf/dl-load.c:949 elf/dl-load.c:2125
+msgid "cannot create shared object descriptor"
+msgstr "não foi possível criar descritor de objeto compartilhado"
 
-#: locale/programs/ld-ctype.c:342
-#, c-format
-msgid "<SP> character must not be in class `%s'"
-msgstr "<SP> caracter no deve estar na classe `%s'"
+#: elf/dl-load.c:968 elf/dl-load.c:1499 elf/dl-load.c:1611
+msgid "cannot read file data"
+msgstr "não foi possível carregar dados do arquivo"
 
-#: locale/programs/ld-ctype.c:330
-#, c-format
-msgid "<SP> character not in class `%s'"
-msgstr "<SP> caracter no est na classe `%s'"
+#: elf/dl-load.c:1014
+msgid "ELF load command alignment not page-aligned"
+msgstr "alinhamento de comando de carregamento de ELF não está alinhado por página"
 
-#. TRANS The experienced user will know what is wrong.
-#. TRANS @c This error code is a joke.  Its perror text is part of the joke.
-#. TRANS @c Don't change it.
-#: stdio-common/../sysdeps/gnu/errlist.c:603
-msgid "?"
-msgstr "?"
+#: elf/dl-load.c:1021
+msgid "ELF load command address/offset not properly aligned"
+msgstr "endereço/deslocamento de comando de carregamento de ELF não alinhado adequadamente"
 
-#: sysdeps/unix/sysv/linux/siglist.h:27
-msgid "Aborted"
-msgstr "Abortado"
+#: elf/dl-load.c:1106
+msgid "object file has no loadable segments"
+msgstr "arquivo de objeto não possui segmentos carregáveis"
 
-#: nis/nis_print.c:318
-msgid "Access Rights : "
-msgstr "Direitos de Acesso : "
+#: elf/dl-load.c:1115 elf/dl-load.c:1591
+msgid "cannot dynamically load executable"
+msgstr "não foi possível carregar dinamicamente o executável"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:774
-msgid "Accessing a corrupted shared library"
-msgstr "Acessando uma biblioteca compartilhado corrompida"
+#: elf/dl-load.c:1136
+msgid "object file has no dynamic section"
+msgstr "arquivo de objeto não possui seção dinâmica"
 
-#. TRANS The requested socket address is already in use.  @xref{Socket Addresses}.
-#: stdio-common/../sysdeps/gnu/errlist.c:366
-msgid "Address already in use"
-msgstr "Endereo j em uso"
+#: elf/dl-load.c:1159
+msgid "shared object cannot be dlopen()ed"
+msgstr "objeto compartilhado não pode ser dlopen()ado"
 
-#: posix/../sysdeps/posix/gai_strerror.c:30
-msgid "Address family for hostname not supported"
-msgstr "Famlia de endereos no suportada para nome de mquina"
+#: elf/dl-load.c:1172
+msgid "cannot allocate memory for program header"
+msgstr "não foi possível alocar memória para cabeçalho do programa"
 
-#. TRANS The address family specified for a socket is not supported; it is
-#. TRANS inconsistent with the protocol being used on the socket.  @xref{Sockets}.
-#: stdio-common/../sysdeps/gnu/errlist.c:361
-msgid "Address family not supported by protocol"
-msgstr "Famlia de endereos no suportada pelo protocolo"
+#: elf/dl-load.c:1188 elf/dl-open.c:193
+msgid "invalid caller"
+msgstr "chamador inválido"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:742
-msgid "Advertise error"
-msgstr "Erro de aviso"
+#: elf/dl-load.c:1211 elf/dl-load.h:130
+msgid "cannot change memory protections"
+msgstr "não é possível alterar proteções de memória"
 
-#: stdio-common/../sysdeps/unix/siglist.c:39
-#: sysdeps/unix/sysv/linux/siglist.h:33
-msgid "Alarm clock"
-msgstr "Alarme de tempo"
+#: elf/dl-load.c:1231
+msgid "cannot enable executable stack as shared object requires"
+msgstr "não foi possível habilitar pilhas de executável como requisitado pelo objeto compartilhado"
 
-#. TRANS Argument list too long; used when the arguments passed to a new program
-#. TRANS being executed with one of the @code{exec} functions (@pxref{Executing a
-#. TRANS File}) occupy too much memory space.  This condition never arises in the
-#. TRANS GNU system.
-#: stdio-common/../sysdeps/gnu/errlist.c:69
-msgid "Argument list too long"
-msgstr "Lista de argumentos muito longa"
+#: elf/dl-load.c:1244
+msgid "cannot close file descriptor"
+msgstr "não é possível fechar o descritor de arquivo"
 
-#: nis/nis_error.c:65
-msgid "Attempt to remove a non-empty table"
-msgstr "Tentativa de remoo de uma tabela que no est vazia"
+#: elf/dl-load.c:1499
+msgid "file too short"
+msgstr "arquivo pequeno demais"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:782
-msgid "Attempting to link in too many shared libraries"
-msgstr "Tentando o link em muitas bibliotecas compartilhadas"
+#: elf/dl-load.c:1534
+msgid "invalid ELF header"
+msgstr "cabeçalho de ELF inválido"
 
-#: sunrpc/clnt_perr.c:273
-msgid "Authentication OK"
-msgstr "Autenticao OK"
+#: elf/dl-load.c:1546
+msgid "ELF file data encoding not big-endian"
+msgstr "codificação de dados de arquivo ELF não é big-endian"
 
-#. TRANS ???
-#: stdio-common/../sysdeps/gnu/errlist.c:561
-msgid "Authentication error"
-msgstr "Erro de autenticao"
+#: elf/dl-load.c:1548
+msgid "ELF file data encoding not little-endian"
+msgstr "codificação de dados de arquivo ELF não é little-endian"
 
-#: nis/nis_print.c:105
-msgid "BOGUS OBJECT\n"
-msgstr "OBJETO FALSO\n"
+#: elf/dl-load.c:1552
+msgid "ELF file version ident does not match current one"
+msgstr "identificação de versão de arquivo ELF não corresponde ao atual"
 
-#. TRANS Bad address; an invalid pointer was detected.
-#. TRANS In the GNU system, this error never happens; you get a signal instead.
-#: stdio-common/../sysdeps/gnu/errlist.c:114
-msgid "Bad address"
-msgstr "Endereo invlido"
+#: elf/dl-load.c:1556
+msgid "ELF file OS ABI invalid"
+msgstr "ABI de SO do arquivo ELF inválido"
 
-#. TRANS Bad file descriptor; for example, I/O on a descriptor that has been
-#. TRANS closed or reading from a descriptor open only for writing (or vice
-#. TRANS versa).
-#: stdio-common/../sysdeps/gnu/errlist.c:82
-msgid "Bad file descriptor"
-msgstr "Descritor de arquivo invlido"
+#: elf/dl-load.c:1559
+msgid "ELF file ABI version invalid"
+msgstr "versão de ABI do arquivo ELF inválido"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:730
-msgid "Bad font file format"
-msgstr "Formato do arquivo fonte invlido "
+#: elf/dl-load.c:1562
+msgid "nonzero padding in e_ident"
+msgstr "espaçamento não-zero em e_ident"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:622
-msgid "Bad message"
-msgstr "Mensagem invlida"
+#: elf/dl-load.c:1565
+msgid "internal error"
+msgstr "erro interno"
 
-#: stdio-common/../sysdeps/unix/siglist.c:37
-#: sysdeps/unix/sysv/linux/siglist.h:56
-msgid "Bad system call"
-msgstr "Chamada de sistema invlida"
+#: elf/dl-load.c:1572
+msgid "ELF file version does not match current one"
+msgstr "versão de arquivo ELF não corresponde à atual"
 
-#: posix/../sysdeps/posix/gai_strerror.c:32
-msgid "Bad value for ai_flags"
-msgstr "Valor invlido para ai_flags"
-
-#: locale/programs/localedef.c:104
-msgid "Be strictly POSIX conform"
-msgstr "Se extremamente compatvel com o POSIX"
+#: elf/dl-load.c:1580
+msgid "only ET_DYN and ET_EXEC can be loaded"
+msgstr "apenas ET_DYN e ET_EXEC podem ser carregados"
 
-#: nis/nis_print.c:301
-msgid "Binary data\n"
-msgstr "Dados binrios\n"
+#: elf/dl-load.c:1596
+msgid "ELF file's phentsize not the expected size"
+msgstr "phentsize do arquivo ELF não está no tamanho esperado"
 
-#. TRANS A file that isn't a block special file was given in a situation that
-#. TRANS requires one.  For example, trying to mount an ordinary file as a file
-#. TRANS system in Unix gives this error.
-#: stdio-common/../sysdeps/gnu/errlist.c:121
-msgid "Block device required"
-msgstr "Dispositivo de bloco requerido"
+#: elf/dl-load.c:2144
+msgid "wrong ELF class: ELFCLASS64"
+msgstr "classe ELF errada: ELFCLASS64"
 
-#: sunrpc/pmap_rmt.c:347
-msgid "Broadcast poll problem"
-msgstr "Problema em select para broadcast"
+#: elf/dl-load.c:2145
+msgid "wrong ELF class: ELFCLASS32"
+msgstr "classe ELF errada: ELFCLASS32"
 
-#. TRANS Broken pipe; there is no process reading from the other end of a pipe.
-#. TRANS Every library function that returns this error code also generates a
-#. TRANS @code{SIGPIPE} signal; this signal terminates the program if not handled
-#. TRANS or blocked.  Thus, your program will never actually see @code{EPIPE}
-#. TRANS unless it has handled or blocked @code{SIGPIPE}.
-#: stdio-common/../sysdeps/gnu/errlist.c:234
-#: stdio-common/../sysdeps/unix/siglist.c:38
-#: sysdeps/unix/sysv/linux/siglist.h:32
-msgid "Broken pipe"
-msgstr "Pipe quebrado"
+#: elf/dl-load.c:2148
+msgid "cannot open shared object file"
+msgstr "não é possível abrir arquivo compartilhado"
 
-#: stdio-common/../sysdeps/unix/siglist.c:35
-#: sysdeps/unix/sysv/linux/siglist.h:30
-msgid "Bus error"
-msgstr "Erro no barramento"
+#: elf/dl-load.h:128
+msgid "failed to map segment from shared object"
+msgstr "falha no mapeamento de segmento do objeto compartilhado"
 
-#: nis/nis_print.c:45
-msgid "CDS"
-msgstr "CDS"
+#: elf/dl-load.h:132
+msgid "cannot map zero-fill pages"
+msgstr "não é possível mapear páginas preenchidas com zero"
 
-#: stdio-common/../sysdeps/unix/siglist.c:49
-#: sysdeps/unix/sysv/linux/siglist.h:43
-msgid "CPU time limit exceeded"
-msgstr "Tempo de CPU excedido"
+#: elf/dl-lookup.c:834
+msgid "relocation error"
+msgstr "erro de realocação"
 
-#: nis/nis_error.c:32
-msgid "Cache expired"
-msgstr "Tempo expirado"
+#: elf/dl-lookup.c:857
+msgid "symbol lookup error"
+msgstr "erro de procura por símbolo"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:770
-msgid "Can not access a needed shared library"
-msgstr "No foi possvel acessar uma biblioteca compartilhada"
+#: elf/dl-open.c:101
+msgid "cannot extend global scope"
+msgstr "não foi possível estender escopo global"
 
-#: nis/ypclnt.c:769
-msgid "Can't bind to server which serves this domain"
-msgstr "No posso executar bind com o servidor deste domnio"
+#: elf/dl-open.c:475
+msgid "TLS generation counter wrapped!  Please report this."
+msgstr "Contador de geração TLS envolto! Por favor, relate isso."
 
-#: nis/ypclnt.c:781
-msgid "Can't communicate with portmapper"
-msgstr "No foi possvel comunicar-se com o portmapper"
+#: elf/dl-open.c:539
+msgid "invalid mode for dlopen()"
+msgstr "modo inválido para dlopen()"
 
-#: nis/ypclnt.c:783
-msgid "Can't communicate with ypbind"
-msgstr "No foi possvel comunicar-se com o ypbind"
+#: elf/dl-open.c:556
+msgid "no more namespaces available for dlmopen()"
+msgstr "não há mais espaços de nomes disponíveis para dlmopen()"
 
-#: nis/ypclnt.c:785
-msgid "Can't communicate with ypserv"
-msgstr "No foi possvel comunicar-se com o ypserv"
+#: elf/dl-open.c:580
+msgid "invalid target namespace in dlmopen()"
+msgstr "espaço de nomes de alvo inválido em dlmopen()"
 
-#. TRANS No memory available.  The system cannot allocate more virtual memory
-#. TRANS because its capacity is full.
-#: stdio-common/../sysdeps/gnu/errlist.c:103
-msgid "Cannot allocate memory"
-msgstr "No foi possvel alocar memria"
+#: elf/dl-reloc.c:120
+msgid "cannot allocate memory in static TLS block"
+msgstr "não foi possível alocar memória em bloco TLS estático"
 
-#. TRANS The requested socket address is not available; for example, you tried
-#. TRANS to give a socket a name that doesn't match the local host name.
-#. TRANS @xref{Socket Addresses}.
-#: stdio-common/../sysdeps/gnu/errlist.c:373
-msgid "Cannot assign requested address"
-msgstr "No foi possvel acessar o endereo requisitado"
+#: elf/dl-reloc.c:205
+msgid "cannot make segment writable for relocation"
+msgstr "não foi possível fazer segmento gravável para realocação"
 
-#: sunrpc/pmap_rmt.c:264
-msgid "Cannot create socket for broadcast rpc"
-msgstr "No  possvel criar socket para rpc de broadcast"
+#: elf/dl-reloc.c:276
+#, c-format
+msgid "%s: out of memory to store relocation results for %s\n"
+msgstr "%s: memória insuficiente para armazenar resultados de realocação para %s\n"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:786
-msgid "Cannot exec a shared library directly"
-msgstr "No foi possvel executar uma biblioteca compartilhado diretamente"
+#: elf/dl-reloc.c:292
+msgid "cannot restore segment prot after reloc"
+msgstr "não foi possível restaurar proteção de segmento após realocação"
 
-#: sunrpc/rpc_main.c:1406
-msgid "Cannot have more than one file generation flag!\n"
-msgstr "No  possvel ter mais de um indicador de gerao de arquivo!\n"
+#: elf/dl-reloc.c:323
+msgid "cannot apply additional memory protection after relocation"
+msgstr "não foi possível aplicar proteção de memória adicional após realocação"
 
-#: sunrpc/pmap_rmt.c:360
-msgid "Cannot receive reply to broadcast"
-msgstr "No foi possvel receber resposta para broadcast"
+#: elf/dl-sym.c:136
+msgid "RTLD_NEXT used in code not dynamically loaded"
+msgstr "RTLD_NEXT usado em código não dinamicamente carregado"
 
-#: sunrpc/pmap_clnt.c:74
-msgid "Cannot register service"
-msgstr "No foi possvel registrar servio"
+#: elf/dl-tls.c:931
+msgid "cannot create TLS data structures"
+msgstr "não é possível criar estruturas de dados TLS"
 
-#. TRANS The socket has already been shut down.
-#: stdio-common/../sysdeps/gnu/errlist.c:434
-msgid "Cannot send after transport endpoint shutdown"
-msgstr "No  possvel enviar aps desligamento do ponto final de transporte"
+#: elf/dl-version.c:148
+msgid "version lookup error"
+msgstr "erro na procura por versão"
 
-#: sunrpc/pmap_rmt.c:322
-msgid "Cannot send broadcast packet"
-msgstr "No foi possvel enviar pacote de broadcast"
+#: elf/dl-version.c:279
+msgid "cannot allocate version reference table"
+msgstr "não foi possível alocar tabela de referência de versão"
 
-#: sunrpc/pmap_rmt.c:271
-msgid "Cannot set socket option SO_BROADCAST"
-msgstr "No foi possvel usar opo do socket SO_BROADCAST"
+#: elf/ldconfig.c:142
+msgid "Print cache"
+msgstr "Mostra o cache"
 
-#: sunrpc/rpc_main.c:1193
-msgid "Cannot specify more than one input file!\n"
-msgstr "Nao  possvel especificar mais de um arquivo de entrada!\n"
+#: elf/ldconfig.c:143
+msgid "Generate verbose messages"
+msgstr "Gera mensagens detalhadas"
 
-#: sunrpc/rpc_main.c:1363
-msgid "Cannot use netid flag with inetd flag!\n"
-msgstr "No  possvel user tabela de indicadores com novo estilo!\n"
+#: elf/ldconfig.c:144
+msgid "Don't build cache"
+msgstr "Não compila o cache"
 
-#: sunrpc/rpc_main.c:1375
-msgid "Cannot use netid flag without TIRPC!\n"
-msgstr "No  possvel usar indicador netid sem TIRPC!\n"
+#: elf/ldconfig.c:145
+msgid "Don't update symbolic links"
+msgstr "Não atualiza links simbólicos"
 
-#: sunrpc/rpc_main.c:1382
-msgid "Cannot use table flags with newstyle!\n"
-msgstr "No  possvel usar indicadores de tabelas com novo estilo!\n"
+#: elf/ldconfig.c:146
+msgid "Change to and use ROOT as root directory"
+msgstr "Muda para e usa ROOT como diretório raiz"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:670
-msgid "Channel number out of range"
-msgstr "Nmero do canal fora do intervalo"
+#: elf/ldconfig.c:146
+msgid "ROOT"
+msgstr "ROOT"
 
-#: nis/nis_print.c:264
-#, c-format
-msgid "Character Separator : %c\n"
-msgstr "Separador de caracteres \"%c\n"
+#: elf/ldconfig.c:147
+msgid "CACHE"
+msgstr "CACHE"
 
-#: stdio-common/../sysdeps/unix/siglist.c:45
-#: sysdeps/unix/sysv/linux/siglist.h:39
-msgid "Child exited"
-msgstr "Filho finalizado"
+#: elf/ldconfig.c:147
+msgid "Use CACHE as cache file"
+msgstr "Usa CACHE como arquivo de cache"
 
-#: sunrpc/clnt_perr.c:283
-msgid "Client credential too weak"
-msgstr "Credencial do cliente muito fraca"
+#: elf/ldconfig.c:148
+msgid "CONF"
+msgstr "CONF"
 
-#: nis/nis_print.c:266
-msgid "Columns             :\n"
-msgstr "Colunas             :\n"
+#: elf/ldconfig.c:148
+msgid "Use CONF as configuration file"
+msgstr "Usa CONF como arquivo de configuração"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:750
-msgid "Communication error on send"
-msgstr "Erro de communicao ao enviar"
+#: elf/ldconfig.c:149
+msgid "Only process directories specified on the command line.  Don't build cache."
+msgstr "Processa apenas diretórios especificados na linha de comando. Não compila o cache."
 
-#: locale/programs/localedef.c:112
-msgid "Compile locale specification"
-msgstr "Compila especificao localizada"
+#: elf/ldconfig.c:150
+msgid "Manually link individual libraries."
+msgstr "Vincula manualmente bibliotecas individuais."
 
-#. TRANS Go home and have a glass of warm, dairy-fresh milk.
-#: stdio-common/../sysdeps/gnu/errlist.c:613
-msgid "Computer bought the farm"
-msgstr "O computador comprou a fazenda"
+#: elf/ldconfig.c:151
+msgid "FORMAT"
+msgstr "FORMATO"
 
-#: locale/programs/ld-ctype.c:1253
-msgid "Computing table size for character classes might take a while..."
-msgstr "O clculo do tamanho da tabela de classes de caracteres pode demorar..."
+#: elf/ldconfig.c:151
+msgid "Format to use: new, old or compat (default)"
+msgstr "Formato para usar: new, old ou compat (padrão)"
 
-#: locale/programs/ld-collate.c:336
-msgid "Computing table size for collation information might take a while..."
-msgstr "O clculo do tamanho da tabela de informaes de comparao (collation) pode demorar..."
+#: elf/ldconfig.c:152
+msgid "Ignore auxiliary cache file"
+msgstr "Ignora arquivo de cache auxiliar"
 
-#. TRANS A remote host refused to allow the network connection (typically because
-#. TRANS it is not running the requested service).
-#: stdio-common/../sysdeps/gnu/errlist.c:451
-msgid "Connection refused"
-msgstr "Conexo recusada"
+#: elf/ldconfig.c:160
+msgid "Configure Dynamic Linker Run Time Bindings."
+msgstr "Configura associações de tempo real do vinculador dinâmico."
 
-#. TRANS A network connection was closed for reasons outside the control of the
-#. TRANS local host, such as by the remote machine rebooting or an unrecoverable
-#. TRANS protocol violation.
-#: stdio-common/../sysdeps/gnu/errlist.c:401
-msgid "Connection reset by peer"
-msgstr "Conexo fechada pela outra ponta"
+#: elf/ldconfig.c:347
+#, c-format
+msgid "Path `%s' given more than once"
+msgstr "Caminho “%s” fornecido mais de uma vez"
 
-#. TRANS A socket operation with a specified timeout received no response during
-#. TRANS the timeout period.
-#: stdio-common/../sysdeps/gnu/errlist.c:445
-msgid "Connection timed out"
-msgstr "Tempo esgotado para conexo"
+#: elf/ldconfig.c:387
+#, c-format
+msgid "%s is not a known library type"
+msgstr "%s não é um tipo de memória conhecida"
 
-#: stdio-common/../sysdeps/unix/siglist.c:44
-#: sysdeps/unix/sysv/linux/siglist.h:38
-msgid "Continued"
-msgstr "Continua"
+#: elf/ldconfig.c:415
+#, c-format
+msgid "Can't stat %s"
+msgstr "Não foi possível obter estado de %s"
 
-#: iconv/iconv_prog.c:66
-msgid "Convert encoding of given files from one encoding to another."
-msgstr "Converte codificao dos arquivos dados de uma codificao para outra."
+#: elf/ldconfig.c:489
+#, c-format
+msgid "Can't stat %s\n"
+msgstr "Não foi possível obter estado de %s\n"
 
-#: db2/makedb.c:58
-msgid "Convert key to lower case"
-msgstr "Converte chave para letras minsculas"
+#: elf/ldconfig.c:499
+#, c-format
+msgid "%s is not a symbolic link\n"
+msgstr "%s não é um link simbólico\n"
 
-#: catgets/gencat.c:236 db2/makedb.c:242 elf/sprof.c:359
-#: iconv/iconv_prog.c:294 locale/programs/locale.c:267
-#: locale/programs/localedef.c:403 nscd/nscd.c:223 nss/getent.c:65
-#: posix/getconf.c:624
+#: elf/ldconfig.c:518
 #, c-format
-msgid ""
-"Copyright (C) %s Free Software Foundation, Inc.\n"
-"This is free software; see the source for copying conditions.  There is NO\n"
-"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"
-msgstr ""
-"Copyright (C) %s Free Software Foundation, Inc.\n"
-"Este  um software free; leia os fontes para condices de cpia. No existe\n"
-"garantia; nem para comrcio ou adequaco para propstios particulares.\n"
+msgid "Can't unlink %s"
+msgstr "Não foi possível desvincular %s"
 
-#: nscd/nscd_conf.c:167
+#: elf/ldconfig.c:524
 #, c-format
-msgid "Could not create log file \"%s\""
-msgstr "no  possvel ler arquivo de registro \"%s\""
+msgid "Can't link %s to %s"
+msgstr "Não foi possível vincular %s a %s"
 
-#: catgets/gencat.c:107
-msgid "Create C header file NAME containing symbol definitions"
-msgstr "Cria arquivo NOME com cabealho C contendo definies de smbolos "
+# link alterado
+#: elf/ldconfig.c:530
+msgid " (changed)\n"
+msgstr " (alterado)\n"
 
-#: locale/programs/localedef.c:103
-msgid "Create output even if warning messages were issued"
-msgstr "Cria sada mesmo que mensagens de aviso forem produzidas"
+# link ignorado
+#: elf/ldconfig.c:532
+msgid " (SKIPPED)\n"
+msgstr " (IGNORADO)\n"
 
-#: db2/makedb.c:68
-msgid "Create simple DB database from textual input."
-msgstr "Cria um base de dados DB simples de uma entrada textual."
+#: elf/ldconfig.c:587
+#, c-format
+msgid "Can't find %s"
+msgstr "Não foi possível localizar %s"
 
-#: nis/nis_print.c:322
+# `lstat' similar a stat(), mas para links; `stat' = obtém estado de arquivo
+#: elf/ldconfig.c:603 elf/ldconfig.c:769 elf/ldconfig.c:825 elf/ldconfig.c:857
 #, c-format
-msgid "Creation Time : %s"
-msgstr "Horrio de criao : %s"
+msgid "Cannot lstat %s"
+msgstr "Não foi possível obter estado do link %s"
 
-#: nis/nss_nisplus/nisplus-publickey.c:89
-#: nis/nss_nisplus/nisplus-publickey.c:159
+#: elf/ldconfig.c:610
 #, c-format
-msgid "DES entry for netname %s not unique\n"
-msgstr "Entrada DES para nome de rede (netname) %s no  nica\n"
+msgid "Ignored file %s since it is not a regular file."
+msgstr "Arquivo %s ignorado já que agora não é mais um arquivo comum."
 
-#: nis/nis_print.c:111
-msgid "DIRECTORY\n"
-msgstr "DIRETRIO\n"
+#: elf/ldconfig.c:619
+#, c-format
+msgid "No link created since soname could not be found for %s"
+msgstr "Nenhum link foi criado porque um soname não foi encontrado para %s"
 
-#: nis/nis_print.c:41
-msgid "DNANS"
-msgstr "DNANS"
+#: elf/ldconfig.c:702
+#, c-format
+msgid "Can't open directory %s"
+msgstr "Não foi possível abrir o diretório %s"
 
-#: nis/nis_print.c:37
-msgid "DNS"
-msgstr "DNS"
+#: elf/ldconfig.c:787 elf/ldconfig.c:845 elf/readlib.c:97
+#, c-format
+msgid "Input file %s not found.\n"
+msgstr "Arquivo de entrada %s não foi localizado.\n"
 
-#: nis/nis_error.c:51
-msgid "Database for table does not exist"
-msgstr "Base de dados para tabela no existe"
+#: elf/ldconfig.c:794
+#, c-format
+msgid "Cannot stat %s"
+msgstr "Não foi possível obter estado do arquivo %s"
 
-#: nis/ypclnt.c:795
-msgid "Database is busy"
-msgstr "Base de dados est ocupada"
+#: elf/ldconfig.c:939
+#, c-format
+msgid "libc5 library %s in wrong directory"
+msgstr "biblioteca libc5 %s em diretório errado"
 
-#: nis/nis_print.c:225
-msgid "Default Access rights :\n"
-msgstr "Direitos de Acesso padro :\n"
+#: elf/ldconfig.c:942
+#, c-format
+msgid "libc6 library %s in wrong directory"
+msgstr "biblioteca libc6 %s em diretório errado"
 
-#. TRANS No default destination address was set for the socket.  You get this
-#. TRANS error when you try to transmit data over a connectionless socket,
-#. TRANS without first specifying a destination for the data with @code{connect}.
-#: stdio-common/../sysdeps/gnu/errlist.c:429
-msgid "Destination address required"
-msgstr "Endereo de destino requerido"
+#: elf/ldconfig.c:945
+#, c-format
+msgid "libc4 library %s in wrong directory"
+msgstr "biblioteca libc4 %s em diretório errado"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:650
-msgid "Device not a stream"
-msgstr "Dispositivo no  um stream"
+#: elf/ldconfig.c:973
+#, c-format
+msgid "libraries %s and %s in directory %s have same soname but different type."
+msgstr "bibliotecas %s e %s no diretório %s possuem o mesmo soname, mas tipos diferentes."
 
-#. TRANS No such device or address.  The system tried to use the device
-#. TRANS represented by a file you specified, and it couldn't find the device.
-#. TRANS This can mean that the device file was installed incorrectly, or that
-#. TRANS the physical device is missing or not correctly attached to the
-#. TRANS computer.
-#: stdio-common/../sysdeps/gnu/errlist.c:61
-msgid "Device not configured"
-msgstr "Dispositivo no configurado"
+#: elf/ldconfig.c:1082
+#, c-format
+msgid "Warning: ignoring configuration file that cannot be opened: %s"
+msgstr "Aviso: ignorando arquivo de configuração que não pode ser aberto: %s"
 
-#. TRANS Resource busy; a system resource that can't be shared is already in use.
-#. TRANS For example, if you try to delete a file that is the root of a currently
-#. TRANS mounted filesystem, you get this error.
-#: stdio-common/../sysdeps/gnu/errlist.c:128
-msgid "Device or resource busy"
-msgstr "Dispositivo ou recurso est ocupado"
+#: elf/ldconfig.c:1148
+#, c-format
+msgid "%s:%u: bad syntax in hwcap line"
+msgstr "%s:%u: sintaxe incorreta na linha hwcap"
 
-#: nis/nis_print.c:179
+#: elf/ldconfig.c:1154
 #, c-format
-msgid "Diffie-Hellmann (%d bits)\n"
-msgstr "Diffie-Hellmann (%d bits)\n"
+msgid "%s:%u: hwcap index %lu above maximum %u"
+msgstr "%s:%u: índica de hwcap %lu acima do máximo %u"
 
-#: nis/nis_print.c:315
+#: elf/ldconfig.c:1161 elf/ldconfig.c:1169
 #, c-format
-msgid "Directory     : %s\n"
-msgstr "Diretrio     : %s\n"
+msgid "%s:%u: hwcap index %lu already defined as %s"
+msgstr "%s:%u: índice de hwcap %lu já definido como %s"
 
-#. TRANS Directory not empty, where an empty directory was expected.  Typically,
-#. TRANS this error occurs when you are trying to delete a directory.
-#: stdio-common/../sysdeps/gnu/errlist.c:480
-msgid "Directory not empty"
-msgstr "Diretrio no vazio"
+#: elf/ldconfig.c:1172
+#, c-format
+msgid "%s:%u: duplicate hwcap %lu %s"
+msgstr "%s:%u: hwcap %lu duplicado %s"
 
-#. TRANS The user's disk quota was exceeded.
-#: stdio-common/../sysdeps/gnu/errlist.c:498
-msgid "Disc quota exceeded"
-msgstr "Cota de disco excedida"
+#: elf/ldconfig.c:1194
+#, c-format
+msgid "need absolute file name for configuration file when using -r"
+msgstr "necessita de nome de arquivo absoluto para arquivo de configuração quando usado -r"
 
-#: nscd/nscd.c:80
-msgid "Do not fork and display messages on the current tty"
-msgstr "No divide (fork) e mostre mensagens na tty corrente"
+#: elf/ldconfig.c:1201 locale/programs/xmalloc.c:63 malloc/obstack.c:416
+#: malloc/obstack.c:418 posix/getconf.c:458 posix/getconf.c:697
+#, c-format
+msgid "memory exhausted"
+msgstr "memória esgotada"
 
-#: db2/makedb.c:61
-msgid "Do not print messages while building database"
-msgstr "No mostra mensagens enquanto constri base de dados"
+#: elf/ldconfig.c:1233
+#, c-format
+msgid "%s:%u: cannot read directory %s"
+msgstr "%s:%u: não foi possível ler diretório %s"
 
-#: catgets/gencat.c:109
-msgid "Do not use existing catalog, force new output file"
-msgstr "No usar catlogo existente, forar novo arquivo de sada"
+#: elf/ldconfig.c:1281
+#, c-format
+msgid "relative path `%s' used to build cache"
+msgstr "caminho relativo “%s” usado para compilar o cache"
 
-#: nis/ypclnt.c:841
-msgid "Domain not bound"
-msgstr "Domnio no limitado (not bound)"
+#: elf/ldconfig.c:1311
+#, c-format
+msgid "Can't chdir to /"
+msgstr "Não foi possível mudar o diretório para /"
 
-#: stdio-common/../sysdeps/unix/siglist.c:32
-#: sysdeps/unix/sysv/linux/siglist.h:53
-msgid "EMT trap"
-msgstr "trap EMT"
+#: elf/ldconfig.c:1352
+#, c-format
+msgid "Can't open cache file directory %s\n"
+msgstr "Não foi possível abrir o diretório de arquivo cache %s\n"
 
-#: nis/nis_print.c:120
-msgid "ENTRY\n"
-msgstr "ENTRADA\n"
+#: elf/ldd.bash.in:42
+msgid "Written by %s and %s.\n"
+msgstr "Escrito por %s e %s.\n"
 
-#: nis/nis_print.c:299
-msgid "Encrypted data\n"
-msgstr "Dado criptografado\n"
+#: elf/ldd.bash.in:47
+msgid ""
+"Usage: ldd [OPTION]... FILE...\n"
+"      --help              print this help and exit\n"
+"      --version           print version information and exit\n"
+"  -d, --data-relocs       process data relocations\n"
+"  -r, --function-relocs   process data and function relocations\n"
+"  -u, --unused            print unused direct dependencies\n"
+"  -v, --verbose           print all information\n"
+msgstr ""
+"Uso: ldd [OPÇÃO]... ARQUIVO...\n"
+"      --help              exibe essa ajuda e sai\n"
+"      --version           exibe informação da versão e sai\n"
+"  -d, --data-relocs       processa realocações de dados\n"
+"  -r, --function-relocs   processa realocações de dados e funções\n"
+"  -u, --unused            exibe dependências diretas não usadas\n"
+"  -v, --verbose           exibe todas informações\n"
+
+#: elf/ldd.bash.in:80
+msgid "ldd: option \\`$1' is ambiguous"
+msgstr "ldd: opção “$1” é ambígua"
+
+#: elf/ldd.bash.in:87
+msgid "unrecognized option"
+msgstr "opção não reconhecida"
+
+#: elf/ldd.bash.in:88 elf/ldd.bash.in:125
+msgid "Try \\`ldd --help' for more information."
+msgstr "Tente “ldd --help” para mais informações."
+
+#: elf/ldd.bash.in:124
+msgid "missing file arguments"
+msgstr "faltando argumento ARQUIVO"
+
+#. TRANS This is a ``file doesn't exist'' error
+#. TRANS for ordinary files that are referenced in contexts where they are
+#. TRANS expected to already exist.
+#: elf/ldd.bash.in:147 sysdeps/gnu/errlist.c:37
+msgid "No such file or directory"
+msgstr "Arquivo ou diretório inexistente"
 
-#: nis/nis_error.c:52
-msgid "Entry/Table type mismatch"
-msgstr "Tipo de entrada/tabela incompatveis"
+#: elf/ldd.bash.in:150 inet/rcmd.c:480
+msgid "not regular file"
+msgstr "não é arquivo normal"
 
-#: nis/nis_error.c:56
-msgid "Error in RPC subsystem"
-msgstr "Erro no subsistema RPC"
+# após "for" vem um nome de arquivo
+#: elf/ldd.bash.in:153
+msgid "warning: you do not have execution permission for"
+msgstr "aviso: você não tem permissão para execução para"
 
-#: nis/nis_error.c:66
-msgid "Error in accessing NIS+ cold start file.  Is NIS+ installed?"
-msgstr "Erro acessando arquivo inicial do NIS+. O NIS+ est instalado?"
+#: elf/ldd.bash.in:170
+msgid "\tnot a dynamic executable"
+msgstr "\tnão é um executável dinâmico"
 
-#: string/../sysdeps/mach/_strerror.c:56
-#: sysdeps/mach/hurd/mips/dl-machine.c:67
-msgid "Error in unknown error system: "
-msgstr "Falha no erro desconhecido do sistema: "
+#: elf/ldd.bash.in:178
+msgid "exited with unknown exit code"
+msgstr "saiu com código de saída desconhecido"
 
-#: nis/nis_error.c:59
-msgid "Error while talking to callback proc"
-msgstr "Erro durante a chamada a processo callback"
+# após "for" vem um nome de arquivo
+#: elf/ldd.bash.in:183
+msgid "error: you do not have read permission for"
+msgstr "erro: você não possui permissão de leitura para"
 
-#: inet/ruserpass.c:161
-msgid "Error: .netrc file is readable by others."
-msgstr "Erro: arquivo .netrc  legvel por outros."
+#: elf/pldd-xx.c:105
+#, c-format
+msgid "cannot find program header of process"
+msgstr "não foi possível localizar cabeçalho do programa do processo"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:710
-msgid "Exchange full"
-msgstr "Troca completa"
+#: elf/pldd-xx.c:110
+#, c-format
+msgid "cannot read program header"
+msgstr "não foi possível ler o cabeçalho do programa"
 
-#. TRANS Invalid executable file format.  This condition is detected by the
-#. TRANS @code{exec} functions; see @ref{Executing a File}.
-#: stdio-common/../sysdeps/gnu/errlist.c:75
-msgid "Exec format error"
-msgstr "Erro no formato exec"
+#: elf/pldd-xx.c:135
+#, c-format
+msgid "cannot read dynamic section"
+msgstr "não foi possível ler a seção dinâmica"
 
-#: locale/programs/localedef.c:190
-msgid "FATAL: system does not define `_POSIX2_LOCALEDEF'"
-msgstr "FATAL: sistema no define `_POSIX2_LOCALEDEF'"
+#: elf/pldd-xx.c:147
+#, c-format
+msgid "cannot read r_debug"
+msgstr "não foi possível ler r_debug"
 
-#: locale/programs/localedef.c:99
-msgid "FILE contains mapping from symbolic names to UCS4 values"
-msgstr "ARQUIVO contm mapas de nomes simblicos para valores UCS4"
+#: elf/pldd-xx.c:167
+#, c-format
+msgid "cannot read program interpreter"
+msgstr "não foi possível ler o interpretador de programa"
 
-#: sunrpc/clnt_perr.c:287
-msgid "Failed (unspecified error)"
-msgstr "Falha (erro no especificado)"
+#: elf/pldd-xx.c:197
+#, c-format
+msgid "cannot read link map"
+msgstr "não foi possível ler o mapa de links"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:762
-msgid "File descriptor in bad state"
-msgstr "Descritor de arquivo em mal estado"
+#: elf/pldd-xx.c:209
+#, c-format
+msgid "cannot read object name"
+msgstr "não foi possível ler o nome do objeto"
 
-#. TRANS File exists; an existing file was specified in a context where it only
-#. TRANS makes sense to specify a new file.
-#: stdio-common/../sysdeps/gnu/errlist.c:134
-msgid "File exists"
-msgstr "Arquivo existe"
+#: elf/pldd-xx.c:219
+#, c-format
+msgid "cannot allocate buffer for object name"
+msgstr "não foi possível alocar buffer para o nome de objeto"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:726
-msgid "File locking deadlock error"
-msgstr "Erro de bloqueio em arquivo (deadlock)"
+#: elf/pldd.c:64
+msgid "List dynamic shared objects loaded into process."
+msgstr "Lista objetos compartilhados dinâmicos carregados no processo."
 
-#. TRANS Filename too long (longer than @code{PATH_MAX}; @pxref{Limits for
-#. TRANS Files}) or host name too long (in @code{gethostname} or
-#. TRANS @code{sethostname}; @pxref{Host Identification}).
-#: stdio-common/../sysdeps/gnu/errlist.c:464
-msgid "File name too long"
-msgstr "Nome de arquivo muito longo"
+#: elf/pldd.c:68
+msgid "PID"
+msgstr "PID"
 
-#: stdio-common/../sysdeps/unix/siglist.c:50
-#: sysdeps/unix/sysv/linux/siglist.h:44
-msgid "File size limit exceeded"
-msgstr "Excedido tamanho limite de arquivo"
+#: elf/pldd.c:100
+#, c-format
+msgid "Exactly one parameter with process ID required.\n"
+msgstr "É necessário exatamente um parâmetro com ID de processo.\n"
 
-#. TRANS File too big; the size of a file would be larger than allowed by the system.
-#: stdio-common/../sysdeps/gnu/errlist.c:202
-msgid "File too large"
-msgstr "Arquivo muito grande"
+#: elf/pldd.c:112
+#, c-format
+msgid "invalid process ID '%s'"
+msgstr "ID de processo inválido “%s”"
 
-#: nis/nis_error.c:37
-msgid "First/Next chain broken"
-msgstr "Primeira/prxima corrente quebrada"
+#: elf/pldd.c:120
+#, c-format
+msgid "cannot open %s"
+msgstr "não foi possível abrir %s"
 
-#: stdio-common/../sysdeps/unix/siglist.c:33
-#: sysdeps/unix/sysv/linux/siglist.h:28
-msgid "Floating point exception"
-msgstr "Exceo de ponto flutuante"
+#: elf/pldd.c:152
+#, c-format
+msgid "cannot open %s/task"
+msgstr "não foi possível abrir %s/tarefa"
 
-#: nis/nis_error.c:67
-msgid "Full resync required for directory"
-msgstr "Resincronismo total necessrio para o diretrio"
+#: elf/pldd.c:155
+#, c-format
+msgid "cannot prepare reading %s/task"
+msgstr "não foi possível preparar a leitura de %s/tarefa"
 
-#. TRANS Function not implemented.  Some functions have commands or options defined
-#. TRANS that might not be supported in all implementations, and this is the kind
-#. TRANS of error you get if you request them and they are not supported.
-#: stdio-common/../sysdeps/gnu/errlist.c:573
-msgid "Function not implemented"
-msgstr "Funo no implementada"
+#: elf/pldd.c:168
+#, c-format
+msgid "invalid thread ID '%s'"
+msgstr "ID de thread “%s” inválido"
 
-#: nis/nis_print.c:114
-msgid "GROUP\n"
-msgstr "GRUPO\n"
+#: elf/pldd.c:179
+#, c-format
+msgid "cannot attach to process %lu"
+msgstr "não foi possível anexar ao processado %lu"
 
-#: argp/argp-help.c:231
+#: elf/pldd.c:294
 #, c-format
-msgid "Garbage in ARGP_HELP_FMT: %s"
-msgstr "Lixo em ARGP_HELP_FMT: %s"
+msgid "cannot get information about process %lu"
+msgstr "não foi possível obter informação sobre o processo %lu"
 
-#: catgets/gencat.c:115
-msgid ""
-"Generate message catalog.\\vIf INPUT-FILE is -, input is read from standard input.  If OUTPUT-FILE\n"
-"is -, output is written to standard output.\n"
-msgstr ""
-"Gera catlogo de mensagens.\\vSe ARQUIVO-DE-ENTRADA  -, a entrada  lidada entrada padro.  Se ARQUIVO-DE-SADA\n"
-" -, a sada  escrita para a sada padro.\n"
+#: elf/pldd.c:307
+#, c-format
+msgid "process %lu is no ELF program"
+msgstr "processo %lu não é um programa ELF"
 
-#: nis/nis_error.c:36
-msgid "Generic system error"
-msgstr "Erro desconhecido de sistema"
+#: elf/readelflib.c:34
+#, c-format
+msgid "file %s is truncated\n"
+msgstr "arquivo %s está truncado\n"
 
-#: locale/programs/locale.c:75
-msgid "Get locale-specific information."
-msgstr "Pegar informaes especficas de localizao."
+#: elf/readelflib.c:66
+#, c-format
+msgid "%s is a 32 bit ELF file.\n"
+msgstr "%s é um arquivo ELF de 32 bits.\n"
 
-#: argp/argp-parse.c:88
-msgid "Give a short usage message"
-msgstr "Retorna uma mensagem de uso curta"
+#: elf/readelflib.c:68
+#, c-format
+msgid "%s is a 64 bit ELF file.\n"
+msgstr "%s é um arquivo ELF de 64 bits.\n"
 
-#: argp/argp-parse.c:87
-msgid "Give this help list"
-msgstr "Retorna este arquivo de ajuda"
+#: elf/readelflib.c:70
+#, c-format
+msgid "Unknown ELFCLASS in file %s.\n"
+msgstr "ELFCLASS desconhecida em arquivo %s.\n"
 
-#. TRANS This error code has no purpose.
-#: stdio-common/../sysdeps/gnu/errlist.c:618
-msgid "Gratuitous error"
-msgstr "Erro gratuito"
+#: elf/readelflib.c:77
+#, c-format
+msgid "%s is not a shared object file (Type: %d).\n"
+msgstr "%s não é um arquivo de objeto compartilhado (Tipo: %d).\n"
 
-#: nis/nis_print.c:317
+#: elf/readelflib.c:108
 #, c-format
-msgid "Group         : %s\n"
-msgstr "Grupo         : %s\n"
+msgid "more than one dynamic segment\n"
+msgstr "mais do que um segmento dinâmico\n"
 
-#: nis/nis_print.c:248
-msgid "Group Flags :"
-msgstr "Indicadores de Grupo :"
+#: elf/readlib.c:103
+#, c-format
+msgid "Cannot fstat file %s.\n"
+msgstr "Não é possível obter estado do arquivo %s.\n"
 
-#: nis/nis_print_group_entry.c:113
+#: elf/readlib.c:114
 #, c-format
-msgid "Group entry for \"%s.%s\" group:\n"
-msgstr "Entrada de Grupo para grupo \"%s.%s\":\n"
+msgid "File %s is empty, not checked."
+msgstr "Arquivo %s está vazio, não verificado."
 
-#: argp/argp-parse.c:91
-msgid "Hang for SECS seconds (default 3600)"
-msgstr "Pendurar por SEG segundos (o padro  3600)"
+#: elf/readlib.c:120
+#, c-format
+msgid "File %s is too small, not checked."
+msgstr "Arquivo %s é pequeno demais, não verificado."
 
-#: stdio-common/../sysdeps/unix/siglist.c:26
-#: sysdeps/unix/sysv/linux/siglist.h:22
-msgid "Hangup"
-msgstr "Desconexo"
+#: elf/readlib.c:130
+#, c-format
+msgid "Cannot mmap file %s.\n"
+msgstr "Não foi possível executar mmap no arquivo %s.\n"
 
-#: nscd/grpcache.c:238
+#: elf/readlib.c:169
 #, c-format
-msgid "Haven't found \"%d\" in group cache!"
-msgstr "No encontrado \"%d\" no cache de grupo!"
+msgid "%s is not an ELF file - it has the wrong magic bytes at the start.\n"
+msgstr "%s não é um arquivo ELF – ele tem os magic bytes errados no início.\n"
 
-#: nscd/pwdcache.c:235
+#: elf/sln.c:76
 #, c-format
-msgid "Haven't found \"%d\" in password cache!"
-msgstr "No encontrado \"%d\" no cache de senhas!"
+msgid ""
+"Usage: sln src dest|file\n"
+"\n"
+msgstr ""
+"Uso: sln fonte destino|arquivo\n"
+"\n"
 
-#: nscd/grpcache.c:210
+#: elf/sln.c:97
 #, c-format
-msgid "Haven't found \"%s\" in group cache!"
-msgstr "No encontrado \"%s\" no cache de grupo!"
+msgid "%s: file open error: %m\n"
+msgstr "%s: erro na abertura do arquivo: %m\n"
 
-#: nscd/hstcache.c:297 nscd/hstcache.c:328 nscd/hstcache.c:359
-#: nscd/hstcache.c:390
+#: elf/sln.c:134
 #, c-format
-msgid "Haven't found \"%s\" in hosts cache!"
-msgstr "No encontrado \"%s\" no cache de mquinas!"
+msgid "No target in line %d\n"
+msgstr "Nenhum alvo na linha %d\n"
 
-#: nscd/pwdcache.c:207
+#: elf/sln.c:164
 #, c-format
-msgid "Haven't found \"%s\" in password cache!"
-msgstr "No encontrado \"%s\" no cache de senhas! "
+msgid "%s: destination must not be a directory\n"
+msgstr "%s: destino não pode ser um diretório\n"
 
-#. TRANS The remote host for a requested network connection is down.
-#: stdio-common/../sysdeps/gnu/errlist.c:469
-msgid "Host is down"
-msgstr "Host est desligado"
+#: elf/sln.c:170
+#, c-format
+msgid "%s: failed to remove the old destination\n"
+msgstr "%s: falha ao remover o destino antigo\n"
 
-#: resolv/herror.c:75
-msgid "Host name lookup failure"
-msgstr "Falha na procura do nome de host"
+#: elf/sln.c:178
+#, c-format
+msgid "%s: invalid destination: %s\n"
+msgstr "%s: destino inválido: %s\n"
 
-#: stdio-common/../sysdeps/unix/siglist.c:48
-#: sysdeps/unix/sysv/linux/siglist.h:42
-msgid "I/O possible"
-msgstr "possvel E/S"
+#: elf/sln.c:189 elf/sln.c:198
+#, c-format
+msgid "Invalid link from \"%s\" to \"%s\": %s\n"
+msgstr "Link inválido de “%s” para “%s”: %s\n"
 
-#: db2/makedb.c:71
+#: elf/sotruss.sh:32
+#, sh-format
 msgid ""
-"INPUT-FILE OUTPUT-FILE\n"
-"-o OUTPUT-FILE INPUT-FILE\n"
-"-u INPUT-FILE"
+"Usage: sotruss [OPTION...] [--] EXECUTABLE [EXECUTABLE-OPTION...]\n"
+"  -F, --from FROMLIST     Trace calls from objects on FROMLIST\n"
+"  -T, --to TOLIST         Trace calls to objects on TOLIST\n"
+"\n"
+"  -e, --exit              Also show exits from the function calls\n"
+"  -f, --follow            Trace child processes\n"
+"  -o, --output FILENAME   Write output to FILENAME (or FILENAME.$PID in case\n"
+"\t\t\t  -f is also used) instead of standard error\n"
+"\n"
+"  -?, --help              Give this help list\n"
+"      --usage             Give a short usage message\n"
+"      --version           Print program version"
 msgstr ""
-"ARQUIVO-ENTRADA ARQUIVO-SADA\n"
-"-o ARQUIVO-SADA ARQUIVO-ENTRADA\n"
-"-u ARQUIVO-ENTRADA"
+"Uso: sotruss [OPÇÃO...] [--] EXECUTÁVEL [OPÇÃO-EXECUTÁVEL...]\n"
+"  -F, --from LISTA-DE     Rastreia chamadas a partir de objetos na LISTA-DE\n"
+"  -T, --to LISTA-PARA     Rastreia chamadas para objetos na LISTA-PARA\n"
+"\n"
+"  -e, --exit              Também mostra saídas de chamadas de função\n"
+"  -f, --follow            Rastreia processos filhos\n"
+"  -o, --output ARQUIVO    Escreve a saída para ARQUIVO (ou ARQUIVO.$PID, caso\n"
+"                            -f também seja usada) em vez da saída de erro\n"
+"\n"
+"  -?, --help              Fornece essa lista de ajuda\n"
+"      --usage             Fornece uma mensagem curta de uso\n"
+"      --version           Exibe a versão do programa"
 
-#: stdio-common/../sysdeps/unix/siglist.c:31
-msgid "IOT trap"
-msgstr "trap IOT"
+# caractere de nova linha (\n) inserido visando não ultrapassar 80 caracteres.
+#: elf/sotruss.sh:46
+msgid "Mandatory arguments to long options are also mandatory for any corresponding\\nshort options.\\n"
+msgstr "Argumentos obrigatórios para opções longas são também obrigatórios para\\nqualquer opção curta correspondente.\\n"
 
-#: nis/nis_print.c:35
-msgid "IVY"
-msgstr "IVY"
+#: elf/sotruss.sh:55
+msgid "%s: option requires an argument -- '%s'\\n"
+msgstr "%s: opção requer um argumento -- “%s”\\n"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:626
-msgid "Identifier removed"
-msgstr "Identificador removido"
+#: elf/sotruss.sh:61
+msgid "%s: option is ambiguous; possibilities:"
+msgstr "%s: opção é ambígua; possibilidades:"
 
-#: stdio-common/../sysdeps/unix/siglist.c:29
-#: sysdeps/unix/sysv/linux/siglist.h:25
-msgid "Illegal instruction"
-msgstr "Instruo ilegal"
+#: elf/sotruss.sh:79
+msgid "Written by %s.\\n"
+msgstr "Escrito por %s.\\n"
 
-#: nis/nis_error.c:61
-msgid "Illegal object type for operation"
-msgstr "Tipo ilegal de objeto para a operao"
-
-#. TRANS Invalid seek operation (such as on a pipe).
-#: stdio-common/../sysdeps/gnu/errlist.c:213
-msgid "Illegal seek"
-msgstr "Procura ilegal"
+#: elf/sotruss.sh:86
+msgid ""
+"Usage: %s [-ef] [-F FROMLIST] [-o FILENAME] [-T TOLIST] [--exit]\n"
+"\t    [--follow] [--from FROMLIST] [--output FILENAME] [--to TOLIST]\n"
+"\t    [--help] [--usage] [--version] [--]\n"
+"\t    EXECUTABLE [EXECUTABLE-OPTION...]\\n"
+msgstr ""
+"Uso: %s [-ef] [-F LISTA-DE] [-o ARQUIVO] [-T LISTA-PARA] [--exit]\n"
+"\t    [--follow] [--from LISTA-DE] [--output ARQUIVO] [--to LISTA-PARA]\n"
+"\t    [--help] [--usage] [--version] [--]\n"
+"\t    EXECUTÁVEL [OPÇÃO-EXECUTÁVEL...]\\n"
 
-#. TRANS Inappropriate file type or format.  The file was the wrong type for the
-#. TRANS operation, or a data file had the wrong format.
-#. TRANS
-#. TRANS On some systems @code{chmod} returns this error if you try to set the
-#. TRANS sticky bit on a non-directory file; @pxref{Setting Permissions}.
-#: stdio-common/../sysdeps/gnu/errlist.c:556
-msgid "Inappropriate file type or format"
-msgstr "Tipo ou formato de arquivo inapropriado"
+#: elf/sotruss.sh:134
+msgid "%s: unrecognized option '%c%s'\\n"
+msgstr "%s: opção não reconhecida “%c%s”\\n"
 
-#. TRANS Inappropriate I/O control operation, such as trying to set terminal
-#. TRANS modes on an ordinary file.
-#: stdio-common/../sysdeps/gnu/errlist.c:188
-msgid "Inappropriate ioctl for device"
-msgstr "ioctl inapropriado para dispositivo"
+#: elf/sprof.c:77
+msgid "Output selection:"
+msgstr "Seleção de saída:"
 
-#. TRANS In the GNU system, servers supporting the @code{term} protocol return
-#. TRANS this error for certain operations when the caller is not in the
-#. TRANS foreground process group of the terminal.  Users do not usually see this
-#. TRANS error because functions such as @code{read} and @code{write} translate
-#. TRANS it into a @code{SIGTTIN} or @code{SIGTTOU} signal.  @xref{Job Control},
-#. TRANS for information on process groups and these signals.
-#: stdio-common/../sysdeps/gnu/errlist.c:589
-msgid "Inappropriate operation for background process"
-msgstr "Operao inapropriada para processo em background"
+#: elf/sprof.c:79
+msgid "print list of count paths and their number of use"
+msgstr "mostra lista de número de rotas e seu número de uso"
 
-#: sysdeps/unix/sysv/linux/siglist.h:62
-msgid "Information request"
-msgstr "Requesio de informao"
+#: elf/sprof.c:81
+msgid "generate flat profile with counts and ticks"
+msgstr "gera perfil com contadores e “ticks”"
 
-#: iconv/iconv_prog.c:57
-msgid "Information:"
-msgstr "Informao:"
+#: elf/sprof.c:82
+msgid "generate call graph"
+msgstr "gera gráfico de chamadas"
 
-#: locale/programs/localedef.c:94
-msgid "Input Files:"
-msgstr "Arquivos de entrada:"
+#: elf/sprof.c:89
+msgid "Read and display shared object profiling data."
+msgstr "Lê e mostra dados de perfil do objeto compartilhado."
 
-#: iconv/iconv_prog.c:54
-msgid "Input/Output format specification:"
-msgstr "Especificao de formato de Entrada/Sada:"
+#: elf/sprof.c:94
+msgid "SHOBJ [PROFDATA]"
+msgstr "SHOBJ [DADOSPERFIL]"
 
-#. TRANS Input/output error; usually used for physical read or write errors.
-#: stdio-common/../sysdeps/gnu/errlist.c:52
-msgid "Input/output error"
-msgstr "Erro de entrada/sada"
+#: elf/sprof.c:433
+#, c-format
+msgid "failed to load shared object `%s'"
+msgstr "falha no carregamento do objeto compartilhado “%s”"
 
-#: nis/ypclnt.c:775
-msgid "Internal NIS error"
-msgstr "Erro NIS interno"
+#: elf/sprof.c:442 elf/sprof.c:825 elf/sprof.c:923
+#, c-format
+msgid "cannot create internal descriptor"
+msgstr "não é possível criar descritor interno"
 
-#: nis/ypclnt.c:839
-msgid "Internal ypbind error"
-msgstr "Erro interno de ypbind"
+#: elf/sprof.c:554
+#, c-format
+msgid "Reopening shared object `%s' failed"
+msgstr "Reabertura de objeto compartilhado “%s” falhou"
 
-#: stdio-common/../sysdeps/unix/siglist.c:27
-#: sysdeps/unix/sysv/linux/siglist.h:23
-msgid "Interrupt"
-msgstr "Interrupo"
+#: elf/sprof.c:561 elf/sprof.c:656
+#, c-format
+msgid "reading of section headers failed"
+msgstr "a leitura de cabeçalhos de seção falhou"
 
-#. TRANS Interrupted function call; an asynchronous signal occurred and prevented
-#. TRANS completion of the call.  When this happens, you should try the call
-#. TRANS again.
-#. TRANS
-#. TRANS You can choose to have functions resume after a signal that is handled,
-#. TRANS rather than failing with @code{EINTR}; see @ref{Interrupted
-#. TRANS Primitives}.
-#: stdio-common/../sysdeps/gnu/errlist.c:47
-msgid "Interrupted system call"
-msgstr "Chamada de sistema interrompida"
+#: elf/sprof.c:569 elf/sprof.c:664
+#, c-format
+msgid "reading of section header string table failed"
+msgstr "a leitura da tabela de string do cabeçalho da seção falhou"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:666
-msgid "Interrupted system call should be restarted"
-msgstr "Chamada de sistema interrompida deve ser reiniciada"
+#: elf/sprof.c:595
+#, c-format
+msgid "*** Cannot read debuginfo file name: %m\n"
+msgstr "*** Não foi possível ler o arquivo de debuginfo: %m\n"
 
-#: nis/nis_error.c:44
-msgid "Invalid Object for operation"
-msgstr "Objeto invlido para operao"
+#: elf/sprof.c:616
+#, c-format
+msgid "cannot determine file name"
+msgstr "não foi possível determinar o nome do arquivo"
 
-#. TRANS Invalid argument.  This is used to indicate various kinds of problems
-#. TRANS with passing the wrong argument to a library function.
-#: stdio-common/../sysdeps/gnu/errlist.c:164
-msgid "Invalid argument"
-msgstr "Argumento invlido"
+#: elf/sprof.c:649
+#, c-format
+msgid "reading of ELF header failed"
+msgstr "a leitura de cabeçalho de ELF falhou"
 
-#: posix/regex.c:1018
-msgid "Invalid back reference"
-msgstr "Referncia anterior invlida"
+#: elf/sprof.c:685
+#, c-format
+msgid "*** The file `%s' is stripped: no detailed analysis possible\n"
+msgstr "*** O arquivo “%s” está sem símbolos (stripped): análise detalhada é impossível\n"
 
-#: posix/regex.c:1016
-msgid "Invalid character class name"
-msgstr "Nome de classe de caracter invlido"
+#: elf/sprof.c:715
+#, c-format
+msgid "failed to load symbol data"
+msgstr "falha ao carregar dados de símbolos"
 
-#: sunrpc/clnt_perr.c:275
-msgid "Invalid client credential"
-msgstr "Credencial de cliente invlido"
+#: elf/sprof.c:780
+#, c-format
+msgid "cannot load profiling data"
+msgstr "impossível carregar dados de perfil"
 
-#: sunrpc/clnt_perr.c:279
-msgid "Invalid client verifier"
-msgstr "Verificador de cliente invlido"
+#: elf/sprof.c:789
+#, c-format
+msgid "while stat'ing profiling data file"
+msgstr "enquanto obtinha estado do arquivo de dados de perfil"
 
-#: posix/regex.c:1015
-msgid "Invalid collation character"
-msgstr "Caracter de comparao invlido"
+#: elf/sprof.c:797
+#, c-format
+msgid "profiling data file `%s' does not match shared object `%s'"
+msgstr "arquivo de dados de perfil “%s” não coincide com objetos compartilhados “%s”"
 
-#: posix/regex.c:1022
-msgid "Invalid content of \\{\\}"
-msgstr "Contedo invlido de \\{\\}"
+#: elf/sprof.c:808
+#, c-format
+msgid "failed to mmap the profiling data file"
+msgstr "falha para mapear (mmap) o arquivo de dados de perfil"
 
-#. TRANS An attempt to make an improper link across file systems was detected.
-#. TRANS This happens not only when you use @code{link} (@pxref{Hard Links}) but
-#. TRANS also when you rename a file with @code{rename} (@pxref{Renaming Files}).
-#: stdio-common/../sysdeps/gnu/errlist.c:141
-msgid "Invalid cross-device link"
-msgstr "Link entre dispositivos invlido"
+#: elf/sprof.c:816
+#, c-format
+msgid "error while closing the profiling data file"
+msgstr "erro ao fechar arquivo de dados de perfil"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:702
-msgid "Invalid exchange"
-msgstr "Troca invlida"
+#: elf/sprof.c:899
+#, c-format
+msgid "`%s' is no correct profile data file for `%s'"
+msgstr "“%s” não é o arquivo de perfil de dados correto para “%s”"
 
-#. TRANS While decoding a multibyte character the function came along an invalid
-#. TRANS or an incomplete sequence of bytes or the given wide character is invalid.
-#: stdio-common/../sysdeps/gnu/errlist.c:579
-msgid "Invalid or incomplete multibyte or wide character"
-msgstr "Multibyte ou caracter largo invlido"
+#: elf/sprof.c:1080 elf/sprof.c:1138
+#, c-format
+msgid "cannot allocate symbol data"
+msgstr "não foi possível alocar dados de símbolos"
 
-#: posix/regex.c:1025
-msgid "Invalid preceding regular expression"
-msgstr "Expresso regular precedente invlida"
+#: iconv/iconv_charmap.c:141 iconv/iconv_prog.c:445
+#, c-format
+msgid "cannot open output file"
+msgstr "não foi possível abrir arquivo de saída"
 
-#: posix/regex.c:1023
-msgid "Invalid range end"
-msgstr "Intervalo final invlida"
+#: iconv/iconv_charmap.c:187 iconv/iconv_prog.c:308
+#, c-format
+msgid "error while closing input `%s'"
+msgstr "erro ao fechar a entrada “%s”"
 
-#: posix/regex.c:1014
-msgid "Invalid regular expression"
-msgstr "Expresso regular invlida"
+#: iconv/iconv_charmap.c:435
+#, c-format
+msgid "illegal input sequence at position %Zd"
+msgstr "sequência de entrada ilegal na posição %Zd"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:718
-msgid "Invalid request code"
-msgstr "Cdigo de requisio invlido"
+#: iconv/iconv_charmap.c:454 iconv/iconv_prog.c:536
+#, c-format
+msgid "incomplete character or shift sequence at end of buffer"
+msgstr "caractere incompleto ou mudança de sequência no final do buffer"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:706
-msgid "Invalid request descriptor"
-msgstr "Descritor de requisio invlido"
+#: iconv/iconv_charmap.c:499 iconv/iconv_charmap.c:535 iconv/iconv_prog.c:579
+#: iconv/iconv_prog.c:615
+#, c-format
+msgid "error while reading the input"
+msgstr "erro ao ler a entrada"
 
-#: sunrpc/clnt_perr.c:285
-msgid "Invalid server verifier"
-msgstr "Verificador de servidor invlido"
+#: iconv/iconv_charmap.c:517 iconv/iconv_prog.c:597
+#, c-format
+msgid "unable to allocate buffer for input"
+msgstr "não foi possível alocar espaço para entrada"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:722
-msgid "Invalid slot"
-msgstr "Slot invlido"
+#: iconv/iconv_prog.c:59
+msgid "Input/Output format specification:"
+msgstr "Especificação de formato de entrada/saída:"
 
-#. TRANS File is a directory; you cannot open a directory for writing,
-#. TRANS or create or remove hard links to it.
-#: stdio-common/../sysdeps/gnu/errlist.c:158
-msgid "Is a directory"
-msgstr " um diretrio"
+#: iconv/iconv_prog.c:60
+msgid "encoding of original text"
+msgstr "codificação para o texto original"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:806
-msgid "Is a named type file"
-msgstr " um arquivo tipo nomevel"
+#: iconv/iconv_prog.c:61
+msgid "encoding for output"
+msgstr "codificação para a saída"
 
-#: nis/nis_print.c:187
-msgid "Kerberos.\n"
-msgstr "Kerberos.\n"
+#: iconv/iconv_prog.c:62
+msgid "Information:"
+msgstr "Informação:"
 
-#: stdio-common/../sysdeps/unix/siglist.c:34
-#: sysdeps/unix/sysv/linux/siglist.h:29
-msgid "Killed"
-msgstr "Morto"
+#: iconv/iconv_prog.c:63
+msgid "list all known coded character sets"
+msgstr "lista todas as coleções de caracteres codificados"
 
-#: nis/nis_print.c:123
-msgid "LINK\n"
-msgstr "LINK\n"
+#: iconv/iconv_prog.c:64 locale/programs/localedef.c:120
+msgid "Output control:"
+msgstr "Controle de saída:"
 
-#: nis/nis_local_names.c:125
-#, c-format
-msgid "LOCAL entry for UID %d in directory %s not unique\n"
-msgstr "Entrada LOCAL para UID %d no diretrio %s no  nica\n"
+#: iconv/iconv_prog.c:65
+msgid "omit invalid characters from output"
+msgstr "omite caracteres inválidos da saída"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:698
-msgid "Level 2 halted"
-msgstr "Parada de sistema nvel 2"
+#: iconv/iconv_prog.c:66 iconv/iconvconfig.c:128
+#: locale/programs/localedef.c:113 locale/programs/localedef.c:115
+#: locale/programs/localedef.c:117 locale/programs/localedef.c:144
+#: malloc/memusagestat.c:56
+msgid "FILE"
+msgstr "ARQUIVO"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:674
-msgid "Level 2 not synchronized"
-msgstr "Nvel 2 no sincronizado"
+#: iconv/iconv_prog.c:66
+msgid "output file"
+msgstr "arquivo de saída"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:678
-msgid "Level 3 halted"
-msgstr "Nvel 3 parado"
+#: iconv/iconv_prog.c:67
+msgid "suppress warnings"
+msgstr "suprime avisos"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:682
-msgid "Level 3 reset"
-msgstr "Nvel 3 resetado"
+#: iconv/iconv_prog.c:68
+msgid "print progress information"
+msgstr "mostra informações de progresso"
 
-#: nis/nis_error.c:53
-msgid "Link Points to illegal name"
-msgstr "Vnculo aponta para nome ilegal"
+#: iconv/iconv_prog.c:73
+msgid "Convert encoding of given files from one encoding to another."
+msgstr "Converte codificação dos arquivos dados de uma codificação para outra."
 
-#: stdio-common/../sysdeps/gnu/errlist.c:638
-msgid "Link has been severed"
-msgstr "Link foi cortado"
+#: iconv/iconv_prog.c:77
+msgid "[FILE...]"
+msgstr "[ARQUIVO...]"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:686
-msgid "Link number out of range"
-msgstr "Nmero de link fora da faixa"
+#: iconv/iconv_prog.c:230
+#, c-format
+msgid "conversions from `%s' and to `%s' are not supported"
+msgstr "não há suporte para as conversões de “%s” e para “%s”"
 
-#: nis/nis_print.c:282
-msgid "Linked Object Type : "
-msgstr "Tipo de Objeto Vinculado (linked) : "
+#: iconv/iconv_prog.c:235
+#, c-format
+msgid "conversion from `%s' is not supported"
+msgstr "não há suporte para a conversão de “%s”"
 
-#: nis/nis_print.c:284
+#: iconv/iconv_prog.c:242
 #, c-format
-msgid "Linked to : %s\n"
-msgstr "Vinculado (linked) para : %s\n"
+msgid "conversion to `%s' is not supported"
+msgstr "não há suporte para a conversão para “%s”"
 
-#: nis/ypclnt.c:787
-msgid "Local domain name not set"
-msgstr "No foi configurado nome de domnio local"
+#: iconv/iconv_prog.c:246
+#, c-format
+msgid "conversion from `%s' to `%s' is not supported"
+msgstr "não há suporte para a conversão de “%s” para “%s”"
 
-#: nis/ypclnt.c:777
-msgid "Local resource allocation failure"
-msgstr "Falha na alocao de recurso local"
+#: iconv/iconv_prog.c:256
+#, c-format
+msgid "failed to start conversion processing"
+msgstr "falha ao iniciar o processo de conversão"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:734
-msgid "Machine is not on the network"
-msgstr "A maquina no est na rede"
+#: iconv/iconv_prog.c:354
+#, c-format
+msgid "error while closing output file"
+msgstr "erro ao fechar o arquivo de saída"
 
-#: nis/nis_error.c:45
-msgid "Malformed Name, or illegal name"
-msgstr "Nome malformado ou ilegal"
+#: iconv/iconv_prog.c:455
+#, c-format
+msgid "conversion stopped due to problem in writing the output"
+msgstr "a conversão parou devido a problemas de escrita na saída"
 
-#: argp/argp-help.c:1182
-msgid "Mandatory or optional arguments to long options are also mandatory or optional for any corresponding short options."
-msgstr "Parmetros obrigatrios ou opcionais para opes longas so tambm obrigatrios ou opcionais para qualquer opo curta correspondente."
+#: iconv/iconv_prog.c:532
+#, c-format
+msgid "illegal input sequence at position %ld"
+msgstr "sequência de entrada ilegal na posição %ld"
 
-#: nis/nis_print.c:168
-msgid "Master Server :\n"
-msgstr "Servidor Mestre :\n"
+#: iconv/iconv_prog.c:540
+#, c-format
+msgid "internal error (illegal descriptor)"
+msgstr "erro interno (descritor ilegal)"
 
-#: nis/nis_error.c:75
-msgid "Master server busy, full dump rescheduled."
-msgstr "Servidor Mestre ocupado, descarregamento completo (dump) remarcado."
+#: iconv/iconv_prog.c:543
+#, c-format
+msgid "unknown iconv() error %d"
+msgstr "erro iconv() desconhecido: %d"
 
-#: posix/../sysdeps/posix/gai_strerror.c:35
-msgid "Memory allocation failure"
-msgstr "Falha de alocao de memria"
+#: iconv/iconv_prog.c:786
+msgid ""
+"The following list contains all the coded character sets known.  This does\n"
+"not necessarily mean that all combinations of these names can be used for\n"
+"the FROM and TO command line parameters.  One coded character set can be\n"
+"listed with several different names (aliases).\n"
+"\n"
+"  "
+msgstr ""
+"A lista a seguir contém todos os conjuntos de codificação de caracteres \n"
+"conhecidos. Isto não quer dizer necessariamente que todas as combinações\n"
+"destes nomes podem ser utilizadas nos parâmetros DE e PARA. Um conjunto\n"
+"de caracteres pode ser listado com vários nomes diferentes (apelidos).\n"
+"\n"
+"  "
 
-#: posix/regex.c:1024
-msgid "Memory exhausted"
-msgstr "Memria esgotada"
+#: iconv/iconvconfig.c:109
+msgid "Create fastloading iconv module configuration file."
+msgstr "Cria um arquivo de configuração para carregamento rápido de módulos iconv."
 
-#. TRANS The size of a message sent on a socket was larger than the supported
-#. TRANS maximum size.
-#: stdio-common/../sysdeps/gnu/errlist.c:317
-msgid "Message too long"
-msgstr "Mensagem muito longa"
+#: iconv/iconvconfig.c:113
+msgid "[DIR...]"
+msgstr "[DIR...]"
 
-#: nis/nis_error.c:57
-msgid "Missing or malformed attribute"
-msgstr "Atributo perdido ou malformado"
+#: iconv/iconvconfig.c:126 locale/programs/localedef.c:123
+msgid "PATH"
+msgstr "CAMINHO"
 
-#: nis/nis_print.c:323
-#, c-format
-msgid "Mod. Time     : %s"
-msgstr "Horrio  Mod. : %s"
+#: iconv/iconvconfig.c:127
+msgid "Prefix used for all file accesses"
+msgstr "Prefixo usado para todos os acessos a arquivos"
 
-#: nis/nis_error.c:50
-msgid "Modification failed"
-msgstr "Modificao falhou"
+#: iconv/iconvconfig.c:128
+msgid "Put output in FILE instead of installed location (--prefix does not apply to FILE)"
+msgstr "Coloca saída em ARQUIVO, em vez da localização instalada (--prefix não se aplica a ARQUIVO)"
 
-#: nis/nis_error.c:63
-msgid "Modify operation failed"
-msgstr "Operao de modificao falhou"
+#: iconv/iconvconfig.c:132
+msgid "Do not search standard directories, only those on the command line"
+msgstr "Não pesquisa por diretórios padrões, e sim apenas por aqueles na linha de comando"
 
-#: locale/programs/locale.c:68
-msgid "Modify output format:"
-msgstr "Formato de modificao de sada:"
+#: iconv/iconvconfig.c:299
+#, c-format
+msgid "Directory arguments required when using --nostdlib"
+msgstr "Argumentos de diretório são necessários ao usar --nostdlib"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:630
-msgid "Multihop attempted"
-msgstr "Tentativa de Multihop"
+#: iconv/iconvconfig.c:341
+#, c-format
+msgid "no output file produced because warnings were issued"
+msgstr "nenhum arquivo de saída foi produzido porque avisos foram emitidos"
 
-#: catgets/gencat.c:106 catgets/gencat.c:110 db2/makedb.c:59
-#: locale/programs/localedef.c:115 nscd/nscd.c:77
-msgid "NAME"
-msgstr "NOME"
+#: iconv/iconvconfig.c:430
+#, c-format
+msgid "while inserting in search tree"
+msgstr "erro ao inserir na área de pesquisa"
 
-#: locale/programs/locale.c:78
-msgid ""
-"NAME\n"
-"[-a|-m]"
-msgstr ""
-"NOME\n"
-"[-a|-m]"
+#: iconv/iconvconfig.c:1238
+#, c-format
+msgid "cannot generate output file"
+msgstr "não foi possível gerar o arquivo de saída"
 
-#: nis/nis_print.c:31
-msgid "NIS"
-msgstr "NIS"
+#: inet/rcmd.c:157
+msgid "rcmd: Cannot allocate memory\n"
+msgstr "rcmd: Não foi possível alocar memória\n"
 
-#: nis/ypclnt.c:791
-msgid "NIS client/server version mismatch - can't supply service"
-msgstr "Verses cliente/servidor NIS no conferem - no  possvel oferecer servio"
+#: inet/rcmd.c:174
+msgid "rcmd: socket: All ports in use\n"
+msgstr "rcmd: socket: Todas as portas em uso\n"
 
-#: nis/ypclnt.c:789
-msgid "NIS map database is bad"
-msgstr "Base de dados de mapas NIS est ruim"
+#: inet/rcmd.c:202
+#, c-format
+msgid "connect to address %s: "
+msgstr "conectar ao endereço %s: "
 
-#: nis/nis_error.c:68
-msgid "NIS+ operation failed"
-msgstr "Operao NIS+ falhou"
+#: inet/rcmd.c:215
+#, c-format
+msgid "Trying %s...\n"
+msgstr "Tentando %s...\n"
 
-#: nis/nis_error.c:33
-msgid "NIS+ servers unreachable"
-msgstr "Servidores NIS+ fora do alcance"
+#: inet/rcmd.c:251
+#, c-format
+msgid "rcmd: write (setting up stderr): %m\n"
+msgstr "rcmd: write (configurando stderr): %m\n"
 
-#: nis/nis_error.c:69
-msgid "NIS+ service is unavailable or not installed"
-msgstr "Servio NIS+ est indisponvel ou no est instalado"
+#: inet/rcmd.c:267
+#, c-format
+msgid "rcmd: poll (setting up stderr): %m\n"
+msgstr "rcmd: poll (configurando stderr): %m\n"
 
-#: nis/nis_print.c:108
-msgid "NO OBJECT\n"
-msgstr "SEM OBJETO\n"
+#: inet/rcmd.c:270
+msgid "poll: protocol failure in circuit setup\n"
+msgstr "poll: falha de protocolo na configuração do circuito\n"
 
-#: nscd/nscd.c:81
-msgid "NUMBER"
-msgstr "NMERO"
+#: inet/rcmd.c:302
+msgid "socket: protocol failure in circuit setup\n"
+msgstr "socket: falha de protocolo na configuração do circuito\n"
 
-#: nis/nis_print.c:162
+#: inet/rcmd.c:326
 #, c-format
-msgid "Name : '%s'\n"
-msgstr "Nome : `%s'\n"
+msgid "rcmd: %s: short read"
+msgstr "rcmd: %s: leitura insuficiente"
 
-#: nscd/nscd.c:88
-msgid "Name Service Cache Daemon."
-msgstr "Servidor de Cache de Nomes."
+#: inet/rcmd.c:478
+msgid "lstat failed"
+msgstr "lstat falhou"
 
-#: nis/nis_error.c:40
-msgid "Name not served by this server"
-msgstr "Nome no servidor por este servidor"
+#: inet/rcmd.c:485
+msgid "cannot open"
+msgstr "não foi possível abrir"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:758
-msgid "Name not unique on network"
-msgstr "O nome no  nico na rede"
+#: inet/rcmd.c:487
+msgid "fstat failed"
+msgstr "fstat falhou"
 
-#: posix/../sysdeps/posix/gai_strerror.c:37
-msgid "Name or service not known"
-msgstr "Nome ou servio desconhecido"
+#: inet/rcmd.c:489
+msgid "bad owner"
+msgstr "dono inválido"
 
-#: nis/nis_error.c:49
-msgid "Name/entry isn't unique"
-msgstr "Nome/entrada no  nico"
+#: inet/rcmd.c:491
+msgid "writeable by other than owner"
+msgstr "permissão de escrita para outros"
 
-#: nis/nis_error.c:58
-msgid "Named object is not searchable"
-msgstr "Objeto nomeado no  pesquisvel"
+#: inet/rcmd.c:493
+msgid "hard linked somewhere"
+msgstr "link absoluto em algum lugar"
 
-#. TRANS ???
-#: stdio-common/../sysdeps/gnu/errlist.c:566
-msgid "Need authenticator"
-msgstr " necessrio um autenticador"
+#: inet/ruserpass.c:165 inet/ruserpass.c:188
+msgid "out of memory"
+msgstr "memória insuficiente"
 
-#. TRANS A network connection was reset because the remote host crashed.
-#: stdio-common/../sysdeps/gnu/errlist.c:389
-msgid "Network dropped connection on reset"
-msgstr "A rede desconectou-se ao resetar"
+#: inet/ruserpass.c:179
+msgid "Error: .netrc file is readable by others."
+msgstr "Erro: arquivo .netrc é legível por outros."
 
-#. TRANS A socket operation failed because the network was down.
-#: stdio-common/../sysdeps/gnu/errlist.c:378
-msgid "Network is down"
-msgstr "A rede no responde"
+#: inet/ruserpass.c:180
+msgid "Remove password or make file unreadable by others."
+msgstr "Remove a senha ou torne arquivo não-legível por outros."
 
-#. TRANS A socket operation failed because the subnet containing the remote host
-#. TRANS was unreachable.
-#: stdio-common/../sysdeps/gnu/errlist.c:384
-msgid "Network is unreachable"
-msgstr "A rede est fora de alcance"
+#: inet/ruserpass.c:199
+#, c-format
+msgid "Unknown .netrc keyword %s"
+msgstr "Palavra-chave em .netrc desconhecida %s"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:694
-msgid "No CSI structure available"
-msgstr "No h estrutura CSI disponvel"
+#: libidn/nfkc.c:463
+msgid "Character out of range for UTF-8"
+msgstr "Caractere fora do limite para UTF-8"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:802
-msgid "No XENIX semaphores available"
-msgstr "No h semforos XENIX disponveis"
+#: locale/programs/charmap-dir.c:56
+#, c-format
+msgid "cannot read character map directory `%s'"
+msgstr "não é possível ler diretório de mapa de caracteres “%s”"
 
-#: posix/../sysdeps/posix/gai_strerror.c:36
-msgid "No address associated with hostname"
-msgstr "No h endereo associado com o nome"
+#: locale/programs/charmap.c:138
+#, c-format
+msgid "character map file `%s' not found"
+msgstr "arquivo de mapa de caracteres “%s” não foi localizado"
 
-#: resolv/herror.c:77
-msgid "No address associated with name"
-msgstr "No h endereo associado com o nome"
+#: locale/programs/charmap.c:196
+#, c-format
+msgid "default character map file `%s' not found"
+msgstr "arquivo padrão de mapa de caracteres “%s” não localizado"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:714
-msgid "No anode"
-msgstr "Sem anode"
+#: locale/programs/charmap.c:265
+#, c-format
+msgid "character map `%s' is not ASCII compatible, locale not ISO C compliant [--no-warnings=ascii]"
+msgstr "mapa de caracteres “%s” não é compatível com ASCII; localidade não é compatível com C ISO [--no-warnings=ascii]"
 
-#. TRANS The kernel's buffers for I/O operations are all in use.  In GNU, this
-#. TRANS error is always synonymous with @code{ENOMEM}; you may get one or the
-#. TRANS other from network operations.
-#: stdio-common/../sysdeps/gnu/errlist.c:408
-msgid "No buffer space available"
-msgstr "No h espao de buffer disponvel"
+#: locale/programs/charmap.c:343
+#, c-format
+msgid "%s: <mb_cur_max> must be greater than <mb_cur_min>\n"
+msgstr "%s: <mb_cur_max> deve ser maior que <mb_cur_min>\n"
 
-#. TRANS There are no child processes.  This error happens on operations that are
-#. TRANS supposed to manipulate child processes, when there aren't any processes
-#. TRANS to manipulate.
-#: stdio-common/../sysdeps/gnu/errlist.c:89
-msgid "No child processes"
-msgstr "No h processos filhos"
+#: locale/programs/charmap.c:363 locale/programs/charmap.c:380
+#: locale/programs/repertoire.c:173
+#, c-format
+msgid "syntax error in prolog: %s"
+msgstr "erro de sintaxe em prolog: %s"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:634
-msgid "No data available"
-msgstr "No h dados disponveis"
+#: locale/programs/charmap.c:364
+msgid "invalid definition"
+msgstr "definição inválida"
 
-#: nis/nis_error.c:73
-msgid "No file space on server"
-msgstr "No h espao disponvel no servidor"
+#: locale/programs/charmap.c:381 locale/programs/locfile.c:131
+#: locale/programs/locfile.c:158 locale/programs/repertoire.c:174
+msgid "bad argument"
+msgstr "argumento inválido"
 
-#. TRANS No locks available.  This is used by the file locking facilities; see
-#. TRANS @ref{File Locks}.  This error is never generated by the GNU system, but
-#. TRANS it can result from an operation to an NFS server running another
-#. TRANS operating system.
-#: stdio-common/../sysdeps/gnu/errlist.c:547
-msgid "No locks available"
-msgstr "No h locks disponveis"
+#: locale/programs/charmap.c:408
+#, c-format
+msgid "duplicate definition of <%s>"
+msgstr "definição duplicada de <%s>"
 
-#: posix/regex.c:1013
-msgid "No match"
-msgstr "No confere"
+#: locale/programs/charmap.c:415
+#, c-format
+msgid "value for <%s> must be 1 or greater"
+msgstr "o valor para <%s> deve ser 1 ou maior"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:814
-msgid "No medium found"
-msgstr "Mdia no encontrada"
+#: locale/programs/charmap.c:427
+#, c-format
+msgid "value of <%s> must be greater or equal than the value of <%s>"
+msgstr "o valor de <%s> deve ser maior ou igual ao valor de <%s>"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:642
-msgid "No message of desired type"
-msgstr "No h mensagens do tipo desejado"
+#: locale/programs/charmap.c:450 locale/programs/repertoire.c:182
+#, c-format
+msgid "argument to <%s> must be a single character"
+msgstr "o argumento para <%s> deve ser um caractere simples"
 
-#: nis/ypclnt.c:779
-msgid "No more records in map database"
-msgstr "No h mais registros no banco de dados map"
+#: locale/programs/charmap.c:476
+msgid "character sets with locking states are not supported"
+msgstr "não há suporte a conjuntos de caracteres com estados de trava"
 
-#: posix/regex.c:5515
-msgid "No previous regular expression"
-msgstr "No h expresso regular anterior"
+#: locale/programs/charmap.c:503 locale/programs/charmap.c:557
+#: locale/programs/charmap.c:589 locale/programs/charmap.c:683
+#: locale/programs/charmap.c:738 locale/programs/charmap.c:779
+#: locale/programs/charmap.c:820
+#, c-format
+msgid "syntax error in %s definition: %s"
+msgstr "erro de sintaxe na definição %s: %s"
 
-#: sunrpc/rpcinfo.c:570
-msgid "No remote programs registered.\n"
-msgstr "No h programas remotos registrados.\n"
+#: locale/programs/charmap.c:504 locale/programs/charmap.c:684
+#: locale/programs/charmap.c:780 locale/programs/repertoire.c:229
+msgid "no symbolic name given"
+msgstr "nenhum nome simbólico dado"
 
-#. TRANS The remote host for a requested network connection is not reachable.
-#: stdio-common/../sysdeps/gnu/errlist.c:474
-msgid "No route to host"
-msgstr "No h rota para o host"
+#: locale/programs/charmap.c:558
+msgid "invalid encoding given"
+msgstr "codificação inválida dada"
 
-#. TRANS No space left on device; write operation on a file failed because the
-#. TRANS disk is full.
-#: stdio-common/../sysdeps/gnu/errlist.c:208
-msgid "No space left on device"
-msgstr "No h espao disponvel no dispositivo"
+#: locale/programs/charmap.c:567
+msgid "too few bytes in character encoding"
+msgstr "poucos bytes na codificação do caractere"
 
-#. TRANS The wrong type of device was given to a function that expects a
-#. TRANS particular sort of device.
-#: stdio-common/../sysdeps/gnu/errlist.c:147
-msgid "No such device"
-msgstr "Dispositivo inexistente"
+#: locale/programs/charmap.c:569
+msgid "too many bytes in character encoding"
+msgstr "muitos bytes na codificação do caractere"
 
-#. TRANS No such file or directory.  This is a ``file doesn't exist'' error
-#. TRANS for ordinary files that are referenced in contexts where they are
-#. TRANS expected to already exist.
-#: stdio-common/../sysdeps/gnu/errlist.c:31
-msgid "No such file or directory"
-msgstr "Arquivo ou diretrio no encontrado"
+#: locale/programs/charmap.c:591 locale/programs/charmap.c:739
+#: locale/programs/charmap.c:822 locale/programs/repertoire.c:295
+msgid "no symbolic name given for end of range"
+msgstr "nenhum nome simbólico dado para fim do intervalo"
+
+#: locale/programs/charmap.c:615 locale/programs/ld-address.c:524
+#: locale/programs/ld-collate.c:2616 locale/programs/ld-collate.c:3774
+#: locale/programs/ld-ctype.c:2117 locale/programs/ld-ctype.c:2829
+#: locale/programs/ld-identification.c:397
+#: locale/programs/ld-measurement.c:213 locale/programs/ld-messages.c:295
+#: locale/programs/ld-monetary.c:748 locale/programs/ld-name.c:262
+#: locale/programs/ld-numeric.c:325 locale/programs/ld-paper.c:212
+#: locale/programs/ld-telephone.c:276 locale/programs/ld-time.c:934
+#: locale/programs/repertoire.c:312
+#, c-format
+msgid "%1$s: definition does not end with `END %1$s'"
+msgstr "%1$s: definição não termina com “END %1$s”"
+
+#: locale/programs/charmap.c:648
+msgid "only WIDTH definitions are allowed to follow the CHARMAP definition"
+msgstr "apenas definições de WIDTH são permitidas em seguida à definição de CHARMAP"
 
-#: nis/ypclnt.c:773
-msgid "No such key in map"
-msgstr "Chave no est no mapa"
+#: locale/programs/charmap.c:656 locale/programs/charmap.c:719
+#, c-format
+msgid "value for %s must be an integer"
+msgstr "o valor para %s deve ser um inteiro"
 
-#: nis/ypclnt.c:771
-msgid "No such map in server's domain"
-msgstr "Mapa no encontrado no domnio do servidor"
+#: locale/programs/charmap.c:847
+#, c-format
+msgid "%s: error in state machine"
+msgstr "%s: erro na máquina de estados"
+
+#: locale/programs/charmap.c:855 locale/programs/ld-address.c:540
+#: locale/programs/ld-collate.c:2613 locale/programs/ld-collate.c:3967
+#: locale/programs/ld-ctype.c:2114 locale/programs/ld-ctype.c:2846
+#: locale/programs/ld-identification.c:413
+#: locale/programs/ld-measurement.c:229 locale/programs/ld-messages.c:311
+#: locale/programs/ld-monetary.c:764 locale/programs/ld-name.c:278
+#: locale/programs/ld-numeric.c:341 locale/programs/ld-paper.c:228
+#: locale/programs/ld-telephone.c:292 locale/programs/ld-time.c:950
+#: locale/programs/locfile.c:997 locale/programs/repertoire.c:323
+#, c-format
+msgid "%s: premature end of file"
+msgstr "%s: fim de arquivo prematuro"
 
-#. TRANS No process matches the specified process ID.
-#: stdio-common/../sysdeps/gnu/errlist.c:36
-msgid "No such process"
-msgstr "Processo inexistente"
+#: locale/programs/charmap.c:874 locale/programs/charmap.c:885
+#, c-format
+msgid "unknown character `%s'"
+msgstr "caractere desconhecido “%s”"
+
+#: locale/programs/charmap.c:893
+#, c-format
+msgid "number of bytes for byte sequence of beginning and end of range not the same: %d vs %d"
+msgstr "número de bytes para a sequência de bytes de começo e término de intervalo não é o mesmo: %d vs %d"
+
+#: locale/programs/charmap.c:998 locale/programs/ld-collate.c:2893
+#: locale/programs/repertoire.c:418
+msgid "invalid names for character range"
+msgstr "nomes inválidos para intervalo de caracteres"
+
+#: locale/programs/charmap.c:1010 locale/programs/repertoire.c:430
+msgid "hexadecimal range format should use only capital characters"
+msgstr "formato de intervalo hexadecimal deve usar apenas caracteres maiúsculos"
+
+#: locale/programs/charmap.c:1028 locale/programs/repertoire.c:448
+#, c-format
+msgid "<%s> and <%s> are invalid names for range"
+msgstr "<%s> e <%s> são nomes inválidos para o intervalo"
+
+#: locale/programs/charmap.c:1034 locale/programs/repertoire.c:455
+msgid "upper limit in range is smaller than lower limit"
+msgstr "o limite superior do intervalo é menor que o limite inferior"
+
+#: locale/programs/charmap.c:1092
+msgid "resulting bytes for range not representable."
+msgstr "bytes resultantes para o intervalo não representáveis."
+
+#: locale/programs/ld-address.c:133 locale/programs/ld-collate.c:1563
+#: locale/programs/ld-ctype.c:430 locale/programs/ld-identification.c:131
+#: locale/programs/ld-measurement.c:92 locale/programs/ld-messages.c:96
+#: locale/programs/ld-monetary.c:192 locale/programs/ld-name.c:93
+#: locale/programs/ld-numeric.c:97 locale/programs/ld-paper.c:89
+#: locale/programs/ld-telephone.c:92 locale/programs/ld-time.c:158
+#, c-format
+msgid "No definition for %s category found"
+msgstr "Nenhuma definição para a categoria %s localizada"
+
+#: locale/programs/ld-address.c:144 locale/programs/ld-address.c:182
+#: locale/programs/ld-address.c:199 locale/programs/ld-address.c:228
+#: locale/programs/ld-address.c:300 locale/programs/ld-address.c:319
+#: locale/programs/ld-address.c:331 locale/programs/ld-identification.c:144
+#: locale/programs/ld-measurement.c:103 locale/programs/ld-monetary.c:204
+#: locale/programs/ld-monetary.c:258 locale/programs/ld-monetary.c:274
+#: locale/programs/ld-monetary.c:286 locale/programs/ld-name.c:104
+#: locale/programs/ld-name.c:141 locale/programs/ld-numeric.c:111
+#: locale/programs/ld-numeric.c:125 locale/programs/ld-paper.c:100
+#: locale/programs/ld-paper.c:109 locale/programs/ld-telephone.c:103
+#: locale/programs/ld-telephone.c:160 locale/programs/ld-time.c:174
+#: locale/programs/ld-time.c:195
+#, c-format
+msgid "%s: field `%s' not defined"
+msgstr "%s: campo “%s” não definido"
 
-#: nis/nis_error.c:60
-msgid "Non NIS+ namespace encountered"
-msgstr "Namespace NIS+ no encontrado"
+#: locale/programs/ld-address.c:156 locale/programs/ld-address.c:207
+#: locale/programs/ld-address.c:237 locale/programs/ld-address.c:275
+#: locale/programs/ld-name.c:116 locale/programs/ld-telephone.c:115
+#, c-format
+msgid "%s: field `%s' must not be empty"
+msgstr "%s: campo “%s” não pode estar vazio"
 
-#: posix/../sysdeps/posix/gai_strerror.c:33
-msgid "Non-recoverable failure in name resolution"
-msgstr "Falha irrecupervel na resoluo de nome"
+#: locale/programs/ld-address.c:168
+#, c-format
+msgid "%s: invalid escape `%%%c' sequence in field `%s'"
+msgstr "%s: sequência de escape “%%%c” inválida no campo “%s”"
 
-#: nis/nis_print.c:176
-msgid "None.\n"
-msgstr "nenhum.\n"
+#: locale/programs/ld-address.c:218
+#, c-format
+msgid "%s: terminology language code `%s' not defined"
+msgstr "%s: código de idioma de terminologia “%s” não definido"
 
-#: nis/nis_error.c:48
-msgid "Not Found, no such name"
-msgstr "No encontrado, nome inexistente"
+#: locale/programs/ld-address.c:243
+#, c-format
+msgid "%s: field `%s' must not be defined"
+msgstr "%s: campo “%s” não pode estar definido"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:798
-msgid "Not a XENIX named type file"
-msgstr "No  um arquivo nomevel XENIX"
+#: locale/programs/ld-address.c:257 locale/programs/ld-address.c:286
+#, c-format
+msgid "%s: language abbreviation `%s' not defined"
+msgstr "%s: abreviação de idioma “%s” não definida"
 
-#. TRANS A file that isn't a directory was specified when a directory is required.
-#: stdio-common/../sysdeps/gnu/errlist.c:152
-msgid "Not a directory"
-msgstr "No  um diretrio"
+#: locale/programs/ld-address.c:264 locale/programs/ld-address.c:292
+#: locale/programs/ld-address.c:325 locale/programs/ld-address.c:337
+#, c-format
+msgid "%s: `%s' value does not match `%s' value"
+msgstr "%s: o valor “%s” não corresponde ao valor “%s”"
 
-#: nis/nis_error.c:30
-msgid "Not found"
-msgstr "No encontrado"
+#: locale/programs/ld-address.c:311
+#, c-format
+msgid "%s: numeric country code `%d' not valid"
+msgstr "%s: código numérico do país “%d” não válido"
 
-#: nis/nis_error.c:43
-msgid "Not master server for this domain"
-msgstr "No  um servidor mestre para este domnio"
+#: locale/programs/ld-address.c:432 locale/programs/ld-address.c:469
+#: locale/programs/ld-address.c:507 locale/programs/ld-ctype.c:2478
+#: locale/programs/ld-identification.c:309
+#: locale/programs/ld-measurement.c:196 locale/programs/ld-messages.c:264
+#: locale/programs/ld-monetary.c:503 locale/programs/ld-monetary.c:538
+#: locale/programs/ld-monetary.c:579 locale/programs/ld-name.c:235
+#: locale/programs/ld-numeric.c:217 locale/programs/ld-paper.c:195
+#: locale/programs/ld-telephone.c:251 locale/programs/ld-time.c:839
+#: locale/programs/ld-time.c:881
+#, c-format
+msgid "%s: field `%s' declared more than once"
+msgstr "%s: campo “%s” declarado mais de uma vez"
 
-#: nis/nis_error.c:39
-msgid "Not owner"
-msgstr "Dono invlido"
+#: locale/programs/ld-address.c:436 locale/programs/ld-address.c:474
+#: locale/programs/ld-identification.c:313 locale/programs/ld-messages.c:274
+#: locale/programs/ld-monetary.c:507 locale/programs/ld-monetary.c:542
+#: locale/programs/ld-name.c:239 locale/programs/ld-numeric.c:221
+#: locale/programs/ld-telephone.c:255 locale/programs/ld-time.c:733
+#: locale/programs/ld-time.c:802 locale/programs/ld-time.c:844
+#, c-format
+msgid "%s: unknown character in field `%s'"
+msgstr "%s: caractere desconhecido no campo “%s”"
 
-#: nis/nis_print.c:263
+#: locale/programs/ld-address.c:521 locale/programs/ld-collate.c:3772
+#: locale/programs/ld-ctype.c:2826 locale/programs/ld-identification.c:394
+#: locale/programs/ld-measurement.c:210 locale/programs/ld-messages.c:293
+#: locale/programs/ld-monetary.c:746 locale/programs/ld-name.c:260
+#: locale/programs/ld-numeric.c:323 locale/programs/ld-paper.c:210
+#: locale/programs/ld-telephone.c:274 locale/programs/ld-time.c:932
 #, c-format
-msgid "Number of Columns   : %d\n"
-msgstr "Nmero de Colunas   : %d\n"
+msgid "%s: incomplete `END' line"
+msgstr "%s: linha “END” incompleta"
 
-#: nis/nis_print.c:358
+#: locale/programs/ld-address.c:531 locale/programs/ld-collate.c:550
+#: locale/programs/ld-collate.c:602 locale/programs/ld-collate.c:898
+#: locale/programs/ld-collate.c:911 locale/programs/ld-collate.c:2582
+#: locale/programs/ld-collate.c:2603 locale/programs/ld-collate.c:3957
+#: locale/programs/ld-ctype.c:1846 locale/programs/ld-ctype.c:2104
+#: locale/programs/ld-ctype.c:2676 locale/programs/ld-ctype.c:2837
+#: locale/programs/ld-identification.c:404
+#: locale/programs/ld-measurement.c:220 locale/programs/ld-messages.c:302
+#: locale/programs/ld-monetary.c:755 locale/programs/ld-name.c:269
+#: locale/programs/ld-numeric.c:332 locale/programs/ld-paper.c:219
+#: locale/programs/ld-telephone.c:283 locale/programs/ld-time.c:941
 #, c-format
-msgid "Number of objects : %u\n"
-msgstr "Nmero de objetos : %u\n"
+msgid "%s: syntax error"
+msgstr "%s: erro de sintaxe"
 
-#. TRANS Domain error; used by mathematical functions when an argument value does
-#. TRANS not fall into the domain over which the function is defined.
-#: stdio-common/../sysdeps/gnu/errlist.c:240
-msgid "Numerical argument out of domain"
-msgstr "Argumento numrico fora de domnio"
+#: locale/programs/ld-collate.c:425
+#, c-format
+msgid "`%.*s' already defined in charmap"
+msgstr "“%.*s” já definido no mapa de caracteres"
 
-#. TRANS Range error; used by mathematical functions when the result value is
-#. TRANS not representable because of overflow or underflow.
-#: stdio-common/../sysdeps/gnu/errlist.c:246
-msgid "Numerical result out of range"
-msgstr "Resultado numrico fora de alcance"
+#: locale/programs/ld-collate.c:434
+#, c-format
+msgid "`%.*s' already defined in repertoire"
+msgstr "“%.*s” já definido no repertório"
 
-#: nis/nis_print.c:362
+#: locale/programs/ld-collate.c:441
 #, c-format
-msgid "Object #%d:\n"
-msgstr "Objeto #%d:\n"
+msgid "`%.*s' already defined as collating symbol"
+msgstr "“%.*s” já definido como símbolo de comparação"
 
-#: nis/nis_print.c:314
+#: locale/programs/ld-collate.c:448
 #, c-format
-msgid "Object Name   : %s\n"
-msgstr "Nome do Objeto: %s\n"
+msgid "`%.*s' already defined as collating element"
+msgstr "“%.*s” já definido como elemento de comparação"
 
-#: nis/nis_print.c:324
-msgid "Object Type   : "
-msgstr "Tipo do Objeto: "
+#: locale/programs/ld-collate.c:479 locale/programs/ld-collate.c:505
+#, c-format
+msgid "%s: `forward' and `backward' are mutually excluding each other"
+msgstr "%s: “forward” e “backward” são mutuamente exclusivas entre si"
 
-#. TRANS An attempt was made to NFS-mount a remote file system with a file name that
-#. TRANS already specifies an NFS-mounted file.
-#. TRANS (This is an error on some operating systems, but we expect it to work
-#. TRANS properly on the GNU system, making this error code impossible.)
-#: stdio-common/../sysdeps/gnu/errlist.c:514
-msgid "Object is remote"
-msgstr "Objeto  remoto"
+#: locale/programs/ld-collate.c:489 locale/programs/ld-collate.c:515
+#: locale/programs/ld-collate.c:531
+#, c-format
+msgid "%s: `%s' mentioned more than once in definition of weight %d"
+msgstr "%s: “%s” mencionado mais de uma vez na definição de peso %d"
 
-#: nis/nis_error.c:42
-msgid "Object with same name exists"
-msgstr "Objeto com o mesmo nome existe"
+#: locale/programs/ld-collate.c:587
+#, c-format
+msgid "%s: too many rules; first entry only had %d"
+msgstr "%s: número excessivo de regras; a primeira entrada tinha apenas %d"
 
-#: timezone/zic.c:1995
-msgid "Odd number of quotation marks"
-msgstr "Nmero mpar de aspas"
+#: locale/programs/ld-collate.c:623
+#, c-format
+msgid "%s: not enough sorting rules"
+msgstr "%s: número insuficiente de regras de ordenação"
 
-#: nscd/nscd.c:185
-msgid "Only root is allowed to use this option!"
-msgstr "Somente o superusurio pode usar esta opo!"
+#: locale/programs/ld-collate.c:788
+#, c-format
+msgid "%s: empty weight string not allowed"
+msgstr "%s: texto de peso vazio não permitida"
 
-#. TRANS An operation is already in progress on an object that has non-blocking
-#. TRANS mode selected.
-#: stdio-common/../sysdeps/gnu/errlist.c:306
-msgid "Operation already in progress"
-msgstr "Operao j em progresso"
+#: locale/programs/ld-collate.c:883
+#, c-format
+msgid "%s: weights must use the same ellipsis symbol as the name"
+msgstr "%s: pesos devem usar o mesmo símbolo de elipse que o nome"
 
-#. TRANS Operation not permitted; only the owner of the file (or other resource)
-#. TRANS or processes with special privileges can perform the operation.
-#: stdio-common/../sysdeps/gnu/errlist.c:24
-msgid "Operation not permitted"
-msgstr "Operao no permitida"
+#: locale/programs/ld-collate.c:939
+#, c-format
+msgid "%s: too many values"
+msgstr "%s: número excessivo de valores"
 
-#. TRANS The operation you requested is not supported.  Some socket functions
-#. TRANS don't make sense for all types of sockets, and others may not be
-#. TRANS implemented for all communications protocols.  In the GNU system, this
-#. TRANS error can happen for many calls when the object does not support the
-#. TRANS particular operation; it is a generic indication that the server knows
-#. TRANS nothing to do for that call.
-#: stdio-common/../sysdeps/gnu/errlist.c:350
-msgid "Operation not supported"
-msgstr "Operao no suportada "
+#: locale/programs/ld-collate.c:1059 locale/programs/ld-collate.c:1234
+#, c-format
+msgid "order for `%.*s' already defined at %s:%Zu"
+msgstr "ordem para “%.*s” já definida em %s:%Zu"
 
-#. TRANS An operation that cannot complete immediately was initiated on an object
-#. TRANS that has non-blocking mode selected.  Some functions that must always
-#. TRANS block (such as @code{connect}; @pxref{Connecting}) never return
-#. TRANS @code{EAGAIN}.  Instead, they return @code{EINPROGRESS} to indicate that
-#. TRANS the operation has begun and will take some time.  Attempts to manipulate
-#. TRANS the object before the call completes return @code{EALREADY}.  You can
-#. TRANS use the @code{select} function to find out when the pending operation
-#. TRANS has completed; @pxref{Waiting for I/O}.
-#: stdio-common/../sysdeps/gnu/errlist.c:300
-msgid "Operation now in progress"
-msgstr "Operao agora em progresso"
+#: locale/programs/ld-collate.c:1109
+#, c-format
+msgid "%s: the start and the end symbol of a range must stand for characters"
+msgstr "%s: o símbolo de início e terminação de um intervalo deve representar caracteres"
 
-#. TRANS In the GNU C library, this is another name for @code{EAGAIN} (above).
-#. TRANS The values are always the same, on every operating system.
-#. TRANS
-#. TRANS C libraries in many older Unix systems have @code{EWOULDBLOCK} as a
-#. TRANS separate error code.
-#: stdio-common/../sysdeps/gnu/errlist.c:288
-msgid "Operation would block"
-msgstr "Operation causaria bloqueio"
+#: locale/programs/ld-collate.c:1136
+#, c-format
+msgid "%s: byte sequences of first and last character must have the same length"
+msgstr "%s: sequências de byte de primeiro e último caractere deve ter o mesmo comprimento"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:646
-msgid "Out of streams resources"
-msgstr "Sem recursos de streams"
+#: locale/programs/ld-collate.c:1178
+#, c-format
+msgid "%s: byte sequence of first character of range is not lower than that of the last character"
+msgstr "%s: sequência de byte do primeiro caractere de intervalo não é menor que aquele do último caractere"
 
-#: iconv/iconv_prog.c:59 locale/programs/localedef.c:101
-msgid "Output control:"
-msgstr "Controle de Sada:"
+#: locale/programs/ld-collate.c:1303
+#, c-format
+msgid "%s: symbolic range ellipsis must not directly follow `order_start'"
+msgstr "%s: elipse de intervalo simbólico não pode seguir diretamente “order_start”"
 
-#: elf/sprof.c:76
-msgid "Output selection:"
-msgstr "Seleo de Sada:"
+#: locale/programs/ld-collate.c:1307
+#, c-format
+msgid "%s: symbolic range ellipsis must not be directly followed by `order_end'"
+msgstr "%s: elipse de intervalo simbólico não pode estar seguido diretamente por “order_end”"
 
-#: nis/nis_print.c:316
+#: locale/programs/ld-collate.c:1327 locale/programs/ld-ctype.c:1363
 #, c-format
-msgid "Owner         : %s\n"
-msgstr "Dono          : %s\n"
+msgid "`%s' and `%.*s' are not valid names for symbolic range"
+msgstr "“%s” e “%.*s” não são nomes válidos para intervalo simbólico"
 
-#: nis/nis_print.c:126
-msgid "PRIVATE\n"
-msgstr "PRIVADO\n"
+#: locale/programs/ld-collate.c:1377 locale/programs/ld-collate.c:3708
+#, c-format
+msgid "%s: order for `%.*s' already defined at %s:%Zu"
+msgstr "%s: ordem para “%.*s” já definida em %s:%Zu"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:738
-msgid "Package not installed"
-msgstr "Pacote no instalado"
+#: locale/programs/ld-collate.c:1386
+#, c-format
+msgid "%s: `%s' must be a character"
+msgstr "%s: “%s” deve ser um caractere"
 
-#: nscd/nscd_conf.c:84
+#: locale/programs/ld-collate.c:1580
 #, c-format
-msgid "Parse error: %s"
-msgstr "Erro de verificao (parser): %s"
+msgid "%s: `position' must be used for a specific level in all sections or none"
+msgstr "%s: “position” deve ser usado para um nível específico em todas as seções ou nenhuma"
 
-#: nis/nis_error.c:54
-msgid "Partial Success"
-msgstr "Sucesso Parcial"
+#: locale/programs/ld-collate.c:1604
+#, c-format
+msgid "symbol `%s' not defined"
+msgstr "símbolo “%s” não definido"
 
-#: nis/nis_error.c:62
-msgid "Passed object is not the same object on server"
-msgstr "Objeto passado no  o mesmo objeto no servidor"
+#: locale/programs/ld-collate.c:1680 locale/programs/ld-collate.c:1785
+#, c-format
+msgid "symbol `%s' has the same encoding as"
+msgstr "o símbolo “%s” possui a mesma codificação que"
 
-#. TRANS Permission denied; the file permissions do not allow the attempted operation.
-#: nis/nis_error.c:38 nis/ypclnt.c:793
-#: stdio-common/../sysdeps/gnu/errlist.c:108
-msgid "Permission denied"
-msgstr "Permisso negada"
+#: locale/programs/ld-collate.c:1684 locale/programs/ld-collate.c:1789
+#, c-format
+msgid "symbol `%s'"
+msgstr "símbolo “%s”"
 
-#: sysdeps/unix/sysv/linux/siglist.h:64
-msgid "Power failure"
-msgstr "Falha de energia"
+#: locale/programs/ld-collate.c:1852
+msgid "too many errors; giving up"
+msgstr "número excessivo de erros; desistindo"
 
-#: posix/regex.c:1026
-msgid "Premature end of regular expression"
-msgstr "Fim prematuro da expresso regular"
+#: locale/programs/ld-collate.c:2508 locale/programs/ld-collate.c:3896
+#, c-format
+msgid "%s: nested conditionals not supported"
+msgstr "%s: condicionais aninhados sem suporte"
 
-#: db2/makedb.c:63
-msgid "Print content of database file, one entry a line"
-msgstr "Mostra o contedo da base de dados do arquivo, um entrada por linha"
+#: locale/programs/ld-collate.c:2526
+#, c-format
+msgid "%s: more than one 'else'"
+msgstr "%s: mais que um “else”"
 
-#: nscd/nscd.c:83
-msgid "Print current configuration statistic"
-msgstr "Mostra estatstica da configurao atual"
+#: locale/programs/ld-collate.c:2701
+#, c-format
+msgid "%s: duplicate definition of `%s'"
+msgstr "%s: definição duplicada de “%s”"
 
-#: locale/programs/localedef.c:107
-msgid "Print more messages"
-msgstr "Mostra mais mensagens"
+#: locale/programs/ld-collate.c:2737
+#, c-format
+msgid "%s: duplicate declaration of section `%s'"
+msgstr "%s: declaração duplicada da seção “%s”"
 
-#: argp/argp-parse.c:148
-msgid "Print program version"
-msgstr "Mostra verso do programa"
+#: locale/programs/ld-collate.c:2873
+#, c-format
+msgid "%s: unknown character in collating symbol name"
+msgstr "%s: caractere desconhecido no nome de símbolo de comparação"
 
-#: nis/nis_error.c:29
-msgid "Probable success"
-msgstr "Sucesso provvel"
+#: locale/programs/ld-collate.c:3002
+#, c-format
+msgid "%s: unknown character in equivalent definition name"
+msgstr "%s: caractere desconhecido no nome de definição equivalente"
 
-#: nis/nis_error.c:31
-msgid "Probably not found"
-msgstr "Provavelmente no encontrado"
+#: locale/programs/ld-collate.c:3013
+#, c-format
+msgid "%s: unknown character in equivalent definition value"
+msgstr "%s: caractere desconhecido no valor de definição equivalente"
 
-#: stdio-common/../sysdeps/unix/siglist.c:52
-#: sysdeps/unix/sysv/linux/siglist.h:46
-msgid "Profiling timer expired"
-msgstr "Tempo expirado para profiling"
+#: locale/programs/ld-collate.c:3023
+#, c-format
+msgid "%s: unknown symbol `%s' in equivalent definition"
+msgstr "%s: símbolo desconhecido “%s” na definição equivalente"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:690
-msgid "Protocol driver not attached"
-msgstr "Driver de protocolo no anexado"
+#: locale/programs/ld-collate.c:3032
+msgid "error while adding equivalent collating symbol"
+msgstr "erro ao adicionar símbolo de colação equivalente"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:658
-msgid "Protocol error"
-msgstr "Erro de protocolo"
+#: locale/programs/ld-collate.c:3070
+#, c-format
+msgid "duplicate definition of script `%s'"
+msgstr "definição duplicada de script “%s”"
 
-#. TRANS The socket communications protocol family you requested is not supported.
-#: stdio-common/../sysdeps/gnu/errlist.c:355
-msgid "Protocol family not supported"
-msgstr "Famlia de protocolo no suportada"
+#: locale/programs/ld-collate.c:3118
+#, c-format
+msgid "%s: unknown section name `%.*s'"
+msgstr "%s: nome de seção desconhecida “%.*s”"
 
-#. TRANS You specified a socket option that doesn't make sense for the
-#. TRANS particular protocol being used by the socket.  @xref{Socket Options}.
-#: stdio-common/../sysdeps/gnu/errlist.c:328
-msgid "Protocol not available"
-msgstr "Protocolo no disponvel"
+#: locale/programs/ld-collate.c:3147
+#, c-format
+msgid "%s: multiple order definitions for section `%s'"
+msgstr "%s: múltiplas definições de ordem para a seção “%s”"
 
-#. TRANS The socket domain does not support the requested communications protocol
-#. TRANS (perhaps because the requested protocol is completely invalid).
-#. TRANS @xref{Creating a Socket}.
-#: stdio-common/../sysdeps/gnu/errlist.c:335
-msgid "Protocol not supported"
-msgstr "Protocolo no suportado"
+#: locale/programs/ld-collate.c:3175
+#, c-format
+msgid "%s: invalid number of sorting rules"
+msgstr "%s: número inválido de regras de ordenação"
 
-#. TRANS The socket type does not support the requested communications protocol.
-#: stdio-common/../sysdeps/gnu/errlist.c:322
-msgid "Protocol wrong type for socket"
-msgstr "Tipo errado de protocolo para socket"
+#: locale/programs/ld-collate.c:3202
+#, c-format
+msgid "%s: multiple order definitions for unnamed section"
+msgstr "%s: múltiplas definições de ordem para seção sem nome"
 
-#: nis/nis_error.c:64
-msgid "Query illegal for named table"
-msgstr "Pergunta ilegal para tabela nominada"
+#: locale/programs/ld-collate.c:3257 locale/programs/ld-collate.c:3387
+#: locale/programs/ld-collate.c:3750
+#, c-format
+msgid "%s: missing `order_end' keyword"
+msgstr "%s: faltando palavra-chave “order_end”"
 
-#: stdio-common/../sysdeps/unix/siglist.c:28
-#: sysdeps/unix/sysv/linux/siglist.h:24
-msgid "Quit"
-msgstr "Sair"
+#: locale/programs/ld-collate.c:3320
+#, c-format
+msgid "%s: order for collating symbol %.*s not yet defined"
+msgstr "%s: ordem para símbolo de comparação %.*s ainda não definida"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:754
-msgid "RFS specific error"
-msgstr "Erro especfico de RFS"
+#: locale/programs/ld-collate.c:3338
+#, c-format
+msgid "%s: order for collating element %.*s not yet defined"
+msgstr "%s: ordem para elemento de comparação %.*s ainda não definida"
 
-#. TRANS ???
-#: stdio-common/../sysdeps/gnu/errlist.c:539
-msgid "RPC bad procedure for program"
-msgstr "Procedimento RPC ruim para programa"
+#: locale/programs/ld-collate.c:3349
+#, c-format
+msgid "%s: cannot reorder after %.*s: symbol not known"
+msgstr "%s: não foi possível reordenar após %.*s: símbolo desconhecido"
 
-#: nis/ypclnt.c:767
-msgid "RPC failure on NIS operation"
-msgstr "Falha RPC na operao NIS"
+#: locale/programs/ld-collate.c:3401 locale/programs/ld-collate.c:3762
+#, c-format
+msgid "%s: missing `reorder-end' keyword"
+msgstr "%s: faltando palavra-chave “reorder-end”"
 
-#. TRANS ???
-#: stdio-common/../sysdeps/gnu/errlist.c:529
-msgid "RPC program not available"
-msgstr "Programa RPC no disponvel"
+#: locale/programs/ld-collate.c:3435 locale/programs/ld-collate.c:3633
+#, c-format
+msgid "%s: section `%.*s' not known"
+msgstr "%s: seção “%.*s” desconhecida"
 
-#. TRANS ???
-#: stdio-common/../sysdeps/gnu/errlist.c:534
-msgid "RPC program version wrong"
-msgstr "Verso incorreta de programa RPC"
+#: locale/programs/ld-collate.c:3500
+#, c-format
+msgid "%s: bad symbol <%.*s>"
+msgstr "%s: símbolo inválido <%.*s>"
 
-#. TRANS ???
-#: stdio-common/../sysdeps/gnu/errlist.c:519
-msgid "RPC struct is bad"
-msgstr "Estrutura RPC invlida"
+#: locale/programs/ld-collate.c:3696
+#, c-format
+msgid "%s: cannot have `%s' as end of ellipsis range"
+msgstr "%s: não pode ter “%s” como terminação de intervalo de elipse"
 
-#. TRANS ???
-#: stdio-common/../sysdeps/gnu/errlist.c:524
-msgid "RPC version wrong"
-msgstr "Verso RPC incorreta"
+#: locale/programs/ld-collate.c:3746
+#, c-format
+msgid "%s: empty category description not allowed"
+msgstr "%s: descrição vazia para categoria não permitida"
 
-#: sunrpc/clnt_perr.c:215
-msgid "RPC: (unknown error code)"
-msgstr "RPC: (cdigo de erro desconhecido)"
+#: locale/programs/ld-collate.c:3765
+#, c-format
+msgid "%s: missing `reorder-sections-end' keyword"
+msgstr "%s: faltando palavra-chave “reorder-sections-end”"
 
-#: sunrpc/clnt_perr.c:176
-msgid "RPC: Authentication error"
-msgstr "RPC: Erro de autenticao"
+#: locale/programs/ld-collate.c:3929
+#, c-format
+msgid "%s: '%s' without matching 'ifdef' or 'ifndef'"
+msgstr "%s: “%s” sem “ifdef” ou “ifndef” correspondente"
 
-#: sunrpc/clnt_perr.c:166
-msgid "RPC: Can't decode result"
-msgstr "RPC: Impossvel decodificar resultado"
+#: locale/programs/ld-collate.c:3947
+#, c-format
+msgid "%s: 'endif' without matching 'ifdef' or 'ifndef'"
+msgstr "%s: “endif” sem “ifdef” ou “ifndef” correspondente"
 
-#: sunrpc/clnt_perr.c:164
-msgid "RPC: Can't encode arguments"
-msgstr "RPC: impossvel codificar argumentos"
+#: locale/programs/ld-ctype.c:448
+msgid "No character set name specified in charmap"
+msgstr "Nenhum nome de conjunto de caracteres especificado no mapa de caracteres"
 
-#: sunrpc/clnt_perr.c:196
-msgid "RPC: Failed (unspecified error)"
-msgstr "RPC: Falhou (erro no especificado)"
+#: locale/programs/ld-ctype.c:476
+#, c-format
+msgid "character L'\\u%0*x' in class `%s' must be in class `%s'"
+msgstr "caractere L“\\u%0*x” na classe “%s” deve estar na classe “%s”"
 
-#: sunrpc/clnt_perr.c:174
-msgid "RPC: Incompatible versions of RPC"
-msgstr "RPC: Verses incompatveis de RPC"
+#: locale/programs/ld-ctype.c:490
+#, c-format
+msgid "character L'\\u%0*x' in class `%s' must not be in class `%s'"
+msgstr "caractere L“\\u%0*x” na classe “%s” não pode estar na classe “%s”"
 
-#: sunrpc/clnt_perr.c:192
-msgid "RPC: Port mapper failure"
-msgstr "RPC: Falha no Port mapper"
+#: locale/programs/ld-ctype.c:504 locale/programs/ld-ctype.c:560
+#, c-format
+msgid "internal error in %s, line %u"
+msgstr "erro interno em %s, linha %u"
 
-#: sunrpc/clnt_perr.c:182
-msgid "RPC: Procedure unavailable"
-msgstr "RPC: Procedimento indisponvel"
+#: locale/programs/ld-ctype.c:532
+#, c-format
+msgid "character '%s' in class `%s' must be in class `%s'"
+msgstr "caractere “%s” na classe “%s” deve estar na classe “%s”"
 
-#: sunrpc/clnt_perr.c:194
-msgid "RPC: Program not registered"
-msgstr "RPC: Programa no registrado"
+#: locale/programs/ld-ctype.c:547
+#, c-format
+msgid "character '%s' in class `%s' must not be in class `%s'"
+msgstr "caractere “%s” na classe “%s” não pode estar na classe “%s”"
 
-#: sunrpc/clnt_perr.c:178
-msgid "RPC: Program unavailable"
-msgstr "RPC: Programa indisponvel"
+#: locale/programs/ld-ctype.c:576 locale/programs/ld-ctype.c:611
+#, c-format
+msgid "<SP> character not in class `%s'"
+msgstr "<SP> caractere não está na classe “%s”"
 
-#: sunrpc/clnt_perr.c:180
-msgid "RPC: Program/version mismatch"
-msgstr "RPC: Programa/verso incompatveis"
-
-#: sunrpc/clnt_perr.c:186
-msgid "RPC: Remote system error"
-msgstr "RPC: Erro remoto de sistema"
-
-#: sunrpc/clnt_perr.c:184
-msgid "RPC: Server can't decode arguments"
-msgstr "RPC: O servidor no pode decodificar os argumentos"
-
-#: sunrpc/clnt_perr.c:162
-msgid "RPC: Success"
-msgstr "RPC: Sucesso"
+#: locale/programs/ld-ctype.c:587 locale/programs/ld-ctype.c:621
+#, c-format
+msgid "<SP> character must not be in class `%s'"
+msgstr "<SP> caractere não pode estar na classe “%s”"
 
-#: sunrpc/clnt_perr.c:172
-msgid "RPC: Timed out"
-msgstr "RPC: Tempo esgotado"
+#: locale/programs/ld-ctype.c:601
+msgid "character <SP> not defined in character map"
+msgstr "caractere <SP> não definido no mapa de caracteres"
 
-#: sunrpc/clnt_perr.c:170
-msgid "RPC: Unable to receive"
-msgstr "RPC: Impossvel receber"
+#: locale/programs/ld-ctype.c:735
+msgid "`digit' category has not entries in groups of ten"
+msgstr "categoria “digit” não possui entradas em grupos de dez"
 
-#: sunrpc/clnt_perr.c:168
-msgid "RPC: Unable to send"
-msgstr "RPC: Impossvel enviar"
+#: locale/programs/ld-ctype.c:784
+msgid "no input digits defined and none of the standard names in the charmap"
+msgstr "nenhum dígito de entrada definido e nenhum dos nomes padrões no mapa de caracteres"
 
-#: sunrpc/clnt_perr.c:188
-msgid "RPC: Unknown host"
-msgstr "RPC: Host desconhecido"
+#: locale/programs/ld-ctype.c:849
+msgid "not all characters used in `outdigit' are available in the charmap"
+msgstr "nem todos os caracteres usados em “outdigit” estão disponíveis no mapa de caracteres"
 
-#: sunrpc/clnt_perr.c:190
-msgid "RPC: Unknown protocol"
-msgstr "RPC: Protocolo desconhecido"
+#: locale/programs/ld-ctype.c:866
+msgid "not all characters used in `outdigit' are available in the repertoire"
+msgstr "nem todos os caracteres usados em “outdigit” estão disponíveis no repertório"
 
-#: nis/nis_print.c:184
+#: locale/programs/ld-ctype.c:1131
 #, c-format
-msgid "RSA (%d bits)\n"
-msgstr "RSA (%d bits)\n"
+msgid "character class `%s' already defined"
+msgstr "classe de caractere “%s” já definida"
 
-#: elf/dlsym.c:59 elf/dlvsym.c:62
-msgid "RTLD_NEXT used in code not dynamically loaded"
-msgstr "RTLD_NEXT usado em cdigo no dinamicamente carregado"
+#: locale/programs/ld-ctype.c:1137
+#, c-format
+msgid "implementation limit: no more than %Zd character classes allowed"
+msgstr "limite de implementação: não são permitidos mais que %Zd classes de caracteres"
 
-#: elf/sprof.c:88
-msgid "Read and display shared object profiling data"
-msgstr "L e mostra perfil de dados do objeto compartilhado"
+#: locale/programs/ld-ctype.c:1163
+#, c-format
+msgid "character map `%s' already defined"
+msgstr "mapa de caracteres “%s” já definido"
 
-#: nscd/nscd.c:78
-msgid "Read configuration data from NAME"
-msgstr "L configurao de dados de NOME"
+#: locale/programs/ld-ctype.c:1169
+#, c-format
+msgid "implementation limit: no more than %d character maps allowed"
+msgstr "limite de implementação: não são permitidos mais que %d mapas de caracteres"
 
-#. TRANS An attempt was made to modify something on a read-only file system.
-#: stdio-common/../sysdeps/gnu/errlist.c:218
-msgid "Read-only file system"
-msgstr "Sistema de arquivos somente para leitura"
+#: locale/programs/ld-ctype.c:1434 locale/programs/ld-ctype.c:1559
+#: locale/programs/ld-ctype.c:1665 locale/programs/ld-ctype.c:2341
+#: locale/programs/ld-ctype.c:3299
+#, c-format
+msgid "%s: field `%s' does not contain exactly ten entries"
+msgstr "%s: campo “%s” não contém exatamente dez entradas"
 
-#: string/strsignal.c:66
+#: locale/programs/ld-ctype.c:1462 locale/programs/ld-ctype.c:2036
 #, c-format
-msgid "Real-time signal %d"
-msgstr "Sinal de tempo-real %d"
+msgid "to-value <U%0*X> of range is smaller than from-value <U%0*X>"
+msgstr "valor-para <U%0*X> de intervalo é menor que o valor-de <U%0*X>"
 
-#: posix/regex.c:1027
-msgid "Regular expression too big"
-msgstr "Expresso regular muito longa"
+#: locale/programs/ld-ctype.c:1589
+msgid "start and end character sequence of range must have the same length"
+msgstr "sequência de caracteres de início e término de intervalo devem ter o mesmo comprimento"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:810
-msgid "Remote I/O error"
-msgstr "Erro de E/S remota"
+#: locale/programs/ld-ctype.c:1596
+msgid "to-value character sequence is smaller than from-value sequence"
+msgstr "sequência de caracteres do valor-para é menor que a sequência de valor-de"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:766
-msgid "Remote address changed"
-msgstr "Endereo remoto alterado"
+#: locale/programs/ld-ctype.c:1956 locale/programs/ld-ctype.c:2007
+msgid "premature end of `translit_ignore' definition"
+msgstr "fim prematuro da definição “translit_ignore”"
 
-#: inet/ruserpass.c:162
-msgid "Remove password or make file unreadable by others."
-msgstr "Remova senha ou torne arquivo no-legvel por outros."
+#: locale/programs/ld-ctype.c:1962 locale/programs/ld-ctype.c:2013
+#: locale/programs/ld-ctype.c:2055
+msgid "syntax error"
+msgstr "erro de sintaxe"
 
-#: elf/sprof.c:537
+#: locale/programs/ld-ctype.c:2188
 #, c-format
-msgid "Reopening shared object `%s' failed"
-msgstr "Reabertura de objeto compartilhado `%s' falhou"
-
-#: nis/nis_print.c:170
-msgid "Replicate :\n"
-msgstr "Duplicado :\n"
+msgid "%s: syntax error in definition of new character class"
+msgstr "%s: erro de sintaxe na definição da nova classe de caracteres"
 
-#: argp/argp-help.c:1638
+#: locale/programs/ld-ctype.c:2203
 #, c-format
-msgid "Report bugs to %s.\n"
-msgstr "Reporte erros (bugs) para %s.\n"
+msgid "%s: syntax error in definition of new character map"
+msgstr "%s: erro de sintaxe na definição do novo mapa de caracteres"
 
-#: catgets/gencat.c:223 db2/makedb.c:229 iconv/iconv_prog.c:280
-#: locale/programs/locale.c:254 locale/programs/localedef.c:389
-msgid "Report bugs using the `glibcbug' script to <bugs@gnu.org>.\n"
-msgstr "Reportar erros usando o script `glibcbug' para <bugs@gnu.org>.\n"
+#: locale/programs/ld-ctype.c:2363
+msgid "ellipsis range must be marked by two operands of same type"
+msgstr "intervalo de elipse deve estar marcado per dois operandos do mesmo tipo"
 
-#: nis/ypclnt.c:765
-msgid "Request arguments bad"
-msgstr "Argumentos de requisio invlidos"
+#: locale/programs/ld-ctype.c:2372
+msgid "with symbolic name range values the absolute ellipsis `...' must not be used"
+msgstr "com valores de intervalo com nome simbólico, a elipse absoluta “...” não pode ser usada"
 
-#: resolv/herror.c:73
-msgid "Resolver Error 0 (no error)"
-msgstr "Erro de resolvedor 0 (no h erro)"
+#: locale/programs/ld-ctype.c:2387
+msgid "with UCS range values one must use the hexadecimal symbolic ellipsis `..'"
+msgstr "com valores de intervalo de UCS, deve-se usar a elipse hexadecimal simbólica “..”"
 
-#: resolv/herror.c:117
-msgid "Resolver internal error"
-msgstr "Erro interno do resolvedor"
+#: locale/programs/ld-ctype.c:2401
+msgid "with character code range values one must use the absolute ellipsis `...'"
+msgstr "com valores de intervalo de código de caracteres, deve-se usar a elipse absoluta “…”"
 
-#. TRANS Deadlock avoided; allocating a system resource would have resulted in a
-#. TRANS deadlock situation.  The system does not guarantee that it will notice
-#. TRANS all such situations.  This error means you got lucky and the system
-#. TRANS noticed; it might just hang.  @xref{File Locks}, for an example.
-#: stdio-common/../sysdeps/gnu/errlist.c:97
-msgid "Resource deadlock avoided"
-msgstr "Evitado deadlock de recurso"
+#: locale/programs/ld-ctype.c:2552
+#, c-format
+msgid "duplicated definition for mapping `%s'"
+msgstr "definição duplicada para o mapeamento “%s”"
 
-#: stdio-common/../sysdeps/unix/siglist.c:54
-msgid "Resource lost"
-msgstr "Recurso perdido"
+#: locale/programs/ld-ctype.c:2638 locale/programs/ld-ctype.c:2782
+#, c-format
+msgid "%s: `translit_start' section does not end with `translit_end'"
+msgstr "%s: a seção “translit_start” não termina com “translit_end”"
 
-#. TRANS Resource temporarily unavailable; the call might work if you try again
-#. TRANS later.  The macro @code{EWOULDBLOCK} is another name for @code{EAGAIN};
-#. TRANS they are always the same in the GNU C library.
-#. TRANS
-#. TRANS This error can happen in a few different situations:
-#. TRANS
-#. TRANS @itemize @bullet
-#. TRANS @item
-#. TRANS An operation that would block was attempted on an object that has
-#. TRANS non-blocking mode selected.  Trying the same operation again will block
-#. TRANS until some external condition makes it possible to read, write, or
-#. TRANS connect (whatever the operation).  You can use @code{select} to find out
-#. TRANS when the operation will be possible; @pxref{Waiting for I/O}.
-#. TRANS
-#. TRANS @strong{Portability Note:} In many older Unix systems, this condition
-#. TRANS was indicated by @code{EWOULDBLOCK}, which was a distinct error code
-#. TRANS different from @code{EAGAIN}.  To make your program portable, you should
-#. TRANS check for both codes and treat them the same.
-#. TRANS
-#. TRANS @item
-#. TRANS A temporary resource shortage made an operation impossible.  @code{fork}
-#. TRANS can return this error.  It indicates that the shortage is expected to
-#. TRANS pass, so your program can try the call again later and it may succeed.
-#. TRANS It is probably a good idea to delay for a few seconds before trying it
-#. TRANS again, to allow time for other processes to release scarce resources.
-#. TRANS Such shortages are usually fairly serious and affect the whole system,
-#. TRANS so usually an interactive program should report the error to the user
-#. TRANS and return to its command loop.
-#. TRANS @end itemize
-#: stdio-common/../sysdeps/gnu/errlist.c:279
-msgid "Resource temporarily unavailable"
-msgstr "Recurso temporariamente indisponvel"
+#: locale/programs/ld-ctype.c:2733
+#, c-format
+msgid "%s: duplicate `default_missing' definition"
+msgstr "%s: definição duplicada de “default_missing”"
 
-#: nis/nis_error.c:47
-msgid "Results Sent to callback proc"
-msgstr "Resultados enviados para processo chamador"
+#: locale/programs/ld-ctype.c:2738
+msgid "previous definition was here"
+msgstr "definição anterior estava aqui"
 
-#: elf/sprof.c:91
-msgid "SHOBJ [PROFDATA]"
-msgstr "SHOBJ [PROFDATA]"
+#: locale/programs/ld-ctype.c:2760
+#, c-format
+msgid "%s: no representable `default_missing' definition found"
+msgstr "%s: nenhuma definição representável de “default_missing” localizada"
 
-#: nis/nis_print.c:33
-msgid "SUNYP"
-msgstr "SUNYP"
+#: locale/programs/ld-ctype.c:2877 locale/programs/ld-ctype.c:2973
+#: locale/programs/ld-ctype.c:2992 locale/programs/ld-ctype.c:3012
+#: locale/programs/ld-ctype.c:3032 locale/programs/ld-ctype.c:3052
+#: locale/programs/ld-ctype.c:3072 locale/programs/ld-ctype.c:3111
+#: locale/programs/ld-ctype.c:3131 locale/programs/ld-ctype.c:3195
+#: locale/programs/ld-ctype.c:3236 locale/programs/ld-ctype.c:3259
+#, c-format
+msgid "%s: character `%s' not defined while needed as default value"
+msgstr "%s: caractere “%s” não definido enquanto necessário como valor padrão"
 
-#: nis/nis_print.c:265
+#: locale/programs/ld-ctype.c:2882 locale/programs/ld-ctype.c:2978
+#: locale/programs/ld-ctype.c:2997 locale/programs/ld-ctype.c:3017
+#: locale/programs/ld-ctype.c:3037 locale/programs/ld-ctype.c:3057
+#: locale/programs/ld-ctype.c:3077 locale/programs/ld-ctype.c:3116
+#: locale/programs/ld-ctype.c:3136 locale/programs/ld-ctype.c:3200
 #, c-format
-msgid "Search Path         : %s\n"
-msgstr "Rota de Busca       :%s\n"
+msgid "%s: character `%s' in charmap not representable with one byte"
+msgstr "%s: caractere “%s” no mapa de caracteres não representável com um byte"
 
-#: stdio-common/../sysdeps/unix/siglist.c:36
-#: sysdeps/unix/sysv/linux/siglist.h:31
-msgid "Segmentation fault"
-msgstr "Falha de segmentao"
+#: locale/programs/ld-ctype.c:3242 locale/programs/ld-ctype.c:3265
+#, c-format
+msgid "%s: character `%s' needed as default value not representable with one byte"
+msgstr "%s: caractere “%s” necessário como valor padrão não representável com um byte"
 
-#: nis/nis_error.c:35
-msgid "Server busy, try again"
-msgstr "Servidor ocupado, tente novamente"
+#: locale/programs/ld-ctype.c:3321
+msgid "no output digits defined and none of the standard names in the charmap"
+msgstr "nenhum dígito de saída definido e nenhum dos nomes padrões no mapa de caracteres"
 
-#: nis/nis_error.c:41
-msgid "Server out of memory"
-msgstr "Memria do servidor exaurida"
+#: locale/programs/ld-ctype.c:3570
+#, c-format
+msgid "%s: transliteration data from locale `%s' not available"
+msgstr "%s: dados de transliteração da localidade “%s” não disponíveis"
 
-#: sunrpc/clnt_perr.c:277
-msgid "Server rejected credential"
-msgstr "Servidor rejeitou credencial"
+#: locale/programs/ld-ctype.c:3669
+#, c-format
+msgid "%s: table for class \"%s\": %lu bytes"
+msgstr "%s: tabela para a classe “%s”: %lu bytes"
 
-#: sunrpc/clnt_perr.c:281
-msgid "Server rejected verifier"
-msgstr "Servidor rejeitou verificador"
+#: locale/programs/ld-ctype.c:3733
+#, c-format
+msgid "%s: table for map \"%s\": %lu bytes"
+msgstr "%s: tabela para o mapa “%s”: %lu bytes"
 
-#: posix/../sysdeps/posix/gai_strerror.c:38
-msgid "Servname not supported for ai_socktype"
-msgstr "`Servname' no suportado para `ai_socktype'"
+#: locale/programs/ld-ctype.c:3857
+#, c-format
+msgid "%s: table for width: %lu bytes"
+msgstr "%s: tabela para largura: %lu bytes"
 
-#: argp/argp-parse.c:89
-msgid "Set the program name"
-msgstr "Configura o nome do programa"
+#: locale/programs/ld-identification.c:173
+#, c-format
+msgid "%s: no identification for category `%s'"
+msgstr "%s: nenhuma identificação para a categoria “%s”"
 
-#: nscd/nscd.c:82
-msgid "Shut the server down"
-msgstr "Encerra o servidor"
+#: locale/programs/ld-identification.c:197
+#, c-format
+msgid "%s: unknown standard `%s' for category `%s'"
+msgstr "%s: padrão desconhecido “%s” para a categoria “%s”"
 
-#: stdio-common/../sysdeps/unix/siglist.c:25
-msgid "Signal 0"
-msgstr "Sinal 0"
+#: locale/programs/ld-identification.c:380
+#, c-format
+msgid "%s: duplicate category version definition"
+msgstr "%s: definição duplicada da versão da categoria"
 
-#. TRANS A file that isn't a socket was specified when a socket is required.
-#: stdio-common/../sysdeps/gnu/errlist.c:311
-msgid "Socket operation on non-socket"
-msgstr "Operao socket em um arquivo no-socket"
+#: locale/programs/ld-measurement.c:111
+#, c-format
+msgid "%s: invalid value for field `%s'"
+msgstr "%s: valor inválido para o campo “%s”"
 
-#. TRANS The socket type is not supported.
-#: stdio-common/../sysdeps/gnu/errlist.c:340
-msgid "Socket type not supported"
-msgstr "Tipo socket no suportado"
+#: locale/programs/ld-messages.c:113 locale/programs/ld-messages.c:146
+#, c-format
+msgid "%s: field `%s' undefined"
+msgstr "%s: campo “%s” indefinido"
 
-#. TRANS A network connection was aborted locally.
-#: stdio-common/../sysdeps/gnu/errlist.c:394
-msgid "Software caused connection abort"
-msgstr "Trmino de conexo causada por software"
+#: locale/programs/ld-messages.c:119 locale/programs/ld-messages.c:152
+#: locale/programs/ld-monetary.c:264 locale/programs/ld-numeric.c:117
+#, c-format
+msgid "%s: value for field `%s' must not be an empty string"
+msgstr "%s: valor para campo “%s” não pode estar vazio"
 
-#: sunrpc/rpcinfo.c:658
-msgid "Sorry. You are not root\n"
-msgstr "Lamento. Voc no  o superusurio\n"
+#: locale/programs/ld-messages.c:135 locale/programs/ld-messages.c:168
+#, c-format
+msgid "%s: no correct regular expression for field `%s': %s"
+msgstr "%s: nenhuma expressão regular correta para o campo “%s”: %s"
 
-#: locale/programs/localedef.c:97
-msgid "Source definitions are found in FILE"
-msgstr "Definies fonte so encontrada no ARQUIVO"
+#: locale/programs/ld-monetary.c:228
+#, c-format
+msgid "%s: value of field `int_curr_symbol' has wrong length"
+msgstr "%s: valor do campo “int_curr_symbol” possui comprimento incorreto"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:746
-msgid "Srmount error"
-msgstr "Erro de Srmount"
+#: locale/programs/ld-monetary.c:245
+#, c-format
+msgid "%s: value of field `int_curr_symbol' does not correspond to a valid name in ISO 4217 [--no-warnings=intcurrsym]"
+msgstr "%s: valor do campo “int_curr_symbol” não corresponde a um nome válido na ISO 4217 [--no-warnings=intcurrsym]"
 
-#: sysdeps/unix/sysv/linux/siglist.h:59
-msgid "Stack fault"
-msgstr "Falha de pilha"
+#: locale/programs/ld-monetary.c:293 locale/programs/ld-monetary.c:322
+#, c-format
+msgid "%s: value for field `%s' must be in range %d...%d"
+msgstr "%s: valor para o campo “%s” deve estar no intervalo %d…%d"
 
-#. TRANS Stale NFS file handle.  This indicates an internal confusion in the NFS
-#. TRANS system which is due to file system rearrangements on the server host.
-#. TRANS Repairing this condition usually requires unmounting and remounting
-#. TRANS the NFS file system on the local host.
-#: stdio-common/../sysdeps/gnu/errlist.c:506
-msgid "Stale NFS file handle"
-msgstr "Manipulador de arquivo NFS corrompido"
+#: locale/programs/ld-monetary.c:549 locale/programs/ld-numeric.c:228
+#, c-format
+msgid "%s: value for field `%s' must be a single character"
+msgstr "%s: valor para o campo “%s” deve estar em um único caractere"
 
-#: nscd/nscd.c:81
-msgid "Start NUMBER threads"
-msgstr "Iniciar NMERO de linhas (threads)"
+#: locale/programs/ld-monetary.c:646 locale/programs/ld-numeric.c:272
+#, c-format
+msgid "%s: `-1' must be last entry in `%s' field"
+msgstr "%s: “-1” deve ser o último registro no campo “%s”"
 
-#: nis/nis_print.c:357
+#: locale/programs/ld-monetary.c:668 locale/programs/ld-numeric.c:289
 #, c-format
-msgid "Status            : %s\n"
-msgstr "Posio           : %s\n"
+msgid "%s: values for field `%s' must be smaller than 127"
+msgstr "%s: valor para o campo “%s” deve ser menor que 127"
 
-#: stdio-common/../sysdeps/unix/siglist.c:43
-#: sysdeps/unix/sysv/linux/siglist.h:37
-msgid "Stopped"
-msgstr "Parado"
+#: locale/programs/ld-monetary.c:714
+msgid "conversion rate value cannot be zero"
+msgstr "valor da taxa de conversão não pode ser zero"
 
-#: stdio-common/../sysdeps/unix/siglist.c:42
-#: sysdeps/unix/sysv/linux/siglist.h:36
-msgid "Stopped (signal)"
-msgstr "Parado (sinal)"
+#: locale/programs/ld-name.c:128 locale/programs/ld-telephone.c:124
+#: locale/programs/ld-telephone.c:147
+#, c-format
+msgid "%s: invalid escape sequence in field `%s'"
+msgstr "%s: sequência de escape inválida no campo “%s”"
 
-#: stdio-common/../sysdeps/unix/siglist.c:46
-#: sysdeps/unix/sysv/linux/siglist.h:40
-msgid "Stopped (tty input)"
-msgstr "Parado (entrada tty)"
+#: locale/programs/ld-time.c:245
+#, c-format
+msgid "%s: direction flag in string %Zd in `era' field is not '+' nor '-'"
+msgstr "%s: sinalizador de direção na string %Zd no campo “era” não é “+” nem “-”"
 
-#: stdio-common/../sysdeps/unix/siglist.c:47
-#: sysdeps/unix/sysv/linux/siglist.h:41
-msgid "Stopped (tty output)"
-msgstr "Parado (sada tty)"
+#: locale/programs/ld-time.c:255
+#, c-format
+msgid "%s: direction flag in string %Zd in `era' field is not a single character"
+msgstr "%s: sinalizador de direção na string %Zd no campo “era” não é um único caractere"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:790
-msgid "Streams pipe error"
-msgstr "Erro de pipe streams"
+#: locale/programs/ld-time.c:267
+#, c-format
+msgid "%s: invalid number for offset in string %Zd in `era' field"
+msgstr "%s: número inválido para deslocamento na string %Zd no campo “era”"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:794
-msgid "Structure needs cleaning"
-msgstr "A estrutura necessita de limpeza"
+#: locale/programs/ld-time.c:274
+#, c-format
+msgid "%s: garbage at end of offset value in string %Zd in `era' field"
+msgstr "%s: lixo no final do valor do deslocamento na string %Zd no campo “era”"
 
-#: nis/nis_error.c:28 nis/ypclnt.c:763 nis/ypclnt.c:837 posix/regex.c:1012
-#: stdio-common/../sysdeps/gnu/errlist.c:19
-msgid "Success"
-msgstr "Sucesso"
+#: locale/programs/ld-time.c:324
+#, c-format
+msgid "%s: invalid starting date in string %Zd in `era' field"
+msgstr "%s: data de início inválida na string %Zd no campo “era”"
 
-#: locale/programs/localedef.c:106
-msgid "Suppress warnings and information messages"
-msgstr "Suprime avisos e mensagens de informao"
+#: locale/programs/ld-time.c:332
+#, c-format
+msgid "%s: garbage at end of starting date in string %Zd in `era' field "
+msgstr "%s: lixo no final da data início na string %Zd no campo “era” "
 
-#: locale/programs/localedef.c:96
-msgid "Symbolic character names defined in FILE"
-msgstr "Nomes de caracteres simblicos definido en ARQUIVO"
+#: locale/programs/ld-time.c:350
+#, c-format
+msgid "%s: starting date is invalid in string %Zd in `era' field"
+msgstr "%s: data de início inválida na string %Zd no campo “era”"
 
-#: posix/../sysdeps/posix/gai_strerror.c:40
-msgid "System error"
-msgstr "Erro de sistema"
+#: locale/programs/ld-time.c:398 locale/programs/ld-time.c:424
+#, c-format
+msgid "%s: invalid stopping date in string %Zd in `era' field"
+msgstr "%s: data de parada inválida na string %Zd no campo “era”"
 
-#: locale/programs/locale.c:63
-msgid "System information:"
-msgstr "Informao do Sistema:"
+#: locale/programs/ld-time.c:406
+#, c-format
+msgid "%s: garbage at end of stopping date in string %Zd in `era' field"
+msgstr "%s: lixo no final da data de parada na string %Zd no campo “era”"
 
-#: nis/ypclnt.c:843
-msgid "System resource allocation failure"
-msgstr "Falha de alocao de recursos do sistema"
+#: locale/programs/ld-time.c:432
+#, c-format
+msgid "%s: missing era name in string %Zd in `era' field"
+msgstr "%s: faltando o nome da era na string %Zd no campo “era”"
 
-#: locale/programs/localedef.c:384
+#: locale/programs/ld-time.c:443
 #, c-format
-msgid ""
-"System's directory for character maps : %s\n"
-"                       repertoire maps: %s\n"
-"                       locale path    : %s\n"
-"%s"
-msgstr ""
-"Diretrio do sistema para mapas de caracteres: %s\n"
-"                          mapas de repertrio: %s\n"
-"                          rota de localizao: %s\n"
-"%s"
+msgid "%s: missing era format in string %Zd in `era' field"
+msgstr "%s: faltando o formato era na string %Zd no campo “era”"
 
-#: nis/nis_print.c:117
-msgid "TABLE\n"
-msgstr "TABELA\n"
+#: locale/programs/ld-time.c:488
+#, c-format
+msgid "%s: third operand for value of field `%s' must not be larger than %d"
+msgstr "%s: terceiro operando para o valor de campo “%s” não pode ser maior que %d"
 
-#: nis/nis_print.c:262
+#: locale/programs/ld-time.c:496 locale/programs/ld-time.c:504
+#: locale/programs/ld-time.c:512
 #, c-format
-msgid "Table Type          : %s\n"
-msgstr "Tipo de Tabela      : %s\n"
+msgid "%s: values for field `%s' must not be larger than %d"
+msgstr "%s: valor para o campo “%s” não pode ser maior que %d"
 
-#: posix/../sysdeps/posix/gai_strerror.c:31
-msgid "Temporary failure in name resolution"
-msgstr "Falha temporrio na resoluo de nome"
+#: locale/programs/ld-time.c:717
+#, c-format
+msgid "%s: too few values for field `%s'"
+msgstr "%s: número insuficiente de valores para o campo “%s”"
 
-#: stdio-common/../sysdeps/unix/siglist.c:40
-#: sysdeps/unix/sysv/linux/siglist.h:34
-msgid "Terminated"
-msgstr "Terminado"
+#: locale/programs/ld-time.c:762
+msgid "extra trailing semicolon"
+msgstr "ponto e vírgula extra no final"
 
-#. TRANS An attempt to execute a file that is currently open for writing, or
-#. TRANS write to a file that is currently being executed.  Often using a
-#. TRANS debugger to run a program is considered having it open for writing and
-#. TRANS will cause this error.  (The name stands for ``text file busy''.)  This
-#. TRANS is not an error in the GNU system; the text is copied as necessary.
-#: stdio-common/../sysdeps/gnu/errlist.c:197
-msgid "Text file busy"
-msgstr "rea de texto ocupada"
+#: locale/programs/ld-time.c:765
+#, c-format
+msgid "%s: too many values for field `%s'"
+msgstr "%s: número excessivo de valores para o campo “%s” de valores"
 
-#: iconv/iconv_prog.c:536
-msgid ""
-"The following list contain all the coded character sets known.  This does\n"
-"not necessarily mean that all combinations of these names can be used for\n"
-"the FROM and TO command line parameters.  One coded character set can be\n"
-"listed with several different names (aliases).\n"
-"  Some of the names are no plain strings but instead regular expressions and\n"
-"they match a variety of names which can be given as parameters to the\n"
-"program.\n"
-"\n"
-"  "
-msgstr ""
-"A lista seguinte contm todos os conjuntos de codificao de caracteres \n"
-"conhecidos.  Isto no quer dizer necessriamente que todas as combinaes\n"
-"destes nomes podem ser utilizadas nos parmetros FROM e TO.  Um conjunto\n"
-"de caracteres pode ser listado com vrios nomes diferentes (apelidos).\n"
-"  Alguns destes nomes no strings simples mas sim, expresses regulares, e\n"
-"eles combinam com uma variedade de nomes que podem ser dados como parmetrosao programa.\n"
-"\n"
-"  "
+#: locale/programs/linereader.c:130
+msgid "trailing garbage at end of line"
+msgstr "lixo no final da linha"
 
-#: nis/nis_print.c:223
-msgid "Time to live : "
-msgstr "Tempo de vida : "
+#: locale/programs/linereader.c:298
+msgid "garbage at end of number"
+msgstr "lixo no final do número"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:662
-msgid "Timer expired"
-msgstr "Tempo expirado"
+#: locale/programs/linereader.c:410
+msgid "garbage at end of character code specification"
+msgstr "lixo no final da especificação do código de caractere"
 
-#: nis/nis_error.c:55
-msgid "Too Many Attributes"
-msgstr "Muitos atributos"
+#: locale/programs/linereader.c:496
+msgid "unterminated symbolic name"
+msgstr "nome simbólico não terminado"
 
-#. TRANS Too many levels of symbolic links were encountered in looking up a file name.
-#. TRANS This often indicates a cycle of symbolic links.
-#: stdio-common/../sysdeps/gnu/errlist.c:457
-msgid "Too many levels of symbolic links"
-msgstr "Muitos nveis de links simblicos"
+#: locale/programs/linereader.c:623
+msgid "illegal escape sequence at end of string"
+msgstr "sequência de escape ilegal no final da string"
 
-#. TRANS Too many links; the link count of a single file would become too large.
-#. TRANS @code{rename} can cause this error if the file being renamed already has
-#. TRANS as many links as it can take (@pxref{Renaming Files}).
-#: stdio-common/../sysdeps/gnu/errlist.c:225
-msgid "Too many links"
-msgstr "Muitos links"
+#: locale/programs/linereader.c:627 locale/programs/linereader.c:847
+msgid "unterminated string"
+msgstr "string não terminada"
 
-#. TRANS The current process has too many files open and can't open any more.
-#. TRANS Duplicate descriptors do count toward this limit.
-#. TRANS
-#. TRANS In BSD and GNU, the number of open files is controlled by a resource
-#. TRANS limit that can usually be increased.  If you get this error, you might
-#. TRANS want to increase the @code{RLIMIT_NOFILE} limit or make it unlimited;
-#. TRANS @pxref{Limits on Resources}.
-#: stdio-common/../sysdeps/gnu/errlist.c:175
-msgid "Too many open files"
-msgstr "Muitos arquivos abertos"
+#: locale/programs/linereader.c:808
+#, c-format
+msgid "symbol `%.*s' not in charmap"
+msgstr "símbolo “%.*s” não está no mapa de caracteres"
 
-#. TRANS There are too many distinct file openings in the entire system.  Note
-#. TRANS that any number of linked channels count as just one file opening; see
-#. TRANS @ref{Linked Channels}.  This error never occurs in the GNU system.
-#: stdio-common/../sysdeps/gnu/errlist.c:182
-msgid "Too many open files in system"
-msgstr "Muitos arquivos abertos no sistema"
+#: locale/programs/linereader.c:829
+#, c-format
+msgid "symbol `%.*s' not in repertoire map"
+msgstr "símbolo “%.*s” não está no mapa de repertório"
 
-#. TRANS This means that the per-user limit on new process would be exceeded by
-#. TRANS an attempted @code{fork}.  @xref{Limits on Resources}, for details on
-#. TRANS the @code{RLIMIT_NPROC} limit.
-#: stdio-common/../sysdeps/gnu/errlist.c:487
-msgid "Too many processes"
-msgstr "Muitos processos"
+#: locale/programs/locale-spec.c:130
+#, c-format
+msgid "unknown name \"%s\""
+msgstr "nome desconhecido “%s”"
 
-#. TRANS ???
-#: stdio-common/../sysdeps/gnu/errlist.c:439
-msgid "Too many references: cannot splice"
-msgstr "Muitas referncias: no  possvel unir"
+#: locale/programs/locale.c:70
+msgid "System information:"
+msgstr "Informação do sistema:"
 
-#. TRANS The file quota system is confused because there are too many users.
-#. TRANS @c This can probably happen in a GNU system when using NFS.
-#: stdio-common/../sysdeps/gnu/errlist.c:493
-msgid "Too many users"
-msgstr "Muitos usurios"
+#: locale/programs/locale.c:72
+msgid "Write names of available locales"
+msgstr "Escreve nomes das localidades (locales) disponíveis"
 
-#: stdio-common/../sysdeps/unix/siglist.c:30
-#: sysdeps/unix/sysv/linux/siglist.h:26
-msgid "Trace/breakpoint trap"
-msgstr "Trace/breakpoint trap"
+#: locale/programs/locale.c:74
+msgid "Write names of available charmaps"
+msgstr "Escreve nomes dos mapas de caracteres disponíveis"
 
-#: posix/regex.c:1017
-msgid "Trailing backslash"
-msgstr "Contrabarra final"
+#: locale/programs/locale.c:75
+msgid "Modify output format:"
+msgstr "Formato de modificação de saída:"
 
-#. TRANS In the GNU system, opening a file returns this error when the file is
-#. TRANS translated by a program and the translator program dies while starting
-#. TRANS up, before it has connected to the file.
-#: stdio-common/../sysdeps/gnu/errlist.c:596
-msgid "Translator died"
-msgstr "Tradutor morto"
+#: locale/programs/locale.c:76
+msgid "Write names of selected categories"
+msgstr "Escreve nomes das categorias selecionadas"
 
-#. TRANS You tried to connect a socket that is already connected.
-#. TRANS @xref{Connecting}.
-#: stdio-common/../sysdeps/gnu/errlist.c:414
-msgid "Transport endpoint is already connected"
-msgstr "Ponto final de transporte j est conectado"
+#: locale/programs/locale.c:77
+msgid "Write names of selected keywords"
+msgstr "Escreve nomes das palavras-chave selecionadas"
 
-#. TRANS The socket is not connected to anything.  You get this error when you
-#. TRANS try to transmit data over a socket, without first specifying a
-#. TRANS destination for the data.  For a connectionless socket (for datagram
-#. TRANS protocols, such as UDP), you get @code{EDESTADDRREQ} instead.
-#: stdio-common/../sysdeps/gnu/errlist.c:422
-msgid "Transport endpoint is not connected"
-msgstr "Ponto final de transporte no est conectado"
+#: locale/programs/locale.c:78
+msgid "Print more information"
+msgstr "Imprime mais informações"
 
-#: argp/argp-help.c:1610
-#, c-format
-msgid "Try `%s --help' or `%s --usage' for more information.\n"
-msgstr "Tente `%s --help' ou `%s --usage' para mais informaes.\n"
+#: locale/programs/locale.c:83
+msgid "Get locale-specific information."
+msgstr "Obtém informações específicas da localidade."
 
-#: inet/rcmd.c:143
-#, c-format
-msgid "Trying %s...\n"
-msgstr "Tentando %s...\n"
+#: locale/programs/locale.c:86
+msgid ""
+"NAME\n"
+"[-a|-m]"
+msgstr ""
+"NOME\n"
+"[-a|-m]"
 
-#: nis/nis_print.c:163
+#: locale/programs/locale.c:190
 #, c-format
-msgid "Type : %s\n"
-msgstr "Tipo : %s\n"
+msgid "Cannot set LC_CTYPE to default locale"
+msgstr "Não foi possível definir LC_CTYPE para a localidade padrão"
 
-#: nis/nis_print.c:47
-msgid "UNKNOWN"
-msgstr "DESCONHECIDO"
-
-#: nis/nis_error.c:72
-msgid "Unable to authenticate NIS+ client"
-msgstr "Impossvel autenticar cliente NIS+"
-
-#: nis/nis_error.c:71
-msgid "Unable to authenticate NIS+ server"
-msgstr "Impossvel autenticar servidor NIS+"
-
-#: nis/nis_error.c:46
-msgid "Unable to create callback"
-msgstr "Impossvel criar chamador"
-
-#: nis/nis_error.c:74
-msgid "Unable to create process on server"
-msgstr "Impossvel criar processo no servidor"
-
-#: nis/nis_print.c:190
+#: locale/programs/locale.c:192
 #, c-format
-msgid "Unknown (type = %d, bits = %d)\n"
-msgstr "Desconhecido (tipo = %d, bits = %d)\n"
+msgid "Cannot set LC_MESSAGES to default locale"
+msgstr "Não foi possível definir LC_MESSAGES para a localidade padrão"
 
-#: inet/ruserpass.c:248
+#: locale/programs/locale.c:205
 #, c-format
-msgid "Unknown .netrc keyword %s"
-msgstr "Palavra-chave em .netrc desconhecida %s"
+msgid "Cannot set LC_COLLATE to default locale"
+msgstr "Não foi possível definir LC_COLLATE para a localidade padrão"
 
-#: nis/ypclnt.c:797
-msgid "Unknown NIS error code"
-msgstr "Cdigo de erro NIS desconhecido"
-
-#: nss/getent.c:505
+#: locale/programs/locale.c:221
 #, c-format
-msgid "Unknown database: %s\n"
-msgstr "Base de dados desconhecida: %s\n"
-
-#: posix/../sysdeps/posix/gai_strerror.c:51
-msgid "Unknown error"
-msgstr "Erro desconhecido"
-
-#: string/../sysdeps/generic/_strerror.c:48
-#: string/../sysdeps/mach/_strerror.c:86
-#: sysdeps/mach/hurd/mips/dl-machine.c:82
-msgid "Unknown error "
-msgstr "Erro desconhecido "
-
-#: resolv/herror.c:74
-msgid "Unknown host"
-msgstr "Host desconhecido"
-
-#: nis/nis_error.c:34
-msgid "Unknown object"
-msgstr "Objeto desconhecido"
+msgid "Cannot set LC_ALL to default locale"
+msgstr "Não foi possível definir LC_ALL para a localidade padrão"
 
-#: nscd/nscd_conf.c:181
+#: locale/programs/locale.c:521
 #, c-format
-msgid "Unknown option: %s %s %s"
-msgstr "Opo desconhecida: %s %s %s"
-
-#: resolv/herror.c:120
-msgid "Unknown resolver error"
-msgstr "Erro desconhecido do resolvedor"
-
-#: resolv/herror.c:76
-msgid "Unknown server error"
-msgstr "Erro desconhecido de servidor"
+msgid "while preparing output"
+msgstr "enquanto preparava a saída"
 
-#: string/strsignal.c:70
-#, c-format
-msgid "Unknown signal %d"
-msgstr "Sinal desconhecido %d"
+#: locale/programs/localedef.c:112
+msgid "Input Files:"
+msgstr "Arquivos de entrada:"
 
-#: misc/error.c:107
-msgid "Unknown system error"
-msgstr "Erro desconhecido de sistema"
+#: locale/programs/localedef.c:114
+msgid "Symbolic character names defined in FILE"
+msgstr "Nomes de caracteres simbólicos definido no ARQUIVO"
 
-#: nis/ypclnt.c:845
-msgid "Unknown ypbind error"
-msgstr "Erro desconhecido de ypbind"
+#: locale/programs/localedef.c:116
+msgid "Source definitions are found in FILE"
+msgstr "Definições fonte são encontradas no ARQUIVO"
 
-#: posix/regex.c:1020
-msgid "Unmatched ( or \\("
-msgstr "( ou \\( descasados"
+#: locale/programs/localedef.c:118
+msgid "FILE contains mapping from symbolic names to UCS4 values"
+msgstr "ARQUIVO contém mapas de nomes simbólicos para valores UCS4"
 
-#: posix/regex.c:1028
-msgid "Unmatched ) or \\)"
-msgstr ") ou \\) descasados"
+#: locale/programs/localedef.c:122
+msgid "Create output even if warning messages were issued"
+msgstr "Cria saída mesmo que mensagens de aviso forem produzidas"
 
-#: posix/regex.c:1019
-msgid "Unmatched [ or [^"
-msgstr "[ ou [^ descasados"
+#: locale/programs/localedef.c:123
+msgid "Optional output file prefix"
+msgstr "Prefixo opcional de arquivo de saída"
 
-#: posix/regex.c:1021
-msgid "Unmatched \\{"
-msgstr "\\{ descasado"
+#: locale/programs/localedef.c:124
+msgid "Strictly conform to POSIX"
+msgstr "Adapta estritamente ao POSIX"
 
-#: posix/getconf.c:692
-#, c-format
-msgid "Unrecognized variable `%s'"
-msgstr "Varivel no reconhecida `%s'"
+#: locale/programs/localedef.c:126
+msgid "Suppress warnings and information messages"
+msgstr "Suprime avisos e mensagens de informação"
 
-#: stdio-common/../sysdeps/unix/siglist.c:41
-#: sysdeps/unix/sysv/linux/siglist.h:35
-msgid "Urgent I/O condition"
-msgstr "Condio urgente de E/S"
+#: locale/programs/localedef.c:127
+msgid "Print more messages"
+msgstr "Mostra mais mensagens"
 
-#: argp/argp-help.c:1567
-msgid "Usage:"
-msgstr "Uso:"
+#: locale/programs/localedef.c:128 locale/programs/localedef.c:131
+msgid "<warnings>"
+msgstr "<avisos>"
 
-#: posix/getconf.c:604
-#, c-format
-msgid "Usage: %s variable_name [pathname]\n"
-msgstr "Uso: %s nome_da_varivel [caminho]\n"
+#: locale/programs/localedef.c:129
+msgid "Comma-separated list of warnings to disable; supported warnings are: ascii, intcurrsym"
+msgstr "Lista separada por vírgulas de avisos para desabilitar; há suporte para os avisos: ascii, intcurrsym"
 
-#: sunrpc/rpcinfo.c:674
-msgid "Usage: rpcinfo [ -n portnum ] -u host prognum [ versnum ]\n"
-msgstr "Uso: rpcinfo [ -n nmporta ] -u host nmprog [ nmvers ]\n"
+#: locale/programs/localedef.c:132
+msgid "Comma-separated list of warnings to enable; supported warnings are: ascii, intcurrsym"
+msgstr "Lista separada por vírgulas de avisos para habilitar; há suporte para os avisos: ascii, intcurrsym"
 
-#: stdio-common/../sysdeps/unix/siglist.c:55
-#: sysdeps/unix/sysv/linux/siglist.h:48
-msgid "User defined signal 1"
-msgstr "Sinal 1 definido pelo usurio"
+#: locale/programs/localedef.c:135
+msgid "Archive control:"
+msgstr "Controle de pacote:"
 
-#: stdio-common/../sysdeps/unix/siglist.c:56
-#: sysdeps/unix/sysv/linux/siglist.h:49
-msgid "User defined signal 2"
-msgstr "Sinal 2 definido pelo usurio"
+#: locale/programs/localedef.c:137
+msgid "Don't add new data to archive"
+msgstr "Não adiciona novos dados ao pacote"
 
-#: stdio-common/../sysdeps/gnu/errlist.c:654
-msgid "Value too large for defined data type"
-msgstr "Valor muito extenso para o tipo de dados definido"
+#: locale/programs/localedef.c:139
+msgid "Add locales named by parameters to archive"
+msgstr "Adiciona localidades nomeadas por parâmetros ao pacote"
 
-#: stdio-common/../sysdeps/unix/siglist.c:51
-#: sysdeps/unix/sysv/linux/siglist.h:45
-msgid "Virtual timer expired"
-msgstr "Temporizador virtual expirado"
+#: locale/programs/localedef.c:140
+msgid "Replace existing archive content"
+msgstr "Substitui o conteúdo de pacote existente"
 
-#: timezone/zic.c:1899
-msgid "Wild result from command execution"
-msgstr "Resultado insensato da execuo do comando"
+#: locale/programs/localedef.c:142
+msgid "Remove locales named by parameters from archive"
+msgstr "Remove localidades nomeadas por parâmetros do pacote"
 
-#: stdio-common/../sysdeps/unix/siglist.c:53
-#: sysdeps/unix/sysv/linux/siglist.h:47
-msgid "Window changed"
-msgstr "Janela alterada"
+#: locale/programs/localedef.c:143
+msgid "List content of archive"
+msgstr "Lista conteúdo do pacote"
 
-#: locale/programs/locale.c:67
-msgid "Write names of available charmaps"
-msgstr "Escreve nomes dos mapas de caracteres (charmaps) disponveis"
+#: locale/programs/localedef.c:145
+msgid "locale.alias file to consult when making archive"
+msgstr "arquivo localidade.apelido a ser consultado ao criar pacote"
 
-#: locale/programs/locale.c:65
-msgid "Write names of available locales"
-msgstr "Escreve nomes das localizaes (locales) disponveis"
+#: locale/programs/localedef.c:147
+msgid "Generate little-endian output"
+msgstr "Gera saída em little-endian"
 
-#: locale/programs/locale.c:69
-msgid "Write names of selected categories"
-msgstr "Escreve nomes das categorias selecionadasd"
+#: locale/programs/localedef.c:149
+msgid "Generate big-endian output"
+msgstr "Gera saída em big-endian"
 
-#: locale/programs/locale.c:70
-msgid "Write names of selected keywords"
-msgstr "Escreve nomes das palavras-chave selecionadas"
+#: locale/programs/localedef.c:154
+msgid "Compile locale specification"
+msgstr "Compila especificação localizada"
 
-#: catgets/gencat.c:110 db2/makedb.c:59
-msgid "Write output to file NAME"
-msgstr "Escreve a sada para o arquivo NOME"
+#: locale/programs/localedef.c:157
+msgid ""
+"NAME\n"
+"[--add-to-archive|--delete-from-archive] FILE...\n"
+"--list-archive [FILE]"
+msgstr ""
+"NOME\n"
+"[--add-to-archive|--delete-from-archive] ARQUIVO...\n"
+"--list-archive [ARQUIVO]"
 
-#: catgets/gencat.c:241 db2/makedb.c:247 elf/sprof.c:365
-#: iconv/iconv_prog.c:299 locale/programs/locale.c:272
-#: locale/programs/localedef.c:408 nscd/nscd.c:228 nss/getent.c:70
-#: posix/getconf.c:629
+#: locale/programs/localedef.c:232
 #, c-format
-msgid "Written by %s.\n"
-msgstr "Escrito por %s.\n"
-
-#: stdio-common/../sysdeps/gnu/errlist.c:818
-msgid "Wrong medium type"
-msgstr "Tipo de mdia incorreta"
+msgid "cannot create directory for output files"
+msgstr "não foi possível criar diretório para os arquivos de saída"
 
-#: nis/nis_print.c:39
-msgid "X500"
-msgstr "X500"
-
-#: nis/nis_print.c:43
-msgid "XCHS"
-msgstr "XCHS"
+#: locale/programs/localedef.c:243
+msgid "FATAL: system does not define `_POSIX2_LOCALEDEF'"
+msgstr "FATAL: sistema não define “_POSIX2_LOCALEDEF”"
 
-#: nis/ypclnt.c:185
+#: locale/programs/localedef.c:257 locale/programs/localedef.c:273
+#: locale/programs/localedef.c:663 locale/programs/localedef.c:683
 #, c-format
-msgid "YPBINDPROC_DOMAIN: %s\n"
-msgstr "YPBINDPROC_DOMAIN: %s\n"
+msgid "cannot open locale definition file `%s'"
+msgstr "não é possível abrir arquivo de definição da localidade “%s”"
 
-#: nis/nis_error.c:70
-msgid "Yes, 42 is the meaning of life"
-msgstr "Sim, 42  o sentido da vida"
+#: locale/programs/localedef.c:297
+#, c-format
+msgid "cannot write output files to `%s'"
+msgstr "não é possível escrever arquivo de saída para “%s”"
 
-#. TRANS You did @strong{what}?
-#: stdio-common/../sysdeps/gnu/errlist.c:608
-msgid "You really blew it this time"
-msgstr "Voc realmente o destruiu desta vez"
+#: locale/programs/localedef.c:303
+msgid "no output file produced because errors were issued"
+msgstr "nenhum arquivo de saída foi produzido porque erros foram emitidos"
 
-#: timezone/zic.c:1063
-msgid "Zone continuation line end time is not after end time of previous line"
-msgstr "Tempo final da linha de zona no est aps o tempo final da linha anterior"
+#: locale/programs/localedef.c:431
+#, c-format
+msgid ""
+"System's directory for character maps : %s\n"
+"\t\t       repertoire maps: %s\n"
+"\t\t       locale path    : %s\n"
+"%s"
+msgstr ""
+"Diretório do sistema para mapas de caracteres: %s\n"
+"                         mapas de repertórios: %s\n"
+"                        caminho da localidade: %s\n"
+"%s"
 
-#: iconv/iconv_prog.c:70
-msgid "[FILE...]"
-msgstr "[ARQUIVO...]"
+#: locale/programs/localedef.c:631
+msgid "circular dependencies between locale definitions"
+msgstr "dependências circulares entre definições de localidade"
 
-#: locale/programs/charmap.c:481 locale/programs/locfile.c:471
-#: locale/programs/repertoire.c:278
+#: locale/programs/localedef.c:637
 #, c-format
-msgid "`%1$s' definition does not end with `END %1$s'"
-msgstr "`%1$s' definio no termina com `END %1$s'"
+msgid "cannot add already read locale `%s' a second time"
+msgstr "não foi possível adicionar localidade já lida “%s” uma segunda vez"
 
-#: elf/sprof.c:766
+#: locale/programs/locarchive.c:133 locale/programs/locarchive.c:380
 #, c-format
-msgid "`%s' is no correct profile data file for `%s'"
-msgstr "`%s' no  o arquivo deperfil de dados correto para `%s'"
+msgid "cannot create temporary file: %s"
+msgstr "não foi possível criar arquivo temporário: %s"
 
-#: locale/programs/ld-monetary.c:369 locale/programs/ld-numeric.c:193
+#: locale/programs/locarchive.c:167 locale/programs/locarchive.c:430
 #, c-format
-msgid "`-1' must be last entry in `%s' field in `%s' category"
-msgstr "`-1' deve ser o ltimo registro no `%s' campo na `%s' categoria"
-
-#: locale/programs/ld-collate.c:1666
-msgid "`...' must only be used in `...' and `UNDEFINED' entries"
-msgstr "`...' deve ser usado apenas em `...' e entradas `UNDEFINED'"
-
-#: locale/programs/locfile.c:668
-msgid "`from' expected after first argument to `collating-element'"
-msgstr "`from' esperado aps primeiro argumento para `collating-element'"
-
-#: locale/programs/ld-collate.c:1118
-msgid "`from' string in collation element declaration contains unknown character"
-msgstr "string `from' na declarao de elemento de comparao contm caracter desconhecido"
+msgid "cannot initialize archive file"
+msgstr "não foi possível inicializar o arquivo do pacote"
 
-#: posix/../sysdeps/posix/gai_strerror.c:34
-msgid "ai_family not supported"
-msgstr "Famlia de protocolo (ai_family) no suportada"
-
-#: posix/../sysdeps/posix/gai_strerror.c:39
-msgid "ai_socktype not supported"
-msgstr "Tipo socket (ai_socktype) no suportado"
-
-#: nscd/nscd.c:121
-msgid "already running"
-msgstr "j est rodando"
-
-#: locale/programs/charmap.c:352 locale/programs/repertoire.c:152
+#: locale/programs/locarchive.c:174 locale/programs/locarchive.c:437
 #, c-format
-msgid "argument to <%s> must be a single character"
-msgstr "argumento para <%s> deve ser um caracter simples"
+msgid "cannot resize archive file"
+msgstr "não foi possível redimensionar o arquivo do pacote"
 
-#: locale/programs/locfile.c:240
+#: locale/programs/locarchive.c:189 locale/programs/locarchive.c:452
+#: locale/programs/locarchive.c:674
 #, c-format
-msgid "argument to `%s' must be a single character"
-msgstr "argumento para `%s' deve ser um caracter simples"
-
-#: sunrpc/auth_unix.c:321
-msgid "auth_none.c - Fatal marshalling problem"
-msgstr "auth_none.c - Problema fatal de marshalling"
-
-#: sunrpc/auth_unix.c:116 sunrpc/auth_unix.c:122 sunrpc/auth_unix.c:151
-msgid "authunix_create: out of memory\n"
-msgstr "authunix_create: no h memria suficiente\n"
-
-#: locale/programs/charmap.c:297 locale/programs/locfile.c:234
-#: locale/programs/locfile.c:261 locale/programs/repertoire.c:144
-msgid "bad argument"
-msgstr "argumento invlido"
-
-#: inet/rcmd.c:318
-msgid "bad owner"
-msgstr "dono invlido"
-
-#: timezone/zic.c:1185
-msgid "blank FROM field on Link line"
-msgstr "campo FROM em branco na linha Link"
-
-#: timezone/zic.c:1189
-msgid "blank TO field on Link line"
-msgstr "campo TO em branco na linha Link"
-
-#: malloc/mcheck.c:208
-msgid "block freed twice\n"
-msgstr "bloco liberado duas vezes\n"
-
-#: malloc/mcheck.c:211
-msgid "bogus mcheck_status, library is buggy\n"
-msgstr "mcheck_status invlido, biblioteca est com problemas\n"
-
-#: sunrpc/pmap_rmt.c:185
-msgid "broadcast: ioctl (get interface configuration)"
-msgstr "broadcast: ioctl (obter configurao de interface)"
+msgid "cannot map archive header"
+msgstr "não foi possível mapear o cabeçalho do pacote"
 
-#: sunrpc/pmap_rmt.c:194
-msgid "broadcast: ioctl (get interface flags)"
-msgstr "broadcast: ioctl (obter flags de interface)"
-
-#: login/programs/request.c:167
-msgid "buffer overflow"
-msgstr "estouro de buffer"
-
-#: sunrpc/svc_udp.c:446
-msgid "cache_set: could not allocate new rpc_buffer"
-msgstr "cache_set: no foi possvel alocar novo rpc_buffer"
-
-#: sunrpc/svc_udp.c:440
-msgid "cache_set: victim alloc failed"
-msgstr "cache_set: alocao de vtima falhou"
+#: locale/programs/locarchive.c:211
+#, c-format
+msgid "failed to create new locale archive"
+msgstr "falha ao criar o novo pacote de localidade"
 
-#: sunrpc/svc_udp.c:429
-msgid "cache_set: victim not found"
-msgstr "cache_set: vtima no localizada"
+#: locale/programs/locarchive.c:223
+#, c-format
+msgid "cannot change mode of new locale archive"
+msgstr "não foi possível alterar o modo do novo arquivo de localidade"
 
-#: timezone/zic.c:1726
-msgid "can't determine time zone abbreviation to use just after until time"
-msgstr "no  possvel determinar abreviao para zona de tempo"
+#: locale/programs/locarchive.c:324
+msgid "cannot read data from locale archive"
+msgstr "não foi possível ler dados do pacote de localidade"
 
-#: sunrpc/svc_simple.c:75
+#: locale/programs/locarchive.c:355
 #, c-format
-msgid "can't reassign procedure number %d\n"
-msgstr "no  possvel reassinalar nmero de procedimento %d\n"
+msgid "cannot map locale archive file"
+msgstr "não foi possível mapear o arquivo do pacote de localidade"
 
-#: locale/programs/localedef.c:279
+#: locale/programs/locarchive.c:460
 #, c-format
-msgid "cannot `stat' locale file `%s'"
-msgstr "no  possvel acessar arquivo de locale `%s'"
+msgid "cannot lock new archive"
+msgstr "não foi possível travar o novo pacote"
 
-#: elf/sprof.c:935 elf/sprof.c:987
-msgid "cannot allocate symbol data"
-msgstr "No foi possvel alocar memria"
+#: locale/programs/locarchive.c:529
+#, c-format
+msgid "cannot extend locale archive file"
+msgstr "não foi possível estender o arquivo do pacote de localidade"
 
-#: elf/sprof.c:719 elf/sprof.c:777
-msgid "cannot create internal descriptor"
-msgstr "no  possvel criar descritor interno"
+#: locale/programs/locarchive.c:538
+#, c-format
+msgid "cannot change mode of resized locale archive"
+msgstr "não foi possível alterar o modo do arquivo de localidade redimensionado"
 
-#: elf/sprof.c:417
-msgid "cannot create internal descriptors"
-msgstr "no  possivel criar descritores internos"
+#: locale/programs/locarchive.c:546
+#, c-format
+msgid "cannot rename new archive"
+msgstr "não foi possível renomear o novo pacote"
 
-#: nscd/connections.c:180
+#: locale/programs/locarchive.c:608
 #, c-format
-msgid "cannot enable socket to accept connections: %s"
-msgstr "impossvel habilitar soquete para aceitar coneces: %s"
+msgid "cannot open locale archive \"%s\""
+msgstr "não foi possível abrir pacote de localidade “%s”"
 
-#: sunrpc/rpc_main.c:342
+#: locale/programs/locarchive.c:613
 #, c-format
-msgid "cannot find C preprocessor: %s \n"
-msgstr "impossvel encontrar pr-processador C: %s\n"
+msgid "cannot stat locale archive \"%s\""
+msgstr "não foi possível obter estado do pacote de localidade “%s”"
 
-#: sunrpc/rpc_main.c:350
-msgid "cannot find any C preprocessor (cpp)\n"
-msgstr "impossvel encontrar qualquer pr-processador C (cpp)\n"
+#: locale/programs/locarchive.c:632
+#, c-format
+msgid "cannot lock locale archive \"%s\""
+msgstr "não foi possível travar o pacote de localidade “%s”"
 
-#: nscd/connections.c:205
+#: locale/programs/locarchive.c:655
 #, c-format
-msgid "cannot handle old request version %d; current version is %d"
-msgstr "impossvel lidar com requisies de verses antigas %d; a verso atual  %d"
+msgid "cannot read archive header"
+msgstr "não foi possível ler o cabeçalho do pacote"
 
-#: locale/programs/ld-collate.c:1324
+#: locale/programs/locarchive.c:728
 #, c-format
-msgid "cannot insert collation element `%.*s'"
-msgstr "no  possvel inserir elemento de comparao `%.*s'"
+msgid "locale '%s' already exists"
+msgstr "localidade “%s” já existe"
 
-#: locale/programs/ld-collate.c:1503 locale/programs/ld-collate.c:1510
-msgid "cannot insert into result table"
-msgstr "no  possvel inserir na tabela de resultados"
+#: locale/programs/locarchive.c:1003 locale/programs/locarchive.c:1018
+#: locale/programs/locarchive.c:1030 locale/programs/locarchive.c:1042
+#: locale/programs/locfile.c:350
+#, c-format
+msgid "cannot add to locale archive"
+msgstr "não foi possível adicionar ao pacote de localidade"
 
-#: locale/programs/ld-collate.c:1175 locale/programs/ld-collate.c:1218
+#: locale/programs/locarchive.c:1203
 #, c-format
-msgid "cannot insert new collating symbol definition: %s"
-msgstr "no  possvel inserir nova definio de smbolo de comparao: %s"
+msgid "locale alias file `%s' not found"
+msgstr "arquivo de apelido de localidade “%s” não localizado"
 
-#: elf/sprof.c:674
-msgid "cannot load profiling data"
-msgstr "impossvel carregar perfis de dados"
+#: locale/programs/locarchive.c:1351
+#, c-format
+msgid "Adding %s\n"
+msgstr "Adicionando %s\n"
 
-#: inet/rcmd.c:314
-msgid "cannot open"
-msgstr "impossvel abrir"
+#: locale/programs/locarchive.c:1357
+#, c-format
+msgid "stat of \"%s\" failed: %s: ignored"
+msgstr "obtenção de estado de “%s” falhou: %s: ignorado"
 
-#: sysdeps/unix/sysv/linux/lddlibc4.c:64
+#: locale/programs/locarchive.c:1363
 #, c-format
-msgid "cannot open `%s'"
-msgstr "no  possvel abrir `%s'"
+msgid "\"%s\" is no directory; ignored"
+msgstr "“%s” não é um diretório; ignorado"
 
-#: db2/makedb.c:146
+#: locale/programs/locarchive.c:1370
 #, c-format
-msgid "cannot open database file `%s': %s"
-msgstr "no  possvel abrir arquivo de banco de dados `%s': %s"
+msgid "cannot open directory \"%s\": %s: ignored"
+msgstr "não foi possível abrir o diretório “%s”: %s: ignorado"
 
-#: catgets/gencat.c:272 db2/makedb.c:167 iconv/iconv_prog.c:177
+#: locale/programs/locarchive.c:1438
 #, c-format
-msgid "cannot open input file `%s'"
-msgstr "no  possvel abrir arquivo de entrada `%s'"
+msgid "incomplete set of locale files in \"%s\""
+msgstr "definição incompleta dos arquivos de localização em “%s”"
 
-#: locale/programs/localedef.c:198
+#: locale/programs/locarchive.c:1502
 #, c-format
-msgid "cannot open locale definition file `%s'"
-msgstr "no  possvel abrir arquivo de definio locale `%s'"
+msgid "cannot read all files in \"%s\": ignored"
+msgstr "não foi possível ler todos os arquivos em “%s”: ignorado"
 
-#: iconv/iconv_prog.c:155
-msgid "cannot open output file"
-msgstr "no  possvel abrir arquivo de sada"
+#: locale/programs/locarchive.c:1572
+#, c-format
+msgid "locale \"%s\" not in archive"
+msgstr "localidade “%s” não está no pacote"
 
-#: catgets/gencat.c:774 catgets/gencat.c:815 db2/makedb.c:181
+#: locale/programs/locfile.c:137
 #, c-format
-msgid "cannot open output file `%s'"
-msgstr "no  possvel abrir arquivo de sada `%s'"
+msgid "argument to `%s' must be a single character"
+msgstr "argumento para “%s” deve ser um caractere simples"
+
+#: locale/programs/locfile.c:257
+msgid "syntax error: not inside a locale definition section"
+msgstr "erro de sintaxe: não está dentro de uma seção de definição de localidade"
 
-#: locale/programs/locfile.c:1129
+#: locale/programs/locfile.c:799
 #, c-format
 msgid "cannot open output file `%s' for category `%s'"
-msgstr "no  possvel abrir arquivo de sada `%s' para categoria `%s'"
+msgstr "não foi possível abrir o arquivo de saída “%s” para a categoria “%s”"
 
-#: nscd/connections.c:162
+#: locale/programs/locfile.c:822
 #, c-format
-msgid "cannot open socket: %s"
-msgstr "no  possvel abrir soquete: `%s'"
-
-#: locale/programs/ld-collate.c:1370
-msgid "cannot process order specification"
-msgstr "no  possvel processar specificao de ordem"
+msgid "failure while writing data for category `%s'"
+msgstr "falha ao escrever dados para categoria “%s”"
 
-#: locale/programs/locale.c:449
+#: locale/programs/locfile.c:917
 #, c-format
-msgid "cannot read character map directory `%s'"
-msgstr "no  possvel ler diretrio de mapa de caracter `%s'"
+msgid "cannot create output file `%s' for category `%s'"
+msgstr "não foi possível criar o arquivo de saída “%s” para a categoria “%s”"
 
-#: nscd/connections.c:122
-msgid "cannot read configuration file; this is fatal"
-msgstr "impossvel ler arquivo de configurao; isto  fatal"
+#: locale/programs/locfile.c:953
+msgid "expecting string argument for `copy'"
+msgstr "esperando argumento em string para “copy”"
 
-#: login/programs/request.c:91
-msgid "cannot read from client"
-msgstr "no  possvel ler do cliente"
+#: locale/programs/locfile.c:957
+msgid "locale name should consist only of portable characters"
+msgstr "nome de localidade deve consistir apenas em caracteres portáteis"
 
-#: sysdeps/unix/sysv/linux/lddlibc4.c:68
-#, c-format
-msgid "cannot read header from `%s'"
-msgstr "no  possvel ler cabealho de `%s'"
+#: locale/programs/locfile.c:976
+msgid "no other keyword shall be specified when `copy' is used"
+msgstr "nenhuma outra palavra-chave deve ser especificada quando “copy” é usado"
 
-#: locale/programs/locale.c:306
+#: locale/programs/locfile.c:990
 #, c-format
-msgid "cannot read locale directory `%s'"
-msgstr "no  possvel ler diretrio locale `%s'"
+msgid "`%1$s' definition does not end with `END %1$s'"
+msgstr "“%1$s” definição não termina com “END %1$s”"
 
-#: locale/programs/localedef.c:303
+#: locale/programs/repertoire.c:228 locale/programs/repertoire.c:269
+#: locale/programs/repertoire.c:294
 #, c-format
-msgid "cannot read locale file `%s'"
-msgstr "no  possvel ler arquivo locale `%s'"
+msgid "syntax error in repertoire map definition: %s"
+msgstr "erro de sintaxe no mapa de repertório: %s"
 
-#: locale/programs/locfile.c:288 locale/programs/locfile.c:306
-#: locale/programs/locfile.c:324 locale/programs/locfile.c:342
-#: locale/programs/locfile.c:360 locale/programs/locfile.c:378
-#, c-format
-msgid "cannot read repertoire map `%s'"
-msgstr "no  possvel ler mapa de repertrio `%s'"
+#: locale/programs/repertoire.c:270
+msgid "no <Uxxxx> or <Uxxxxxxxx> value given"
+msgstr "valores <Uxxxx> ou <Uxxxxxxxx> não dados"
 
-#: nscd/nscd_stat.c:127
-msgid "cannot read statistics data"
-msgstr "impossvel ler dados de estatstica"
+#: locale/programs/repertoire.c:330
+msgid "cannot save new repertoire map"
+msgstr "não foi possível salvar novo mapa de repertório"
 
-#: nscd/cache.c:141 nscd/connections.c:148
+#: locale/programs/repertoire.c:341
 #, c-format
-msgid "cannot stat() file `%s': %s"
-msgstr "no  possvel ler atributos do arquivo `%s': %s"
+msgid "repertoire map file `%s' not found"
+msgstr "arquivo de mapa de repertório “%s” não foi encontrado"
 
-#: locale/programs/localedef.c:328
+#: login/programs/pt_chown.c:79
 #, c-format
-msgid "cannot write output files to `%s'"
-msgstr "no  possvel escrever arquivo de sada para `%s'"
+msgid "Set the owner, group and access permission of the slave pseudo terminal corresponding to the master pseudo terminal passed on file descriptor `%d'.  This is the helper program for the `grantpt' function.  It is not intended to be run directly from the command line.\n"
+msgstr "Define o dono, grupo e permissão de acesso ao pseudoterminal escravo correspondente ao pseudoterminal mestre passado no descritor de arquivo “%d”. Esse é um programa auxiliar para a função “grantpt”. Ele não tem a intenção de ser executado diretamente da linha de comando.\n"
 
-#: nscd/connections.c:229 nscd/connections.c:250
+#: login/programs/pt_chown.c:93
 #, c-format
-msgid "cannot write result: %s"
-msgstr "no  possvel escrever resultado: %s"
+msgid ""
+"The owner is set to the current user, the group is set to `%s', and the access permission is set to `%o'.\n"
+"\n"
+"%s"
+msgstr ""
+"O dono está definido como o usuário atual, o grupo está definido para “%s” e a permissão de acesso está definida para “%o”.\n"
+"\n"
+"%s"
 
-#: nscd/nscd_stat.c:86
+#: login/programs/pt_chown.c:204
 #, c-format
-msgid "cannot write statistics: %s"
-msgstr "no  possvel escrever estatisticas: %s"
+msgid "too many arguments"
+msgstr "número excessivo de argumentos"
 
-#: login/programs/request.c:120
-msgid "cannot write to client"
-msgstr "no  possvel escrever para o cliente"
+#: login/programs/pt_chown.c:212
+#, c-format
+msgid "needs to be installed setuid `root'"
+msgstr "precisa ser instalado com setuid “root”"
 
-#: locale/programs/localedef.c:442
-msgid "category data requested more than once: should not happen"
-msgstr "categoria de dados requisitada mais que uma vez: isto no deveria acontecer"
+#: malloc/mcheck.c:344
+msgid "memory is consistent, library is buggy\n"
+msgstr "a memória está consistente; a biblioteca está problemática\n"
 
-#: locale/programs/ld-ctype.c:269
-#, c-format
-msgid "character %s'%s' in class `%s' must be in class `%s'"
-msgstr "caracter %s'%s' na classe `%s' deve estar na classe `%s'"
+#: malloc/mcheck.c:347
+msgid "memory clobbered before allocated block\n"
+msgstr "memória sobrescrita antes do bloco alocado\n"
 
-#: locale/programs/ld-ctype.c:294
-#, c-format
-msgid "character %s'%s' in class `%s' must not be in class `%s'"
-msgstr "caracter %s'%s' na classe `%s' no deve estar na classe `%s'"
+#: malloc/mcheck.c:350
+msgid "memory clobbered past end of allocated block\n"
+msgstr "memória sobrescrita após o fim do bloco alocado\n"
 
-#: locale/programs/ld-ctype.c:320
-msgid "character <SP> not defined in character map"
-msgstr "caracter <SP> no definido no mapa de caracteres"
+#: malloc/mcheck.c:353
+msgid "block freed twice\n"
+msgstr "bloco liberado duas vezes\n"
 
-#: locale/programs/ld-ctype.c:964 locale/programs/ld-ctype.c:1029
-#: locale/programs/ld-ctype.c:1040 locale/programs/ld-ctype.c:1051
-#: locale/programs/ld-ctype.c:1062 locale/programs/ld-ctype.c:1073
-#: locale/programs/ld-ctype.c:1084 locale/programs/ld-ctype.c:1113
-#: locale/programs/ld-ctype.c:1124 locale/programs/ld-ctype.c:1165
-#: locale/programs/ld-ctype.c:1194 locale/programs/ld-ctype.c:1206
-#, c-format
-msgid "character `%s' not defined while needed as default value"
-msgstr "caracter `%s' no definido enquanto necessrio como valor default"
+#: malloc/mcheck.c:356
+msgid "bogus mcheck_status, library is buggy\n"
+msgstr "mcheck_status inválido; a biblioteca está problemática\n"
 
-#: locale/programs/ld-ctype.c:825
-#, c-format
-msgid "character class `%s' already defined"
-msgstr "classe de caracter `%s' j definida"
+#: malloc/memusage.sh:32
+msgid "%s: option '%s' requires an argument\\n"
+msgstr "%s: a opção “%s” requer um argumento\\n"
 
-#: locale/programs/ld-ctype.c:857
-#, c-format
-msgid "character map `%s' already defined"
-msgstr "mapa de caracteres `%s' j definido"
+#: malloc/memusage.sh:38
+msgid ""
+"Usage: memusage [OPTION]... PROGRAM [PROGRAMOPTION]...\n"
+"Profile memory usage of PROGRAM.\n"
+"\n"
+"   -n,--progname=NAME     Name of the program file to profile\n"
+"   -p,--png=FILE          Generate PNG graphic and store it in FILE\n"
+"   -d,--data=FILE         Generate binary data file and store it in FILE\n"
+"   -u,--unbuffered        Don't buffer output\n"
+"   -b,--buffer=SIZE       Collect SIZE entries before writing them out\n"
+"      --no-timer          Don't collect additional information through timer\n"
+"   -m,--mmap              Also trace mmap & friends\n"
+"\n"
+"   -?,--help              Print this help and exit\n"
+"      --usage             Give a short usage message\n"
+"   -V,--version           Print version information and exit\n"
+"\n"
+" The following options only apply when generating graphical output:\n"
+"   -t,--time-based        Make graph linear in time\n"
+"   -T,--total             Also draw graph of total memory use\n"
+"      --title=STRING      Use STRING as title of the graph\n"
+"   -x,--x-size=SIZE       Make graphic SIZE pixels wide\n"
+"   -y,--y-size=SIZE       Make graphic SIZE pixels high\n"
+"\n"
+"Mandatory arguments to long options are also mandatory for any corresponding\n"
+"short options.\n"
+"\n"
+msgstr ""
+"Uso: memusage [OPÇÃO]... PROGRAMA [OPÇÃO-PROGRAMA]...\n"
+"Perfila o uso de memória do PROGRAMA.\n"
+"\n"
+"   -n,--progname=NOME     Nome do arquivo de programa a perfilar\n"
+"   -p,--png=ARQUIVO       Gera um gráfico em PNG e o armazena em ARQUIVO\n"
+"   -d,--data=ARQUIVO      Gera um arquivo de dados binários e o armazena \n"
+"                            em ARQUIVO\n"
+"   -u,--unbuffered        Não utiliza buffer na saída\n"
+"   -b,--buffer=TAM        Coleta TAM registros antes de escrevê-los na saída\n"
+"      --no-timer          Não coleta informações adicionais do temporizador\n"
+"   -m,--mmap              Também rastreia mmap & amigos\n"
+"\n"
+"   -?,--help              Exibe essa ajuda e sai\n"
+"      --usage             Fornece uma curta mensagem de uso\n"
+"   -V,--version           Exibe informação da versão e sai\n"
+"\n"
+" As seguintes opções se aplicam apenas ao gerar saída gráfica:\n"
+"   -t,--time-based        Cria um gráfico linear no tempo\n"
+"   -T,--total             Também desenha um gráfico do uso total de memória\n"
+"      --title=TEXTO       Usa TEXTO como título do gráfico\n"
+"   -x,--x-size=TAM        Faz com que o gráfico tenha TAM pixels de largura\n"
+"   -y,--y-size=TAM        Faz com que o gráfico tenha TAM pixels de altura\n"
+"\n"
+"Argumentos obrigatórios para opções longas são também obrigatórios para\n"
+"qualquer opção curta correspondente.\n"
+"\n"
 
-#: locale/programs/charmap.c:83
-#, c-format
-msgid "character map file `%s' not found"
-msgstr "arquivo de mapa de caracter `%s' no foi localizado"
+# Usei "Uso:" para caber tudo na mesma linha e para padronizar -- Rafael
+#: malloc/memusage.sh:99
+msgid ""
+"Syntax: memusage [--data=FILE] [--progname=NAME] [--png=FILE] [--unbuffered]\n"
+"\t    [--buffer=SIZE] [--no-timer] [--time-based] [--total]\n"
+"\t    [--title=STRING] [--x-size=SIZE] [--y-size=SIZE]\n"
+"\t    PROGRAM [PROGRAMOPTION]..."
+msgstr ""
+"Uso: memusage [--data=ARQUIVO] [--progname=NOME] [--png=ARQUIVO] [--unbuffered]\n"
+"\t    [--buffer=TAM] [--no-timer] [--time-based] [--total]\n"
+"\t    [--title=TEXTO] [--x-size=TAM] [--y-size=TAM]\n"
+"\t    PROGRAMA [OPÇÃO-PROGRAMA]..."
 
-#: sunrpc/clnt_raw.c:110
-msgid "clnt_raw.c - Fatal header serialization error."
-msgstr "clnt_raw.c - Erro fatal no cabealho de serializao."
+#: malloc/memusage.sh:191
+msgid "memusage: option \\`${1##*=}' is ambiguous"
+msgstr "memusage: opção “${1##*=}” é ambígua"
 
-#: sunrpc/clnt_tcp.c:125 sunrpc/clnt_tcp.c:133
-msgid "clnttcp_create: out of memory\n"
-msgstr "clnttcp_create: no h memria suficiente\n"
+#: malloc/memusage.sh:200
+msgid "memusage: unrecognized option \\`$1'"
+msgstr "memusage: opção não reconhecida “$1”"
 
-#: sunrpc/clnt_udp.c:124 sunrpc/clnt_udp.c:134
-msgid "clntudp_create: out of memory\n"
-msgstr "clntudp_create: no h memria suficiente\n"
+#: malloc/memusage.sh:213
+msgid "No program name given"
+msgstr "Nenhum nome de programa fornecido"
 
-#: sunrpc/clnt_unix.c:123 sunrpc/clnt_unix.c:131
-msgid "clntunix_create: out of memory\n"
-msgstr "clntunix_reate: no h memria suficiente\n"
+#: malloc/memusagestat.c:56
+msgid "Name output file"
+msgstr "Nome do arquivo de saída"
 
-#: locale/programs/ld-collate.c:1339
-#, c-format
-msgid "collation element `%.*s' appears more than once: ignore line"
-msgstr "o elemento de comparao `%.*s' aparece mais que uma vez: ignorar linha"
+#: malloc/memusagestat.c:57
+msgid "STRING"
+msgstr "TEXTO"
 
-#: locale/programs/ld-collate.c:1357
-#, c-format
-msgid "collation symbol `%.*s' appears more than once: ignore line"
-msgstr "o smbolo de comparao `%.*s' aparece mais que uma vez: ignorar linha"
+#: malloc/memusagestat.c:57
+msgid "Title string used in output graphic"
+msgstr "Texto do título usado no gráfico de saída"
 
-#: locale/programs/locfile.c:652
-#, c-format
-msgid "collation symbol expected after `%s'"
-msgstr "smbolo de comparao esperado aps `%s'"
+#: malloc/memusagestat.c:58
+msgid "Generate output linear to time (default is linear to number of function calls)"
+msgstr "Gera uma saída linear no tempo (padrão é linear ao número de chamadas de função)"
 
-#: inet/rcmd.c:136
-#, c-format
-msgid "connect to address %s: "
-msgstr "connectar-se ao endereo %s: "
+#: malloc/memusagestat.c:62
+msgid "Also draw graph for total memory consumption"
+msgstr "Também desenha um gráfico de consumo total de memória"
 
-#: sunrpc/rpc_scan.c:115
-msgid "constant or identifier expected"
-msgstr "identificador ou constante esperado"
+#: malloc/memusagestat.c:63
+msgid "VALUE"
+msgstr "VALOR"
 
-#: iconv/iconv_prog.c:144
-#, c-format
-msgid "conversion from `%s' to `%s' not supported"
-msgstr "converso de `%s' para `%s' no  suportada"
+#: malloc/memusagestat.c:64
+msgid "Make output graphic VALUE pixels wide"
+msgstr "Fazer um gráfico de saída com VALOR pixels de largura"
 
-#: iconv/iconv_prog.c:326
-msgid "conversion stopped due to problem in writing the output"
-msgstr "a converso parou devido a problemas de escrita na sada"
+#: malloc/memusagestat.c:65
+msgid "Make output graphic VALUE pixels high"
+msgstr "Fazer um gráfico de saída com VALOR pixels de altura"
 
-#: sunrpc/svc_simple.c:83
-msgid "couldn't create an rpc server\n"
-msgstr "no foi possvel criar um servidor rpc\n"
+#: malloc/memusagestat.c:70
+msgid "Generate graphic from memory profiling data"
+msgstr "Gera um gráfico a partir dos dados de perfilamento de memória"
 
-#: sunrpc/svc_simple.c:91
-#, c-format
-msgid "couldn't register prog %d vers %d\n"
-msgstr "no foi possvel registrar prog %d vers %d\n"
+#: malloc/memusagestat.c:73
+msgid "DATAFILE [OUTFILE]"
+msgstr "ARQUIVO-DADOS [ARQUIVO-SAÍDA]"
 
-#: nss/getent.c:49
-msgid "database [key ...]"
-msgstr "base de dados [chave ...]"
+#: misc/error.c:192
+msgid "Unknown system error"
+msgstr "Erro desconhecido de sistema"
+
+#: nis/nis_callback.c:188
+msgid "unable to free arguments"
+msgstr "não foi possível liberar argumentos"
+
+#: nis/nis_error.h:1 nis/ypclnt.c:824 nis/ypclnt.c:913 posix/regcomp.c:137
+#: sysdeps/gnu/errlist.c:21
+msgid "Success"
+msgstr "Sucesso"
+
+#: nis/nis_error.h:2
+msgid "Probable success"
+msgstr "Sucesso provável"
+
+#: nis/nis_error.h:3
+msgid "Not found"
+msgstr "Não localizado"
+
+#: nis/nis_error.h:4
+msgid "Probably not found"
+msgstr "Provavelmente não encontrado"
+
+#: nis/nis_error.h:5
+msgid "Cache expired"
+msgstr "Tempo expirado"
+
+#: nis/nis_error.h:6
+msgid "NIS+ servers unreachable"
+msgstr "Servidores NIS+ fora do alcance"
+
+#: nis/nis_error.h:7
+msgid "Unknown object"
+msgstr "Objeto desconhecido"
+
+#: nis/nis_error.h:8
+msgid "Server busy, try again"
+msgstr "Servidor ocupado, tente novamente"
+
+#: nis/nis_error.h:9
+msgid "Generic system error"
+msgstr "Erro genérico de sistema"
+
+#: nis/nis_error.h:10
+msgid "First/next chain broken"
+msgstr "Primeira/próxima corrente quebrada"
+
+#. TRANS The file permissions do not allow the attempted operation.
+#: nis/nis_error.h:11 nis/ypclnt.c:869 sysdeps/gnu/errlist.c:158
+msgid "Permission denied"
+msgstr "Permissão negada"
+
+#: nis/nis_error.h:12
+msgid "Not owner"
+msgstr "Dono inválido"
+
+#: nis/nis_error.h:13
+msgid "Name not served by this server"
+msgstr "Nome não servido por este servidor"
+
+#: nis/nis_error.h:14
+msgid "Server out of memory"
+msgstr "Memória do servidor exaurida"
+
+#: nis/nis_error.h:15
+msgid "Object with same name exists"
+msgstr "Um objeto com o mesmo nome existe"
+
+#: nis/nis_error.h:16
+msgid "Not master server for this domain"
+msgstr "Não é um servidor mestre para este domínio"
+
+#: nis/nis_error.h:17
+msgid "Invalid object for operation"
+msgstr "Objeto inválido para a operação"
+
+#: nis/nis_error.h:18
+msgid "Malformed name, or illegal name"
+msgstr "Nome malformado ou nome ilegal"
+
+#: nis/nis_error.h:19
+msgid "Unable to create callback"
+msgstr "Impossível criar retorno de chamada"
+
+#: nis/nis_error.h:20
+msgid "Results sent to callback proc"
+msgstr "Resultados enviados para o processo de retorno chamada"
+
+#: nis/nis_error.h:21
+msgid "Not found, no such name"
+msgstr "Não localizado, nome inexistente"
+
+#: nis/nis_error.h:22
+msgid "Name/entry isn't unique"
+msgstr "Nome/entrada não é único"
+
+#: nis/nis_error.h:23
+msgid "Modification failed"
+msgstr "Modificação falhou"
+
+#: nis/nis_error.h:24
+msgid "Database for table does not exist"
+msgstr "Banco de dados para a tabela não existe"
+
+#: nis/nis_error.h:25
+msgid "Entry/table type mismatch"
+msgstr "Tipo de entrada/tabela incompatível"
+
+#: nis/nis_error.h:26
+msgid "Link points to illegal name"
+msgstr "Link aponta para um nome ilegal"
+
+#: nis/nis_error.h:27
+msgid "Partial success"
+msgstr "Sucesso parcial"
+
+#: nis/nis_error.h:28
+msgid "Too many attributes"
+msgstr "Número excessivo de atributos"
+
+#: nis/nis_error.h:29
+msgid "Error in RPC subsystem"
+msgstr "Erro no subsistema RPC"
+
+#: nis/nis_error.h:30
+msgid "Missing or malformed attribute"
+msgstr "Atributo perdido ou malformado"
+
+#: nis/nis_error.h:31
+msgid "Named object is not searchable"
+msgstr "Objeto nomeado não é pesquisável"
+
+#: nis/nis_error.h:32
+msgid "Error while talking to callback proc"
+msgstr "Erro durante a chamada a processo de retorno de chamada"
+
+#: nis/nis_error.h:33
+msgid "Non NIS+ namespace encountered"
+msgstr "Espaço de nomes não-NIS+ encontrado"
+
+#: nis/nis_error.h:34
+msgid "Illegal object type for operation"
+msgstr "Tipo ilegal de objeto para a operação"
+
+#: nis/nis_error.h:35
+msgid "Passed object is not the same object on server"
+msgstr "Objeto passado não é o mesmo objeto no servidor"
+
+#: nis/nis_error.h:36
+msgid "Modify operation failed"
+msgstr "Operação de modificação falhou"
+
+#: nis/nis_error.h:37
+msgid "Query illegal for named table"
+msgstr "Pergunta ilegal para tabela nominada"
+
+#: nis/nis_error.h:38
+msgid "Attempt to remove a non-empty table"
+msgstr "Tentativa de remoção de uma tabela não vazia"
+
+#: nis/nis_error.h:39
+msgid "Error in accessing NIS+ cold start file.  Is NIS+ installed?"
+msgstr "Erro acessando arquivo inicial do NIS+. O NIS+ está instalado?"
+
+#: nis/nis_error.h:40
+msgid "Full resync required for directory"
+msgstr "Nova sincronização total necessária para o diretório"
+
+#: nis/nis_error.h:41
+msgid "NIS+ operation failed"
+msgstr "Operação NIS+ falhou"
+
+#: nis/nis_error.h:42
+msgid "NIS+ service is unavailable or not installed"
+msgstr "Serviço NIS+ está indisponível ou não está instalado"
+
+#: nis/nis_error.h:43
+msgid "Yes, 42 is the meaning of life"
+msgstr "Sim, 42 é o sentido da vida"
+
+#: nis/nis_error.h:44
+msgid "Unable to authenticate NIS+ server"
+msgstr "Não foi possível autenticar servidor NIS+"
+
+#: nis/nis_error.h:45
+msgid "Unable to authenticate NIS+ client"
+msgstr "Não foi possível autenticar cliente NIS+"
+
+#: nis/nis_error.h:46
+msgid "No file space on server"
+msgstr "Não há espaço disponível no servidor"
 
-#: locale/programs/charmap.c:170
+#: nis/nis_error.h:47
+msgid "Unable to create process on server"
+msgstr "Não foi possível criar processo no servidor"
+
+#: nis/nis_error.h:48
+msgid "Master server busy, full dump rescheduled."
+msgstr "Servidor mestre ocupado, descarregamento completo (dump) remarcado."
+
+#: nis/nis_local_names.c:122
 #, c-format
-msgid "default character map file `%s' not found"
-msgstr "arquivo default de mapa de caracter `%s' no localizado"
+msgid "LOCAL entry for UID %d in directory %s not unique\n"
+msgstr "Entrada LOCAL para UID %d no diretório %s não é única\n"
+
+#: nis/nis_print.c:52
+msgid "UNKNOWN"
+msgstr "DESCONHECIDO"
+
+#: nis/nis_print.c:110
+msgid "BOGUS OBJECT\n"
+msgstr "OBJETO FALSO\n"
+
+#: nis/nis_print.c:113
+msgid "NO OBJECT\n"
+msgstr "SEM OBJETO\n"
+
+#: nis/nis_print.c:116
+msgid "DIRECTORY\n"
+msgstr "DIRETÓRIO\n"
+
+#: nis/nis_print.c:119
+msgid "GROUP\n"
+msgstr "GRUPO\n"
+
+#: nis/nis_print.c:122
+msgid "TABLE\n"
+msgstr "TABELA\n"
+
+#: nis/nis_print.c:125
+msgid "ENTRY\n"
+msgstr "ENTRADA\n"
+
+#: nis/nis_print.c:128
+msgid "LINK\n"
+msgstr "LINK\n"
+
+#: nis/nis_print.c:131
+msgid "PRIVATE\n"
+msgstr "PRIVADO\n"
 
-#: locale/programs/ld-time.c:163
+#: nis/nis_print.c:134
+msgid "(Unknown object)\n"
+msgstr "(Objeto desconhecido)\n"
+
+#: nis/nis_print.c:168
 #, c-format
-msgid "direction flag in string %d in `era' field in category `%s' is not '+' nor '-'"
-msgstr "flag de direo na string %d no campo `era', categoria `%s', no  '+'nem '_'"
+msgid "Name : `%s'\n"
+msgstr "Nome : “%s”\n"
 
-#: locale/programs/ld-time.c:174
+#: nis/nis_print.c:169
 #, c-format
-msgid "direction flag in string %d in `era' field in category `%s' is not a single character"
-msgstr "flag de direo na string %d no campo `era', categoria `%s', no  um caracter simples"
+msgid "Type : %s\n"
+msgstr "Tipo : %s\n"
+
+#: nis/nis_print.c:174
+msgid "Master Server :\n"
+msgstr "Servidor mestre :\n"
+
+#: nis/nis_print.c:176
+msgid "Replicate :\n"
+msgstr "Duplicado :\n"
 
-#: locale/programs/charset.c:64 locale/programs/charset.c:118
+#: nis/nis_print.c:177
 #, c-format
-msgid "duplicate character name `%s'"
-msgstr "nome de caracter duplicado `%s'"
+msgid "\tName       : %s\n"
+msgstr "\tNome          : %s\n"
 
-#: locale/programs/ld-collate.c:1150
-msgid "duplicate collating element definition"
-msgstr "definio de elemento de comparao duplicada"
+#: nis/nis_print.c:178
+msgid "\tPublic Key : "
+msgstr "\tChave pública : "
+
+#: nis/nis_print.c:182
+msgid "None.\n"
+msgstr "nenhum.\n"
 
-#: locale/programs/ld-collate.c:1297
+#: nis/nis_print.c:185
 #, c-format
-msgid "duplicate definition for character `%.*s'"
-msgstr "definio para caracter duplicada `%.*s'"
+msgid "Diffie-Hellmann (%d bits)\n"
+msgstr "Diffie-Hellman (%d bits)\n"
 
-#: db2/makedb.c:328
-msgid "duplicate key"
-msgstr "chave duplicada"
+#: nis/nis_print.c:190
+#, c-format
+msgid "RSA (%d bits)\n"
+msgstr "RSA (%d bits)\n"
 
-#: catgets/gencat.c:388
-msgid "duplicate set definition"
-msgstr "definio de conjunto duplicada"
+#: nis/nis_print.c:193
+msgid "Kerberos.\n"
+msgstr "Kerberos.\n"
 
-#: timezone/zic.c:978
+#: nis/nis_print.c:196
 #, c-format
-msgid "duplicate zone name %s (file \"%s\", line %d)"
-msgstr "nome de zona duplicado %s (arquivo \"%s\", linha %d)"
+msgid "Unknown (type = %d, bits = %d)\n"
+msgstr "Desconhecido (tipo = %d, bits = %d)\n"
 
-#: catgets/gencat.c:551
-msgid "duplicated message identifier"
-msgstr "identificador de mensagens duplicado"
+#: nis/nis_print.c:207
+#, c-format
+msgid "\tUniversal addresses (%u)\n"
+msgstr "\tEndereço universal (%u)\n"
 
-#: catgets/gencat.c:524
-msgid "duplicated message number"
-msgstr "nmero de mensagem duplicado"
+#: nis/nis_print.c:229
+msgid "Time to live : "
+msgstr "Tempo de vida : "
 
-#: sunrpc/rpc_scan.c:382
-msgid "empty char string"
-msgstr "cadeia de caractere vazia"
+#: nis/nis_print.c:231
+msgid "Default Access rights :\n"
+msgstr "Direitos de acesso padrão :\n"
 
-#: locale/programs/ld-collate.c:1710
-msgid "empty weight name: line ignored"
-msgstr "nome do peso vazio: linha ignorada"
+#: nis/nis_print.c:240
+#, c-format
+msgid "\tType         : %s\n"
+msgstr "\tTipo           : %s\n"
 
-#: sunrpc/svc_udp.c:372
-msgid "enablecache: cache already enabled"
-msgstr "enablecache: cache j ativado"
+#: nis/nis_print.c:241
+msgid "\tAccess rights: "
+msgstr "\tDireitos acesso: "
 
-#: sunrpc/svc_udp.c:378
-msgid "enablecache: could not allocate cache"
-msgstr "enablecache: no foi possvel alocar cache"
+#: nis/nis_print.c:255
+msgid "Group Flags :"
+msgstr "Indicadores de grupo :"
 
-#: sunrpc/svc_udp.c:386
-msgid "enablecache: could not allocate cache data"
-msgstr "enablecache: no foi possvel alocar dados do cache"
+#: nis/nis_print.c:258
+msgid ""
+"\n"
+"Group Members :\n"
+msgstr ""
+"\n"
+"Membros do grupo :\n"
 
-#: sunrpc/svc_udp.c:393
-msgid "enablecache: could not allocate cache fifo"
-msgstr "enablecache: no foi possvel alocar cache fifo"
+#: nis/nis_print.c:270
+#, c-format
+msgid "Table Type          : %s\n"
+msgstr "Tipo de tabela          : %s\n"
 
-#: iconv/iconv_prog.c:56
-msgid "encoding for output"
-msgstr "codificao para a sada"
+#: nis/nis_print.c:271
+#, c-format
+msgid "Number of Columns   : %d\n"
+msgstr "Número de colunas       : %d\n"
 
-#: iconv/iconv_prog.c:55
-msgid "encoding of original text"
-msgstr "codificao para o texto original"
+#: nis/nis_print.c:272
+#, c-format
+msgid "Character Separator : %c\n"
+msgstr "Separador de caracteres : %c\n"
+
+#: nis/nis_print.c:273
+#, c-format
+msgid "Search Path         : %s\n"
+msgstr "Caminho de pesquisa     : %s\n"
+
+#: nis/nis_print.c:274
+msgid "Columns             :\n"
+msgstr "Colunas                 :\n"
+
+#: nis/nis_print.c:277
+#, c-format
+msgid "\t[%d]\tName          : %s\n"
+msgstr "\t[%d]\tNome               : %s\n"
+
+#: nis/nis_print.c:279
+msgid "\t\tAttributes    : "
+msgstr "\t\tAtributos          : "
+
+#: nis/nis_print.c:281
+msgid "\t\tAccess Rights : "
+msgstr "\t\tDireitos de acesso : "
+
+#: nis/nis_print.c:291
+msgid "Linked Object Type : "
+msgstr "Tipo de objeto vinculado : "
+
+#: nis/nis_print.c:293
+#, c-format
+msgid "Linked to : %s\n"
+msgstr "Vinculado a : %s\n"
+
+#: nis/nis_print.c:303
+#, c-format
+msgid "\tEntry data of type %s\n"
+msgstr "\tEntrada de dados de tipo %s\n"
+
+#: nis/nis_print.c:306
+#, c-format
+msgid "\t[%u] - [%u bytes] "
+msgstr "\t[%u] – [%u bytes] "
+
+#: nis/nis_print.c:309
+msgid "Encrypted data\n"
+msgstr "Dados criptografados\n"
+
+#: nis/nis_print.c:311
+msgid "Binary data\n"
+msgstr "Dados binários\n"
+
+#: nis/nis_print.c:327
+#, c-format
+msgid "Object Name   : %s\n"
+msgstr "Nome do objeto     : %s\n"
+
+#: nis/nis_print.c:328
+#, c-format
+msgid "Directory     : %s\n"
+msgstr "Diretório          : %s\n"
+
+#: nis/nis_print.c:329
+#, c-format
+msgid "Owner         : %s\n"
+msgstr "Dono               : %s\n"
+
+#: nis/nis_print.c:330
+#, c-format
+msgid "Group         : %s\n"
+msgstr "Grupo              : %s\n"
+
+#: nis/nis_print.c:331
+msgid "Access Rights : "
+msgstr "Direitos de acesso : "
+
+#: nis/nis_print.c:333
+#, c-format
+msgid ""
+"\n"
+"Time to Live  : "
+msgstr ""
+"\n"
+"Tempo de vida      : "
+
+#: nis/nis_print.c:336
+#, c-format
+msgid "Creation Time : %s"
+msgstr "Horário de criação : %s"
+
+#: nis/nis_print.c:338
+#, c-format
+msgid "Mod. Time     : %s"
+msgstr "Horário de mod.    : %s"
+
+#: nis/nis_print.c:339
+msgid "Object Type   : "
+msgstr "Tipo do objeto     : "
+
+#: nis/nis_print.c:359
+#, c-format
+msgid "    Data Length = %u\n"
+msgstr "  Tamanho dados = %u\n"
+
+#: nis/nis_print.c:373
+#, c-format
+msgid "Status            : %s\n"
+msgstr "Posição           : %s\n"
 
-#: locale/programs/ld-collate.c:1429
-msgid "end point of ellipsis range is bigger then start"
-msgstr "o ponto final da rea da elipse  maior que o incio "
+#: nis/nis_print.c:374
+#, c-format
+msgid "Number of objects : %u\n"
+msgstr "Número de objetos : %u\n"
+
+#: nis/nis_print.c:378
+#, c-format
+msgid "Object #%d:\n"
+msgstr "Objeto #%d:\n"
+
+#: nis/nis_print_group_entry.c:117
+#, c-format
+msgid "Group entry for \"%s.%s\" group:\n"
+msgstr "Entrada para o grupo “%s.%s”:\n"
+
+#: nis/nis_print_group_entry.c:125
+msgid "    Explicit members:\n"
+msgstr "    Membros explícitos:\n"
+
+#: nis/nis_print_group_entry.c:130
+msgid "    No explicit members\n"
+msgstr "    Nenhum membro explícito\n"
+
+#: nis/nis_print_group_entry.c:133
+msgid "    Implicit members:\n"
+msgstr "    Membros implícitos:\n"
+
+#: nis/nis_print_group_entry.c:138
+msgid "    No implicit members\n"
+msgstr "    Nenhum membro implícito\n"
+
+#: nis/nis_print_group_entry.c:141
+msgid "    Recursive members:\n"
+msgstr "    Membros recursivos:\n"
+
+#: nis/nis_print_group_entry.c:146
+msgid "    No recursive members\n"
+msgstr "    Nenhuma membros recursivo\n"
+
+#: nis/nis_print_group_entry.c:149
+msgid "    Explicit nonmembers:\n"
+msgstr "    Não-membros explícitos:\n"
+
+#: nis/nis_print_group_entry.c:154
+msgid "    No explicit nonmembers\n"
+msgstr "    Nenhum não-membro explícito\n"
+
+#: nis/nis_print_group_entry.c:157
+msgid "    Implicit nonmembers:\n"
+msgstr "    Não-membros implícitos:\n"
+
+#: nis/nis_print_group_entry.c:162
+msgid "    No implicit nonmembers\n"
+msgstr "    Nenhum não-membro implícito\n"
+
+#: nis/nis_print_group_entry.c:165
+msgid "    Recursive nonmembers:\n"
+msgstr "    Não-membros recursivos:\n"
+
+#: nis/nis_print_group_entry.c:170
+msgid "    No recursive nonmembers\n"
+msgstr "    Nenhum não-membro recursivo\n"
+
+#: nis/nss_nisplus/nisplus-publickey.c:100
+#: nis/nss_nisplus/nisplus-publickey.c:182
+#, c-format
+msgid "DES entry for netname %s not unique\n"
+msgstr "Entrada DES para nome de rede (netname) %s não é única\n"
+
+#: nis/nss_nisplus/nisplus-publickey.c:219
+#, c-format
+msgid "netname2user: missing group id list in `%s'"
+msgstr "netname2user: faltando lista de id do grupo em “%s”"
+
+#: nis/nss_nisplus/nisplus-publickey.c:301
+#: nis/nss_nisplus/nisplus-publickey.c:307
+#: nis/nss_nisplus/nisplus-publickey.c:372
+#: nis/nss_nisplus/nisplus-publickey.c:381
+#, c-format
+msgid "netname2user: (nis+ lookup): %s\n"
+msgstr "netname2user: (nis+ lookup): %s\n"
+
+#: nis/nss_nisplus/nisplus-publickey.c:320
+#, c-format
+msgid "netname2user: DES entry for %s in directory %s not unique"
+msgstr "netname2user: entrada DES para %s no diretório %s não é única"
+
+#: nis/nss_nisplus/nisplus-publickey.c:338
+#, c-format
+msgid "netname2user: principal name `%s' too long"
+msgstr "netname2user: nome princpal “%s” longo demais"
+
+#: nis/nss_nisplus/nisplus-publickey.c:394
+#, c-format
+msgid "netname2user: LOCAL entry for %s in directory %s not unique"
+msgstr "netname2user: entrada LOCAL para %s no diretório %s não é única"
+
+#: nis/nss_nisplus/nisplus-publickey.c:401
+msgid "netname2user: should not have uid 0"
+msgstr "netname2user: não deve possuir uid 0"
+
+#: nis/ypclnt.c:827
+msgid "Request arguments bad"
+msgstr "Argumentos de requisição inválidos"
+
+#: nis/ypclnt.c:830
+msgid "RPC failure on NIS operation"
+msgstr "Falha RPC na operação NIS"
+
+#: nis/ypclnt.c:833
+msgid "Can't bind to server which serves this domain"
+msgstr "Não é possível vincular ao servidor que serve este domínio"
+
+#: nis/ypclnt.c:836
+msgid "No such map in server's domain"
+msgstr "Mapa inexistente no domínio do servidor"
+
+#: nis/ypclnt.c:839
+msgid "No such key in map"
+msgstr "Chave inexistente no mapa"
+
+#: nis/ypclnt.c:842
+msgid "Internal NIS error"
+msgstr "Erro NIS interno"
+
+#: nis/ypclnt.c:845
+msgid "Local resource allocation failure"
+msgstr "Falha na alocação de recurso local"
+
+#: nis/ypclnt.c:848
+msgid "No more records in map database"
+msgstr "Não há mais registros no banco de dados de mapas"
+
+#: nis/ypclnt.c:851
+msgid "Can't communicate with portmapper"
+msgstr "Não foi possível comunicar com o portmapper"
+
+#: nis/ypclnt.c:854
+msgid "Can't communicate with ypbind"
+msgstr "Não foi possível comunicar com o ypbind"
+
+#: nis/ypclnt.c:857
+msgid "Can't communicate with ypserv"
+msgstr "Não foi possível comunicar com o ypserv"
+
+#: nis/ypclnt.c:860
+msgid "Local domain name not set"
+msgstr "Nome de domínio local não definido"
+
+#: nis/ypclnt.c:863
+msgid "NIS map database is bad"
+msgstr "Banco de dados de mapas NIS é inválido"
+
+#: nis/ypclnt.c:866
+msgid "NIS client/server version mismatch - can't supply service"
+msgstr "Versões cliente/servidor NIS não conferem – não foi possível oferecer serviço"
+
+#: nis/ypclnt.c:872
+msgid "Database is busy"
+msgstr "Banco de dados está ocupado"
+
+#: nis/ypclnt.c:875
+msgid "Unknown NIS error code"
+msgstr "Código de erro NIS desconhecido"
+
+#: nis/ypclnt.c:916
+msgid "Internal ypbind error"
+msgstr "Erro interno de ypbind"
+
+#: nis/ypclnt.c:919
+msgid "Domain not bound"
+msgstr "Domínio não vinculado"
+
+#: nis/ypclnt.c:922
+msgid "System resource allocation failure"
+msgstr "Falha de alocação de recursos do sistema"
+
+#: nis/ypclnt.c:925
+msgid "Unknown ypbind error"
+msgstr "Erro desconhecido de ypbind"
+
+#: nis/ypclnt.c:966
+msgid "yp_update: cannot convert host to netname\n"
+msgstr "yp_update: não foi possível converter host para netname\n"
+
+#: nis/ypclnt.c:984
+msgid "yp_update: cannot get server address\n"
+msgstr "yp_update: não foi possível obter o endereço do servidor\n"
+
+#: nscd/aicache.c:85 nscd/hstcache.c:485
+#, c-format
+msgid "Haven't found \"%s\" in hosts cache!"
+msgstr "Não foi encontrado “%s” no cache de máquinas!"
+
+#: nscd/aicache.c:87 nscd/hstcache.c:487
+#, c-format
+msgid "Reloading \"%s\" in hosts cache!"
+msgstr "Recarregando “%s” no cache de máquinas!"
+
+#: nscd/cache.c:151
+#, c-format
+msgid "add new entry \"%s\" of type %s for %s to cache%s"
+msgstr "adicionar nova entrada “%s” do tipo %s para %s ao cache%s"
+
+#: nscd/cache.c:153
+msgid " (first)"
+msgstr " (primeira)"
+
+#: nscd/cache.c:288
+#, c-format
+msgid "checking for monitored file `%s': %s"
+msgstr "verificando pelo arquivo monitorado “%s”: %s"
+
+#: nscd/cache.c:298
+#, c-format
+msgid "monitored file `%s` changed (mtime)"
+msgstr "arquivo monitorado “%s” foi modificado (mtime)"
+
+#: nscd/cache.c:341
+#, c-format
+msgid "pruning %s cache; time %ld"
+msgstr "removendo cache %s; tempo %ld"
+
+#: nscd/cache.c:370
+#, c-format
+msgid "considering %s entry \"%s\", timeout %<PRIu64>"
+msgstr "considerando entrada %s “%s”, tempo limite %<PRIu64>"
+
+#: nscd/connections.c:537
+#, c-format
+msgid "invalid persistent database file \"%s\": %s"
+msgstr "arquivo inválido de banco de dados persistente “%s”: %s"
+
+#: nscd/connections.c:545
+msgid "uninitialized header"
+msgstr "cabeçalho não inicializado"
+
+#: nscd/connections.c:550
+msgid "header size does not match"
+msgstr "tamanho do cabeçalho não confere"
+
+#: nscd/connections.c:560
+msgid "file size does not match"
+msgstr "tamanho de arquivo não confere"
+
+#: nscd/connections.c:577
+msgid "verification failed"
+msgstr "verificação falhou"
+
+#: nscd/connections.c:591
+#, c-format
+msgid "suggested size of table for database %s larger than the persistent database's table"
+msgstr "tamanho sugerido de tabela para banco de dados %s maior que a tabela do banco de dados persistente"
+
+#: nscd/connections.c:602 nscd/connections.c:686
+#, c-format
+msgid "cannot create read-only descriptor for \"%s\"; no mmap"
+msgstr "não foi possível criar descritor somente leitura para “%s”; nenhum mmap"
+
+#: nscd/connections.c:618
+#, c-format
+msgid "cannot access '%s'"
+msgstr "não foi possível acessar “%s”"
+
+#: nscd/connections.c:666
+#, c-format
+msgid "database for %s corrupted or simultaneously used; remove %s manually if necessary and restart"
+msgstr "banco de dados para %s corrompido ou usado simultaneamente; remova %s manualmente, se necessário, e reinicie"
+
+#: nscd/connections.c:672
+#, c-format
+msgid "cannot create %s; no persistent database used"
+msgstr "não foi possível criar %s; nenhum banco de dados persistente usado"
+
+#: nscd/connections.c:675
+#, c-format
+msgid "cannot create %s; no sharing possible"
+msgstr "não foi possível criar %s; nenhum compartilhamento possível"
+
+#: nscd/connections.c:746
+#, c-format
+msgid "cannot write to database file %s: %s"
+msgstr "não foi possível escrever para o arquivo de banco de dados %s: %s"
+
+#: nscd/connections.c:802
+#, c-format
+msgid "cannot open socket: %s"
+msgstr "não é possível abrir soquete: “%s”"
+
+#: nscd/connections.c:821
+#, c-format
+msgid "cannot enable socket to accept connections: %s"
+msgstr "impossível habilitar soquete para aceitar conexões: %s"
+
+#: nscd/connections.c:878
+#, c-format
+msgid "disabled inotify-based monitoring for file `%s': %s"
+msgstr "desabilitado monitoramento baseado em inotify para o arquivo “%s”: %s"
+
+#: nscd/connections.c:882
+#, c-format
+msgid "monitoring file `%s` (%d)"
+msgstr "monitorando o arquivo “%s” (%d)"
+
+#: nscd/connections.c:895
+#, c-format
+msgid "disabled inotify-based monitoring for directory `%s': %s"
+msgstr "desabilitado monitoramento baseado em inotify para o diretório “%s”: %s"
+
+#: nscd/connections.c:899
+#, c-format
+msgid "monitoring directory `%s` (%d)"
+msgstr "monitorando o diretório “%s” (%d)"
+
+#: nscd/connections.c:927
+#, c-format
+msgid "monitoring file %s for database %s"
+msgstr "monitorando o arquivo %s para o banco de dados %s"
+
+#: nscd/connections.c:937
+#, c-format
+msgid "stat failed for file `%s'; will try again later: %s"
+msgstr "obtenção de estado falhou para o arquivo “%s”; nova tentativa posteriormente: %s"
+
+#: nscd/connections.c:1056
+#, c-format
+msgid "provide access to FD %d, for %s"
+msgstr "fornece acesso ao descritor de arquivo %d, para %s"
+
+#: nscd/connections.c:1068
+#, c-format
+msgid "cannot handle old request version %d; current version is %d"
+msgstr "impossível lidar com requisições de versões antigas %d; a versão atual é %d"
+
+#: nscd/connections.c:1091
+#, c-format
+msgid "request from %ld not handled due to missing permission"
+msgstr "requisição de %ld não manipulada em razão de falta de permissão"
+
+#: nscd/connections.c:1096
+#, c-format
+msgid "request from '%s' [%ld] not handled due to missing permission"
+msgstr "requisição de “%s” [%ld] não manipulada em razão de falta de permissão"
+
+#: nscd/connections.c:1101
+msgid "request not handled due to missing permission"
+msgstr "requisição não manipulada em razão de falta de permissão"
+
+#: nscd/connections.c:1139 nscd/connections.c:1192
+#, c-format
+msgid "cannot write result: %s"
+msgstr "não é possível escrever resultado: %s"
+
+#: nscd/connections.c:1283
+#, c-format
+msgid "error getting caller's id: %s"
+msgstr "erro ao obter o id do chamador: %s"
+
+#: nscd/connections.c:1343
+#, c-format
+msgid "cannot open /proc/self/cmdline: %s; disabling paranoia mode"
+msgstr "não foi possível abrir /proc/self/cmdline: %s; desabilitando modo paranoia"
+
+#: nscd/connections.c:1357
+#, c-format
+msgid "cannot read /proc/self/cmdline: %s; disabling paranoia mode"
+msgstr "não foi possível ler /proc/self/cmdline: %s; desabilitando modo paranoia"
+
+#: nscd/connections.c:1397
+#, c-format
+msgid "cannot change to old UID: %s; disabling paranoia mode"
+msgstr "não foi possível alterar para UID antigo: %s; desabilitando modo paranoia"
+
+#: nscd/connections.c:1407
+#, c-format
+msgid "cannot change to old GID: %s; disabling paranoia mode"
+msgstr "não foi possível alterar para GID antigo: %s; desabilitando modo paranoia"
+
+#: nscd/connections.c:1420
+#, c-format
+msgid "cannot change to old working directory: %s; disabling paranoia mode"
+msgstr "não foi possível mudar para diretório de trabalho anterior: %s; desabilitando modo paranoia"
+
+#: nscd/connections.c:1466
+#, c-format
+msgid "re-exec failed: %s; disabling paranoia mode"
+msgstr "reexecução falhou: %s; desabilitando modo paranoia"
+
+#: nscd/connections.c:1475
+#, c-format
+msgid "cannot change current working directory to \"/\": %s"
+msgstr "não foi possível mudar o diretório de trabalho atual para “/”: %s"
+
+#: nscd/connections.c:1658
+#, c-format
+msgid "short read while reading request: %s"
+msgstr "leitura insuficiente durante a leitura da requisição: %s"
+
+#: nscd/connections.c:1691
+#, c-format
+msgid "key length in request too long: %d"
+msgstr "tamanho da chave na requisição é grande demais: %d"
+
+#: nscd/connections.c:1704
+#, c-format
+msgid "short read while reading request key: %s"
+msgstr "leitura insuficiente durante a leitura da chave de requisição: %s"
+
+#: nscd/connections.c:1714
+#, c-format
+msgid "handle_request: request received (Version = %d) from PID %ld"
+msgstr "handle_request: requisição recebida (Versão = %d) do PID %ld"
+
+#: nscd/connections.c:1719
+#, c-format
+msgid "handle_request: request received (Version = %d)"
+msgstr "handle_request: requisição recebida (Versão = %d)"
+
+#: nscd/connections.c:1859
+#, c-format
+msgid "ignored inotify event for `%s` (file exists)"
+msgstr "evento inotify ignorado para “%s” (arquivo existe)"
+
+#: nscd/connections.c:1864
+#, c-format
+msgid "monitored file `%s` was %s, removing watch"
+msgstr "arquivo monitorado “%s” era %s, removendo inspeção"
+
+#: nscd/connections.c:1872 nscd/connections.c:1914
+#, c-format
+msgid "failed to remove file watch `%s`: %s"
+msgstr "falha ao remover inspeção do arquivo “%s”: %s"
+
+#: nscd/connections.c:1887
+#, c-format
+msgid "monitored file `%s` was written to"
+msgstr "arquivo monitorado “%s” foi escrito para"
+
+#: nscd/connections.c:1911
+#, c-format
+msgid "monitored parent directory `%s` was %s, removing watch on `%s`"
+msgstr "diretório pai monitorado “%s” foi %s, removendo inspeção em “%s”"
+
+#: nscd/connections.c:1937
+#, c-format
+msgid "monitored file `%s` was %s, adding watch"
+msgstr "arquivo monitorado “%s” foi %s, adicionando inspeção"
+
+#: nscd/connections.c:1949
+#, c-format
+msgid "failed to add file watch `%s`: %s"
+msgstr "falha ao adicionar inspeção do arquivo “%s”: %s"
+
+#: nscd/connections.c:2127 nscd/connections.c:2292
+#, c-format
+msgid "disabled inotify-based monitoring after read error %d"
+msgstr "desabilitado monitoramento baseado em inotify após erro de leitura %d"
+
+#: nscd/connections.c:2407
+msgid "could not initialize conditional variable"
+msgstr "não foi possível inicializar variável condicional"
+
+#: nscd/connections.c:2415
+msgid "could not start clean-up thread; terminating"
+msgstr "não foi possível iniciar fluxo de limpeza; terminando"
+
+#: nscd/connections.c:2429
+msgid "could not start any worker thread; terminating"
+msgstr "não foi possível iniciar qualquer fluxo de trabalho; terminando"
+
+#: nscd/connections.c:2484 nscd/connections.c:2486 nscd/connections.c:2502
+#: nscd/connections.c:2512 nscd/connections.c:2530 nscd/connections.c:2541
+#: nscd/connections.c:2551
+#, c-format
+msgid "Failed to run nscd as user '%s'"
+msgstr "Falha ao executar nscd como usuário “%s”"
+
+#: nscd/connections.c:2504
+msgid "initial getgrouplist failed"
+msgstr "getgrouplist inicial falhou"
+
+#: nscd/connections.c:2513
+msgid "getgrouplist failed"
+msgstr "getgrouplist falhou"
+
+#: nscd/connections.c:2531
+msgid "setgroups failed"
+msgstr "setgroups falhou"
+
+#: nscd/grpcache.c:416 nscd/hstcache.c:432 nscd/initgrcache.c:416
+#: nscd/pwdcache.c:394 nscd/servicescache.c:338
+#, c-format
+msgid "short write in %s: %s"
+msgstr "escrita insuficiente em %s: %s"
+
+#: nscd/grpcache.c:461 nscd/initgrcache.c:84
+#, c-format
+msgid "Haven't found \"%s\" in group cache!"
+msgstr "Não foi encontrado “%s” no cache de grupo!"
+
+#: nscd/grpcache.c:463 nscd/initgrcache.c:86
+#, c-format
+msgid "Reloading \"%s\" in group cache!"
+msgstr "Recarregando “%s” no cache de grupo!"
+
+#: nscd/grpcache.c:542
+#, c-format
+msgid "Invalid numeric gid \"%s\"!"
+msgstr "GID numérico inválido “%s”!"
+
+#: nscd/mem.c:425
+#, c-format
+msgid "freed %zu bytes in %s cache"
+msgstr "liberados %zu bytes no cache de %s"
+
+#: nscd/mem.c:568
+#, c-format
+msgid "no more memory for database '%s'"
+msgstr "não há mais memória para o banco de dados “%s”"
+
+#: nscd/netgroupcache.c:121
+#, c-format
+msgid "Haven't found \"%s\" in netgroup cache!"
+msgstr "Não foi encontrado “%s” no cache de netgroup!"
+
+#: nscd/netgroupcache.c:123
+#, c-format
+msgid "Reloading \"%s\" in netgroup cache!"
+msgstr "Recarregando “%s” no cache de netgroup!"
+
+#: nscd/netgroupcache.c:495
+#, c-format
+msgid "Haven't found \"%s (%s,%s,%s)\" in netgroup cache!"
+msgstr "Não foi encontrado “%s (%s,%s,%s)” no cache de netgroup!"
+
+#: nscd/netgroupcache.c:498
+#, c-format
+msgid "Reloading \"%s (%s,%s,%s)\" in netgroup cache!"
+msgstr "Recarregando “%s (%s,%s,%s)” no cache de netgroup!"
+
+#: nscd/nscd.c:106
+msgid "Read configuration data from NAME"
+msgstr "Lê configuração de dados de NOME"
+
+#: nscd/nscd.c:108
+msgid "Do not fork and display messages on the current tty"
+msgstr "Não bifurca (fork) e mostre mensagens na tty corrente"
+
+#: nscd/nscd.c:110
+msgid "Do not fork, but otherwise behave like a daemon"
+msgstr "Não bifurca (fork), mas, em vez disso, se comporta como um serviço (daemon)"
+
+#: nscd/nscd.c:111
+msgid "NUMBER"
+msgstr "NÚMERO"
+
+# Espaço inical adicionado para corrigir alinhamento; veja 'nscd --help' -- Rafael
+#: nscd/nscd.c:111
+msgid "Start NUMBER threads"
+msgstr " Inicia NÚMERO threads"
+
+#: nscd/nscd.c:112
+msgid "Shut the server down"
+msgstr "Encerra o servidor"
+
+#: nscd/nscd.c:113
+msgid "Print current configuration statistics"
+msgstr "Reúne e imprime as estatísticas de configuração"
+
+#: nscd/nscd.c:114
+msgid "TABLE"
+msgstr "TABELA"
+
+#: nscd/nscd.c:115
+msgid "Invalidate the specified cache"
+msgstr "Invalida o cache especificado"
+
+#: nscd/nscd.c:116
+msgid "TABLE,yes"
+msgstr "TABELA,sim"
+
+#: nscd/nscd.c:117
+msgid "Use separate cache for each user"
+msgstr "Usa um cache separado para cada usuário"
+
+#: nscd/nscd.c:122
+msgid "Name Service Cache Daemon."
+msgstr "Daemon de cache de serviço de nomes."
+
+#: nscd/nscd.c:155 nss/getent.c:947 nss/makedb.c:206
+#, c-format
+msgid "wrong number of arguments"
+msgstr "número incorreto de argumentos"
+
+#: nscd/nscd.c:165
+#, c-format
+msgid "failure while reading configuration file; this is fatal"
+msgstr "falha ao ler arquivo de configuração; isto é fatal"
+
+#: nscd/nscd.c:174
+#, c-format
+msgid "already running"
+msgstr "já está em execução"
+
+#: nscd/nscd.c:194
+#, c-format
+msgid "cannot create a pipe to talk to the child"
+msgstr "não foi possível criar um pipe para falar com o processo filho"
+
+#: nscd/nscd.c:198
+#, c-format
+msgid "cannot fork"
+msgstr "não foi possível bifurcar (fork)"
+
+#: nscd/nscd.c:268
+msgid "cannot change current working directory to \"/\""
+msgstr "não foi possível mudar o diretório de trabalho atual para “/”"
+
+#: nscd/nscd.c:276
+msgid "Could not create log file"
+msgstr "Não foi possível criar o arquivo de log"
+
+#: nscd/nscd.c:355 nscd/nscd_stat.c:209
+#, c-format
+msgid "write incomplete"
+msgstr "escrita incompleta"
+
+#: nscd/nscd.c:366
+#, c-format
+msgid "cannot read invalidate ACK"
+msgstr "não foi possível ler ACK inválida"
+
+#: nscd/nscd.c:372
+#, c-format
+msgid "invalidation failed"
+msgstr "invalidação falhou"
+
+#: nscd/nscd.c:417 nscd/nscd.c:442 nscd/nscd_stat.c:190
+#, c-format
+msgid "Only root is allowed to use this option!"
+msgstr "Somente o superusuário pode usar esta opção!"
+
+#: nscd/nscd.c:437
+#, c-format
+msgid "'%s' is not a known database"
+msgstr "“%s” não é um banco de dados conhecido"
+
+#: nscd/nscd.c:452
+#, c-format
+msgid "secure services not implemented anymore"
+msgstr "serviços seguros não mais implementado"
+
+#: nscd/nscd.c:485
+#, c-format
+msgid ""
+"Supported tables:\n"
+"%s\n"
+"\n"
+"For bug reporting instructions, please see:\n"
+"%s.\n"
+msgstr ""
+"Há suporte às seguintes tabelas:\n"
+"%s\n"
+"\n"
+"Para instruções sobre como relatar erros, por favor veja:\n"
+"%s.\n"
+
+#: nscd/nscd.c:635
+#, c-format
+msgid "'wait' failed\n"
+msgstr "“wait” falhou\n"
+
+#: nscd/nscd.c:642
+#, c-format
+msgid "child exited with status %d\n"
+msgstr "processo filho saiu com erro %d\n"
+
+#: nscd/nscd.c:647
+#, c-format
+msgid "child terminated by signal %d\n"
+msgstr "processo filho terminado pelo sinal %d\n"
+
+#: nscd/nscd_conf.c:54
+#, c-format
+msgid "database %s is not supported"
+msgstr "sem suporte ao banco de dados %s"
+
+#: nscd/nscd_conf.c:105
+#, c-format
+msgid "Parse error: %s"
+msgstr "Erro de análise: %s"
+
+#: nscd/nscd_conf.c:191
+#, c-format
+msgid "Must specify user name for server-user option"
+msgstr "Deve-se especificar o nome do usuário para a opção “server-user”"
+
+#: nscd/nscd_conf.c:198
+#, c-format
+msgid "Must specify user name for stat-user option"
+msgstr "Deve-se especificar o nome do usuário para a opção “stat-user”"
+
+#: nscd/nscd_conf.c:255
+#, c-format
+msgid "Must specify value for restart-interval option"
+msgstr "Deve-se especificar valor para a opção “restart-interval”"
+
+#: nscd/nscd_conf.c:269
+#, c-format
+msgid "Unknown option: %s %s %s"
+msgstr "Opção desconhecida: %s %s %s"
+
+#: nscd/nscd_conf.c:282
+#, c-format
+msgid "cannot get current working directory: %s; disabling paranoia mode"
+msgstr "não foi possível obter o diretório de trabalho: %s; desabilitando modo paranoia"
+
+#: nscd/nscd_conf.c:302
+#, c-format
+msgid "maximum file size for %s database too small"
+msgstr "tamanho máximo de arquivo para o banco de dados %s é pequeno demais"
+
+#: nscd/nscd_stat.c:159
+#, c-format
+msgid "cannot write statistics: %s"
+msgstr "não foi possível escrever estatísticas: %s"
+
+#: nscd/nscd_stat.c:174
+msgid "yes"
+msgstr "sim"
+
+#: nscd/nscd_stat.c:175
+msgid "no"
+msgstr "não"
+
+#: nscd/nscd_stat.c:186
+#, c-format
+msgid "Only root or %s is allowed to use this option!"
+msgstr "Somente o superusuário ou %s pode usar esta opção!"
+
+#: nscd/nscd_stat.c:197
+#, c-format
+msgid "nscd not running!\n"
+msgstr "nscd não está em execução!\n"
+
+#: nscd/nscd_stat.c:221
+#, c-format
+msgid "cannot read statistics data"
+msgstr "não foi possível ler dados de estatística"
+
+#: nscd/nscd_stat.c:224
+#, c-format
+msgid ""
+"nscd configuration:\n"
+"\n"
+"%15d  server debug level\n"
+msgstr ""
+"configuração do nscd:\n"
+"\n"
+"%15d nível de depuração do servidor\n"
+
+#: nscd/nscd_stat.c:248
+#, c-format
+msgid "%3ud %2uh %2um %2lus  server runtime\n"
+msgstr "%3ud %2uh %2um %2lus  tempo de execução do servidor\n"
+
+#: nscd/nscd_stat.c:251
+#, c-format
+msgid "    %2uh %2um %2lus  server runtime\n"
+msgstr "    %2uh %2um %2lus  tempo de execução do servidor\n"
+
+#: nscd/nscd_stat.c:253
+#, c-format
+msgid "        %2um %2lus  server runtime\n"
+msgstr "        %2um %2lus  tempo de execução do servidor\n"
+
+#: nscd/nscd_stat.c:255
+#, c-format
+msgid "            %2lus  server runtime\n"
+msgstr "            %2lus  tempo de execução do servidor\n"
+
+#: nscd/nscd_stat.c:257
+#, c-format
+msgid ""
+"%15d  current number of threads\n"
+"%15d  maximum number of threads\n"
+"%15lu  number of times clients had to wait\n"
+"%15s  paranoia mode enabled\n"
+"%15lu  restart internal\n"
+"%15u  reload count\n"
+msgstr ""
+"%15d  número atual de threads\n"
+"%15d  número máximo de threads\n"
+"%15lu  número de tempos de espera de clientes\n"
+"%15s  modo paranoia habilitado\n"
+"%15lu  reinicialização interna\n"
+"%15u  recarregamento de contagem\n"
+
+#: nscd/nscd_stat.c:292
+#, c-format
+msgid ""
+"\n"
+"%s cache:\n"
+"\n"
+"%15s  cache is enabled\n"
+"%15s  cache is persistent\n"
+"%15s  cache is shared\n"
+"%15zu  suggested size\n"
+"%15zu  total data pool size\n"
+"%15zu  used data pool size\n"
+"%15lu  seconds time to live for positive entries\n"
+"%15lu  seconds time to live for negative entries\n"
+"%15<PRIuMAX>  cache hits on positive entries\n"
+"%15<PRIuMAX>  cache hits on negative entries\n"
+"%15<PRIuMAX>  cache misses on positive entries\n"
+"%15<PRIuMAX>  cache misses on negative entries\n"
+"%15lu%% cache hit rate\n"
+"%15zu  current number of cached values\n"
+"%15zu  maximum number of cached values\n"
+"%15zu  maximum chain length searched\n"
+"%15<PRIuMAX>  number of delays on rdlock\n"
+"%15<PRIuMAX>  number of delays on wrlock\n"
+"%15<PRIuMAX>  memory allocations failed\n"
+"%15s  check /etc/%s for changes\n"
+msgstr ""
+"\n"
+"cache %s:\n"
+"\n"
+"%15s  cache está habilitado\n"
+"%15s  cache é persistente\n"
+"%15s  cache está compartilhado\n"
+"%15zu  tamanho sugerido\n"
+"%15zu  tamanho total de pool de dados\n"
+"%15zu  tamanho usado de pool de dados\n"
+"%15lu  segundos de vida para entradas positivas\n"
+"%15lu  segundos de vida para entradas negativas\n"
+"%15<PRIuMAX>  acertos do cache para entradas positivas\n"
+"%15<PRIuMAX>  acertos do cache para entradas negativas\n"
+"%15<PRIuMAX>  erros do cache para entradas positivas\n"
+"%15<PRIuMAX>  erros do cache para entradas negativas\n"
+"%15lu%% taxa de acertos do cache\n"
+"%15zu  número atual de valores em cache\n"
+"%15zu  número máximo de valores em cache\n"
+"%15zu  tamanho máximo de correntes pesquisadas\n"
+"%15<PRIuMAX>  número de atraso no rdlock\n"
+"%15<PRIuMAX>  número de atraso no wrlock\n"
+"%15<PRIuMAX>  alocações de memória falharam\n"
+"%15s  verifica /etc/%s por alterações\n"
+
+#: nscd/pwdcache.c:439
+#, c-format
+msgid "Haven't found \"%s\" in password cache!"
+msgstr "Não foi encontrado “%s” no cache de senhas!"
+
+#: nscd/pwdcache.c:441
+#, c-format
+msgid "Reloading \"%s\" in password cache!"
+msgstr "Recarregando “%s” no cache de senhas!"
+
+#: nscd/pwdcache.c:522
+#, c-format
+msgid "Invalid numeric uid \"%s\"!"
+msgstr "UID numérico inválido “%s”!"
+
+#: nscd/selinux.c:154
+#, c-format
+msgid "Failed opening connection to the audit subsystem: %m"
+msgstr "Falha ao abrir conexão com o subsistema de auditoria: %m"
+
+#: nscd/selinux.c:175
+msgid "Failed to set keep-capabilities"
+msgstr "Falha ao definir capacidades a serem mantidas"
+
+#: nscd/selinux.c:176 nscd/selinux.c:239
+msgid "prctl(KEEPCAPS) failed"
+msgstr "prctl(KEEPCAPS) falhou"
+
+#: nscd/selinux.c:190
+msgid "Failed to initialize drop of capabilities"
+msgstr "Falha ao inicializar descarte de capacidades"
+
+#: nscd/selinux.c:191
+msgid "cap_init failed"
+msgstr "cap_init falhou"
+
+#: nscd/selinux.c:212 nscd/selinux.c:229
+msgid "Failed to drop capabilities"
+msgstr "Falha ao descartar capacidades"
+
+#: nscd/selinux.c:213 nscd/selinux.c:230
+msgid "cap_set_proc failed"
+msgstr "cap_set_proc falhou"
+
+#: nscd/selinux.c:238
+msgid "Failed to unset keep-capabilities"
+msgstr "Falha ao remover definição de capacidades a serem mantidas"
+
+#: nscd/selinux.c:254
+msgid "Failed to determine if kernel supports SELinux"
+msgstr "Falha ao determinar se o kernel oferece suporte a SELinux"
+
+#: nscd/selinux.c:269
+msgid "Failed to start AVC thread"
+msgstr "Falha ao iniciar fluxo de AVC"
+
+#: nscd/selinux.c:291
+msgid "Failed to create AVC lock"
+msgstr "Falha ao criar trava de AVC"
+
+#: nscd/selinux.c:331
+msgid "Failed to start AVC"
+msgstr "Falha ao iniciar AVC"
+
+#: nscd/selinux.c:333
+msgid "Access Vector Cache (AVC) started"
+msgstr "Cache do Vetor de Acesso (AVC) iniciado"
+
+#: nscd/selinux.c:368
+msgid "Error querying policy for undefined object classes or permissions."
+msgstr "Erro ao consultar política por classes de objetos indefinidos ou permissões."
+
+#: nscd/selinux.c:375
+msgid "Error getting security class for nscd."
+msgstr "Erro ao obter classe de segurança para nscd."
+
+#: nscd/selinux.c:380
+#, c-format
+msgid "Error translating permission name \"%s\" to access vector bit."
+msgstr "Erro ao traduzir nome de permissão “%s” para bit do vetor de acesso."
+
+#: nscd/selinux.c:390
+msgid "Error getting context of socket peer"
+msgstr "Erro ao obter contexto do soquete da outra ponta"
+
+#: nscd/selinux.c:395
+msgid "Error getting context of nscd"
+msgstr "Erro ao obter um contexto do nscd"
+
+#: nscd/selinux.c:401
+msgid "Error getting sid from context"
+msgstr "Erro ao obter sid do contexto"
+
+#: nscd/selinux.c:439
+#, c-format
+msgid ""
+"\n"
+"SELinux AVC Statistics:\n"
+"\n"
+"%15u  entry lookups\n"
+"%15u  entry hits\n"
+"%15u  entry misses\n"
+"%15u  entry discards\n"
+"%15u  CAV lookups\n"
+"%15u  CAV hits\n"
+"%15u  CAV probes\n"
+"%15u  CAV misses\n"
+msgstr ""
+"\n"
+"Estatísticas do AVC do SELinux:\n"
+"\n"
+"%15u  consultas a registros\n"
+"%15u  acerto a registros\n"
+"%15u  erros a registros\n"
+"%15u  descarte de registros\n"
+"%15u  consultas a CAV\n"
+"%15u  acertos a CAV\n"
+"%15u  investigações de CAV\n"
+"%15u  erros de CAV\n"
+
+#: nscd/servicescache.c:387
+#, c-format
+msgid "Haven't found \"%s\" in services cache!"
+msgstr "Não foi encontrado “%s” no cache de serviços!"
+
+#: nscd/servicescache.c:389
+#, c-format
+msgid "Reloading \"%s\" in services cache!"
+msgstr "Recarregando “%s” no cache de serviços!"
+
+#: nss/getent.c:53
+msgid "database [key ...]"
+msgstr "base_de_dados [chave ...]"
+
+#: nss/getent.c:58
+msgid "CONFIG"
+msgstr "CONFIG"
+
+#: nss/getent.c:58
+msgid "Service configuration to be used"
+msgstr "Serviço de configuração a ser usado"
+
+#: nss/getent.c:59
+msgid "disable IDN encoding"
+msgstr "desabilita codificação de IDN"
+
+#: nss/getent.c:64
+msgid "Get entries from administrative database."
+msgstr "Obtém registros de banco de dados administrativo."
+
+#: nss/getent.c:148 nss/getent.c:441 nss/getent.c:486
+#, c-format
+msgid "Enumeration not supported on %s\n"
+msgstr "Sem suporte a enumeração no %s\n"
+
+#: nss/getent.c:861
+#, c-format
+msgid "Unknown database name"
+msgstr "Nome de banco de dados desconhecido"
+
+#: nss/getent.c:891
+msgid "Supported databases:\n"
+msgstr "Há suporte aos seguintes bancos de dados:\n"
+
+#: nss/getent.c:957
+#, c-format
+msgid "Unknown database: %s\n"
+msgstr "Base de dados desconhecida: %s\n"
+
+#: nss/makedb.c:119
+msgid "Convert key to lower case"
+msgstr "Converte chave para letras minúsculas"
+
+#: nss/makedb.c:122
+msgid "Do not print messages while building database"
+msgstr "Não mostra mensagens enquanto constrói base de dados"
+
+#: nss/makedb.c:124
+msgid "Print content of database file, one entry a line"
+msgstr "Mostra o conteúdo da base de dados do arquivo, um entrada por linha"
+
+#: nss/makedb.c:125
+msgid "CHAR"
+msgstr "CARACT"
+
+#: nss/makedb.c:126
+msgid "Generated line not part of iteration"
+msgstr "Linha gerada não é parte da iteração"
+
+#: nss/makedb.c:131
+msgid "Create simple database from textual input."
+msgstr "Cria um banco de dados simples de uma entrada textual."
+
+#: nss/makedb.c:134
+msgid ""
+"INPUT-FILE OUTPUT-FILE\n"
+"-o OUTPUT-FILE INPUT-FILE\n"
+"-u INPUT-FILE"
+msgstr ""
+"ARQUIVO-ENTRADA ARQUIVO-SAÍDA\n"
+"-o ARQUIVO-SAÍDA ARQUIVO-ENTRADA\n"
+"-u ARQUIVO-ENTRADA"
+
+#: nss/makedb.c:227
+#, c-format
+msgid "cannot open database file `%s'"
+msgstr "não foi possível abrir o arquivo de banco de dados “%s”"
+
+#: nss/makedb.c:272
+#, c-format
+msgid "no entries to be processed"
+msgstr "nenhum registro a ser processado"
+
+#: nss/makedb.c:282
+#, c-format
+msgid "cannot create temporary file name"
+msgstr "não foi possível criar um nome de arquivo temporário"
+
+#: nss/makedb.c:288
+#, c-format
+msgid "cannot create temporary file"
+msgstr "não foi possível criar um arquivo temporário"
+
+#: nss/makedb.c:304
+#, c-format
+msgid "cannot stat newly created file"
+msgstr "não foi possível obter estado do arquivo recém-criado"
+
+#: nss/makedb.c:315
+#, c-format
+msgid "cannot rename temporary file"
+msgstr "não foi possível renomear o arquivo temporário"
+
+#: nss/makedb.c:527 nss/makedb.c:550
+#, c-format
+msgid "cannot create search tree"
+msgstr "não foi possível criar árvore de pesquisa"
+
+#: nss/makedb.c:556
+msgid "duplicate key"
+msgstr "chave duplicada"
+
+#: nss/makedb.c:568
+#, c-format
+msgid "problems while reading `%s'"
+msgstr "problemas durante a leitura de “%s”"
+
+#: nss/makedb.c:795
+#, c-format
+msgid "failed to write new database file"
+msgstr "falha ao escrever novo arquivo de banco de dados"
+
+#: nss/makedb.c:808
+#, c-format
+msgid "cannot stat database file"
+msgstr "não foi possível obter estado do arquivo de banco de dados"
+
+#: nss/makedb.c:813
+#, c-format
+msgid "cannot map database file"
+msgstr "não foi possível mapear o arquivo de banco de dados"
+
+#: nss/makedb.c:816
+#, c-format
+msgid "file not a database file"
+msgstr "o arquivo não é um arquivo de banco de dados"
+
+#: nss/makedb.c:867
+#, c-format
+msgid "cannot set file creation context for `%s'"
+msgstr "não foi possível definir contexto de criação de arquivo para “%s”"
+
+#: posix/getconf.c:417
+#, c-format
+msgid "Usage: %s [-v specification] variable_name [pathname]\n"
+msgstr "Uso: %s [-v especificação] nome_da_variável [caminho]\n"
+
+#: posix/getconf.c:420
+#, c-format
+msgid "       %s -a [pathname]\n"
+msgstr "     %s -a [caminho]\n"
+
+#: posix/getconf.c:496
+#, c-format
+msgid ""
+"Usage: getconf [-v SPEC] VAR\n"
+"  or:  getconf [-v SPEC] PATH_VAR PATH\n"
+"\n"
+"Get the configuration value for variable VAR, or for variable PATH_VAR\n"
+"for path PATH.  If SPEC is given, give values for compilation\n"
+"environment SPEC.\n"
+"\n"
+msgstr ""
+"Uso: getconf [-v ESPEC] VAR\n"
+" ou: getconf [-v ESPEC] VAR_CAMINHO CAMINHO\n"
+"\n"
+"Obtém o valor de configuração da variável VAR ou para variável VAR_CAMINHO\n"
+"para caminho CAMINHO. Se ESPEC for dado, atribuir valores para ambiente de\n"
+"compilação ESPEC.\n"
+"\n"
+
+#: posix/getconf.c:572
+#, c-format
+msgid "unknown specification \"%s\""
+msgstr "especificação desconhecida “%s”"
+
+#: posix/getconf.c:624
+#, c-format
+msgid "Couldn't execute %s"
+msgstr "Não foi possível executar %s"
+
+#: posix/getconf.c:669 posix/getconf.c:685
+msgid "undefined"
+msgstr "indefinido"
+
+#: posix/getconf.c:707
+#, c-format
+msgid "Unrecognized variable `%s'"
+msgstr "Variável não reconhecida “%s”"
+
+#: posix/getopt.c:277
+#, c-format
+msgid "%s: option '%s%s' is ambiguous\n"
+msgstr "%s: a opção “%s%s” é ambígua\n"
+
+#: posix/getopt.c:283
+#, c-format
+msgid "%s: option '%s%s' is ambiguous; possibilities:"
+msgstr "%s: a opção “%s%s” é ambígua; possibilidades:"
+
+#: posix/getopt.c:318
+#, c-format
+msgid "%s: unrecognized option '%s%s'\n"
+msgstr "%s: opção não reconhecida “%s%s”\n"
+
+#: posix/getopt.c:344
+#, c-format
+msgid "%s: option '%s%s' doesn't allow an argument\n"
+msgstr "%s: a opção “%s%s” não permite um argumento\n"
+
+#: posix/getopt.c:359
+#, c-format
+msgid "%s: option '%s%s' requires an argument\n"
+msgstr "%s: a opção “%s%s” requer um argumento\n"
+
+#: posix/getopt.c:620
+#, c-format
+msgid "%s: invalid option -- '%c'\n"
+msgstr "%s: opção inválida -- “%c”\n"
+
+#: posix/getopt.c:635 posix/getopt.c:681
+#, c-format
+msgid "%s: option requires an argument -- '%c'\n"
+msgstr "%s: a opção requer um argumento -- “%c”\n"
+
+#: posix/regcomp.c:140
+msgid "No match"
+msgstr "Não confere"
+
+#: posix/regcomp.c:143
+msgid "Invalid regular expression"
+msgstr "Expressão regular inválida"
+
+#: posix/regcomp.c:146
+msgid "Invalid collation character"
+msgstr "Caractere de comparação inválido"
+
+#: posix/regcomp.c:149
+msgid "Invalid character class name"
+msgstr "Nome de classe de caractere inválido"
+
+#: posix/regcomp.c:152
+msgid "Trailing backslash"
+msgstr "Barra invertida final"
+
+#: posix/regcomp.c:155
+msgid "Invalid back reference"
+msgstr "Referência anterior inválida"
+
+#: posix/regcomp.c:158
+msgid "Unmatched [ or [^"
+msgstr "[ ou [^ descasados"
+
+#: posix/regcomp.c:161
+msgid "Unmatched ( or \\("
+msgstr "( ou \\( descasados"
+
+#: posix/regcomp.c:164
+msgid "Unmatched \\{"
+msgstr "\\{ descasado"
+
+#: posix/regcomp.c:167
+msgid "Invalid content of \\{\\}"
+msgstr "Conteúdo inválido de \\{\\}"
+
+#: posix/regcomp.c:170
+msgid "Invalid range end"
+msgstr "Intervalo final inválida"
+
+#: posix/regcomp.c:173
+msgid "Memory exhausted"
+msgstr "Memória esgotada"
+
+#: posix/regcomp.c:176
+msgid "Invalid preceding regular expression"
+msgstr "Expressão regular precedente inválida"
+
+#: posix/regcomp.c:179
+msgid "Premature end of regular expression"
+msgstr "Fim prematuro da expressão regular"
+
+#: posix/regcomp.c:182
+msgid "Regular expression too big"
+msgstr "Expressão regular muito longa"
+
+#: posix/regcomp.c:185
+msgid "Unmatched ) or \\)"
+msgstr ") ou \\) descasados"
+
+#: posix/regcomp.c:675
+msgid "No previous regular expression"
+msgstr "Não há expressão regular anterior"
+
+#: posix/wordexp.c:1803
+msgid "parameter null or not set"
+msgstr "parâmetro nulo ou não definido"
+
+#: resolv/herror.c:63
+msgid "Resolver Error 0 (no error)"
+msgstr "Erro de resolvedor 0 (não há erro)"
+
+#: resolv/herror.c:64
+msgid "Unknown host"
+msgstr "Host desconhecido"
+
+#: resolv/herror.c:65
+msgid "Host name lookup failure"
+msgstr "Falha na procura do nome de host"
+
+#: resolv/herror.c:66
+msgid "Unknown server error"
+msgstr "Erro desconhecido de servidor"
+
+#: resolv/herror.c:67
+msgid "No address associated with name"
+msgstr "Não há endereço associado com o nome"
+
+#: resolv/herror.c:102
+msgid "Resolver internal error"
+msgstr "Erro interno do resolvedor"
+
+#: resolv/herror.c:105
+msgid "Unknown resolver error"
+msgstr "Erro desconhecido do resolvedor"
+
+#: resolv/res_hconf.c:118
+#, c-format
+msgid "%s: line %d: cannot specify more than %d trim domains"
+msgstr "%s: linha %d: não é possível especificar mais de %d domínios"
+
+#: resolv/res_hconf.c:139
+#, c-format
+msgid "%s: line %d: list delimiter not followed by domain"
+msgstr "%s: linha %d: delimitador de lista não seguido pelo domínio"
+
+#: resolv/res_hconf.c:176
+#, c-format
+msgid "%s: line %d: expected `on' or `off', found `%s'\n"
+msgstr "%s: linha %d: esperava “on” ou “off”, encontrou “%s”\n"
+
+#: resolv/res_hconf.c:219
+#, c-format
+msgid "%s: line %d: bad command `%s'\n"
+msgstr "%s: linha %d: comando inválido “%s”\n"
+
+#: resolv/res_hconf.c:252
+#, c-format
+msgid "%s: line %d: ignoring trailing garbage `%s'\n"
+msgstr "%s: linha %d: ignorando lixo ao final “%s”\n"
+
+#: stdio-common/psiginfo-data.h:2
+msgid "Illegal opcode"
+msgstr "Código de operação ilegal"
+
+#: stdio-common/psiginfo-data.h:3
+msgid "Illegal operand"
+msgstr "Operando ilegal"
+
+#: stdio-common/psiginfo-data.h:4
+msgid "Illegal addressing mode"
+msgstr "Modo de endereçamento ilegal"
+
+#: stdio-common/psiginfo-data.h:5
+msgid "Illegal trap"
+msgstr "Armadilha ilegal"
+
+#: stdio-common/psiginfo-data.h:6
+msgid "Privileged opcode"
+msgstr "Código de operação privilegiado"
+
+#: stdio-common/psiginfo-data.h:7
+msgid "Privileged register"
+msgstr "Registrador privilegiado"
+
+#: stdio-common/psiginfo-data.h:8
+msgid "Coprocessor error"
+msgstr "Erro do coprocessador"
+
+#: stdio-common/psiginfo-data.h:9
+msgid "Internal stack error"
+msgstr "Erro interno da pilha"
+
+#: stdio-common/psiginfo-data.h:12
+msgid "Integer divide by zero"
+msgstr "Divisão de inteiro por zero"
+
+#: stdio-common/psiginfo-data.h:13
+msgid "Integer overflow"
+msgstr "Estouro de valor inteiro"
+
+#: stdio-common/psiginfo-data.h:14
+msgid "Floating-point divide by zero"
+msgstr "Divisão de ponto flutuante por zero"
+
+#: stdio-common/psiginfo-data.h:15
+msgid "Floating-point overflow"
+msgstr "Estouro de ponto flutuante"
+
+#: stdio-common/psiginfo-data.h:16
+msgid "Floating-point underflow"
+msgstr "Estouro negativo de ponto flutuante"
+
+#: stdio-common/psiginfo-data.h:17
+msgid "Floating-poing inexact result"
+msgstr "Resultado inexato de ponto flutuante"
+
+#: stdio-common/psiginfo-data.h:18
+msgid "Invalid floating-point operation"
+msgstr "Operação inválida de ponto flutuante"
+
+#: stdio-common/psiginfo-data.h:19
+msgid "Subscript out of range"
+msgstr "Subscrito fora da faixa"
+
+#: stdio-common/psiginfo-data.h:22
+msgid "Address not mapped to object"
+msgstr "Endereço não mapeado ao objeto"
+
+#: stdio-common/psiginfo-data.h:23
+msgid "Invalid permissions for mapped object"
+msgstr "Permissões inválidas para objeto mapeado"
+
+#: stdio-common/psiginfo-data.h:26
+msgid "Invalid address alignment"
+msgstr "Alinhamento inválido de endereço"
+
+#: stdio-common/psiginfo-data.h:27
+msgid "Nonexisting physical address"
+msgstr "Endereço físico inexistente"
+
+#: stdio-common/psiginfo-data.h:28
+msgid "Object-specific hardware error"
+msgstr "Erro de hardware específico do objeto"
+
+#: stdio-common/psiginfo-data.h:31
+msgid "Process breakpoint"
+msgstr "Ponto de interrupção de processo"
+
+#: stdio-common/psiginfo-data.h:32
+msgid "Process trace trap"
+msgstr "Interrupção de rastreamento de processo"
+
+#: stdio-common/psiginfo-data.h:35
+msgid "Child has exited"
+msgstr "Processo filho saiu"
+
+#: stdio-common/psiginfo-data.h:36
+msgid "Child has terminated abnormally and did not create a core file"
+msgstr "Processo filho foi terminado anormalmente e não criou um arquivo de núcleo"
+
+#: stdio-common/psiginfo-data.h:37
+msgid "Child has terminated abnormally and created a core file"
+msgstr "Processo filho foi terminado anormalmente e criou um arquivo de núcleo"
+
+#: stdio-common/psiginfo-data.h:38
+msgid "Traced child has trapped"
+msgstr "Processo filho rastreado atingiu uma armadilha"
+
+#: stdio-common/psiginfo-data.h:39
+msgid "Child has stopped"
+msgstr "Processo filho parou"
+
+#: stdio-common/psiginfo-data.h:40
+msgid "Stopped child has continued"
+msgstr "Processo filho parado continuou"
+
+#: stdio-common/psiginfo-data.h:43
+msgid "Data input available"
+msgstr "Entrada de dados disponível"
+
+#: stdio-common/psiginfo-data.h:44
+msgid "Output buffers available"
+msgstr "Buffers de saída disponíveis"
+
+#: stdio-common/psiginfo-data.h:45
+msgid "Input message available"
+msgstr "Mensagem de entrada disponível"
+
+#: stdio-common/psiginfo-data.h:46 timezone/zdump.c:381 timezone/zic.c:520
+msgid "I/O error"
+msgstr "Erro de E/S"
+
+#: stdio-common/psiginfo-data.h:47
+msgid "High priority input available"
+msgstr "Entrada de prioridade muito alta disponível"
+
+#: stdio-common/psiginfo-data.h:48
+msgid "Device disconnected"
+msgstr "Dispositivo desconectado"
+
+#: stdio-common/psiginfo.c:140
+msgid "Signal sent by kill()"
+msgstr "Sinal enviado por kill()"
+
+#: stdio-common/psiginfo.c:143
+msgid "Signal sent by sigqueue()"
+msgstr "Sinal enviado por sigqueue()"
+
+#: stdio-common/psiginfo.c:146
+msgid "Signal generated by the expiration of a timer"
+msgstr "Sinal gerado pela expiração de um temporizador"
+
+#: stdio-common/psiginfo.c:149
+msgid "Signal generated by the completion of an asynchronous I/O request"
+msgstr "Sinal gerado pelo completamento de uma requisição assíncrona de E/S"
+
+#: stdio-common/psiginfo.c:153
+msgid "Signal generated by the arrival of a message on an empty message queue"
+msgstr "Sinal gerado pela chegada de uma mensagem em uma pilhe de mensagens vazia"
+
+#: stdio-common/psiginfo.c:158
+msgid "Signal sent by tkill()"
+msgstr "Sinal enviado por tkill()"
+
+#: stdio-common/psiginfo.c:163
+msgid "Signal generated by the completion of an asynchronous name lookup request"
+msgstr "Sinal gerada pelo completamento de uma requisição assíncrona de procura de nome"
+
+#: stdio-common/psiginfo.c:169
+msgid "Signal generated by the completion of an I/O request"
+msgstr "Sinal gerado pelo completamento de uma requisição de E/S"
+
+#: stdio-common/psiginfo.c:175
+msgid "Signal sent by the kernel"
+msgstr "Sinal enviado pelo kernel"
+
+#: stdio-common/psiginfo.c:199
+#, c-format
+msgid "Unknown signal %d\n"
+msgstr "Sinal desconhecido %d\n"
+
+#: stdio-common/psignal.c:43
+#, c-format
+msgid "%s%sUnknown signal %d\n"
+msgstr "%s%sSinal desconhecido %d\n"
+
+#: stdio-common/psignal.c:44
+msgid "Unknown signal"
+msgstr "Sinal desconhecido"
+
+#: string/_strerror.c:45 sysdeps/mach/_strerror.c:86
+msgid "Unknown error "
+msgstr "Erro desconhecido "
+
+#: string/strerror.c:41
+msgid "Unknown error"
+msgstr "Erro desconhecido"
+
+#: string/strsignal.c:60
+#, c-format
+msgid "Real-time signal %d"
+msgstr "Sinal de tempo-real %d"
+
+#: string/strsignal.c:64
+#, c-format
+msgid "Unknown signal %d"
+msgstr "Sinal desconhecido %d"
+
+#: sunrpc/auth_unix.c:112 sunrpc/clnt_tcp.c:124 sunrpc/clnt_udp.c:139
+#: sunrpc/clnt_unix.c:125 sunrpc/svc_tcp.c:189 sunrpc/svc_tcp.c:233
+#: sunrpc/svc_udp.c:161 sunrpc/svc_unix.c:189 sunrpc/svc_unix.c:229
+#: sunrpc/xdr.c:628 sunrpc/xdr.c:788 sunrpc/xdr_array.c:102
+#: sunrpc/xdr_rec.c:153 sunrpc/xdr_ref.c:79
+msgid "out of memory\n"
+msgstr "memória insuficiente\n"
+
+#: sunrpc/auth_unix.c:349
+msgid "auth_unix.c: Fatal marshalling problem"
+msgstr "auth_unix.c: Problema fatal de marshalling"
+
+#: sunrpc/clnt_perr.c:96 sunrpc/clnt_perr.c:112
+#, c-format
+msgid "%s: %s; low version = %lu, high version = %lu"
+msgstr "%s: %s; versão baixa = %lu, versão alta = %lu"
+
+#: sunrpc/clnt_perr.c:103
+#, c-format
+msgid "%s: %s; why = %s\n"
+msgstr "%s: %s; por que = %s\n"
+
+#: sunrpc/clnt_perr.c:105
+#, c-format
+msgid "%s: %s; why = (unknown authentication error - %d)\n"
+msgstr "%s: %s; por que = (erro desconhecido de autenticação – %d)\n"
+
+#: sunrpc/clnt_perr.c:154
+msgid "RPC: Success"
+msgstr "RPC: Sucesso"
+
+#: sunrpc/clnt_perr.c:157
+msgid "RPC: Can't encode arguments"
+msgstr "RPC: não foi possível codificar argumentos"
+
+#: sunrpc/clnt_perr.c:161
+msgid "RPC: Can't decode result"
+msgstr "RPC: não foi possível decodificar resultado"
+
+#: sunrpc/clnt_perr.c:165
+msgid "RPC: Unable to send"
+msgstr "RPC: não foi possível enviar"
+
+#: sunrpc/clnt_perr.c:169
+msgid "RPC: Unable to receive"
+msgstr "RPC: não foi possível receber"
+
+#: sunrpc/clnt_perr.c:173
+msgid "RPC: Timed out"
+msgstr "RPC: Tempo esgotado"
+
+#: sunrpc/clnt_perr.c:177
+msgid "RPC: Incompatible versions of RPC"
+msgstr "RPC: Versões incompatíveis de RPC"
+
+#: sunrpc/clnt_perr.c:181
+msgid "RPC: Authentication error"
+msgstr "RPC: Erro de autenticação"
+
+#: sunrpc/clnt_perr.c:185
+msgid "RPC: Program unavailable"
+msgstr "RPC: Programa indisponível"
+
+#: sunrpc/clnt_perr.c:189
+msgid "RPC: Program/version mismatch"
+msgstr "RPC: Programa/versão incompatíveis"
+
+#: sunrpc/clnt_perr.c:193
+msgid "RPC: Procedure unavailable"
+msgstr "RPC: Procedimento indisponível"
+
+#: sunrpc/clnt_perr.c:197
+msgid "RPC: Server can't decode arguments"
+msgstr "RPC: O servidor não pode decodificar os argumentos"
+
+#: sunrpc/clnt_perr.c:201
+msgid "RPC: Remote system error"
+msgstr "RPC: Erro remoto de sistema"
+
+#: sunrpc/clnt_perr.c:205
+msgid "RPC: Unknown host"
+msgstr "RPC: Host desconhecido"
+
+#: sunrpc/clnt_perr.c:209
+msgid "RPC: Unknown protocol"
+msgstr "RPC: Protocolo desconhecido"
+
+#: sunrpc/clnt_perr.c:213
+msgid "RPC: Port mapper failure"
+msgstr "RPC: Falha no Port mapper"
+
+#: sunrpc/clnt_perr.c:217
+msgid "RPC: Program not registered"
+msgstr "RPC: Programa não registrado"
+
+#: sunrpc/clnt_perr.c:221
+msgid "RPC: Failed (unspecified error)"
+msgstr "RPC: Falhou (erro não especificado)"
+
+#: sunrpc/clnt_perr.c:262
+msgid "RPC: (unknown error code)"
+msgstr "RPC: (código de erro desconhecido)"
+
+#: sunrpc/clnt_perr.c:334
+msgid "Authentication OK"
+msgstr "Autenticação OK"
+
+#: sunrpc/clnt_perr.c:337
+msgid "Invalid client credential"
+msgstr "Credencial de cliente inválido"
+
+#: sunrpc/clnt_perr.c:341
+msgid "Server rejected credential"
+msgstr "Servidor rejeitou credencial"
+
+#: sunrpc/clnt_perr.c:345
+msgid "Invalid client verifier"
+msgstr "Verificador de cliente inválido"
+
+#: sunrpc/clnt_perr.c:349
+msgid "Server rejected verifier"
+msgstr "Servidor rejeitou verificador"
+
+#: sunrpc/clnt_perr.c:353
+msgid "Client credential too weak"
+msgstr "Credencial do cliente muito fraca"
+
+#: sunrpc/clnt_perr.c:357
+msgid "Invalid server verifier"
+msgstr "Verificador de servidor inválido"
+
+#: sunrpc/clnt_perr.c:361
+msgid "Failed (unspecified error)"
+msgstr "Falha (erro não especificado)"
+
+#: sunrpc/clnt_raw.c:116
+msgid "clnt_raw.c: fatal header serialization error"
+msgstr "clnt_raw.c: erro fatal no cabeçalho de serialização"
+
+#: sunrpc/pm_getmaps.c:78
+msgid "pmap_getmaps.c: rpc problem"
+msgstr "pmap_getmaps.c: problema de rpc"
+
+#: sunrpc/pmap_clnt.c:128
+msgid "Cannot register service"
+msgstr "Não foi possível registrar serviço"
+
+#: sunrpc/pmap_rmt.c:244
+msgid "Cannot create socket for broadcast rpc"
+msgstr "Não foi possível criar socket para rpc de broadcast"
+
+#: sunrpc/pmap_rmt.c:251
+msgid "Cannot set socket option SO_BROADCAST"
+msgstr "Não foi possível usar opção do socket SO_BROADCAST"
+
+#: sunrpc/pmap_rmt.c:303
+msgid "Cannot send broadcast packet"
+msgstr "Não foi possível enviar pacote de broadcast"
+
+#: sunrpc/pmap_rmt.c:328
+msgid "Broadcast poll problem"
+msgstr "Problema na pesquisa de broadcast"
+
+#: sunrpc/pmap_rmt.c:341
+msgid "Cannot receive reply to broadcast"
+msgstr "Não foi possível receber resposta para broadcast"
+
+#: sunrpc/rpc_main.c:281
+#, c-format
+msgid "%s: output would overwrite %s\n"
+msgstr "%s: saída poderá sobrescrever %s\n"
+
+#: sunrpc/rpc_main.c:288
+#, c-format
+msgid "%s: unable to open %s: %m\n"
+msgstr "%s: não foi possível abrir %s: %m\n"
+
+#: sunrpc/rpc_main.c:300
+#, c-format
+msgid "%s: while writing output %s: %m"
+msgstr "%s: ao escrever saída %s: %m"
+
+#: sunrpc/rpc_main.c:336 sunrpc/rpc_main.c:375
+#, c-format
+msgid "cannot find C preprocessor: %s\n"
+msgstr "não foi possível localizar pré-processador C: %s\n"
+
+#: sunrpc/rpc_main.c:411
+#, c-format
+msgid "%s: C preprocessor failed with signal %d\n"
+msgstr "%s: pré-processador C falhou com sinal %d\n"
+
+#: sunrpc/rpc_main.c:414
+#, c-format
+msgid "%s: C preprocessor failed with exit code %d\n"
+msgstr "%s: pré-processador C falhou com código de saída %d\n"
+
+#: sunrpc/rpc_main.c:454
+#, c-format
+msgid "illegal nettype: `%s'\n"
+msgstr "nettype ilegal: “%s”\n"
+
+#: sunrpc/rpc_main.c:1089
+#, c-format
+msgid "rpcgen: too many defines\n"
+msgstr "rpcgen: número excessivo de definições\n"
+
+#: sunrpc/rpc_main.c:1101
+#, c-format
+msgid "rpcgen: arglist coding error\n"
+msgstr "rpcgen: erro na codificação de parâmetros\n"
+
+#. TRANS: the file will not be removed; this is an
+#. TRANS: informative message.
+#: sunrpc/rpc_main.c:1134
+#, c-format
+msgid "file `%s' already exists and may be overwritten\n"
+msgstr "o arquivo “%s” já existe e pode ser sobrescrito\n"
+
+#: sunrpc/rpc_main.c:1179
+#, c-format
+msgid "Cannot specify more than one input file!\n"
+msgstr "Não é possível especificar mais de um arquivo de entrada!\n"
+
+#: sunrpc/rpc_main.c:1349
+#, c-format
+msgid "This implementation doesn't support newstyle or MT-safe code!\n"
+msgstr "Essa implementação não oferece suporte a código newstyle ou MT-safe!\n"
+
+#: sunrpc/rpc_main.c:1358
+#, c-format
+msgid "Cannot use netid flag with inetd flag!\n"
+msgstr "Não é possível usar tabela de indicadores com novo estilo!\n"
+
+#: sunrpc/rpc_main.c:1367
+#, c-format
+msgid "Cannot use netid flag without TIRPC!\n"
+msgstr "Não é possível usar indicador netid sem TIRPC!\n"
+
+#: sunrpc/rpc_main.c:1374
+#, c-format
+msgid "Cannot use table flags with newstyle!\n"
+msgstr "Não é possível usar indicadores de tabelas com novo estilo!\n"
+
+#: sunrpc/rpc_main.c:1393
+#, c-format
+msgid "\"infile\" is required for template generation flags.\n"
+msgstr "“arq-entrada” é necessário para geração de indicadores do modelo.\n"
+
+#: sunrpc/rpc_main.c:1398
+#, c-format
+msgid "Cannot have more than one file generation flag!\n"
+msgstr "Não é possível ter mais de um indicador de geração de arquivo!\n"
+
+#: sunrpc/rpc_main.c:1407
+#, c-format
+msgid "usage: %s infile\n"
+msgstr "uso: %s arq-entrada\n"
+
+#: sunrpc/rpc_main.c:1408
+#, c-format
+msgid "\t%s [-abkCLNTM][-Dname[=value]] [-i size] [-I [-K seconds]] [-Y path] infile\n"
+msgstr "\t%s [-abkCLNTM][-Dnome[=valor]] [-i tam] [-I [-K segs]] [-Y rota] arq-entrada\n"
+
+#: sunrpc/rpc_main.c:1410
+#, c-format
+msgid "\t%s [-c | -h | -l | -m | -t | -Sc | -Ss | -Sm] [-o outfile] [infile]\n"
+msgstr "\t%s [-c | -h | -l | -m | -t | -Sc | -Ss | -Sm] [-o arq-saída] [arq-entrada]\n"
+
+#: sunrpc/rpc_main.c:1412
+#, c-format
+msgid "\t%s [-s nettype]* [-o outfile] [infile]\n"
+msgstr "\t%s [-s tipo-rede]* [-o arq-saída] [arq-entrada]\n"
+
+#: sunrpc/rpc_main.c:1413
+#, c-format
+msgid "\t%s [-n netid]* [-o outfile] [infile]\n"
+msgstr "\t%s [-n id-rede]* [-o arq-saída] [arq-entrada]\n"
+
+#: sunrpc/rpc_main.c:1421
+#, c-format
+msgid "options:\n"
+msgstr "opções:\n"
+
+#: sunrpc/rpc_main.c:1422
+#, c-format
+msgid "-a\t\tgenerate all files, including samples\n"
+msgstr "-a\t\tgera todos arquivos, incluindo amostras\n"
+
+#: sunrpc/rpc_main.c:1423
+#, c-format
+msgid "-b\t\tbackward compatibility mode (generates code for SunOS 4.1)\n"
+msgstr "-b\t\tmodo de compatibilidade reversa (gera código para SunOS 4.1)\n"
+
+#: sunrpc/rpc_main.c:1424
+#, c-format
+msgid "-c\t\tgenerate XDR routines\n"
+msgstr "-c\t\tgera rotinas XDR\n"
+
+#: sunrpc/rpc_main.c:1425
+#, c-format
+msgid "-C\t\tANSI C mode\n"
+msgstr "-C\t\tmodo ANSI C\n"
+
+#: sunrpc/rpc_main.c:1426
+#, c-format
+msgid "-Dname[=value]\tdefine a symbol (same as #define)\n"
+msgstr "-Dnome[=valor]\tdefine um símbolo (mesmos que #define)\n"
+
+#: sunrpc/rpc_main.c:1427
+#, c-format
+msgid "-h\t\tgenerate header file\n"
+msgstr "-h\t\tgera arquivo de cabeçalho\n"
+
+#: sunrpc/rpc_main.c:1428
+#, c-format
+msgid "-i size\t\tsize at which to start generating inline code\n"
+msgstr "-i tamanho\ttamanho no qual se inicia geração de código em linha\n"
+
+#: sunrpc/rpc_main.c:1429
+#, c-format
+msgid "-I\t\tgenerate code for inetd support in server (for SunOS 4.1)\n"
+msgstr "-I\t\tgera código para suporte inetd em servidor (para SunOS 4.1)\n"
+
+#: sunrpc/rpc_main.c:1430
+#, c-format
+msgid "-K seconds\tserver exits after K seconds of inactivity\n"
+msgstr "-K segundos\tservidor sai após K segundos de inatividade\n"
+
+#: sunrpc/rpc_main.c:1431
+#, c-format
+msgid "-l\t\tgenerate client side stubs\n"
+msgstr "-l\t\tgera stubs do lado do cliente\n"
+
+#: sunrpc/rpc_main.c:1432
+#, c-format
+msgid "-L\t\tserver errors will be printed to syslog\n"
+msgstr "-L\t\terros de servidor serão imprimidos ao syslog\n"
+
+#: sunrpc/rpc_main.c:1433
+#, c-format
+msgid "-m\t\tgenerate server side stubs\n"
+msgstr "-l\t\tgera stubs do lado do servidor\n"
+
+#: sunrpc/rpc_main.c:1434
+#, c-format
+msgid "-M\t\tgenerate MT-safe code\n"
+msgstr "-M\t\tgera código MT-safe\n"
+
+#: sunrpc/rpc_main.c:1435
+#, c-format
+msgid "-n netid\tgenerate server code that supports named netid\n"
+msgstr "-n id-rede\tgera código de servidor que aceita o id-rede nomeado\n"
+
+#: sunrpc/rpc_main.c:1436
+#, c-format
+msgid "-N\t\tsupports multiple arguments and call-by-value\n"
+msgstr "-N\t\taceita múltiplos argumentos de chamadas por valor\n"
+
+#: sunrpc/rpc_main.c:1437
+#, c-format
+msgid "-o outfile\tname of the output file\n"
+msgstr "-o arq-saída\tnome do arquivo de saída\n"
+
+#: sunrpc/rpc_main.c:1438
+#, c-format
+msgid "-s nettype\tgenerate server code that supports named nettype\n"
+msgstr "-s tipo-rede\tgera código de servidor que aceita o tipo-rede nomeado\n"
+
+#: sunrpc/rpc_main.c:1439
+#, c-format
+msgid "-Sc\t\tgenerate sample client code that uses remote procedures\n"
+msgstr "-Sc\t\tgera amostra de código cliente que usa procedimentos remotos\n"
+
+#: sunrpc/rpc_main.c:1440
+#, c-format
+msgid "-Ss\t\tgenerate sample server code that defines remote procedures\n"
+msgstr "-Ss\t\tgera amostra de código servidor que define procedimentos remotos\n"
+
+#: sunrpc/rpc_main.c:1441
+#, c-format
+msgid "-Sm \t\tgenerate makefile template \n"
+msgstr "-Sm \t\tgera modelo de makefile \n"
+
+#: sunrpc/rpc_main.c:1442
+#, c-format
+msgid "-t\t\tgenerate RPC dispatch table\n"
+msgstr "-t\t\tgera tabela de expedição RPC\n"
+
+#: sunrpc/rpc_main.c:1443
+#, c-format
+msgid "-T\t\tgenerate code to support RPC dispatch tables\n"
+msgstr "-T\t\tgera código para lidar com tabelas de expedição RPC\n"
+
+#: sunrpc/rpc_main.c:1444
+#, c-format
+msgid "-Y path\t\tdirectory name to find C preprocessor (cpp)\n"
+msgstr "-Y rota\t\tnome do diretório para localizar pré-processador C (cpp)\n"
+
+#: sunrpc/rpc_main.c:1445
+#, c-format
+msgid "-5\t\tSysVr4 compatibility mode\n"
+msgstr "-5\t\tmodo de compatibilidade com SysVr4\n"
+
+#: sunrpc/rpc_main.c:1446
+#, c-format
+msgid "--help\t\tgive this help list\n"
+msgstr "--help\t\tfornece essa lista de ajuda\n"
+
+#: sunrpc/rpc_main.c:1447
+#, c-format
+msgid "--version\tprint program version\n"
+msgstr "--version\temite a versão do programa\n"
+
+#: sunrpc/rpc_main.c:1449
+#, c-format
+msgid ""
+"\n"
+"For bug reporting instructions, please see:\n"
+"%s.\n"
+msgstr ""
+"\n"
+"Para instruções sobre relatório de erro, veja:\n"
+"%s.\n"
+
+#: sunrpc/rpc_scan.c:112
+msgid "constant or identifier expected"
+msgstr "identificador ou constante esperado"
+
+#: sunrpc/rpc_scan.c:308
+msgid "illegal character in file: "
+msgstr "caracteres ilegais no arquivo: "
+
+#: sunrpc/rpc_scan.c:347 sunrpc/rpc_scan.c:373
+msgid "unterminated string constant"
+msgstr "constante string não terminada"
+
+#: sunrpc/rpc_scan.c:379
+msgid "empty char string"
+msgstr "cadeia de caractere vazia"
+
+#: sunrpc/rpc_scan.c:521 sunrpc/rpc_scan.c:531
+msgid "preprocessor error"
+msgstr "Erro de pré-processador"
+
+#: sunrpc/svc_run.c:72
+msgid "svc_run: - out of memory"
+msgstr "svc_run: – memória insuficiente"
+
+#: sunrpc/svc_run.c:92
+msgid "svc_run: - poll failed"
+msgstr "svc_run: – poll falhou"
+
+#: sunrpc/svc_simple.c:80
+#, c-format
+msgid "can't reassign procedure number %ld\n"
+msgstr "não é possível reatribuir número de procedimento %ld\n"
+
+#: sunrpc/svc_simple.c:90
+msgid "couldn't create an rpc server\n"
+msgstr "não foi possível criar um servidor rpc\n"
+
+#: sunrpc/svc_simple.c:98
+#, c-format
+msgid "couldn't register prog %ld vers %ld\n"
+msgstr "não foi possível registrar prog %ld vers %ld\n"
+
+#: sunrpc/svc_simple.c:106
+msgid "registerrpc: out of memory\n"
+msgstr "registerrpc: memória insuficiente\n"
+
+#: sunrpc/svc_simple.c:169
+#, c-format
+msgid "trouble replying to prog %d\n"
+msgstr "problemas ao responder ao prog %d\n"
+
+#: sunrpc/svc_simple.c:178
+#, c-format
+msgid "never registered prog %d\n"
+msgstr "prog %d nunca registrado\n"
+
+#: sunrpc/svc_tcp.c:165
+msgid "svc_tcp.c - tcp socket creation problem"
+msgstr "svc_tcp_.c – problema na criação do soquete AF_UNIX"
+
+#: sunrpc/svc_tcp.c:180
+msgid "svc_tcp.c - cannot getsockname or listen"
+msgstr "svc_tcp_.c – não foi possível receber getsocknome ou listen"
+
+#: sunrpc/svc_udp.c:136
+msgid "svcudp_create: socket creation problem"
+msgstr "svcudp_create: problema na criação socket"
+
+#: sunrpc/svc_udp.c:150
+msgid "svcudp_create - cannot getsockname"
+msgstr "svcudp_create – não foi possível getsockname"
+
+#: sunrpc/svc_udp.c:182
+msgid "svcudp_create: xp_pad is too small for IP_PKTINFO\n"
+msgstr "svcudp_create: xp_pad é pequeno demais para IP_PKTINFO\n"
+
+#: sunrpc/svc_udp.c:481
+msgid "enablecache: cache already enabled"
+msgstr "enablecache: cache já ativado"
+
+#: sunrpc/svc_udp.c:487
+msgid "enablecache: could not allocate cache"
+msgstr "enablecache: não foi possível alocar cache"
+
+#: sunrpc/svc_udp.c:496
+msgid "enablecache: could not allocate cache data"
+msgstr "enablecache: não foi possível alocar dados do cache"
+
+#: sunrpc/svc_udp.c:504
+msgid "enablecache: could not allocate cache fifo"
+msgstr "enablecache: não foi possível alocar fifo de cache"
+
+#: sunrpc/svc_udp.c:540
+msgid "cache_set: victim not found"
+msgstr "cache_set: vítima não localizada"
+
+#: sunrpc/svc_udp.c:551
+msgid "cache_set: victim alloc failed"
+msgstr "cache_set: alocação de vítima falhou"
+
+#: sunrpc/svc_udp.c:558
+msgid "cache_set: could not allocate new rpc_buffer"
+msgstr "cache_set: não foi possível alocar novo rpc_buffer"
+
+#: sunrpc/svc_unix.c:163
+msgid "svc_unix.c - AF_UNIX socket creation problem"
+msgstr "svc_tcp_.c – problema na criação do soquete AF_UNIX"
+
+#: sunrpc/svc_unix.c:179
+msgid "svc_unix.c - cannot getsockname or listen"
+msgstr "svc_tcp_.c – não foi possível receber getsocknome ou listen"
+
+#: sysdeps/generic/siglist.h:29
+msgid "Hangup"
+msgstr "Desconexão"
+
+#: sysdeps/generic/siglist.h:30
+msgid "Interrupt"
+msgstr "Interrupção"
+
+#: sysdeps/generic/siglist.h:31
+msgid "Quit"
+msgstr "Sair"
+
+#: sysdeps/generic/siglist.h:32
+msgid "Illegal instruction"
+msgstr "Instrução ilegal"
+
+#: sysdeps/generic/siglist.h:33
+msgid "Trace/breakpoint trap"
+msgstr "Trace/breakpoint trap"
+
+#: sysdeps/generic/siglist.h:34
+msgid "Aborted"
+msgstr "Abortado"
+
+#: sysdeps/generic/siglist.h:35
+msgid "Floating point exception"
+msgstr "Exceção de ponto flutuante"
+
+#: sysdeps/generic/siglist.h:36
+msgid "Killed"
+msgstr "Morto"
+
+#: sysdeps/generic/siglist.h:37
+msgid "Bus error"
+msgstr "Erro no barramento"
+
+#: sysdeps/generic/siglist.h:38
+msgid "Bad system call"
+msgstr "Chamada de sistema inválida"
+
+#: sysdeps/generic/siglist.h:39
+msgid "Segmentation fault"
+msgstr "Falha de segmentação"
+
+#. TRANS There is no process reading from the other end of a pipe.
+#. TRANS Every library function that returns this error code also generates a
+#. TRANS @code{SIGPIPE} signal; this signal terminates the program if not handled
+#. TRANS or blocked.  Thus, your program will never actually see @code{EPIPE}
+#. TRANS unless it has handled or blocked @code{SIGPIPE}.
+#: sysdeps/generic/siglist.h:40 sysdeps/gnu/errlist.c:360
+msgid "Broken pipe"
+msgstr "Pipe quebrado"
+
+#: sysdeps/generic/siglist.h:41
+msgid "Alarm clock"
+msgstr "Alarme de tempo"
+
+#: sysdeps/generic/siglist.h:42
+msgid "Terminated"
+msgstr "Terminado"
+
+#: sysdeps/generic/siglist.h:43
+msgid "Urgent I/O condition"
+msgstr "Condição urgente de E/S"
+
+#: sysdeps/generic/siglist.h:44
+msgid "Stopped (signal)"
+msgstr "Parado (sinal)"
+
+#: sysdeps/generic/siglist.h:45
+msgid "Stopped"
+msgstr "Parado"
+
+#: sysdeps/generic/siglist.h:46
+msgid "Continued"
+msgstr "Continua"
+
+#: sysdeps/generic/siglist.h:47
+msgid "Child exited"
+msgstr "Filho finalizado"
+
+#: sysdeps/generic/siglist.h:48
+msgid "Stopped (tty input)"
+msgstr "Parado (entrada tty)"
+
+#: sysdeps/generic/siglist.h:49
+msgid "Stopped (tty output)"
+msgstr "Parado (saída tty)"
+
+#: sysdeps/generic/siglist.h:50
+msgid "I/O possible"
+msgstr "Possível E/S"
+
+#: sysdeps/generic/siglist.h:51
+msgid "CPU time limit exceeded"
+msgstr "Tempo de CPU excedido"
+
+#: sysdeps/generic/siglist.h:52
+msgid "File size limit exceeded"
+msgstr "Excedido tamanho limite de arquivo"
+
+#: sysdeps/generic/siglist.h:53
+msgid "Virtual timer expired"
+msgstr "Temporizador virtual expirado"
+
+#: sysdeps/generic/siglist.h:54
+msgid "Profiling timer expired"
+msgstr "Tempo expirado para perfilamento"
+
+#: sysdeps/generic/siglist.h:55
+msgid "User defined signal 1"
+msgstr "Sinal 1 definido pelo usuário"
+
+#: sysdeps/generic/siglist.h:56
+msgid "User defined signal 2"
+msgstr "Sinal 2 definido pelo usuário"
+
+#: sysdeps/generic/siglist.h:57
+msgid "Window changed"
+msgstr "Janela alterada"
+
+#: sysdeps/generic/siglist.h:61
+msgid "EMT trap"
+msgstr "Trap EMT"
+
+#: sysdeps/generic/siglist.h:64
+msgid "Stack fault"
+msgstr "Falha de pilha"
+
+#: sysdeps/generic/siglist.h:67
+msgid "Power failure"
+msgstr "Falha de energia"
+
+#: sysdeps/generic/siglist.h:70
+msgid "Information request"
+msgstr "Requisição de informação"
+
+#: sysdeps/generic/siglist.h:73
+msgid "Resource lost"
+msgstr "Recurso perdido"
+
+#. TRANS Only the owner of the file (or other resource)
+#. TRANS or processes with special privileges can perform the operation.
+#: sysdeps/gnu/errlist.c:26
+msgid "Operation not permitted"
+msgstr "Operação não permitida"
+
+#. TRANS No process matches the specified process ID.
+#: sysdeps/gnu/errlist.c:46
+msgid "No such process"
+msgstr "Processo inexistente"
+
+#. TRANS An asynchronous signal occurred and prevented
+#. TRANS completion of the call.  When this happens, you should try the call
+#. TRANS again.
+#. TRANS
+#. TRANS You can choose to have functions resume after a signal that is handled,
+#. TRANS rather than failing with @code{EINTR}; see @ref{Interrupted
+#. TRANS Primitives}.
+#: sysdeps/gnu/errlist.c:61
+msgid "Interrupted system call"
+msgstr "Chamada de sistema interrompida"
+
+#. TRANS Usually used for physical read or write errors.
+#: sysdeps/gnu/errlist.c:70
+msgid "Input/output error"
+msgstr "Erro de entrada/saída"
+
+#. TRANS The system tried to use the device
+#. TRANS represented by a file you specified, and it couldn't find the device.
+#. TRANS This can mean that the device file was installed incorrectly, or that
+#. TRANS the physical device is missing or not correctly attached to the
+#. TRANS computer.
+#: sysdeps/gnu/errlist.c:83
+msgid "No such device or address"
+msgstr "Endereço ou dispositivo inexistente"
+
+#. TRANS Used when the arguments passed to a new program
+#. TRANS being executed with one of the @code{exec} functions (@pxref{Executing a
+#. TRANS File}) occupy too much memory space.  This condition never arises on
+#. TRANS @gnuhurdsystems{}.
+#: sysdeps/gnu/errlist.c:95
+msgid "Argument list too long"
+msgstr "Lista de argumentos muito longa"
+
+#. TRANS Invalid executable file format.  This condition is detected by the
+#. TRANS @code{exec} functions; see @ref{Executing a File}.
+#: sysdeps/gnu/errlist.c:105
+msgid "Exec format error"
+msgstr "Erro no formato exec"
+
+#. TRANS For example, I/O on a descriptor that has been
+#. TRANS closed or reading from a descriptor open only for writing (or vice
+#. TRANS versa).
+#: sysdeps/gnu/errlist.c:116
+msgid "Bad file descriptor"
+msgstr "Descritor de arquivo inválido"
+
+#. TRANS This error happens on operations that are
+#. TRANS supposed to manipulate child processes, when there aren't any processes
+#. TRANS to manipulate.
+#: sysdeps/gnu/errlist.c:127
+msgid "No child processes"
+msgstr "Não há processos filhos"
+
+#. TRANS Allocating a system resource would have resulted in a
+#. TRANS deadlock situation.  The system does not guarantee that it will notice
+#. TRANS all such situations.  This error means you got lucky and the system
+#. TRANS noticed; it might just hang.  @xref{File Locks}, for an example.
+#: sysdeps/gnu/errlist.c:139
+msgid "Resource deadlock avoided"
+msgstr "Evitado deadlock de recurso"
+
+#. TRANS The system cannot allocate more virtual memory
+#. TRANS because its capacity is full.
+#: sysdeps/gnu/errlist.c:149
+msgid "Cannot allocate memory"
+msgstr "Não foi possível alocar memória"
+
+#. TRANS An invalid pointer was detected.
+#. TRANS On @gnuhurdsystems{}, this error never happens; you get a signal instead.
+#: sysdeps/gnu/errlist.c:168
+msgid "Bad address"
+msgstr "Endereço inválido"
+
+#. TRANS A file that isn't a block special file was given in a situation that
+#. TRANS requires one.  For example, trying to mount an ordinary file as a file
+#. TRANS system in Unix gives this error.
+#: sysdeps/gnu/errlist.c:179
+msgid "Block device required"
+msgstr "Dispositivo de bloco requerido"
+
+#. TRANS A system resource that can't be shared is already in use.
+#. TRANS For example, if you try to delete a file that is the root of a currently
+#. TRANS mounted filesystem, you get this error.
+#: sysdeps/gnu/errlist.c:190
+msgid "Device or resource busy"
+msgstr "Dispositivo ou recurso está ocupado"
+
+#. TRANS An existing file was specified in a context where it only
+#. TRANS makes sense to specify a new file.
+#: sysdeps/gnu/errlist.c:200
+msgid "File exists"
+msgstr "Arquivo existe"
+
+#. TRANS An attempt to make an improper link across file systems was detected.
+#. TRANS This happens not only when you use @code{link} (@pxref{Hard Links}) but
+#. TRANS also when you rename a file with @code{rename} (@pxref{Renaming Files}).
+#: sysdeps/gnu/errlist.c:211
+msgid "Invalid cross-device link"
+msgstr "Link entre dispositivos inválido"
+
+#. TRANS The wrong type of device was given to a function that expects a
+#. TRANS particular sort of device.
+#: sysdeps/gnu/errlist.c:221
+msgid "No such device"
+msgstr "Dispositivo inexistente"
+
+#. TRANS A file that isn't a directory was specified when a directory is required.
+#: sysdeps/gnu/errlist.c:230
+msgid "Not a directory"
+msgstr "Não é um diretório"
+
+#. TRANS You cannot open a directory for writing,
+#. TRANS or create or remove hard links to it.
+#: sysdeps/gnu/errlist.c:240
+msgid "Is a directory"
+msgstr "É um diretório"
+
+#. TRANS This is used to indicate various kinds of problems
+#. TRANS with passing the wrong argument to a library function.
+#: sysdeps/gnu/errlist.c:250
+msgid "Invalid argument"
+msgstr "Argumento inválido"
+
+#. TRANS The current process has too many files open and can't open any more.
+#. TRANS Duplicate descriptors do count toward this limit.
+#. TRANS
+#. TRANS In BSD and GNU, the number of open files is controlled by a resource
+#. TRANS limit that can usually be increased.  If you get this error, you might
+#. TRANS want to increase the @code{RLIMIT_NOFILE} limit or make it unlimited;
+#. TRANS @pxref{Limits on Resources}.
+#: sysdeps/gnu/errlist.c:265
+msgid "Too many open files"
+msgstr "Muitos arquivos abertos"
+
+#. TRANS There are too many distinct file openings in the entire system.  Note
+#. TRANS that any number of linked channels count as just one file opening; see
+#. TRANS @ref{Linked Channels}.  This error never occurs on @gnuhurdsystems{}.
+#: sysdeps/gnu/errlist.c:276
+msgid "Too many open files in system"
+msgstr "Muitos arquivos abertos no sistema"
+
+#. TRANS Inappropriate I/O control operation, such as trying to set terminal
+#. TRANS modes on an ordinary file.
+#: sysdeps/gnu/errlist.c:286
+msgid "Inappropriate ioctl for device"
+msgstr "ioctl inapropriado para dispositivo"
+
+#. TRANS An attempt to execute a file that is currently open for writing, or
+#. TRANS write to a file that is currently being executed.  Often using a
+#. TRANS debugger to run a program is considered having it open for writing and
+#. TRANS will cause this error.  (The name stands for ``text file busy''.)  This
+#. TRANS is not an error on @gnuhurdsystems{}; the text is copied as necessary.
+#: sysdeps/gnu/errlist.c:299
+msgid "Text file busy"
+msgstr "Área de texto ocupada"
+
+#. TRANS The size of a file would be larger than allowed by the system.
+#: sysdeps/gnu/errlist.c:308
+msgid "File too large"
+msgstr "Arquivo muito grande"
+
+#. TRANS Write operation on a file failed because the
+#. TRANS disk is full.
+#: sysdeps/gnu/errlist.c:318
+msgid "No space left on device"
+msgstr "Não há espaço disponível no dispositivo"
+
+#. TRANS Invalid seek operation (such as on a pipe).
+#: sysdeps/gnu/errlist.c:327
+msgid "Illegal seek"
+msgstr "Procura ilegal"
+
+#. TRANS An attempt was made to modify something on a read-only file system.
+#: sysdeps/gnu/errlist.c:336
+msgid "Read-only file system"
+msgstr "Sistema de arquivos somente para leitura"
+
+#. TRANS The link count of a single file would become too large.
+#. TRANS @code{rename} can cause this error if the file being renamed already has
+#. TRANS as many links as it can take (@pxref{Renaming Files}).
+#: sysdeps/gnu/errlist.c:347
+msgid "Too many links"
+msgstr "Muitos links"
+
+#. TRANS Used by mathematical functions when an argument value does
+#. TRANS not fall into the domain over which the function is defined.
+#: sysdeps/gnu/errlist.c:370
+msgid "Numerical argument out of domain"
+msgstr "Argumento numérico fora de domínio"
+
+#. TRANS Used by mathematical functions when the result value is
+#. TRANS not representable because of overflow or underflow.
+#: sysdeps/gnu/errlist.c:380
+msgid "Numerical result out of range"
+msgstr "Resultado numérico fora de alcance"
+
+#. TRANS The call might work if you try again
+#. TRANS later.  The macro @code{EWOULDBLOCK} is another name for @code{EAGAIN};
+#. TRANS they are always the same in @theglibc{}.
+#. TRANS
+#. TRANS This error can happen in a few different situations:
+#. TRANS
+#. TRANS @itemize @bullet
+#. TRANS @item
+#. TRANS An operation that would block was attempted on an object that has
+#. TRANS non-blocking mode selected.  Trying the same operation again will block
+#. TRANS until some external condition makes it possible to read, write, or
+#. TRANS connect (whatever the operation).  You can use @code{select} to find out
+#. TRANS when the operation will be possible; @pxref{Waiting for I/O}.
+#. TRANS
+#. TRANS @strong{Portability Note:} In many older Unix systems, this condition
+#. TRANS was indicated by @code{EWOULDBLOCK}, which was a distinct error code
+#. TRANS different from @code{EAGAIN}.  To make your program portable, you should
+#. TRANS check for both codes and treat them the same.
+#. TRANS
+#. TRANS @item
+#. TRANS A temporary resource shortage made an operation impossible.  @code{fork}
+#. TRANS can return this error.  It indicates that the shortage is expected to
+#. TRANS pass, so your program can try the call again later and it may succeed.
+#. TRANS It is probably a good idea to delay for a few seconds before trying it
+#. TRANS again, to allow time for other processes to release scarce resources.
+#. TRANS Such shortages are usually fairly serious and affect the whole system,
+#. TRANS so usually an interactive program should report the error to the user
+#. TRANS and return to its command loop.
+#. TRANS @end itemize
+#: sysdeps/gnu/errlist.c:417
+msgid "Resource temporarily unavailable"
+msgstr "Recurso temporariamente indisponível"
+
+#. TRANS In @theglibc{}, this is another name for @code{EAGAIN} (above).
+#. TRANS The values are always the same, on every operating system.
+#. TRANS
+#. TRANS C libraries in many older Unix systems have @code{EWOULDBLOCK} as a
+#. TRANS separate error code.
+#: sysdeps/gnu/errlist.c:430
+msgid "Operation would block"
+msgstr "Operation causaria bloqueio"
+
+#. TRANS An operation that cannot complete immediately was initiated on an object
+#. TRANS that has non-blocking mode selected.  Some functions that must always
+#. TRANS block (such as @code{connect}; @pxref{Connecting}) never return
+#. TRANS @code{EAGAIN}.  Instead, they return @code{EINPROGRESS} to indicate that
+#. TRANS the operation has begun and will take some time.  Attempts to manipulate
+#. TRANS the object before the call completes return @code{EALREADY}.  You can
+#. TRANS use the @code{select} function to find out when the pending operation
+#. TRANS has completed; @pxref{Waiting for I/O}.
+#: sysdeps/gnu/errlist.c:446
+msgid "Operation now in progress"
+msgstr "Operação agora em progresso"
+
+#. TRANS An operation is already in progress on an object that has non-blocking
+#. TRANS mode selected.
+#: sysdeps/gnu/errlist.c:456
+msgid "Operation already in progress"
+msgstr "Operação já em progresso"
+
+#. TRANS A file that isn't a socket was specified when a socket is required.
+#: sysdeps/gnu/errlist.c:465
+msgid "Socket operation on non-socket"
+msgstr "Operação socket em um arquivo não-socket"
+
+#. TRANS The size of a message sent on a socket was larger than the supported
+#. TRANS maximum size.
+#: sysdeps/gnu/errlist.c:475
+msgid "Message too long"
+msgstr "Mensagem muito longa"
+
+#. TRANS The socket type does not support the requested communications protocol.
+#: sysdeps/gnu/errlist.c:484
+msgid "Protocol wrong type for socket"
+msgstr "Tipo errado de protocolo para socket"
+
+#. TRANS You specified a socket option that doesn't make sense for the
+#. TRANS particular protocol being used by the socket.  @xref{Socket Options}.
+#: sysdeps/gnu/errlist.c:494
+msgid "Protocol not available"
+msgstr "Protocolo não disponível"
+
+#. TRANS The socket domain does not support the requested communications protocol
+#. TRANS (perhaps because the requested protocol is completely invalid).
+#. TRANS @xref{Creating a Socket}.
+#: sysdeps/gnu/errlist.c:505
+msgid "Protocol not supported"
+msgstr "Protocolo sem suporte"
+
+#. TRANS The socket type is not supported.
+#: sysdeps/gnu/errlist.c:514
+msgid "Socket type not supported"
+msgstr "Tipo socket sem suporte"
+
+#. TRANS The operation you requested is not supported.  Some socket functions
+#. TRANS don't make sense for all types of sockets, and others may not be
+#. TRANS implemented for all communications protocols.  On @gnuhurdsystems{}, this
+#. TRANS error can happen for many calls when the object does not support the
+#. TRANS particular operation; it is a generic indication that the server knows
+#. TRANS nothing to do for that call.
+#: sysdeps/gnu/errlist.c:528
+msgid "Operation not supported"
+msgstr "Operação sem suporte"
+
+#. TRANS The socket communications protocol family you requested is not supported.
+#: sysdeps/gnu/errlist.c:537
+msgid "Protocol family not supported"
+msgstr "Família de protocolo sem suporte"
+
+#. TRANS The address family specified for a socket is not supported; it is
+#. TRANS inconsistent with the protocol being used on the socket.  @xref{Sockets}.
+#: sysdeps/gnu/errlist.c:547
+msgid "Address family not supported by protocol"
+msgstr "Família de endereços sem suporte pelo protocolo"
+
+#. TRANS The requested socket address is already in use.  @xref{Socket Addresses}.
+#: sysdeps/gnu/errlist.c:556
+msgid "Address already in use"
+msgstr "Endereço já em uso"
+
+#. TRANS The requested socket address is not available; for example, you tried
+#. TRANS to give a socket a name that doesn't match the local host name.
+#. TRANS @xref{Socket Addresses}.
+#: sysdeps/gnu/errlist.c:567
+msgid "Cannot assign requested address"
+msgstr "Não foi possível acessar o endereço requisitado"
 
-#: iconv/iconv_prog.c:193
-#, c-format
-msgid "error while closing input `%s'"
-msgstr "erro fechando entrada `%s'"
+#. TRANS A socket operation failed because the network was down.
+#: sysdeps/gnu/errlist.c:576
+msgid "Network is down"
+msgstr "A rede não responde"
 
-#: iconv/iconv_prog.c:239
-msgid "error while closing output file"
-msgstr "erro fechando arquivo de sada"
+#. TRANS A socket operation failed because the subnet containing the remote host
+#. TRANS was unreachable.
+#: sysdeps/gnu/errlist.c:586
+msgid "Network is unreachable"
+msgstr "A rede está fora de alcance"
 
-#: elf/sprof.c:710
-msgid "error while closing the profiling data file"
-msgstr "erro fechando arquivo de dados de perfil"
+#. TRANS A network connection was reset because the remote host crashed.
+#: sysdeps/gnu/errlist.c:595
+msgid "Network dropped connection on reset"
+msgstr "A rede desconectou-se ao reiniciar"
 
-#: locale/programs/ld-collate.c:1158
-msgid "error while inserting collation element into hash table"
-msgstr "erro enquanto inserindo elemento de comparao na tabela hash"
+#. TRANS A network connection was aborted locally.
+#: sysdeps/gnu/errlist.c:604
+msgid "Software caused connection abort"
+msgstr "Término de conexão causada por software"
 
-#: locale/programs/ld-collate.c:1170
-msgid "error while inserting to hash table"
-msgstr "erro ao inserir na tabela hash"
+#. TRANS A network connection was closed for reasons outside the control of the
+#. TRANS local host, such as by the remote machine rebooting or an unrecoverable
+#. TRANS protocol violation.
+#: sysdeps/gnu/errlist.c:615
+msgid "Connection reset by peer"
+msgstr "Conexão fechada pela outra ponta"
 
-#: iconv/iconv_prog.c:389 iconv/iconv_prog.c:420
-msgid "error while reading the input"
-msgstr "enquanto lendo entrada"
+#. TRANS The kernel's buffers for I/O operations are all in use.  In GNU, this
+#. TRANS error is always synonymous with @code{ENOMEM}; you may get one or the
+#. TRANS other from network operations.
+#: sysdeps/gnu/errlist.c:626
+msgid "No buffer space available"
+msgstr "Não há espaço de buffer disponível"
 
-#: locale/programs/locfile.c:595
-msgid "expect string argument for `copy'"
-msgstr "esperado argumento tipo string para `copy'"
+#. TRANS You tried to connect a socket that is already connected.
+#. TRANS @xref{Connecting}.
+#: sysdeps/gnu/errlist.c:636
+msgid "Transport endpoint is already connected"
+msgstr "Ponto final de transporte já está conectado"
 
-#: timezone/zic.c:868
-msgid "expected continuation line not found"
-msgstr "linha de continuao no foi localizada"
+#. TRANS The socket is not connected to anything.  You get this error when you
+#. TRANS try to transmit data over a socket, without first specifying a
+#. TRANS destination for the data.  For a connectionless socket (for datagram
+#. TRANS protocols, such as UDP), you get @code{EDESTADDRREQ} instead.
+#: sysdeps/gnu/errlist.c:648
+msgid "Transport endpoint is not connected"
+msgstr "Ponto final de transporte não está conectado"
 
-#: elf/sprof.c:408
-#, c-format
-msgid "failed to load shared object `%s'"
-msgstr "falha no carregamento do objeto compartilhado `%s'"
+#. TRANS No default destination address was set for the socket.  You get this
+#. TRANS error when you try to transmit data over a connectionless socket,
+#. TRANS without first specifying a destination for the data with @code{connect}.
+#: sysdeps/gnu/errlist.c:659
+msgid "Destination address required"
+msgstr "Endereço de destino requerido"
 
-#: elf/sprof.c:604
-msgid "failed to load symbol data"
-msgstr "falha para carregar dados de smbolos"
+#. TRANS The socket has already been shut down.
+#: sysdeps/gnu/errlist.c:668
+msgid "Cannot send after transport endpoint shutdown"
+msgstr "Não é possível enviar após desligamento do ponto final de transporte"
 
-#: elf/sprof.c:702
-msgid "failed to mmap the profiling data file"
-msgstr "falha para mapear (mmap) o arquivo de dados do perfil"
+#: sysdeps/gnu/errlist.c:676
+msgid "Too many references: cannot splice"
+msgstr "Muitas referências: não é possível unir"
 
-#: iconv/iconv_prog.c:147
-msgid "failed to start conversion processing"
-msgstr "falha para iniciar o processo de converso"
+#. TRANS A socket operation with a specified timeout received no response during
+#. TRANS the timeout period.
+#: sysdeps/gnu/errlist.c:686
+msgid "Connection timed out"
+msgstr "Tempo esgotado para conexão"
 
-#: locale/programs/locfile.c:1154
-#, c-format
-msgid "failure while writing data for category `%s'"
-msgstr "falha ao escrever dados para categoria `%s'"
+#. TRANS A remote host refused to allow the network connection (typically because
+#. TRANS it is not running the requested service).
+#: sysdeps/gnu/errlist.c:696
+msgid "Connection refused"
+msgstr "Conexão recusada"
 
-#: nis/nis_call.c:155
-msgid "fcntl: F_SETFD"
-msgstr "fcntl: F_SETFD"
+#. TRANS Too many levels of symbolic links were encountered in looking up a file name.
+#. TRANS This often indicates a cycle of symbolic links.
+#: sysdeps/gnu/errlist.c:706
+msgid "Too many levels of symbolic links"
+msgstr "Muitos níveis de links simbólicos"
 
-#: locale/programs/ld-monetary.c:163 locale/programs/ld-numeric.c:98
-#, c-format
-msgid "field `%s' in category `%s' not defined"
-msgstr "campo `%s' na categoria `%s' no definido"
+#. TRANS Filename too long (longer than @code{PATH_MAX}; @pxref{Limits for
+#. TRANS Files}) or host name too long (in @code{gethostname} or
+#. TRANS @code{sethostname}; @pxref{Host Identification}).
+#: sysdeps/gnu/errlist.c:717
+msgid "File name too long"
+msgstr "Nome de arquivo muito longo"
 
-#: locale/programs/ld-messages.c:86 locale/programs/ld-messages.c:110
-#, c-format
-msgid "field `%s' in category `%s' undefined"
-msgstr "campo `%s' na categoria `%s' no definido"
+#. TRANS The remote host for a requested network connection is down.
+#: sysdeps/gnu/errlist.c:726
+msgid "Host is down"
+msgstr "Host está desligado"
 
-#: sunrpc/rpc_main.c:1148
-#, c-format
-msgid "file '%s' already exists and may be overwritten\n"
-msgstr "arquivo `%s' j existe e pode ser sobrescrito\n"
+#. TRANS The remote host for a requested network connection is not reachable.
+#: sysdeps/gnu/errlist.c:735
+msgid "No route to host"
+msgstr "Não há rota para o host"
 
-#: locale/programs/locfile.c:677
-msgid "from-value of `collating-element' must be a string"
-msgstr "valor `from' do elemento de comparao deve ser uma string"
+#. TRANS Directory not empty, where an empty directory was expected.  Typically,
+#. TRANS this error occurs when you are trying to delete a directory.
+#: sysdeps/gnu/errlist.c:745
+msgid "Directory not empty"
+msgstr "Diretório não vazio"
 
-#: inet/rcmd.c:316
-msgid "fstat failed"
-msgstr "falha em fstat"
+#. TRANS This means that the per-user limit on new process would be exceeded by
+#. TRANS an attempted @code{fork}.  @xref{Limits on Resources}, for details on
+#. TRANS the @code{RLIMIT_NPROC} limit.
+#: sysdeps/gnu/errlist.c:756
+msgid "Too many processes"
+msgstr "Muitos processos"
 
-#: locale/programs/linereader.c:333
-msgid "garbage at end of character code specification"
-msgstr "lixo no final da especificao do cdigo de caracter"
+#. TRANS The file quota system is confused because there are too many users.
+#. TRANS @c This can probably happen in a GNU system when using NFS.
+#: sysdeps/gnu/errlist.c:766
+msgid "Too many users"
+msgstr "Muitos usuários"
 
-#: locale/programs/linereader.c:219
-msgid "garbage at end of number"
-msgstr "lixo no final do nmero"
+#. TRANS The user's disk quota was exceeded.
+#: sysdeps/gnu/errlist.c:775
+msgid "Disk quota exceeded"
+msgstr "Cota da disco excedida"
+
+#. TRANS This indicates an internal confusion in the
+#. TRANS file system which is due to file system rearrangements on the server host
+#. TRANS for NFS file systems or corruption in other file systems.
+#. TRANS Repairing this condition usually requires unmounting, possibly repairing
+#. TRANS and remounting the file system.
+#: sysdeps/gnu/errlist.c:788
+msgid "Stale file handle"
+msgstr "Manipulador de arquivo corrompido"
 
-#: locale/programs/ld-time.c:195
-#, c-format
-msgid "garbage at end of offset value in string %d in `era' field in category `%s'"
-msgstr "lixo no final do valor do deslocamento na string %d no campo `era', categoria `%s'"
+#. TRANS An attempt was made to NFS-mount a remote file system with a file name that
+#. TRANS already specifies an NFS-mounted file.
+#. TRANS (This is an error on some operating systems, but we expect it to work
+#. TRANS properly on @gnuhurdsystems{}, making this error code impossible.)
+#: sysdeps/gnu/errlist.c:800
+msgid "Object is remote"
+msgstr "Objeto é remoto"
 
-#: locale/programs/ld-time.c:252
-#, c-format
-msgid "garbage at end of starting date in string %d in `era' field in category `%s'"
-msgstr "lixo no final da data de incio na string %d no campo `era', categoria `%s'"
+#: sysdeps/gnu/errlist.c:808
+msgid "RPC struct is bad"
+msgstr "Estrutura RPC inválida"
 
-#: locale/programs/ld-time.c:328
-#, c-format
-msgid "garbage at end of stopping date in string %d in `era' field in category `%s'"
-msgstr "lixo no final da data de parada na string %d no campo `era', categoria `%s'"
+#: sysdeps/gnu/errlist.c:816
+msgid "RPC version wrong"
+msgstr "Versão RPC incorreta"
 
-#: elf/sprof.c:81
-msgid "generate call graph"
-msgstr "gera grfico de chamadas"
+#: sysdeps/gnu/errlist.c:824
+msgid "RPC program not available"
+msgstr "Programa RPC não disponível"
 
-#: elf/sprof.c:80
-msgid "generate flat profile with counts and ticks"
-msgstr "gera perfil com contadores e `ticks'"
+#: sysdeps/gnu/errlist.c:832
+msgid "RPC program version wrong"
+msgstr "Versão incorreta de programa RPC"
 
-#: sunrpc/get_myaddr.c:77
-msgid "get_myaddress: ioctl (get interface configuration)"
-msgstr "get_myaddress: ioctl (obtm configurao de interface)"
+#: sysdeps/gnu/errlist.c:840
+msgid "RPC bad procedure for program"
+msgstr "Procedimento RPC ruim para programa"
 
-#: nss/getent.c:53
-msgid "getent - get entries from administrative database."
-msgstr "getent - pega entrada da base de dados administrativa."
+#. TRANS This is used by the file locking facilities; see
+#. TRANS @ref{File Locks}.  This error is never generated by @gnuhurdsystems{}, but
+#. TRANS it can result from an operation to an NFS server running another
+#. TRANS operating system.
+#: sysdeps/gnu/errlist.c:852
+msgid "No locks available"
+msgstr "Não há travas disponíveis"
 
-#: nscd/connections.c:200
-#, c-format
-msgid "handle_request: request received (Version = %d)"
-msgstr "handle_request: requisio recebida (Verso = %d)"
+#. TRANS The file was the wrong type for the
+#. TRANS operation, or a data file had the wrong format.
+#. TRANS
+#. TRANS On some systems @code{chmod} returns this error if you try to set the
+#. TRANS sticky bit on a non-directory file; @pxref{Setting Permissions}.
+#: sysdeps/gnu/errlist.c:865
+msgid "Inappropriate file type or format"
+msgstr "Tipo ou formato de arquivo inapropriado"
 
-#: timezone/zic.c:613
-msgid "hard link failed, symbolic link used"
-msgstr "vnculo (link( falhou, vnculo simblico usado"
+#: sysdeps/gnu/errlist.c:873
+msgid "Authentication error"
+msgstr "Erro de autenticação"
 
-#: inet/rcmd.c:322
-msgid "hard linked somewhere"
-msgstr "vinculo (hard linked)  em algm lugar"
+#: sysdeps/gnu/errlist.c:881
+msgid "Need authenticator"
+msgstr "É necessário um autenticador"
+
+#. TRANS This indicates that the function called is
+#. TRANS not implemented at all, either in the C library itself or in the
+#. TRANS operating system.  When you get this error, you can be sure that this
+#. TRANS particular function will always fail with @code{ENOSYS} unless you
+#. TRANS install a new version of the C library or the operating system.
+#: sysdeps/gnu/errlist.c:894
+msgid "Function not implemented"
+msgstr "Função não implementada"
+
+#. TRANS A function returns this error when certain parameter
+#. TRANS values are valid, but the functionality they request is not available.
+#. TRANS This can mean that the function does not implement a particular command
+#. TRANS or option value or flag bit at all.  For functions that operate on some
+#. TRANS object given in a parameter, such as a file descriptor or a port, it
+#. TRANS might instead mean that only @emph{that specific object} (file
+#. TRANS descriptor, port, etc.) is unable to support the other parameters given;
+#. TRANS different file descriptors might support different ranges of parameter
+#. TRANS values.
+#. TRANS
+#. TRANS If the entire function is not available at all in the implementation,
+#. TRANS it returns @code{ENOSYS} instead.
+#: sysdeps/gnu/errlist.c:914
+msgid "Not supported"
+msgstr "Não há suporte"
 
-#: timezone/zic.c:1162
-msgid "illegal CORRECTION field on Leap line"
-msgstr "Campo CORRECTION ilegal em linha Leap (ajuste)"
+#. TRANS While decoding a multibyte character the function came along an invalid
+#. TRANS or an incomplete sequence of bytes or the given wide character is invalid.
+#: sysdeps/gnu/errlist.c:924
+msgid "Invalid or incomplete multibyte or wide character"
+msgstr "Multibyte ou caractere largo inválido"
 
-#: timezone/zic.c:1166
-msgid "illegal Rolling/Stationary field on Leap line"
-msgstr "campo Rolling/Stationary ilegal em linha Leap (ajuste)"
+#. TRANS On @gnuhurdsystems{}, servers supporting the @code{term} protocol return
+#. TRANS this error for certain operations when the caller is not in the
+#. TRANS foreground process group of the terminal.  Users do not usually see this
+#. TRANS error because functions such as @code{read} and @code{write} translate
+#. TRANS it into a @code{SIGTTIN} or @code{SIGTTOU} signal.  @xref{Job Control},
+#. TRANS for information on process groups and these signals.
+#: sysdeps/gnu/errlist.c:938
+msgid "Inappropriate operation for background process"
+msgstr "Operação inapropriada para processo em background"
 
-#: locale/programs/ld-collate.c:1782
-msgid "illegal character constant in string"
-msgstr "constante de caracteres ilegal na string"
+#. TRANS On @gnuhurdsystems{}, opening a file returns this error when the file is
+#. TRANS translated by a program and the translator program dies while starting
+#. TRANS up, before it has connected to the file.
+#: sysdeps/gnu/errlist.c:949
+msgid "Translator died"
+msgstr "Tradutor morto"
 
-#: sunrpc/rpc_scan.c:311
-msgid "illegal character in file: "
-msgstr "caracteres ilegais no arquivo: "
+#. TRANS The experienced user will know what is wrong.
+#. TRANS @c This error code is a joke.  Its perror text is part of the joke.
+#. TRANS @c Don't change it.
+#: sysdeps/gnu/errlist.c:960
+msgid "?"
+msgstr "?"
 
-#: locale/programs/ld-collate.c:1125
-msgid "illegal collation element"
-msgstr "elemento de comparao ilegal"
+#. TRANS You did @strong{what}?
+#: sysdeps/gnu/errlist.c:969
+msgid "You really blew it this time"
+msgstr "Você realmente estragou desta vez"
 
-#: locale/programs/charmap.c:281
-msgid "illegal definition"
-msgstr "definio ilegal"
+#. TRANS Go home and have a glass of warm, dairy-fresh milk.
+#: sysdeps/gnu/errlist.c:978
+msgid "Computer bought the farm"
+msgstr "O computador comprou a fazenda"
 
-#: locale/programs/charmap.c:434
-msgid "illegal encoding given"
-msgstr "dada codificao ilegal"
+#. TRANS This error code has no purpose.
+#: sysdeps/gnu/errlist.c:987
+msgid "Gratuitous error"
+msgstr "Erro gratuito"
 
-#: locale/programs/linereader.c:551
-msgid "illegal escape sequence at end of string"
-msgstr "sequncia de escape ilegal no final da string"
+#: sysdeps/gnu/errlist.c:995
+msgid "Bad message"
+msgstr "Mensagem inválida"
 
-#: iconv/iconv_prog.c:342
-#, c-format
-msgid "illegal input sequence at position %ld"
-msgstr "sequncia de entrada ilegal na posio %ld"
+#: sysdeps/gnu/errlist.c:1003
+msgid "Identifier removed"
+msgstr "Identificador removido"
 
-#: locale/programs/charset.c:78
-msgid "illegal names for character range"
-msgstr "nomes ilegais para faixa de caracteres"
+#: sysdeps/gnu/errlist.c:1011
+msgid "Multihop attempted"
+msgstr "Tentativa de Multihop"
 
-#: sunrpc/rpc_main.c:462
-#, c-format
-msgid "illegal nettype :'%s'\n"
-msgstr "nettype ilegal: `%s'\n"
+#: sysdeps/gnu/errlist.c:1019
+msgid "No data available"
+msgstr "Não há dados disponíveis"
 
-#: locale/programs/ld-time.c:187
-#, c-format
-msgid "illegal number for offset in string %d in `era' field in category `%s'"
-msgstr "nmero ilegal para offset na string %d no campo `era', categoria `%s'"
+#: sysdeps/gnu/errlist.c:1027
+msgid "Link has been severed"
+msgstr "Link foi cortado"
 
-#: catgets/gencat.c:361 catgets/gencat.c:438
-msgid "illegal set number"
-msgstr "nmero de conjunto ilegal"
+#: sysdeps/gnu/errlist.c:1035
+msgid "No message of desired type"
+msgstr "Não há mensagens do tipo desejado"
 
-#: locale/programs/ld-time.c:243
-#, c-format
-msgid "illegal starting date in string %d in `era' field in category `%s'"
-msgstr "data de incio ilegal na string %d no campo `era', categoria `%s'"
+#: sysdeps/gnu/errlist.c:1043
+msgid "Out of streams resources"
+msgstr "Sem recursos de streams"
 
-#: locale/programs/ld-time.c:319
-#, c-format
-msgid "illegal stopping date in string %d in `era' field in category `%s'"
-msgstr "data de parada ilegal na string %d no campo `era', categoria `%s'"
+#: sysdeps/gnu/errlist.c:1051
+msgid "Device not a stream"
+msgstr "Dispositivo não é um stream"
 
-#: locale/programs/ld-ctype.c:831
-#, c-format
-msgid "implementation limit: no more than %d character classes allowed"
-msgstr "limite de implementaco: no so permitidas mais que %d classes de caracter"
+#: sysdeps/gnu/errlist.c:1059
+msgid "Value too large for defined data type"
+msgstr "Valor muito grande para o tipo de dados definido"
 
-#: locale/programs/ld-ctype.c:863
-#, c-format
-msgid "implementation limit: no more than %d character maps allowed"
-msgstr "limite de implementaco: no so permitidos mais que %d mapas de caracter"
+#: sysdeps/gnu/errlist.c:1067
+msgid "Protocol error"
+msgstr "Erro de protocolo"
 
-#: iconv/iconv_prog.c:346
-msgid "incomplete character or shift sequence at end of buffer"
-msgstr "caractere incompleto ou mudana de seqencia no final do buffer"
+#: sysdeps/gnu/errlist.c:1075
+msgid "Timer expired"
+msgstr "Tempo expirado"
 
-#: db2/makedb.c:148
-msgid "incorrectly formatted file"
-msgstr "arquivo formatado incorretamente"
+#. TRANS An asynchronous operation was canceled before it
+#. TRANS completed.  @xref{Asynchronous I/O}.  When you call @code{aio_cancel},
+#. TRANS the normal result is for the operations affected to complete with this
+#. TRANS error; @pxref{Cancel AIO Operations}.
+#: sysdeps/gnu/errlist.c:1087
+msgid "Operation canceled"
+msgstr "Operação cancelada"
 
-#: timezone/zic.c:825
-msgid "input line of unknown type"
-msgstr "linha de entrada de tipo desconhecido"
+#: sysdeps/gnu/errlist.c:1095
+msgid "Interrupted system call should be restarted"
+msgstr "Chamada de sistema interrompida deve ser reiniciada"
 
-#: iconv/iconv_prog.c:350
-msgid "internal error (illegal descriptor)"
-msgstr "erro interno (descritor ilegal)"
+#: sysdeps/gnu/errlist.c:1103
+msgid "Channel number out of range"
+msgstr "Número do canal fora do intervalo"
 
-#: timezone/zic.c:1788
-msgid "internal error - addtype called with bad isdst"
-msgstr "erro interno - addtype chamado com isdst incorreto"
+#: sysdeps/gnu/errlist.c:1111
+msgid "Level 2 not synchronized"
+msgstr "Nível 2 não sincronizado"
 
-#: timezone/zic.c:1796
-msgid "internal error - addtype called with bad ttisgmt"
-msgstr "erro interno - addtype chamado com ttisgmt incorreto"
+#: sysdeps/gnu/errlist.c:1119
+msgid "Level 3 halted"
+msgstr "Nível 3 parado"
 
-#: timezone/zic.c:1792
-msgid "internal error - addtype called with bad ttisstd"
-msgstr "erro interno - addtype chamado com ttisstd incorreto"
+#: sysdeps/gnu/errlist.c:1127
+msgid "Level 3 reset"
+msgstr "Nível 3 reiniciado"
 
-#: locale/programs/ld-ctype.c:307
-#, c-format
-msgid "internal error in %s, line %u"
-msgstr "erro interno em %s, linha %u"
+#: sysdeps/gnu/errlist.c:1135
+msgid "Link number out of range"
+msgstr "Número de link fora da faixa"
 
-#: timezone/zic.c:1034
-msgid "invalid UTC offset"
-msgstr "deslocamento UTC invlido"
+#: sysdeps/gnu/errlist.c:1143
+msgid "Protocol driver not attached"
+msgstr "Driver de protocolo não anexado"
 
-#: timezone/zic.c:1037
-msgid "invalid abbreviation format"
-msgstr "formato de abreviao invlido"
+#: sysdeps/gnu/errlist.c:1151
+msgid "No CSI structure available"
+msgstr "Não há estrutura CSI disponível"
 
-#: timezone/zic.c:1127 timezone/zic.c:1339 timezone/zic.c:1353
-msgid "invalid day of month"
-msgstr "dia do ms invlido"
+#: sysdeps/gnu/errlist.c:1159
+msgid "Level 2 halted"
+msgstr "Parada de sistema nível 2"
 
-#: timezone/zic.c:1291
-msgid "invalid ending year"
-msgstr "ano final invlido"
+#: sysdeps/gnu/errlist.c:1167
+msgid "Invalid exchange"
+msgstr "Troca inválida"
 
-#: timezone/zic.c:1099
-msgid "invalid leaping year"
-msgstr "ano bissexto invlido"
+#: sysdeps/gnu/errlist.c:1175
+msgid "Invalid request descriptor"
+msgstr "Descritor de requisição inválido"
 
-#: elf/dl-open.c:159
-msgid "invalid mode for dlopen()"
-msgstr "modo invlido para dlopen()"
+#: sysdeps/gnu/errlist.c:1183
+msgid "Exchange full"
+msgstr "Troca completa"
 
-#: timezone/zic.c:1114 timezone/zic.c:1217
-msgid "invalid month name"
-msgstr "nome do ms invlido"
+#: sysdeps/gnu/errlist.c:1191
+msgid "No anode"
+msgstr "Sem anode"
 
-#: timezone/zic.c:933
-msgid "invalid saved time"
-msgstr "tempo gravado invlido"
+#: sysdeps/gnu/errlist.c:1199
+msgid "Invalid request code"
+msgstr "Código de requisição inválido"
 
-#: timezone/zic.c:1266
-msgid "invalid starting year"
-msgstr "ano inicial invlido"
+#: sysdeps/gnu/errlist.c:1207
+msgid "Invalid slot"
+msgstr "Slot inválido"
 
-#: timezone/zic.c:1143 timezone/zic.c:1246
-msgid "invalid time of day"
-msgstr "hora do dia invlida"
+#: sysdeps/gnu/errlist.c:1215
+msgid "File locking deadlock error"
+msgstr "Erro de bloqueio em arquivo (deadlock)"
 
-#: timezone/zic.c:1344
-msgid "invalid weekday name"
-msgstr "nome de dia de semana invlido"
+#: sysdeps/gnu/errlist.c:1223
+msgid "Bad font file format"
+msgstr "Formato do arquivo fonte inválido"
 
-#: nscd/connections.c:375
-#, c-format
-msgid "key length in request too long: %Zd"
-msgstr "tamanho de chave na requisio muito longa: %Zd"
+#: sysdeps/gnu/errlist.c:1231
+msgid "Machine is not on the network"
+msgstr "A maquina não está na rede"
 
-#: locale/programs/ld-collate.c:1422
-msgid "line after ellipsis must contain character definition"
-msgstr "linha aps elipse deve conter definio de caracter"
+#: sysdeps/gnu/errlist.c:1239
+msgid "Package not installed"
+msgstr "Pacote não instalado"
 
-#: locale/programs/ld-collate.c:1401
-msgid "line before ellipsis does not contain definition for character constant"
-msgstr "linha antes da elipse no contm definio para constante de caracter"
+#: sysdeps/gnu/errlist.c:1247
+msgid "Advertise error"
+msgstr "Erro de aviso"
 
-#: timezone/zic.c:805
-msgid "line too long"
-msgstr "linha muito longa"
+#: sysdeps/gnu/errlist.c:1255
+msgid "Srmount error"
+msgstr "Erro de srmount"
 
-#: iconv/iconv_prog.c:58
-msgid "list all known coded character sets"
-msgstr "lista todas as colees de caracteres codificados"
+#: sysdeps/gnu/errlist.c:1263
+msgid "Communication error on send"
+msgstr "Erro de comunicação ao enviar"
 
-#: locale/programs/localedef.c:273
-#, c-format
-msgid "locale file `%s', used in `copy' statement, not found"
-msgstr "arquivo locale `%s', usado na declarao `copy' , no encontrado"
+#: sysdeps/gnu/errlist.c:1271
+msgid "RFS specific error"
+msgstr "Erro específico de RFS"
 
-#: inet/rcmd.c:307
-msgid "lstat failed"
-msgstr "falha em lstat"
+#: sysdeps/gnu/errlist.c:1279
+msgid "Name not unique on network"
+msgstr "O nome não é único na rede"
 
-#: catgets/gencat.c:619
-msgid "malformed line ignored"
-msgstr "linha invlida ignorada"
+#: sysdeps/gnu/errlist.c:1287
+msgid "File descriptor in bad state"
+msgstr "Descritor de arquivo em mal estado"
 
-#: elf/sprof.c:554
-msgid "mapping of section header string table failed"
-msgstr "mapeamento da tabela de cadeias do cabealho da seo falhou"
+#: sysdeps/gnu/errlist.c:1295
+msgid "Remote address changed"
+msgstr "Endereço remoto alterado"
 
-#: elf/sprof.c:544
-msgid "mapping of section headers failed"
-msgstr "mapeamento dos cabealhos da seo falhou"
+#: sysdeps/gnu/errlist.c:1303
+msgid "Can not access a needed shared library"
+msgstr "Não foi possível acessar uma biblioteca compartilhada"
 
-#: malloc/mcheck.c:202
-msgid "memory clobbered before allocated block\n"
-msgstr "memria sobrescrita antes do bloco alocado\n"
+#: sysdeps/gnu/errlist.c:1311
+msgid "Accessing a corrupted shared library"
+msgstr "Acessando uma biblioteca compartilhado corrompida"
 
-#: malloc/mcheck.c:205
-msgid "memory clobbered past end of allocated block\n"
-msgstr "memria sobrescrita aps o fim do bloco allocado\n"
-
-#: locale/programs/ld-collate.c:170 locale/programs/ld-collate.c:176
-#: locale/programs/ld-collate.c:180 locale/programs/ld-collate.c:1449
-#: locale/programs/ld-collate.c:1478 locale/programs/locfile.c:1082
-#: locale/programs/xmalloc.c:70 login/programs/database.c:62
-#: login/programs/database.c:79 login/programs/database.c:95
-#: posix/getconf.c:682
-msgid "memory exhausted"
-msgstr "memria esgotada"
+#: sysdeps/gnu/errlist.c:1319
+msgid ".lib section in a.out corrupted"
+msgstr "Seção .lib corrompida em a.out"
 
-#: malloc/obstack.c:471
-msgid "memory exhausted\n"
-msgstr "memria esgotada\n"
+#: sysdeps/gnu/errlist.c:1327
+msgid "Attempting to link in too many shared libraries"
+msgstr "Tentando vincular em muitas bibliotecas compartilhadas"
 
-#: malloc/mcheck.c:199
-msgid "memory is consistent, library is buggy\n"
-msgstr "a memria est consistente, problemas na biblioteca\n"
+#: sysdeps/gnu/errlist.c:1335
+msgid "Cannot exec a shared library directly"
+msgstr "Não foi possível executar uma biblioteca compartilhado diretamente"
 
-#: locale/programs/ld-time.c:370
-#, c-format
-msgid "missing era format in string %d in `era' field in category `%s'"
-msgstr "formato era ausente na string %d no campo `era', categoria`%s'"
+#: sysdeps/gnu/errlist.c:1343
+msgid "Streams pipe error"
+msgstr "Erro de fluxos de pipe"
 
-#: locale/programs/ld-time.c:358
-#, c-format
-msgid "missing era name in string %d in `era' field in category `%s'"
-msgstr "nome era ausente na string %d no campo `era', categoria `%s'"
+#: sysdeps/gnu/errlist.c:1351
+msgid "Structure needs cleaning"
+msgstr "A estrutura necessita de limpeza"
 
-#: timezone/zic.c:928
-msgid "nameless rule"
-msgstr "regra sem nome"
+#: sysdeps/gnu/errlist.c:1359
+msgid "Not a XENIX named type file"
+msgstr "Não é um arquivo nomeável XENIX"
 
-#: iconv/iconv_prog.c:133
-msgid "neither original nor target encoding specified"
-msgstr "codificao original nem destino especificada"
+#: sysdeps/gnu/errlist.c:1367
+msgid "No XENIX semaphores available"
+msgstr "Não há semáforos XENIX disponíveis"
 
-#: nis/nss_nisplus/nisplus-publickey.c:262
-#: nis/nss_nisplus/nisplus-publickey.c:268
-#: nis/nss_nisplus/nisplus-publickey.c:327
-#: nis/nss_nisplus/nisplus-publickey.c:336
-#, c-format
-msgid "netname2user: (nis+ lookup): %s\n"
-msgstr "netname2user: (nis+ lookup): %s\n"
+#: sysdeps/gnu/errlist.c:1375
+msgid "Is a named type file"
+msgstr "É um arquivo tipo nomeável"
 
-#: nis/nss_nisplus/nisplus-publickey.c:281
-#, c-format
-msgid "netname2user: DES entry for %s in directory %s not unique"
-msgstr "netname2user: entrada DES para %s no diretrio %s no  nica"
+#: sysdeps/gnu/errlist.c:1383
+msgid "Remote I/O error"
+msgstr "Erro de E/S remota"
 
-#: nis/nss_nisplus/nisplus-publickey.c:349
-#, c-format
-msgid "netname2user: LOCAL entry for %s in directory %s not unique"
-msgstr "netname2user: entrada LOCAL para %s no diretrio %s no  nica"
+#: sysdeps/gnu/errlist.c:1391
+msgid "No medium found"
+msgstr "Mídia não encontrada"
 
-#: nis/nss_nisplus/nisplus-publickey.c:194
-#, c-format
-msgid "netname2user: missing group id list in '%s'."
-msgstr "netname2user: lista de id do grupo perdida em `%s'."
+#: sysdeps/gnu/errlist.c:1399
+msgid "Wrong medium type"
+msgstr "Tipo de mídia incorreta"
 
-#: nis/nss_nisplus/nisplus-publickey.c:299
-#, c-format
-msgid "netname2user: principal name '%s' too long"
-msgstr "netname2user: nome principal `%s' muito longo"
+#: sysdeps/gnu/errlist.c:1407
+msgid "Required key not available"
+msgstr "Chave necessária não disponível"
 
-#: nis/nss_nisplus/nisplus-publickey.c:356
-msgid "netname2user: should not have uid 0"
-msgstr "netname2user: no deve possuir uid 0"
+#: sysdeps/gnu/errlist.c:1415
+msgid "Key has expired"
+msgstr "A chave expirou"
 
-#: sunrpc/svc_simple.c:158
-#, c-format
-msgid "never registered prog %d\n"
-msgstr "nunca registrado prog %d\n"
+#: sysdeps/gnu/errlist.c:1423
+msgid "Key has been revoked"
+msgstr "A chave foi revogada"
 
-#: locale/programs/repertoire.c:238
-msgid "no <Uxxxx> or <Uxxxxxxxx> value given"
-msgstr "Valores <Uxxxx> ou <Uxxxxxxxx> no entrados"
+#: sysdeps/gnu/errlist.c:1431
+msgid "Key was rejected by service"
+msgstr "A chave foi rejeitada pelo serviço"
 
-#: locale/programs/ld-messages.c:101 locale/programs/ld-messages.c:125
-#, c-format
-msgid "no correct regular expression for field `%s' in category `%s': %s"
-msgstr "no h expresso regular correta para campo `%s', categoria `%s': %s"
+#: sysdeps/gnu/errlist.c:1439
+msgid "Owner died"
+msgstr "Dono morto"
 
-#: timezone/zic.c:2115
-msgid "no day in month matches rule"
-msgstr "nehum dia do ms satisfaz a norma"
+#: sysdeps/gnu/errlist.c:1447
+msgid "State not recoverable"
+msgstr "Estado não recuperável"
 
-#: locale/programs/ld-collate.c:267
-msgid "no definition of `UNDEFINED'"
-msgstr "no h definio de `UNDEFINED'"
+#: sysdeps/gnu/errlist.c:1455
+msgid "Operation not possible due to RF-kill"
+msgstr "Operação não permitida em razão de RF-kill"
 
-#: elf/sprof.c:276
-#, c-format
-msgid "no filename for profiling data given and shared object `%s' has no soname"
-msgstr "nome de arquivo para perfil de dados no informado e objetos compartilhados `%s' no tem `soname'"
+#: sysdeps/gnu/errlist.c:1463
+msgid "Memory page has hardware error"
+msgstr "Página de memória possui um erro de hardware"
 
-#: locale/programs/locfile.c:609
-msgid "no other keyword shall be specified when `copy' is used"
-msgstr "nehuma outra palavra-chave deve ser especificada quando `copy'  usado"
+#: sysdeps/mach/_strerror.c:56
+msgid "Error in unknown error system: "
+msgstr "Falha no erro desconhecido do sistema: "
 
-#: locale/programs/localedef.c:334
-msgid "no output file produced because warning were issued"
-msgstr "nenhum arquivo de sada foi produzido porque avisos foram emitidos"
+#: sysdeps/posix/gai_strerror-strs.h:1
+msgid "Address family for hostname not supported"
+msgstr "Família de endereços não suportada para nome de máquina"
 
-#: locale/programs/locfile.c:283 locale/programs/locfile.c:301
-#: locale/programs/locfile.c:319 locale/programs/locfile.c:337
-#: locale/programs/locfile.c:355 locale/programs/locfile.c:373
-msgid "no repertoire map specified: cannot proceed"
-msgstr "mapa de repertrio no especificado: no posso prosseguir"
+#: sysdeps/posix/gai_strerror-strs.h:2
+msgid "Temporary failure in name resolution"
+msgstr "Falha temporário na resolução de nome"
 
-#: locale/programs/charmap.c:400 locale/programs/charmap.c:550
-#: locale/programs/charmap.c:629 locale/programs/repertoire.c:199
-msgid "no symbolic name given"
-msgstr "nenhum nome simblico dado"
+#: sysdeps/posix/gai_strerror-strs.h:3
+msgid "Bad value for ai_flags"
+msgstr "Valor inválido para ai_flags"
 
-#: locale/programs/charmap.c:465 locale/programs/charmap.c:596
-#: locale/programs/charmap.c:662 locale/programs/repertoire.c:261
-msgid "no symbolic name given for end of range"
-msgstr "nenhum nome simblico dado para fim do intervalo"
+#: sysdeps/posix/gai_strerror-strs.h:4
+msgid "Non-recoverable failure in name resolution"
+msgstr "Falha irrecuperável na resolução de nome"
 
-#: locale/programs/ld-collate.c:249
-#, c-format
-msgid "no weight defined for symbol `%s'"
-msgstr "no foi definido peso para o smbolo `%s'"
+#: sysdeps/posix/gai_strerror-strs.h:5
+msgid "ai_family not supported"
+msgstr "Família de protocolo (ai_family) sem suporte"
 
-#: inet/rcmd.c:309
-msgid "not regular file"
-msgstr "no  arquivo normal"
+#: sysdeps/posix/gai_strerror-strs.h:6
+msgid "Memory allocation failure"
+msgstr "Falha de alocação de memória"
 
-#: nscd/nscd_stat.c:130
-#, c-format
-msgid ""
-"nscd configuration:\n"
-"\n"
-"%15d  server debug level\n"
-msgstr ""
-"configurao nscd:\n"
-"\n"
-"%15d nvel de debug do servidor\n"
+#: sysdeps/posix/gai_strerror-strs.h:7
+msgid "No address associated with hostname"
+msgstr "Não há endereço associado com o nome"
 
-#: nscd/nscd_stat.c:104
-msgid "nscd not running!\n"
-msgstr "nscd no est rodando!\n"
+#: sysdeps/posix/gai_strerror-strs.h:8
+msgid "Name or service not known"
+msgstr "Nome ou serviço desconhecido"
 
-#: locale/programs/charmap.c:514
-msgid "only WIDTH definitions are allowed to follow the CHARMAP definition"
-msgstr "apenas definies de WIDTH so permitidas em seguida  definio de CHARMAP"
+#: sysdeps/posix/gai_strerror-strs.h:9
+msgid "Servname not supported for ai_socktype"
+msgstr "Servname sem suporte para “ai_socktype”"
 
-#: iconv/iconv_prog.c:135
-msgid "original encoding not specified using `-f'"
-msgstr "codificao original no especificada usando `-f'"
+#: sysdeps/posix/gai_strerror-strs.h:10
+msgid "ai_socktype not supported"
+msgstr "ai_socktype sem suporte"
 
-#: iconv/iconv_prog.c:60
-msgid "output file"
-msgstr "arquivo de sada"
+#: sysdeps/posix/gai_strerror-strs.h:11
+msgid "System error"
+msgstr "Erro de sistema"
 
-#: sunrpc/pm_getmaps.c:73
-msgid "pmap_getmaps rpc problem"
-msgstr "problemas de pmap_getmaps rpc"
+#: sysdeps/posix/gai_strerror-strs.h:12
+msgid "Processing request in progress"
+msgstr "Processamento da requisição em progresso"
 
-#: inet/rcmd.c:179
-msgid "poll: protocol failure in circuit setup\n"
-msgstr "poll: falha de protocolo na configurao do circuito\n"
+#: sysdeps/posix/gai_strerror-strs.h:13
+msgid "Request canceled"
+msgstr "Requisição cancelada"
 
-#: sunrpc/rpc_scan.c:523 sunrpc/rpc_scan.c:533
-msgid "preprocessor error"
-msgstr "Erro de pr-processador"
+#: sysdeps/posix/gai_strerror-strs.h:14
+msgid "Request not canceled"
+msgstr "Requisição não cancelada"
 
-#: elf/sprof.c:78
-msgid "print list of count paths and their number of use"
-msgstr "mostra lista de nmero de rotas e seu nmero de uso"
+#: sysdeps/posix/gai_strerror-strs.h:15
+msgid "All requests done"
+msgstr "Todas as requisições feitas"
 
-#: iconv/iconv_prog.c:61
-msgid "print progress information"
-msgstr "mostra informaes de progresso"
+#: sysdeps/posix/gai_strerror-strs.h:16
+msgid "Interrupted by a signal"
+msgstr "Interrompido por um sinal"
 
-#: db2/makedb.c:345
-#, c-format
-msgid "problems while reading `%s'"
-msgstr "problems lendo `%s'"
+#: sysdeps/posix/gai_strerror-strs.h:17
+msgid "Parameter string not correctly encoded"
+msgstr "String de parâmetro não codificado corretamente"
 
-#: elf/sprof.c:691
+#: sysdeps/unix/sysv/linux/i386/readelflib.c:65
 #, c-format
-msgid "profiling data file `%s' does not match shared object `%s'"
-msgstr "arquivo de dados de perfil `%s' no coincide com objetos compartilhados `%s'"
+msgid "%s is for unknown machine %d.\n"
+msgstr "%s é para máquina desconhecida %d.\n"
 
-#: sunrpc/rpcinfo.c:237 sunrpc/rpcinfo.c:383
+#: sysdeps/unix/sysv/linux/ia64/makecontext.c:58
 #, c-format
-msgid "program %lu is not available\n"
-msgstr "programa %lu no est disponvel\n"
+msgid "makecontext: does not know how to handle more than 8 arguments\n"
+msgstr "makecontext: não sabe como lidar com mais de 8 argumentos\n"
 
-#: sunrpc/rpcinfo.c:264 sunrpc/rpcinfo.c:310 sunrpc/rpcinfo.c:333
-#: sunrpc/rpcinfo.c:407 sunrpc/rpcinfo.c:453 sunrpc/rpcinfo.c:476
-#: sunrpc/rpcinfo.c:510
+#: sysdeps/unix/sysv/linux/lddlibc4.c:60
 #, c-format
-msgid "program %lu version %lu is not available\n"
-msgstr "programa %lu verso %lu no est disponvel\n"
+msgid ""
+"Usage: lddlibc4 FILE\n"
+"\n"
+msgstr ""
+"Uso: lddlibc4 ARQUIVO\n"
+"\n"
 
-#: sunrpc/rpcinfo.c:515
+#: sysdeps/unix/sysv/linux/lddlibc4.c:81
 #, c-format
-msgid "program %lu version %lu ready and waiting\n"
-msgstr "programa %lu verso %lu pronto e aguardando\n"
+msgid "cannot open `%s'"
+msgstr "não foi possível abrir “%s”"
 
-#: inet/rcmd.c:176
+#: sysdeps/unix/sysv/linux/lddlibc4.c:85
 #, c-format
-msgid "rcmd: poll (setting up stderr): %m\n"
-msgstr "rcmd: poll (configurando stderr): %m\n"
-
-#: inet/rcmd.c:110
-msgid "rcmd: socket: All ports in use\n"
-msgstr "rcmd: socket: Todas as portas em uso\n"
+msgid "cannot read header from `%s'"
+msgstr "não foi possível ler cabeçalho de “%s”"
 
-#: inet/rcmd.c:166
-#, c-format
-msgid "rcmd: write (setting up stderr): %m\n"
-msgstr "rcmd: write (configurando stderr): %m\n"
+#: timezone/zdump.c:338
+msgid "has fewer than 3 characters"
+msgstr "possui menos de 3 caracteres"
 
-#: sunrpc/svc_simple.c:98
-msgid "registerrpc: out of memory\n"
-msgstr "registerrpc: no h memria suficiente\n"
+#: timezone/zdump.c:340
+msgid "has more than 6 characters"
+msgstr "possui mais de 6 caracteres"
 
-#: timezone/zic.c:1849
-msgid "repeated leap second moment"
-msgstr "ajuste repetido em segundo momento"
+#: timezone/zdump.c:342
+msgid "has characters other than ASCII alphanumerics, '-' or '+'"
+msgstr "possui caracteres além de “-”, “+” ou alfanuméricos ASCII"
 
-#: locale/programs/repertoire.c:95
+#: timezone/zdump.c:347
 #, c-format
-msgid "repertoire map file `%s' not found"
-msgstr "arquivo de mapas `%s' no foi localizado"
-
-#: sunrpc/rpc_main.c:1117
-msgid "rpcgen: arglist coding error\n"
-msgstr "rpcgen: erro na codificao de parmetros\n"
-
-#: sunrpc/rpc_main.c:1105
-msgid "rpcgen: too many defines\n"
-msgstr "rpcgen: muitas definies\n"
+msgid "%s: warning: zone \"%s\" abbreviation \"%s\" %s\n"
+msgstr "%s: aviso: fuso “%s” abreviação “%s” %s\n"
 
-#: sunrpc/rpcinfo.c:732
+#: timezone/zdump.c:393
 #, c-format
-msgid "rpcinfo: %s is unknown host\n"
-msgstr "rpcinfo: %s  um host desconhecido\n"
+msgid ""
+"%s: usage: %s OPTIONS ZONENAME ...\n"
+"Options include:\n"
+"  -c [L,]U   Start at year L (default -500), end before year U (default 2500)\n"
+"  -t [L,]U   Start at time L, end before time U (in seconds since 1970)\n"
+"  -i         List transitions briefly (format is experimental)\n"
+"  -v         List transitions verbosely\n"
+"  -V         List transitions a bit less verbosely\n"
+"  --help     Output this help\n"
+"  --version  Output version info\n"
+"\n"
+"Report bugs to %s.\n"
+msgstr ""
+"%s: uso: %s OPÇÕES NOMEFUSO ...\n"
+"Opções incluem:\n"
+"  -c [L,]U   Inicia no ano L (padrão -500), termina até o ano U (padrão 2500)\n"
+"  -t [L,]U   Inicia no tempo L, termina até o tempo U (em segundos desde 1970)\n"
+"  -i         Lista transições brevemente (formato é experimental)\n"
+"  -v         Lista transições verbosamente\n"
+"  -V         Lista transições um pouco menos verbosamente\n"
+"  --help     Emite essa ajuda\n"
+"  --version  Emite informação da versão\n"
+"\n"
+"Relate erros para %s.\n"
 
-#: sunrpc/rpcinfo.c:695
+#: timezone/zdump.c:479
 #, c-format
-msgid "rpcinfo: %s is unknown service\n"
-msgstr "rpcinfo: %s  um servio desconhecido\n"
+msgid "%s: wild -c argument %s\n"
+msgstr "%s: argumento -c insensato %s\n"
 
-#: sunrpc/rpcinfo.c:665
+#: timezone/zdump.c:512
 #, c-format
-msgid "rpcinfo: Could not delete registration for prog %s version %s\n"
-msgstr "rpcinfo: No foi possvel apagar registro para prog %s verso %s\n"
+msgid "%s: wild -t argument %s\n"
+msgstr "%s: argumento -t insensato %s\n"
 
-#: sunrpc/rpcinfo.c:637
+#: timezone/zic.c:398
 #, c-format
-msgid "rpcinfo: broadcast failed: %s\n"
-msgstr "rpcinfo: broadcast falhou: %s\n"
+msgid "%s: Memory exhausted: %s\n"
+msgstr "%s: Memória esgotada: %s\n"
 
-#: sunrpc/rpcinfo.c:556 sunrpc/rpcinfo.c:563
-msgid "rpcinfo: can't contact portmapper"
-msgstr "rpcinfo: impossvel contactar portmapper"
+#: timezone/zic.c:406
+msgid "size overflow"
+msgstr "estouro de tamanho"
 
-#: timezone/zic.c:718 timezone/zic.c:720
-msgid "same rule name in multiple files"
-msgstr "mesmo nome de regra em mltiplos arquivos"
+#: timezone/zic.c:454
+msgid "integer overflow"
+msgstr "estouro de valor inteiro"
 
-#: nscd/connections.c:387
+#: timezone/zic.c:488
 #, c-format
-msgid "short read while reading request key: %s"
-msgstr "falha na leitura lendo chave de requisio: %s"
+msgid "\"%s\", line %<PRIdMAX>: "
+msgstr "“%s”, linha %<PRIdMAX>: "
 
-#: nscd/connections.c:364
+#: timezone/zic.c:491
 #, c-format
-msgid "short read while reading request: %s"
-msgstr "problems lendo `%s'"
+msgid " (rule from \"%s\", line %<PRIdMAX>)"
+msgstr " (regra de “%s”, linha %<PRIdMAX>)"
 
-#: nscd/grpcache.c:191 nscd/hstcache.c:278 nscd/pwdcache.c:188
+#: timezone/zic.c:510
 #, c-format
-msgid "short write in %s: %s"
-msgstr "Erro escrevendo em %s: %s"
-
-#: inet/rcmd.c:197
-msgid "socket: protocol failure in circuit setup\n"
-msgstr "socket: falha de protocolo na configurao do circuito\n"
-
-#: locale/programs/locfile.c:730
-msgid "sorting order `forward' and `backward' are mutually exclusive"
-msgstr "as ordens de classificao `forward' e `backward' so mutuamente exclusivas"
-
-#: locale/programs/ld-collate.c:1582 locale/programs/ld-collate.c:1628
-msgid "specification of sorting weight for collation symbol does not make sense"
-msgstr "especificao de peso para smbolo de comparao no faz sentido"
-
-#: timezone/zic.c:789
-msgid "standard input"
-msgstr "entrada padro"
-
-#: timezone/zdump.c:268
-msgid "standard output"
-msgstr "sada padro"
+msgid "warning: "
+msgstr "aviso: "
 
-#: locale/programs/ld-time.c:272
+#: timezone/zic.c:535
 #, c-format
-msgid "starting date is illegal in string %d in `era' field in category `%s'"
-msgstr "data inicial  ilegal na string %d no campo `era', categoria `%s'"
-
-#: timezone/zic.c:1300
-msgid "starting year greater than ending year"
-msgstr "ano inicial maior que ano final"
-
-#: timezone/zic.c:1272 timezone/zic.c:1297
-msgid "starting year too high to be represented"
-msgstr "ano inicial muito alto para ser representado"
-
-#: timezone/zic.c:1270 timezone/zic.c:1295
-msgid "starting year too low to be represented"
-msgstr "ano inicial muito baixo para ser representado"
+msgid ""
+"%s: usage is %s [ --version ] [ --help ] [ -v ] \\\n"
+"\t[ -l localtime ] [ -p posixrules ] [ -d directory ] \\\n"
+"\t[ -L leapseconds ] [ filename ... ]\n"
+"\n"
+"Report bugs to %s.\n"
+msgstr ""
+"%s: uso é %s [ --version ] [ --help ] [ -h ] \\\n"
+"\t[ -l tempolocal ] [ -p regrasposix ] [ -d diretório ] \\\n"
+"\t[ -L segundos bissextos ] [ nome do arquivo ... ]\n"
+"\n"
+"Relate erros para %s.\n"
 
-#: locale/programs/ld-time.c:348
+#: timezone/zic.c:558
 #, c-format
-msgid "stopping date is illegal in string %d in `era' field in category `%s'"
-msgstr "data de trmino  ilegal na string %d no campo `era', categoria `%s'"
+msgid "%s: Can't chdir to %s: %s\n"
+msgstr "%s: Não foi fazer chdir criar %s: %s\n"
 
-#: sunrpc/svc_run.c:81
-msgid "svc_run: - select failed"
-msgstr "svc_run: - select falhou"
+#: timezone/zic.c:590
+msgid "wild compilation-time specification of zic_t"
+msgstr "especificação insensata de tempo de compilação de zic_t"
 
-#: sunrpc/svc_tcp.c:160
-msgid "svc_tcp.c - cannot getsockname or listen"
-msgstr "svc_tcp_.c - no  possvel receber `getsocknome' ou `listen'"
+#: timezone/zic.c:610
+#, c-format
+msgid "%s: More than one -d option specified\n"
+msgstr "%s: Mais de uma opção -d foi especificada\n"
 
-#: sunrpc/svc_tcp.c:145
-msgid "svc_tcp.c - tcp socket creation problem"
-msgstr "svc_tcp_.c - problema na criao do soquete AF_UNIX"
+#: timezone/zic.c:620
+#, c-format
+msgid "%s: More than one -l option specified\n"
+msgstr "%s: Mais de uma opção -l especificada\n"
 
-#: sunrpc/svc_tcp.c:209 sunrpc/svc_tcp.c:215
-msgid "svc_tcp: makefd_xprt: out of memory\n"
-msgstr "svc_tcp: makefd_xprt: no h memria suficiente\n"
+#: timezone/zic.c:630
+#, c-format
+msgid "%s: More than one -p option specified\n"
+msgstr "%s: Mais de uma opção -p especificada\n"
 
-#: sunrpc/svc_unix.c:135
-msgid "svc_unix.c - AF_UNIX socket creation problem"
-msgstr "svc_tcp_.c - problema na criao do soquete AF_UNIX"
+#: timezone/zic.c:640
+#, c-format
+msgid "%s: More than one -y option specified\n"
+msgstr "%s: Mais de uma opção -y especificada\n"
 
-#: sunrpc/svc_unix.c:151
-msgid "svc_unix.c - cannot getsockname or listen"
-msgstr "svc_tcp_.c - memria exaurida"
+#: timezone/zic.c:650
+#, c-format
+msgid "%s: More than one -L option specified\n"
+msgstr "%s: Mais de uma opção -L foi especificada\n"
 
-#: sunrpc/svc_unix.c:201 sunrpc/svc_unix.c:207
-msgid "svc_unix: makefd_xprt: out of memory\n"
-msgstr "svc_unix: makefd_xprt: no h memria suficiente\n"
+#: timezone/zic.c:659
+msgid "-s ignored"
+msgstr "-s ignorada"
 
-#: sunrpc/svc_tcp.c:168 sunrpc/svc_tcp.c:176
-msgid "svctcp_create: out of memory\n"
-msgstr "svctcp_create: no h memria suficiente\n"
+#: timezone/zic.c:698
+msgid "link to link"
+msgstr "link para o link"
 
-#: sunrpc/svc_udp.c:135
-msgid "svcudp_create - cannot getsockname"
-msgstr "svcudp_create - no  possvel getsockname"
+#: timezone/zic.c:701 timezone/zic.c:705
+msgid "command line"
+msgstr "linha de comando"
 
-#: sunrpc/svc_udp.c:143 sunrpc/svc_udp.c:149 sunrpc/svc_udp.c:155
-msgid "svcudp_create: out of memory\n"
-msgstr "svcucp_create: no h memria suficiente\n"
+#: timezone/zic.c:721
+msgid "empty file name"
+msgstr "arquivo com nome vazio"
 
-#: sunrpc/svc_udp.c:121
-msgid "svcudp_create: socket creation problem"
-msgstr "svcudp_create: problema na criao socket"
+#: timezone/zic.c:724
+#, c-format
+msgid "file name '%s' begins with '/'"
+msgstr "nome de arquivo “%s” começa com “/”"
 
-#: sunrpc/svc_unix.c:160 sunrpc/svc_unix.c:168
-msgid "svcunix_create: out of memory\n"
-msgstr "svcunix_create: no h memria suficiente\n"
+#: timezone/zic.c:734
+#, c-format
+msgid "file name '%s' contains '%.*s' component"
+msgstr "nome de arquivo “%s” contém componente “%.*s”"
 
-#: locale/programs/ld-collate.c:1201
+#: timezone/zic.c:740
 #, c-format
-msgid "symbol for multicharacter collating element `%.*s' duplicates element definition"
-msgstr "smbolo para elemento de comparao multicaracter `%.*s' duplica a definio do elemento"
+msgid "file name '%s' component contains leading '-'"
+msgstr "um componente do nome de arquivo “%s” inicia com “-”"
 
-#: locale/programs/ld-collate.c:1073
+#: timezone/zic.c:743
 #, c-format
-msgid "symbol for multicharacter collating element `%.*s' duplicates other element definition"
-msgstr "smbolo para elemento de comparao multicaracter `%.*s' duplica a definio do elemento"
+msgid "file name '%s' contains overlength component '%.*s...'"
+msgstr "nome de arquivo “%s” contém componente “%.*s...” comprido demais"
 
-#: locale/programs/ld-collate.c:1210
+#: timezone/zic.c:771
 #, c-format
-msgid "symbol for multicharacter collating element `%.*s' duplicates other symbol definition"
-msgstr "smbolo para elemento de comparao multicaracter `%.*s' duplica outra definio de smbolo"
+msgid "file name '%s' contains byte '%c'"
+msgstr "nome de arquivo “%s” contém byte “%c”"
 
-#: locale/programs/ld-collate.c:1082
+#: timezone/zic.c:772
 #, c-format
-msgid "symbol for multicharacter collating element `%.*s' duplicates symbol definition"
-msgstr "smbolo para elemento de comparao multicaracter `%.*s' duplica a definio do smbolo"
+msgid "file name '%s' contains byte '\\%o'"
+msgstr "nome de arquivo “%s” contém byte “\\%o”"
 
-#: locale/programs/ld-collate.c:1064 locale/programs/ld-collate.c:1192
+#: timezone/zic.c:842
 #, c-format
-msgid "symbol for multicharacter collating element `%.*s' duplicates symbolic name in charset"
-msgstr "smbolo para elemento de comparao multicaracter `%.*s duplicado"
+msgid "%s: link from %s/%s failed: %s\n"
+msgstr "%s: link de %s/%s falhou: %s\n"
 
-#: locale/programs/charmap.c:399 locale/programs/charmap.c:433
-#: locale/programs/charmap.c:463 locale/programs/charmap.c:549
-#: locale/programs/charmap.c:595 locale/programs/charmap.c:628
-#: locale/programs/charmap.c:660
+#: timezone/zic.c:852 timezone/zic.c:1815
 #, c-format
-msgid "syntax error in %s definition: %s"
-msgstr "erro de sintaxe na definio %s: %s"
+msgid "%s: Can't remove %s/%s: %s\n"
+msgstr "%s: Não é possível remover %s/%s: %s\n"
 
-#: locale/programs/locfile.c:750
-msgid "syntax error in `order_start' directive"
-msgstr "erro de sintaxe na diretiva `order_start'"
+#: timezone/zic.c:874
+#, c-format
+msgid "symbolic link used because hard link failed: %s"
+msgstr "link simbólico usado porque link absoluto falhou: %s"
 
-#: locale/programs/locfile.c:492
-msgid "syntax error in character class definition"
-msgstr "erro de sintaxe na definio de classe de caracteres"
+#: timezone/zic.c:882
+#, c-format
+msgid "%s: Can't read %s/%s: %s\n"
+msgstr "%s: Não foi possível ler %s/%s: %s\n"
 
-#: locale/programs/locfile.c:550
-msgid "syntax error in character conversion definition"
-msgstr "erro de sintaxe na definio de converso de caracteres"
+#: timezone/zic.c:889 timezone/zic.c:1828
+#, c-format
+msgid "%s: Can't create %s/%s: %s\n"
+msgstr "%s: Não é possível criar %s/%s (%s)\n"
 
-#: locale/programs/locfile.c:792
-msgid "syntax error in collating order definition"
-msgstr "erro de sintaxe na definio de ordem de comparao"
+#: timezone/zic.c:898
+#, c-format
+msgid "copy used because hard link failed: %s"
+msgstr "cópia usada porque link absoluto falhou: %s"
 
-#: locale/programs/locfile.c:642
-msgid "syntax error in collation definition"
-msgstr "erro de sintaxe na definio de comparao"
+#: timezone/zic.c:901
+#, c-format
+msgid "copy used because symbolic link failed: %s"
+msgstr "cópia usada porque link simbólico falhou: %s"
 
-#: locale/programs/locfile.c:465
-msgid "syntax error in definition of LC_CTYPE category"
-msgstr "erro de sintaxe na definio da categoria LC_CTYPE"
+#: timezone/zic.c:1013 timezone/zic.c:1015
+msgid "same rule name in multiple files"
+msgstr "mesmo nome de regra em múltiplos arquivos"
 
-#: locale/programs/locfile.c:408
-msgid "syntax error in definition of new character class"
-msgstr "erro de sintaxe na definio de uma nova classe de caracteres"
+#: timezone/zic.c:1056
+msgid "unruly zone"
+msgstr "fuso horário sem regras"
 
-#: locale/programs/locfile.c:418
-msgid "syntax error in definition of new character map"
-msgstr "erro de sintaxe na definio de um novo mapa de caracteres"
+#: timezone/zic.c:1063
+#, c-format
+msgid "%s in ruleless zone"
+msgstr "%s em uma fuso horário sem regras"
 
-#: locale/programs/locfile.c:1003
-msgid "syntax error in message locale definition"
-msgstr "erro de sintaxe na definio da mensagem locale"
+#: timezone/zic.c:1083
+msgid "standard input"
+msgstr "entrada padrão"
 
-#: locale/programs/locfile.c:914
-msgid "syntax error in monetary locale definition"
-msgstr "erro de sintaxe na definio monetria locale"
+#: timezone/zic.c:1088
+#, c-format
+msgid "%s: Can't open %s: %s\n"
+msgstr "%s: Não é possível abrir %s: %s\n"
 
-#: locale/programs/locfile.c:941
-msgid "syntax error in numeric locale definition"
-msgstr "erro de sintaxe na definio numrica locale"
+#: timezone/zic.c:1099
+msgid "line too long"
+msgstr "linha muito longa"
 
-#: locale/programs/locfile.c:852
-msgid "syntax error in order specification"
-msgstr "erro de sintaxe na especificao de ordem"
+#: timezone/zic.c:1119
+msgid "input line of unknown type"
+msgstr "linha de entrada de tipo desconhecido"
 
-#: locale/programs/charmap.c:280 locale/programs/charmap.c:296
-#: locale/programs/repertoire.c:143
+#: timezone/zic.c:1134
 #, c-format
-msgid "syntax error in prolog: %s"
-msgstr "erro de sintaxe em prolog: %s"
+msgid "%s: Leap line in non leap seconds file %s"
+msgstr "%s: linha Leap em arquivo de segundos não bissextos %s"
 
-#: locale/programs/repertoire.c:198 locale/programs/repertoire.c:237
-#: locale/programs/repertoire.c:260
+#: timezone/zic.c:1142 timezone/zic.c:1547 timezone/zic.c:1569
 #, c-format
-msgid "syntax error in repertoire map definition: %s"
-msgstr "erro de sintaxe no mapa de repertrio: %s"
-
-#: locale/programs/locfile.c:979
-msgid "syntax error in time locale definition"
-msgstr "erro de sintaxe na definio de tempo locale"
-
-#: locale/programs/locfile.c:385
-msgid "syntax error: not inside a locale definition section"
-msgstr "erro de sintaxe: no est dentro de uma definio de seo locale"
-
-#: iconv/iconv_prog.c:137
-msgid "target encoding not specified using `-t'"
-msgstr "codificao destino no especificada usando `-t'"
-
-#: catgets/gencat.c:390 catgets/gencat.c:526 catgets/gencat.c:553
-msgid "this is the first definition"
-msgstr "esta  a primeira definio"
+msgid "%s: panic: Invalid l_value %d\n"
+msgstr "%s: pânico: l_value inválido %d\n"
 
-#: timezone/zic.c:1132
-msgid "time before zero"
-msgstr "tempo menor que zero"
+#: timezone/zic.c:1151
+msgid "expected continuation line not found"
+msgstr "linha de continuação não foi localizada"
 
-#: timezone/zic.c:1140 timezone/zic.c:2015 timezone/zic.c:2034
+#: timezone/zic.c:1193 timezone/zic.c:2976
 msgid "time overflow"
 msgstr "estouro de tempo"
 
-#: locale/programs/charmap.c:443
-msgid "too few bytes in character encoding"
-msgstr "poucos bytes na codificao do caracter"
-
-#: locale/programs/charmap.c:445
-msgid "too many bytes in character encoding"
-msgstr "muitos bytes na codificao do caracter"
-
-#: locale/programs/locales.h:92
-msgid "too many character classes defined"
-msgstr "muitas classes de caracteres definidas"
+#: timezone/zic.c:1198
+msgid "values over 24 hours not handled by pre-2007 versions of zic"
+msgstr "valor sobre 24 horas não tratado por versões anteriores a 2007 do zic"
 
-#: timezone/zic.c:1843
-msgid "too many leap seconds"
-msgstr "excessivos ajustes em segundos"
+#: timezone/zic.c:1209
+msgid "wrong number of fields on Rule line"
+msgstr "número incorreto de campos na linha Rule"
 
-#: timezone/zic.c:1815
-msgid "too many local time types"
-msgstr "muitos tipos de tempo local"
+#: timezone/zic.c:1213
+msgid "nameless rule"
+msgstr "regra sem nome"
 
-#: timezone/zic.c:1769
-msgid "too many transitions?!"
-msgstr "muitas transies?!"
+#: timezone/zic.c:1218
+msgid "invalid saved time"
+msgstr "tempo gravado inválido"
 
-#: locale/programs/ld-collate.c:1637
-msgid "too many weights"
-msgstr "muitos pesos"
+#: timezone/zic.c:1235
+msgid "wrong number of fields on Zone line"
+msgstr "número incorreto de campos na linha Zone"
 
-#: timezone/zic.c:2138
-msgid "too many, or too long, time zone abbreviations"
-msgstr "abreviaes de zona de tempo excessivas ou muito extensas"
+#: timezone/zic.c:1240
+#, c-format
+msgid "\"Zone %s\" line and -l option are mutually exclusive"
+msgstr "A linha “Zone %s” e a opção -l são mutuamente exclusivas"
 
-#: locale/programs/linereader.h:146
-msgid "trailing garbage at end of line"
-msgstr "lixo no final da linha"
+#: timezone/zic.c:1246
+#, c-format
+msgid "\"Zone %s\" line and -p option are mutually exclusive"
+msgstr "A linha “Zone %s” e a opção -p são mutuamente exclusivas"
 
-#: sunrpc/svc_simple.c:150
+#: timezone/zic.c:1253
 #, c-format
-msgid "trouble replying to prog %d\n"
-msgstr "problemas respondendo ao prog %d\n"
+msgid "duplicate zone name %s (file \"%s\", line %<PRIdMAX>)"
+msgstr "nome de fuso horário duplicado %s (arquivo “%s”, linha %<PRIdMAX>)"
 
-#: locale/programs/ld-collate.c:1393
-msgid "two lines in a row containing `...' are not allowed"
-msgstr "duas linhas em uma lista contendo `...' no so permitidas"
+#: timezone/zic.c:1267
+msgid "wrong number of fields on Zone continuation line"
+msgstr "número incorreto de campos na linha de continuação de Zone"
 
 #: timezone/zic.c:1307
-msgid "typed single year"
-msgstr "digitado ano simples"
+msgid "invalid UT offset"
+msgstr "deslocamento de UT inválido"
 
-#: iconv/iconv_prog.c:406
-msgid "unable to allocate buffer for input"
-msgstr "incapaz de alocar espao para entrada"
-
-#: nis/nis_callback.c:187
-msgid "unable to free arguments"
-msgstr "no consegui liberar parmetros"
-
-#: posix/getconf.c:654 posix/getconf.c:670
-msgid "undefined"
-msgstr "indefinido"
-
-#: locale/programs/charmap.c:701 locale/programs/charmap.c:712
-#, c-format
-msgid "unknown character `%s'"
-msgstr "caracter desconhecido `%s'"
-
-#: locale/programs/ld-messages.c:202 locale/programs/ld-messages.c:213
-#: locale/programs/ld-messages.c:224 locale/programs/ld-messages.c:235
-#: locale/programs/ld-time.c:718
-#, c-format
-msgid "unknown character in field `%s' of category `%s'"
-msgstr "caracter desconhecido no campo `%s', categoria `%s'"
-
-#: locale/programs/locfile.c:715
-msgid "unknown collation directive"
-msgstr "diretiva de comparao desconhecida"
+#: timezone/zic.c:1311
+msgid "invalid abbreviation format"
+msgstr "formato de abreviação inválido"
 
-#: catgets/gencat.c:487
+#: timezone/zic.c:1320
 #, c-format
-msgid "unknown directive `%s': line ignored"
-msgstr "diretiva desconhecida `%s': linha ignorada"
+msgid "format '%s' not handled by pre-2015 versions of zic"
+msgstr "formato “%s” não tratado por versões pré-2015 do zic"
 
-#: iconv/iconv_prog.c:353
-#, c-format
-msgid "unknown iconv() error %d"
-msgstr "erro iconv() desconhecido: %d"
+#: timezone/zic.c:1347
+msgid "Zone continuation line end time is not after end time of previous line"
+msgstr "Hora final da linha de fuso horário não está após o tempo final da linha anterior"
 
-#: catgets/gencat.c:466
-#, c-format
-msgid "unknown set `%s'"
-msgstr "conjunto desconhecido `%s'"
+#: timezone/zic.c:1374
+msgid "wrong number of fields on Leap line"
+msgstr "número incorreto de campos na linha Leap"
 
-#: locale/programs/ld-collate.c:1377 locale/programs/ld-collate.c:1572
-#: locale/programs/ld-collate.c:1747
-#, c-format
-msgid "unknown symbol `%.*s': line ignored"
-msgstr "smbolo desconhecido `%.*s': linha ignorada"
+#: timezone/zic.c:1383
+msgid "invalid leaping year"
+msgstr "ano bissexto inválido"
 
-#: timezone/zic.c:761
-msgid "unruly zone"
-msgstr "zona sem regras"
+#: timezone/zic.c:1403 timezone/zic.c:1501
+msgid "invalid month name"
+msgstr "nome do mês inválido"
 
-#: catgets/gencat.c:971
-msgid "unterminated message"
-msgstr "mensagem no terminada"
+#: timezone/zic.c:1416 timezone/zic.c:1614 timezone/zic.c:1628
+msgid "invalid day of month"
+msgstr "dia do mês inválido"
 
-#: locale/programs/linereader.c:520 locale/programs/linereader.c:555
-msgid "unterminated string"
-msgstr "string no terminada"
+#: timezone/zic.c:1421
+msgid "time too small"
+msgstr "hora pequena demais"
 
-#: sunrpc/rpc_scan.c:350 sunrpc/rpc_scan.c:376
-msgid "unterminated string constant"
-msgstr "string no terminada"
+#: timezone/zic.c:1425
+msgid "time too large"
+msgstr "hora grande demais"
 
-#: locale/programs/linereader.c:390
-msgid "unterminated symbolic name"
-msgstr "nome simblico no terminado"
+#: timezone/zic.c:1429 timezone/zic.c:1530
+msgid "invalid time of day"
+msgstr "hora do dia inválida"
 
-#: locale/programs/ld-collate.c:1699
-msgid "unterminated weight name"
-msgstr "nome do peso no terminado"
+#: timezone/zic.c:1448
+msgid "illegal CORRECTION field on Leap line"
+msgstr "Campo CORRECTION ilegal em linha Leap (ajuste)"
 
-#: locale/programs/charset.c:104
-msgid "upper limit in range is not smaller then lower limit"
-msgstr "o limite inferior do intervalo  maior que o limite superior"
+#: timezone/zic.c:1453
+msgid "illegal Rolling/Stationary field on Leap line"
+msgstr "campo Rolling/Stationary ilegal em linha Leap (ajuste)"
 
-#: sunrpc/rpc_main.c:1415
-#, c-format
-msgid "usage:  %s infile\n"
-msgstr "uso: %s arquivo_entrada\n"
+#: timezone/zic.c:1459
+msgid "leap second precedes Big Bang"
+msgstr "segundo bissexto precede Big Bang"
 
-#: timezone/zic.c:2081
-msgid "use of 2/29 in non leap-year"
-msgstr "use 2/29 em ano no bissexto"
+#: timezone/zic.c:1472
+msgid "wrong number of fields on Link line"
+msgstr "número incorreto de campos na linha Link"
 
-#: locale/programs/charmap.c:522 locale/programs/charmap.c:576
-#, c-format
-msgid "value for %s must be an integer"
-msgstr "valor para %s deve ser um inteiro"
+#: timezone/zic.c:1476
+msgid "blank FROM field on Link line"
+msgstr "campo FROM em branco na linha Link"
 
-#: locale/programs/charmap.c:318
-#, c-format
-msgid "value for <%s> must lie between 1 and 4"
-msgstr "valor para <%s> deve estar entre 1 e 4"
+#: timezone/zic.c:1551
+msgid "invalid starting year"
+msgstr "ano inicial inválido"
 
-#: locale/programs/ld-monetary.c:157 locale/programs/ld-numeric.c:92
-#, c-format
-msgid "value for field `%s' in category `%s' must not be the empty string"
-msgstr "valor para campo `%s', categoria `%s', no deve ser uma string vazia"
+#: timezone/zic.c:1573
+msgid "invalid ending year"
+msgstr "ano final inválido"
 
-#: locale/programs/charmap.c:330
-msgid "value of <mb_cur_max> must be greater than the value of <mb_cur_min>"
-msgstr "o valor de <mb_cur_max> deve ser maior que o valor de <mb_cur_min>"
+#: timezone/zic.c:1577
+msgid "starting year greater than ending year"
+msgstr "ano inicial maior que ano final"
 
-#: locale/programs/ld-monetary.c:147
-msgid "value of field `int_curr_symbol' in category `LC_MONETARY' does not correspond to a valid name in ISO 4217"
-msgstr "o valor do campo `int_curr_symbol' na categoria `LC_MONETARY' no corresponde a um nome vlido na ISO 4217"
+#: timezone/zic.c:1584
+msgid "typed single year"
+msgstr "digitado ano simples"
 
-#: locale/programs/ld-monetary.c:139
-msgid "value of field `int_curr_symbol' in category `LC_MONETARY' has wrong length"
-msgstr "o valor do campo `int_curr_symbol' na categoria `LC_MONETARY' possui tamanho errado"
+#: timezone/zic.c:1619
+msgid "invalid weekday name"
+msgstr "nome de dia de semana inválido"
 
-#: locale/programs/ld-monetary.c:383 locale/programs/ld-numeric.c:207
+#: timezone/zic.c:1743
 #, c-format
-msgid "values for field `%s' in category `%s' must be smaller than 127"
-msgstr "os valores para o campo `%s' na categoria `%s' devem ser menores que 127"
+msgid "reference clients mishandle more than %d transition times"
+msgstr "clientes de referência lidam incorretamente com mais %d tempos de transição"
 
-#: nscd/connections.c:355
-#, c-format
-msgid "while accepting connection: %s"
-msgstr "enquanto aceitando coneco: %s"
+#: timezone/zic.c:1747
+msgid "pre-2014 clients may mishandle more than 1200 transition times"
+msgstr "clientes pré-2014 podem não lidar corretamente comais de 1200 tempos de transições"
 
-#: nscd/grpcache.c:149 nscd/hstcache.c:168 nscd/pwdcache.c:142
-msgid "while allocating cache entry"
-msgstr "enquanto alocando entrada de cache"
+#: timezone/zic.c:1858
+msgid "too many transition times"
+msgstr "tempos de transição em excesso"
 
-#: nscd/cache.c:85
-msgid "while allocating hash table entry"
-msgstr "enquanto alocando entrada na tabela hash"
+#: timezone/zic.c:2047
+#, c-format
+msgid "%%z UTC offset magnitude exceeds 99:59:59"
+msgstr "a magnitude do deslocamento de %%z UTC excede 99:59:59"
 
-#: nscd/grpcache.c:99 nscd/hstcache.c:109 nscd/pwdcache.c:105
-msgid "while allocating key copy"
-msgstr "enquanto alocando chave cpia"
+#: timezone/zic.c:2424
+msgid "no POSIX environment variable for zone"
+msgstr "nenhuma variável de ambiente POSIX para o fuso horário"
 
-#: catgets/gencat.c:1001
-msgid "while opening old catalog file"
-msgstr "enquanto abrindo antigo arquivo de catlogo"
+#: timezone/zic.c:2430
+#, c-format
+msgid "%s: pre-%d clients may mishandle distant timestamps"
+msgstr "%s: clientes pré-%d podem não lidar corretamente com marcas de tempo distantes"
 
-#: locale/programs/locale.c:346
-msgid "while preparing output"
-msgstr "enquanto preparando sada"
+#: timezone/zic.c:2566
+msgid "two rules for same instant"
+msgstr "duas regras para o mesmo instante"
 
-#: db2/makedb.c:365 db2/makedb.c:382
-msgid "while reading database"
-msgstr "enquanto lendo database"
+#: timezone/zic.c:2627
+msgid "can't determine time zone abbreviation to use just after until time"
+msgstr "não é possível determinar abreviação de fuso horário para usar apenas após um tempo"
 
-#: elf/sprof.c:683
-msgid "while stat'ing profiling data file"
-msgstr "enquanto escrevendo arquivo data de dados de perfil"
+#: timezone/zic.c:2725
+msgid "too many local time types"
+msgstr "tipos de tempo local em excesso"
 
-#: db2/makedb.c:334
-msgid "while writing database file"
-msgstr "enquanto escrevendo arquivo data base"
+#: timezone/zic.c:2729
+msgid "UT offset out of range"
+msgstr "deslocamento de UT fora da faixa"
 
-#: nscd/nscd_stat.c:115
-msgid "write incomplete"
-msgstr "escrita incompleta"
+#: timezone/zic.c:2753
+msgid "too many leap seconds"
+msgstr "número excessivo de segundos bissextos"
 
-#: inet/rcmd.c:320
-msgid "writeable by other than owner"
-msgstr "permisso de escrita para outros"
+#: timezone/zic.c:2759
+msgid "repeated leap second moment"
+msgstr "momento de segundo bissexto repetido"
 
-#: db2/makedb.c:124 nscd/nscd.c:114 nss/getent.c:392
-msgid "wrong number of arguments"
-msgstr "nmero incorreto de argumentos"
+#: timezone/zic.c:2830
+msgid "Wild result from command execution"
+msgstr "Resultado insensato da execução do comando"
 
-#: timezone/zic.c:1090
-msgid "wrong number of fields on Leap line"
-msgstr "nmero incorreto de campos na linha Leap"
+#: timezone/zic.c:2831
+#, c-format
+msgid "%s: command was '%s', result was %d\n"
+msgstr "%s: comando era “%s”, resultado era %d\n"
 
-#: timezone/zic.c:1181
-msgid "wrong number of fields on Link line"
-msgstr "nmero incorreto de campos na linha Link"
+#: timezone/zic.c:2961
+msgid "Odd number of quotation marks"
+msgstr "Número ímpar de aspas"
 
-#: timezone/zic.c:924
-msgid "wrong number of fields on Rule line"
-msgstr "nmero incorreto de campos na linha Rule"
+#: timezone/zic.c:3046
+msgid "use of 2/29 in non leap-year"
+msgstr "uso de 2/29 em ano não bissexto"
 
-#: timezone/zic.c:994
-msgid "wrong number of fields on Zone continuation line"
-msgstr "nmero incorreto de campos na linha de continuao de Zone"
+#: timezone/zic.c:3081
+msgid "rule goes past start/end of month; will not work with pre-2004 versions of zic"
+msgstr "regra vai de início/fim do mês; não vai funcionar em versões pré-2004 do zic"
 
-#: timezone/zic.c:952
-msgid "wrong number of fields on Zone line"
-msgstr "nmero incorreto de campos na linha Zone"
+#: timezone/zic.c:3108
+msgid "time zone abbreviation has fewer than 3 characters"
+msgstr "abreviação de fuso horário possui menos de 3 caracteres"
 
-#: sunrpc/xdr_ref.c:84
-msgid "xdr_reference: out of memory\n"
-msgstr "xdr_reference: no h memria suficiente\n"
+#: timezone/zic.c:3110
+msgid "time zone abbreviation has too many characters"
+msgstr "abreviação de fuso horário possui um número excessivo de caracteres"
 
-#: sunrpc/xdr_rec.c:151 sunrpc/xdr_rec.c:166
-msgid "xdrrec_create: out of memory\n"
-msgstr "xdrrec_create: no h memria suficiente\n"
+#: timezone/zic.c:3112
+msgid "time zone abbreviation differs from POSIX standard"
+msgstr "abreviação de fuso horário difere do padrão POSIX"
 
-#: nis/ypclnt.c:884
-msgid "yp_update: cannot convert host to netname\n"
-msgstr "yp_update: no  possvel converter host para netname\n"
+#: timezone/zic.c:3118
+msgid "too many, or too long, time zone abbreviations"
+msgstr "abreviações de fuso horário em excesso ou muito extensas"
 
-#: nis/ypclnt.c:896
-msgid "yp_update: cannot get server address\n"
-msgstr "yp_update: no  possvel obter o endereo do servidor\n"
+#: timezone/zic.c:3161
+#, c-format
+msgid "%s: Can't create directory %s: %s"
+msgstr "%s: Não foi possível criar o diretório %s: %s"
diff --git a/posix/Makefile b/posix/Makefile
index 83b3d7418c..0fb280ba69 100644
--- a/posix/Makefile
+++ b/posix/Makefile
@@ -95,10 +95,10 @@ tests		:= test-errno tstgetopt testfnm runtests runptests \
 		   tst-posix_spawn-fd tst-posix_spawn-setsid \
 		   tst-posix_fadvise tst-posix_fadvise64 \
 		   tst-sysconf-empty-chroot tst-glob_symlinks tst-fexecve \
-		   tst-glob-tilde
+		   tst-glob-tilde tst-spawn4
 tests-internal	:= bug-regex5 bug-regex20 bug-regex33 \
 		   tst-rfc3484 tst-rfc3484-2 tst-rfc3484-3 \
-		   tst-glob_lstat_compat
+		   tst-glob_lstat_compat tst-spawn4-compat
 xtests		:= bug-ga2 tst-getaddrinfo4 tst-getaddrinfo5
 ifeq (yes,$(build-shared))
 test-srcs	:= globtest
diff --git a/posix/execvpe.c b/posix/execvpe.c
index 859c0f69bf..ea67d19fcd 100644
--- a/posix/execvpe.c
+++ b/posix/execvpe.c
@@ -67,11 +67,9 @@ maybe_script_execute (const char *file, char *const argv[], char *const envp[])
   __execve (new_argv[0], new_argv, envp);
 }
 
-
-/* Execute FILE, searching in the `PATH' environment variable if it contains
-   no slashes, with arguments ARGV and environment from ENVP.  */
-int
-__execvpe (const char *file, char *const argv[], char *const envp[])
+static int
+__execvpe_common (const char *file, char *const argv[], char *const envp[],
+	          bool exec_script)
 {
   /* We check the simple case first. */
   if (*file == '\0')
@@ -85,7 +83,7 @@ __execvpe (const char *file, char *const argv[], char *const envp[])
     {
       __execve (file, argv, envp);
 
-      if (errno == ENOEXEC)
+      if (errno == ENOEXEC && exec_script)
         maybe_script_execute (file, argv, envp);
 
       return -1;
@@ -137,7 +135,7 @@ __execvpe (const char *file, char *const argv[], char *const envp[])
 
       __execve (buffer, argv, envp);
 
-      if (errno == ENOEXEC)
+      if (errno == ENOEXEC && exec_script)
         /* This has O(P*C) behavior, where P is the length of the path and C
            is the argument count.  A better strategy would be allocate the
            substitute argv and reuse it each time through the loop (so it
@@ -184,4 +182,18 @@ __execvpe (const char *file, char *const argv[], char *const envp[])
   return -1;
 }
 
+/* Execute FILE, searching in the `PATH' environment variable if it contains
+   no slashes, with arguments ARGV and environment from ENVP.  */
+int
+__execvpe (const char *file, char *const argv[], char *const envp[])
+{
+  return __execvpe_common (file, argv, envp, true);
+}
 weak_alias (__execvpe, execvpe)
+
+/* Same as __EXECVPE, but does not try to execute NOEXEC files.  */
+int
+__execvpex (const char *file, char *const argv[], char *const envp[])
+{
+  return __execvpe_common (file, argv, envp, false);
+}
diff --git a/posix/glob.c b/posix/glob.c
index 8444b2f79e..1b389d2da1 100644
--- a/posix/glob.c
+++ b/posix/glob.c
@@ -827,31 +827,32 @@ __glob (const char *pattern, int flags, int (*errfunc) (const char *, int),
 	      {
 		size_t home_len = strlen (p->pw_dir);
 		size_t rest_len = end_name == NULL ? 0 : strlen (end_name);
-		char *d;
+		char *d, *newp;
+		bool use_alloca = glob_use_alloca (alloca_used,
+						   home_len + rest_len + 1);
 
-		if (__glibc_unlikely (malloc_dirname))
-		  free (dirname);
-		malloc_dirname = 0;
-
-		if (glob_use_alloca (alloca_used, home_len + rest_len + 1))
-		  dirname = alloca_account (home_len + rest_len + 1,
-					    alloca_used);
+		if (use_alloca)
+		  newp = alloca_account (home_len + rest_len + 1, alloca_used);
 		else
 		  {
-		    dirname = malloc (home_len + rest_len + 1);
-		    if (dirname == NULL)
+		    newp = malloc (home_len + rest_len + 1);
+		    if (newp == NULL)
 		      {
 			scratch_buffer_free (&pwtmpbuf);
 			retval = GLOB_NOSPACE;
 			goto out;
 		      }
-		    malloc_dirname = 1;
 		  }
-		d = mempcpy (dirname, p->pw_dir, home_len);
+		d = mempcpy (newp, p->pw_dir, home_len);
 		if (end_name != NULL)
 		  d = mempcpy (d, end_name, rest_len);
 		*d = '\0';
 
+		if (__glibc_unlikely (malloc_dirname))
+		  free (dirname);
+		dirname = newp;
+		malloc_dirname = !use_alloca;
+
 		dirlen = home_len + rest_len;
 		dirname_modified = 1;
 	      }
diff --git a/posix/regexec.c b/posix/regexec.c
index 4b1ab4ecff..21129432d1 100644
--- a/posix/regexec.c
+++ b/posix/regexec.c
@@ -3848,30 +3848,27 @@ check_node_accept_bytes (const re_dfa_t *dfa, int node_idx,
 	      indirect = (const int32_t *)
 		_NL_CURRENT (LC_COLLATE, _NL_COLLATE_INDIRECTMB);
 	      int32_t idx = findidx (table, indirect, extra, &cp, elem_len);
+	      int32_t rule = idx >> 24;
+	      idx &= 0xffffff;
 	      if (idx > 0)
-		for (i = 0; i < cset->nequiv_classes; ++i)
-		  {
-		    int32_t equiv_class_idx = cset->equiv_classes[i];
-		    size_t weight_len = weights[idx & 0xffffff];
-		    if (weight_len == weights[equiv_class_idx & 0xffffff]
-			&& (idx >> 24) == (equiv_class_idx >> 24))
-		      {
-			int cnt = 0;
-
-			idx &= 0xffffff;
-			equiv_class_idx &= 0xffffff;
-
-			while (cnt <= weight_len
-			       && (weights[equiv_class_idx + 1 + cnt]
-				   == weights[idx + 1 + cnt]))
-			  ++cnt;
-			if (cnt > weight_len)
-			  {
-			    match_len = elem_len;
-			    goto check_node_accept_bytes_match;
-			  }
-		      }
-		  }
+		{
+		  size_t weight_len = weights[idx];
+		  for (i = 0; i < cset->nequiv_classes; ++i)
+		    {
+		      int32_t equiv_class_idx = cset->equiv_classes[i];
+		      int32_t equiv_class_rule = equiv_class_idx >> 24;
+		      equiv_class_idx &= 0xffffff;
+		      if (weights[equiv_class_idx] == weight_len
+			  && equiv_class_rule == rule
+			  && memcmp (weights + idx + 1,
+				     weights + equiv_class_idx + 1,
+				     weight_len) == 0)
+			{
+			  match_len = elem_len;
+			  goto check_node_accept_bytes_match;
+			}
+		    }
+		}
 	    }
 	}
       else
diff --git a/posix/tst-glob_lstat_compat.c b/posix/tst-glob_lstat_compat.c
index c46bc9e578..22cd1f02f9 100644
--- a/posix/tst-glob_lstat_compat.c
+++ b/posix/tst-glob_lstat_compat.c
@@ -35,7 +35,14 @@
 #if TEST_COMPAT (libc, GLIBC_2_0, GLIBC_2_27)
 
 __typeof (glob) glob;
+/* On alpha glob exists in version GLIBC_2_0, GLIBC_2_1, and GLIBC_2_27.
+   This test needs to access the version prior to GLIBC_2_27, which is
+   GLIBC_2_1 on alpha, GLIBC_2_0 elsewhere.  */
+# ifdef __alpha__
+compat_symbol_reference (libc, glob, glob, GLIBC_2_1);
+# else
 compat_symbol_reference (libc, glob, glob, GLIBC_2_0);
+# endif
 
 /* Compat glob should not call gl_lstat since for some old binaries it
    might be unitialized (for instance GNUmake).  Check if it is indeed
diff --git a/posix/tst-mmap-offset.c b/posix/tst-mmap-offset.c
index 92ea794c5a..cf17ba077c 100644
--- a/posix/tst-mmap-offset.c
+++ b/posix/tst-mmap-offset.c
@@ -1,4 +1,4 @@
-/* BZ #18877 and #21270 mmap offset test.
+/* BZ #18877, BZ #21270, and BZ #24699 mmap offset test.
 
    Copyright (C) 2015-2018 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -24,6 +24,7 @@
 #include <unistd.h>
 #include <errno.h>
 #include <sys/mman.h>
+#include <mmap_info.h>
 
 #include <support/check.h>
 
@@ -76,7 +77,7 @@ do_test_bz18877 (void)
 
 /* Check if invalid offset are handled correctly by mmap.  */
 static int
-do_test_bz21270 (void)
+do_test_large_offset (void)
 {
   /* For architectures with sizeof (off_t) < sizeof (off64_t) mmap is
      implemented with __SYS_mmap2 syscall and the offset is represented in
@@ -90,7 +91,7 @@ do_test_bz21270 (void)
   const size_t length = 4096;
 
   void *addr = mmap64 (NULL, length, prot, flags, fd, offset);
-  if (sizeof (off_t) < sizeof (off64_t))
+  if (mmap64_maximum_offset (page_shift) < UINT64_MAX)
     {
       if ((addr != MAP_FAILED) && (errno != EINVAL))
 	FAIL_RET ("mmap succeed");
@@ -110,7 +111,7 @@ do_test (void)
   int ret = 0;
 
   ret += do_test_bz18877 ();
-  ret += do_test_bz21270 ();
+  ret += do_test_large_offset ();
 
   return ret;
 }
diff --git a/posix/tst-rfc3484-2.c b/posix/tst-rfc3484-2.c
index f509534ca9..8c64ac59ff 100644
--- a/posix/tst-rfc3484-2.c
+++ b/posix/tst-rfc3484-2.c
@@ -58,6 +58,7 @@ _res_hconf_init (void)
 #undef	USE_NSCD
 #include "../sysdeps/posix/getaddrinfo.c"
 
+service_user *__nss_hosts_database attribute_hidden;
 
 /* This is the beginning of the real test code.  The above defines
    (among other things) the function rfc3484_sort.  */
diff --git a/posix/tst-rfc3484-3.c b/posix/tst-rfc3484-3.c
index ae44087a10..1c61aaf844 100644
--- a/posix/tst-rfc3484-3.c
+++ b/posix/tst-rfc3484-3.c
@@ -58,6 +58,7 @@ _res_hconf_init (void)
 #undef	USE_NSCD
 #include "../sysdeps/posix/getaddrinfo.c"
 
+service_user *__nss_hosts_database attribute_hidden;
 
 /* This is the beginning of the real test code.  The above defines
    (among other things) the function rfc3484_sort.  */
diff --git a/posix/tst-rfc3484.c b/posix/tst-rfc3484.c
index 7f191abbbc..8f45848e44 100644
--- a/posix/tst-rfc3484.c
+++ b/posix/tst-rfc3484.c
@@ -58,6 +58,7 @@ _res_hconf_init (void)
 #undef	USE_NSCD
 #include "../sysdeps/posix/getaddrinfo.c"
 
+service_user *__nss_hosts_database attribute_hidden;
 
 /* This is the beginning of the real test code.  The above defines
    (among other things) the function rfc3484_sort.  */
diff --git a/posix/tst-spawn4-compat.c b/posix/tst-spawn4-compat.c
new file mode 100644
index 0000000000..11f654b913
--- /dev/null
+++ b/posix/tst-spawn4-compat.c
@@ -0,0 +1,77 @@
+/* Check if posix_spawn does handle correctly ENOEXEC files.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <spawn.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+
+#include <support/xunistd.h>
+#include <support/check.h>
+#include <support/temp_file.h>
+
+#include <shlib-compat.h>
+#if TEST_COMPAT (libc, GLIBC_2_0, GLIBC_2_15)
+
+compat_symbol_reference (libc, posix_spawn, posix_spawn, GLIBC_2_2);
+compat_symbol_reference (libc, posix_spawnp, posix_spawnp, GLIBC_2_2);
+
+static int
+do_test (void)
+{
+  char *scriptname;
+  int fd = create_temp_file ("tst-spawn4.", &scriptname);
+  TEST_VERIFY_EXIT (fd >= 0);
+
+  const char script[] = "exit 65";
+  xwrite (fd, script, sizeof (script) - 1);
+  xclose (fd);
+
+  TEST_VERIFY_EXIT (chmod (scriptname, 0x775) == 0);
+
+  pid_t pid;
+  int status;
+
+  /* For compat symbol it verifies that trying to issued a shell script
+     without a shebang is correctly executed.  */
+  status = posix_spawn (&pid, scriptname, NULL, NULL, (char *[]) { 0 },
+                        (char *[]) { 0 });
+  TEST_VERIFY_EXIT (status == 0);
+
+  TEST_VERIFY_EXIT (waitpid (pid, &status, 0) == pid);
+  TEST_VERIFY_EXIT (WIFEXITED (status) == 1 && WEXITSTATUS (status) == 65);
+
+  status = posix_spawnp (&pid, scriptname, NULL, NULL, (char *[]) { 0 },
+                         (char *[]) { 0 });
+  TEST_VERIFY_EXIT (status == 0);
+
+  TEST_VERIFY_EXIT (waitpid (pid, &status, 0) == pid);
+  TEST_VERIFY_EXIT (WIFEXITED (status) == 1 && WEXITSTATUS (status) == 65);
+
+  return 0;
+}
+#else
+static int
+do_test (void)
+{
+  return 77;
+}
+#endif
+
+#include <support/test-driver.c>
diff --git a/posix/tst-spawn4.c b/posix/tst-spawn4.c
new file mode 100644
index 0000000000..e4a1fa3f00
--- /dev/null
+++ b/posix/tst-spawn4.c
@@ -0,0 +1,56 @@
+/* Check if posix_spawn does handle correctly ENOEXEC files.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <spawn.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/stat.h>
+
+#include <support/xunistd.h>
+#include <support/check.h>
+#include <support/temp_file.h>
+
+static int
+do_test (void)
+{
+  char *scriptname;
+  int fd = create_temp_file ("tst-spawn4.", &scriptname);
+  TEST_VERIFY_EXIT (fd >= 0);
+
+  const char script[] = "echo it should not happen";
+  xwrite (fd, script, sizeof (script) - 1);
+  xclose (fd);
+
+  TEST_VERIFY_EXIT (chmod (scriptname, 0x775) == 0);
+
+  pid_t pid;
+  int status;
+
+  /* Check if scripts without shebang are correctly not executed.  */
+  status = posix_spawn (&pid, scriptname, NULL, NULL, (char *[]) { 0 },
+                        (char *[]) { 0 });
+  TEST_VERIFY_EXIT (status == ENOEXEC);
+
+  status = posix_spawnp (&pid, scriptname, NULL, NULL, (char *[]) { 0 },
+                         (char *[]) { 0 });
+  TEST_VERIFY_EXIT (status == ENOEXEC);
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/posix/wordexp-test.c b/posix/wordexp-test.c
index cc29840355..30c1dd65ef 100644
--- a/posix/wordexp-test.c
+++ b/posix/wordexp-test.c
@@ -200,6 +200,7 @@ struct test_case_struct
     { 0, NULL, "$var", 0, 0, { NULL, }, IFS },
     { 0, NULL, "\"\\n\"", 0, 1, { "\\n", }, IFS },
     { 0, NULL, "", 0, 0, { NULL, }, IFS },
+    { 0, NULL, "${1234567890123456789012}", 0, 0, { NULL, }, IFS },
 
     /* Flags not already covered (testit() has special handling for these) */
     { 0, NULL, "one two", WRDE_DOOFFS, 2, { "one", "two", }, IFS },
diff --git a/posix/wordexp.c b/posix/wordexp.c
index 8e33ad95b0..b13b0d4b20 100644
--- a/posix/wordexp.c
+++ b/posix/wordexp.c
@@ -1407,7 +1407,7 @@ envsubst:
   /* Is it a numeric parameter? */
   else if (isdigit (env[0]))
     {
-      int n = atoi (env);
+      unsigned long n = strtoul (env, NULL, 10);
 
       if (n >= __libc_argc)
 	/* Substitute NULL. */
diff --git a/resolv/gai_misc.c b/resolv/gai_misc.c
index e7c3b63cc5..80a2cff835 100644
--- a/resolv/gai_misc.c
+++ b/resolv/gai_misc.c
@@ -261,8 +261,11 @@ __gai_enqueue_request (struct gaicb *gaicbp)
 	      /* We cannot create a thread in the moment and there is
 		 also no thread running.  This is a problem.  `errno' is
 		 set to EAGAIN if this is only a temporary problem.  */
-	      assert (lastp->next == newp);
-	      lastp->next = NULL;
+	      assert (requests == newp || lastp->next == newp);
+	      if (lastp != NULL)
+		lastp->next = NULL;
+	      else
+		requests = NULL;
 	      requests_tail = lastp;
 
 	      newp->next = freelist;
diff --git a/resolv/res_send.c b/resolv/res_send.c
index dde0425a33..9e9541789b 100644
--- a/resolv/res_send.c
+++ b/resolv/res_send.c
@@ -471,6 +471,11 @@ __res_context_send (struct resolv_context *ctx,
 					'\0',
 					sizeof (struct sockaddr_in6)
 					- sizeof (struct sockaddr_in));
+			else
+			  {
+			    __set_errno (ENOMEM);
+			    return -1;
+			  }
 		}
 		EXT(statp).nscount = statp->nscount;
 	}
@@ -1152,25 +1157,27 @@ send_dg(res_state statp,
 		if (have_sendmmsg >= 0 && nwritten == 0 && buf2 != NULL
 		    && !single_request)
 		  {
-		    struct iovec iov[2];
-		    struct mmsghdr reqs[2];
-		    reqs[0].msg_hdr.msg_name = NULL;
-		    reqs[0].msg_hdr.msg_namelen = 0;
-		    reqs[0].msg_hdr.msg_iov = &iov[0];
-		    reqs[0].msg_hdr.msg_iovlen = 1;
-		    iov[0].iov_base = (void *) buf;
-		    iov[0].iov_len = buflen;
-		    reqs[0].msg_hdr.msg_control = NULL;
-		    reqs[0].msg_hdr.msg_controllen = 0;
-
-		    reqs[1].msg_hdr.msg_name = NULL;
-		    reqs[1].msg_hdr.msg_namelen = 0;
-		    reqs[1].msg_hdr.msg_iov = &iov[1];
-		    reqs[1].msg_hdr.msg_iovlen = 1;
-		    iov[1].iov_base = (void *) buf2;
-		    iov[1].iov_len = buflen2;
-		    reqs[1].msg_hdr.msg_control = NULL;
-		    reqs[1].msg_hdr.msg_controllen = 0;
+		    struct iovec iov =
+		      { .iov_base = (void *) buf, .iov_len = buflen };
+		    struct iovec iov2 =
+		      { .iov_base = (void *) buf2, .iov_len = buflen2 };
+		    struct mmsghdr reqs[2] =
+		      {
+			{
+			  .msg_hdr =
+			    {
+			      .msg_iov = &iov,
+			      .msg_iovlen = 1,
+			    },
+			},
+			{
+			  .msg_hdr =
+			    {
+			      .msg_iov = &iov2,
+			      .msg_iovlen = 1,
+			    }
+			},
+		      };
 
 		    int ndg = __sendmmsg (pfd[0].fd, reqs, 2, MSG_NOSIGNAL);
 		    if (__glibc_likely (ndg == 2))
diff --git a/resolv/tst-resolv-network.c b/resolv/tst-resolv-network.c
index 4b862d57e6..735e38d0f8 100644
--- a/resolv/tst-resolv-network.c
+++ b/resolv/tst-resolv-network.c
@@ -149,6 +149,9 @@ handle_code (const struct resolv_response_context *ctx,
           resolv_response_add_data (b, &rrtype, sizeof (rrtype));
         }
       break;
+    case 104:
+      send_ptr (b, qname, qclass, qtype, "host.example");
+      break;
     default:
       FAIL_EXIT1 ("invalid QNAME: %s (code %d)", qname, code);
     }
@@ -257,6 +260,9 @@ do_test (void)
                 "error: TRY_AGAIN\n");
   check_netent ("code103.example", getnetbyname ("code103.example"),
                 "error: NO_RECOVERY\n");
+  /* Test bug #17630.  */
+  check_netent ("code104.example", getnetbyname ("code104.example"),
+                "error: TRY_AGAIN\n");
 
   /* Lookup by address, success cases.  */
   check_reverse (1,
diff --git a/signal/Makefile b/signal/Makefile
index a9b99a20be..aa63434f47 100644
--- a/signal/Makefile
+++ b/signal/Makefile
@@ -46,7 +46,7 @@ routines	:= signal raise killpg \
 		   sighold sigrelse sigignore sigset
 
 tests		:= tst-signal tst-sigset tst-sigsimple tst-raise tst-sigset2 \
-  tst-sigwait-eintr \
+		   tst-sigwait-eintr tst-sigaction \
 
 include ../Rules
 
diff --git a/signal/tst-sigaction.c b/signal/tst-sigaction.c
new file mode 100644
index 0000000000..c908e8f6f6
--- /dev/null
+++ b/signal/tst-sigaction.c
@@ -0,0 +1,56 @@
+/* Test sigaction regression for BZ #23069.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <signal.h>
+#include <unistd.h>
+
+#include <support/check.h>
+
+static void
+my_sig_handler (int signum)
+{
+}
+
+static int
+do_test (void)
+{
+  /* Define a simple signal handler */
+  struct sigaction act;
+  act.sa_handler = my_sig_handler;
+  act.sa_flags = 0;
+  sigemptyset (&act.sa_mask);
+
+  /* Set it as SIGUSR1 signal handler */
+  TEST_VERIFY_EXIT (sigaction (SIGUSR1, &act, NULL) == 0);
+
+  /* Get SIGUSR1 signal handler */
+  TEST_VERIFY_EXIT (sigaction (SIGUSR1, NULL, &act) == 0);
+
+  /* Check it is consistent with the defined one */
+  TEST_VERIFY (act.sa_handler == my_sig_handler);
+  TEST_VERIFY (!(act.sa_flags & SA_RESETHAND));
+
+  for (int i = 1; i < _NSIG; i++)
+    {
+      TEST_VERIFY (!sigismember (&act.sa_mask, i));
+    }
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/stdio-common/tst-printf.c b/stdio-common/tst-printf.c
index d73f0cc34e..70d9e584b3 100644
--- a/stdio-common/tst-printf.c
+++ b/stdio-common/tst-printf.c
@@ -69,77 +69,7 @@ fmtst2chk (const char *fmt)
   (void) printf(fmt, 4, 4, 0x12);
   (void) printf("'\n");
 }
-
-/* This page is covered by the following copyright: */
-
-/* (C) Copyright C E Chew
- *
- * Feel free to copy, use and distribute this software provided:
- *
- *	1. you do not pretend that you wrote it
- *	2. you leave this copyright notice intact.
- */
-
-/*
- * Extracted from exercise.c for glibc-1.05 bug report by Bruce Evans.
- */
-
-#define DEC -123
-#define INT 255
-#define UNS (~0)
 
-/* Formatted Output Test
- *
- * This exercises the output formatting code.
- */
-
-static void
-fp_test (void)
-{
-  int i, j, k, l;
-  char buf[7];
-  char *prefix = buf;
-  char tp[20];
-
-  puts("\nFormatted output test");
-  printf("prefix  6d      6o      6x      6X      6u\n");
-  strcpy(prefix, "%");
-  for (i = 0; i < 2; i++) {
-    for (j = 0; j < 2; j++) {
-      for (k = 0; k < 2; k++) {
-	for (l = 0; l < 2; l++) {
-	  strcpy(prefix, "%");
-	  if (i == 0) strcat(prefix, "-");
-	  if (j == 0) strcat(prefix, "+");
-	  if (k == 0) strcat(prefix, "#");
-	  if (l == 0) strcat(prefix, "0");
-	  printf("%5s |", prefix);
-	  strcpy(tp, prefix);
-	  strcat(tp, "6d |");
-	  printf(tp, DEC);
-	  strcpy(tp, prefix);
-	  strcat(tp, "6o |");
-	  printf(tp, INT);
-	  strcpy(tp, prefix);
-	  strcat(tp, "6x |");
-	  printf(tp, INT);
-	  strcpy(tp, prefix);
-	  strcat(tp, "6X |");
-	  printf(tp, INT);
-	  strcpy(tp, prefix);
-	  strcat(tp, "6u |");
-	  printf(tp, UNS);
-	  printf("\n");
-	}
-      }
-    }
-  }
-  printf("%10s\n", (char *) NULL);
-  printf("%-10s\n", (char *) NULL);
-  printf("%.8f\n", DBL_MAX);
-  printf("%.8f\n", -DBL_MAX);
-}
-
 static int
 do_test (void)
 {
@@ -239,8 +169,8 @@ I am ready for my first lesson today.";
 	    snprintf(buf2, sizeof(buf2), "%.999999u", 10));
   }
 
-  fp_test ();
-
+  printf("%.8f\n", DBL_MAX);
+  printf("%.8f\n", -DBL_MAX);
   printf ("%e should be 1.234568e+06\n", 1234567.8);
   printf ("%f should be 1234567.800000\n", 1234567.8);
   printf ("%g should be 1.23457e+06\n", 1234567.8);
diff --git a/stdio-common/tst-printf.sh b/stdio-common/tst-printf.sh
index 93bfe03c6f..b543cc646c 100644
--- a/stdio-common/tst-printf.sh
+++ b/stdio-common/tst-printf.sh
@@ -105,27 +105,6 @@ something really insane: 1.00000000000000000000000000000000000000000000000000000
 | 123456.0000|  1.2346e+05|   1.235e+05|
 snprintf ("%30s", "foo") == 30, "                   "
 snprintf ("%.999999u", 10) == 999999
-
-Formatted output test
-prefix  6d      6o      6x      6X      6u
-%-+#0 |-123   |0377   |0xff   |0XFF   |4294967295 |
- %-+# |-123   |0377   |0xff   |0XFF   |4294967295 |
- %-+0 |-123   |377    |ff     |FF     |4294967295 |
-  %-+ |-123   |377    |ff     |FF     |4294967295 |
- %-#0 |-123   |0377   |0xff   |0XFF   |4294967295 |
-  %-# |-123   |0377   |0xff   |0XFF   |4294967295 |
-  %-0 |-123   |377    |ff     |FF     |4294967295 |
-   %- |-123   |377    |ff     |FF     |4294967295 |
- %+#0 |-00123 |000377 |0x00ff |0X00FF |4294967295 |
-  %+# |  -123 |  0377 |  0xff |  0XFF |4294967295 |
-  %+0 |-00123 |000377 |0000ff |0000FF |4294967295 |
-   %+ |  -123 |   377 |    ff |    FF |4294967295 |
-  %#0 |-00123 |000377 |0x00ff |0X00FF |4294967295 |
-   %# |  -123 |  0377 |  0xff |  0XFF |4294967295 |
-   %0 |-00123 |000377 |0000ff |0000FF |4294967295 |
-    % |  -123 |   377 |    ff |    FF |4294967295 |
-    (null)
-(null)    
 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
 -179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
 1.234568e+06 should be 1.234568e+06
@@ -225,27 +204,6 @@ something really insane: 1.00000000000000000000000000000000000000000000000000000
 | 123456.0000|  1.2346e+05|   1.235e+05|
 snprintf ("%30s", "foo") == 30, "                   "
 snprintf ("%.999999u", 10) == 999999
-
-Formatted output test
-prefix  6d      6o      6x      6X      6u
-%-+#0 |-123   |0377   |0xff   |0XFF   |4294967295 |
- %-+# |-123   |0377   |0xff   |0XFF   |4294967295 |
- %-+0 |-123   |377    |ff     |FF     |4294967295 |
-  %-+ |-123   |377    |ff     |FF     |4294967295 |
- %-#0 |-123   |0377   |0xff   |0XFF   |4294967295 |
-  %-# |-123   |0377   |0xff   |0XFF   |4294967295 |
-  %-0 |-123   |377    |ff     |FF     |4294967295 |
-   %- |-123   |377    |ff     |FF     |4294967295 |
- %+#0 |-00123 |000377 |0x00ff |0X00FF |4294967295 |
-  %+# |  -123 |  0377 |  0xff |  0XFF |4294967295 |
-  %+0 |-00123 |000377 |0000ff |0000FF |4294967295 |
-   %+ |  -123 |   377 |    ff |    FF |4294967295 |
-  %#0 |-00123 |000377 |0x00ff |0X00FF |4294967295 |
-   %# |  -123 |  0377 |  0xff |  0XFF |4294967295 |
-   %0 |-00123 |000377 |0000ff |0000FF |4294967295 |
-    % |  -123 |   377 |    ff |    FF |4294967295 |
-    (null)
-(null)    
 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
 -179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.00000000
 1.234568e+06 should be 1.234568e+06
diff --git a/stdlib/Makefile b/stdlib/Makefile
index 7c363a6e4d..a9ad849531 100644
--- a/stdlib/Makefile
+++ b/stdlib/Makefile
@@ -84,7 +84,7 @@ tests		:= tst-strtol tst-strtod testmb testrand testsort testdiv   \
 		   tst-cxa_atexit tst-on_exit test-atexit-race 		    \
 		   test-at_quick_exit-race test-cxa_atexit-race             \
 		   test-on_exit-race test-dlclose-exit-race 		    \
-		   tst-makecontext-align
+		   tst-makecontext-align test-bz22786
 
 tests-internal	:= tst-strtod1i tst-strtod3 tst-strtod4 tst-strtod5i \
 		   tst-tls-atexit tst-tls-atexit-nodelete
diff --git a/stdlib/canonicalize.c b/stdlib/canonicalize.c
index 30825a91b8..432fc82b4a 100644
--- a/stdlib/canonicalize.c
+++ b/stdlib/canonicalize.c
@@ -181,7 +181,7 @@ __realpath (const char *name, char *resolved)
 		extra_buf = __alloca (path_max);
 
 	      len = strlen (end);
-	      if ((long int) (n + len) >= path_max)
+	      if (path_max - n <= len)
 		{
 		  __set_errno (ENAMETOOLONG);
 		  goto error;
diff --git a/stdlib/random_r.c b/stdlib/random_r.c
index 4d2f0d472f..b47c65c6d7 100644
--- a/stdlib/random_r.c
+++ b/stdlib/random_r.c
@@ -361,8 +361,7 @@ __random_r (struct random_data *buf, int32_t *result)
 
   if (buf->rand_type == TYPE_0)
     {
-      int32_t val = state[0];
-      val = ((state[0] * 1103515245) + 12345) & 0x7fffffff;
+      int32_t val = ((state[0] * 1103515245U) + 12345U) & 0x7fffffff;
       state[0] = val;
       *result = val;
     }
@@ -371,11 +370,11 @@ __random_r (struct random_data *buf, int32_t *result)
       int32_t *fptr = buf->fptr;
       int32_t *rptr = buf->rptr;
       int32_t *end_ptr = buf->end_ptr;
-      int32_t val;
+      uint32_t val;
 
-      val = *fptr += *rptr;
+      val = *fptr += (uint32_t) *rptr;
       /* Chucking least random bit.  */
-      *result = (val >> 1) & 0x7fffffff;
+      *result = val >> 1;
       ++fptr;
       if (fptr >= end_ptr)
 	{
diff --git a/stdlib/test-bz22786.c b/stdlib/test-bz22786.c
new file mode 100644
index 0000000000..e7837f98c1
--- /dev/null
+++ b/stdlib/test-bz22786.c
@@ -0,0 +1,90 @@
+/* Bug 22786: test for buffer overflow in realpath.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This file must be run from within a directory called "stdlib".  */
+
+#include <errno.h>
+#include <limits.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <support/test-driver.h>
+#include <libc-diag.h>
+
+static int
+do_test (void)
+{
+  const char dir[] = "bz22786";
+  const char lnk[] = "bz22786/symlink";
+
+  rmdir (dir);
+  if (mkdir (dir, 0755) != 0 && errno != EEXIST)
+    {
+      printf ("mkdir %s: %m\n", dir);
+      return EXIT_FAILURE;
+    }
+  if (symlink (".", lnk) != 0 && errno != EEXIST)
+    {
+      printf ("symlink (%s, %s): %m\n", dir, lnk);
+      return EXIT_FAILURE;
+    }
+
+  const size_t path_len = (size_t) INT_MAX + 1;
+
+  DIAG_PUSH_NEEDS_COMMENT;
+#if __GNUC_PREREQ (7, 0)
+  /* GCC 7 warns about too-large allocations; here we need such
+     allocation to succeed for the test to work.  */
+  DIAG_IGNORE_NEEDS_COMMENT (7, "-Walloc-size-larger-than=");
+#endif
+  char *path = malloc (path_len);
+  DIAG_POP_NEEDS_COMMENT;
+
+  if (path == NULL)
+    {
+      printf ("malloc (%zu): %m\n", path_len);
+      return EXIT_UNSUPPORTED;
+    }
+
+  /* Construct very long path = "bz22786/symlink/aaaa....."  */
+  char *p = mempcpy (path, lnk, sizeof (lnk) - 1);
+  *(p++) = '/';
+  memset (p, 'a', path_len - (path - p) - 2);
+  p[path_len - (path - p) - 1] = '\0';
+
+  /* This call crashes before the fix for bz22786 on 32-bit platforms.  */
+  p = realpath (path, NULL);
+
+  if (p != NULL || errno != ENAMETOOLONG)
+    {
+      printf ("realpath: %s (%m)", p);
+      return EXIT_FAILURE;
+    }
+
+  /* Cleanup.  */
+  unlink (lnk);
+  rmdir (dir);
+
+  return 0;
+}
+
+#define TEST_FUNCTION do_test
+#include <support/test-driver.c>
diff --git a/string/memmem.c b/string/memmem.c
index c17e1cf6a6..7fbe1cb5d6 100644
--- a/string/memmem.c
+++ b/string/memmem.c
@@ -15,67 +15,115 @@
    License along with the GNU C Library; if not, see
    <http://www.gnu.org/licenses/>.  */
 
-/* This particular implementation was written by Eric Blake, 2008.  */
-
 #ifndef _LIBC
 # include <config.h>
 #endif
 
-/* Specification of memmem.  */
 #include <string.h>
 
 #ifndef _LIBC
-# define __builtin_expect(expr, val)   (expr)
 # define __memmem	memmem
 #endif
 
 #define RETURN_TYPE void *
 #define AVAILABLE(h, h_l, j, n_l) ((j) <= (h_l) - (n_l))
+#define FASTSEARCH(S,C,N) (void*) memchr ((void *)(S), (C), (N))
 #include "str-two-way.h"
 
 #undef memmem
 
-/* Return the first occurrence of NEEDLE in HAYSTACK.  Return HAYSTACK
-   if NEEDLE_LEN is 0, otherwise NULL if NEEDLE is not found in
-   HAYSTACK.  */
+/* Hash character pairs so a small shift table can be used.  All bits of
+   p[0] are included, but not all bits from p[-1].  So if two equal hashes
+   match on p[-1], p[0] matches too.  Hash collisions are harmless and result
+   in smaller shifts.  */
+#define hash2(p) (((size_t)(p)[0] - ((size_t)(p)[-1] << 3)) % sizeof (shift))
+
+/* Fast memmem algorithm with guaranteed linear-time performance.
+   Small needles up to size 2 use a dedicated linear search.  Longer needles
+   up to size 256 use a novel modified Horspool algorithm.  It hashes pairs
+   of characters to quickly skip past mismatches.  The main search loop only
+   exits if the last 2 characters match, avoiding unnecessary calls to memcmp
+   and allowing for a larger skip if there is no match.  A self-adapting
+   filtering check is used to quickly detect mismatches in long needles.
+   By limiting the needle length to 256, the shift table can be reduced to 8
+   bits per entry, lowering preprocessing overhead and minimizing cache effects.
+   The limit also implies worst-case performance is linear.
+   Needles larger than 256 characters use the linear-time Two-Way algorithm.  */
 void *
-__memmem (const void *haystack_start, size_t haystack_len,
-	  const void *needle_start, size_t needle_len)
+__memmem (const void *haystack, size_t hs_len,
+	  const void *needle, size_t ne_len)
 {
-  /* Abstract memory is considered to be an array of 'unsigned char' values,
-     not an array of 'char' values.  See ISO C 99 section 6.2.6.1.  */
-  const unsigned char *haystack = (const unsigned char *) haystack_start;
-  const unsigned char *needle = (const unsigned char *) needle_start;
-
-  if (needle_len == 0)
-    /* The first occurrence of the empty string is deemed to occur at
-       the beginning of the string.  */
-    return (void *) haystack;
-
-  /* Sanity check, otherwise the loop might search through the whole
-     memory.  */
-  if (__glibc_unlikely (haystack_len < needle_len))
+  const unsigned char *hs = (const unsigned char *) haystack;
+  const unsigned char *ne = (const unsigned char *) needle;
+
+  if (ne_len == 0)
+    return (void *) hs;
+  if (ne_len == 1)
+    return (void *) memchr (hs, ne[0], hs_len);
+
+  /* Ensure haystack length is >= needle length.  */
+  if (hs_len < ne_len)
     return NULL;
 
-  /* Use optimizations in memchr when possible, to reduce the search
-     size of haystack using a linear algorithm with a smaller
-     coefficient.  However, avoid memchr for long needles, since we
-     can often achieve sublinear performance.  */
-  if (needle_len < LONG_NEEDLE_THRESHOLD)
+  const unsigned char *end = hs + hs_len - ne_len;
+
+  if (ne_len == 2)
+    {
+      uint32_t nw = ne[0] << 16 | ne[1], hw = hs[0] << 16 | hs[1];
+      for (hs++; hs <= end && hw != nw; )
+	hw = hw << 16 | *++hs;
+      return hw == nw ? (void *)hs - 1 : NULL;
+    }
+
+  /* Use Two-Way algorithm for very long needles.  */
+  if (__builtin_expect (ne_len > 256, 0))
+    return two_way_long_needle (hs, hs_len, ne, ne_len);
+
+  uint8_t shift[256];
+  size_t tmp, shift1;
+  size_t m1 = ne_len - 1;
+  size_t offset = 0;
+
+  memset (shift, 0, sizeof (shift));
+  for (int i = 1; i < m1; i++)
+    shift[hash2 (ne + i)] = i;
+  /* Shift1 is the amount we can skip after matching the hash of the
+     needle end but not the full needle.  */
+  shift1 = m1 - shift[hash2 (ne + m1)];
+  shift[hash2 (ne + m1)] = m1;
+
+  for ( ; hs <= end; )
     {
-      haystack = memchr (haystack, *needle, haystack_len);
-      if (!haystack || __builtin_expect (needle_len == 1, 0))
-	return (void *) haystack;
-      haystack_len -= haystack - (const unsigned char *) haystack_start;
-      if (haystack_len < needle_len)
-	return NULL;
-      return two_way_short_needle (haystack, haystack_len, needle, needle_len);
+      /* Skip past character pairs not in the needle.  */
+      do
+	{
+	  hs += m1;
+	  tmp = shift[hash2 (hs)];
+	}
+      while (tmp == 0 && hs <= end);
+
+      /* If the match is not at the end of the needle, shift to the end
+	 and continue until we match the hash of the needle end.  */
+      hs -= tmp;
+      if (tmp < m1)
+	continue;
+
+      /* Hash of the last 2 characters matches.  If the needle is long,
+	 try to quickly filter out mismatches.  */
+      if (m1 < 15 || memcmp (hs + offset, ne + offset, 8) == 0)
+	{
+	  if (memcmp (hs, ne, m1) == 0)
+	    return (void *) hs;
+
+	  /* Adjust filter offset when it doesn't find the mismatch.  */
+	  offset = (offset >= 8 ? offset : m1) - 8;
+	}
+
+      /* Skip based on matching the hash of the needle end.  */
+      hs += shift1;
     }
-  else
-    return two_way_long_needle (haystack, haystack_len, needle, needle_len);
+  return NULL;
 }
 libc_hidden_def (__memmem)
 weak_alias (__memmem, memmem)
 libc_hidden_weak (memmem)
-
-#undef LONG_NEEDLE_THRESHOLD
diff --git a/string/str-two-way.h b/string/str-two-way.h
index cd2605857d..358959bef0 100644
--- a/string/str-two-way.h
+++ b/string/str-two-way.h
@@ -221,7 +221,7 @@ critical_factorization (const unsigned char *needle, size_t needle_len,
    most 2 * HAYSTACK_LEN - NEEDLE_LEN comparisons occur in searching.
    If AVAILABLE modifies HAYSTACK_LEN (as in strstr), then at most 3 *
    HAYSTACK_LEN - NEEDLE_LEN comparisons occur in searching.  */
-static RETURN_TYPE
+static inline RETURN_TYPE
 two_way_short_needle (const unsigned char *haystack, size_t haystack_len,
 		      const unsigned char *needle, size_t needle_len)
 {
@@ -281,50 +281,50 @@ two_way_short_needle (const unsigned char *haystack, size_t haystack_len,
     }
   else
     {
-      const unsigned char *phaystack = &haystack[suffix];
+      const unsigned char *phaystack;
       /* The comparison always starts from needle[suffix], so cache it
 	 and use an optimized first-character loop.  */
       unsigned char needle_suffix = CANON_ELEMENT (needle[suffix]);
 
-#if CHECK_EOL
-      /* We start matching from the SUFFIX'th element, so make sure we
-	 don't hit '\0' before that.  */
-      if (haystack_len < suffix + 1
-	  && !AVAILABLE (haystack, haystack_len, 0, suffix + 1))
-	return NULL;
-#endif
-
       /* The two halves of needle are distinct; no extra memory is
 	 required, and any mismatch results in a maximal shift.  */
       period = MAX (suffix, needle_len - suffix) + 1;
       j = 0;
-      while (1
-#if !CHECK_EOL
-	     && AVAILABLE (haystack, haystack_len, j, needle_len)
-#endif
-	     )
+      while (AVAILABLE (haystack, haystack_len, j, needle_len))
 	{
 	  unsigned char haystack_char;
 	  const unsigned char *pneedle;
 
-	  /* TODO: The first-character loop can be sped up by adapting
-	     longword-at-a-time implementation of memchr/strchr.  */
-	  if (needle_suffix
+	  phaystack = &haystack[suffix + j];
+
+#ifdef FASTSEARCH
+	  if (*phaystack++ != needle_suffix)
+	    {
+	      phaystack = FASTSEARCH (phaystack, needle_suffix,
+				      haystack_len - needle_len - j);
+	      if (phaystack == NULL)
+		goto ret0;
+	      j = phaystack - &haystack[suffix];
+	      phaystack++;
+	    }
+#else
+	  while (needle_suffix
 	      != (haystack_char = CANON_ELEMENT (*phaystack++)))
 	    {
 	      RET0_IF_0 (haystack_char);
-#if !CHECK_EOL
+# if !CHECK_EOL
 	      ++j;
-#endif
-	      continue;
+	      if (!AVAILABLE (haystack, haystack_len, j, needle_len))
+		goto ret0;
+# endif
 	    }
 
-#if CHECK_EOL
+# if CHECK_EOL
 	  /* Calculate J if it wasn't kept up-to-date in the first-character
 	     loop.  */
 	  j = phaystack - &haystack[suffix] - 1;
+# endif
 #endif
-
 	  /* Scan for matches in right half.  */
 	  i = suffix + 1;
 	  pneedle = &needle[i];
@@ -338,6 +338,11 @@ two_way_short_needle (const unsigned char *haystack, size_t haystack_len,
 		}
 	      ++i;
 	    }
+#if CHECK_EOL
+	  /* Update minimal length of haystack.  */
+	  if (phaystack > haystack + haystack_len)
+	    haystack_len = phaystack - haystack;
+#endif
 	  if (needle_len <= i)
 	    {
 	      /* Scan for matches in left half.  */
@@ -360,13 +365,6 @@ two_way_short_needle (const unsigned char *haystack, size_t haystack_len,
 	    }
 	  else
 	    j += i - suffix + 1;
-
-#if CHECK_EOL
-	  if (!AVAILABLE (haystack, haystack_len, j, needle_len))
-	    break;
-#endif
-
-	  phaystack = &haystack[suffix + j];
 	}
     }
  ret0: __attribute__ ((unused))
@@ -384,8 +382,11 @@ two_way_short_needle (const unsigned char *haystack, size_t haystack_len,
    and sublinear performance O(HAYSTACK_LEN / NEEDLE_LEN) is possible.
    If AVAILABLE modifies HAYSTACK_LEN (as in strstr), then at most 3 *
    HAYSTACK_LEN - NEEDLE_LEN comparisons occur in searching, and
-   sublinear performance is not possible.  */
-static RETURN_TYPE
+   sublinear performance is not possible.
+
+   Since this function is large and complex, block inlining to avoid
+   slowing down the common case of small needles.  */
+__attribute__((noinline)) static RETURN_TYPE
 two_way_long_needle (const unsigned char *haystack, size_t haystack_len,
 		     const unsigned char *needle, size_t needle_len)
 {
diff --git a/string/strcasestr.c b/string/strcasestr.c
index 90ba189790..8aa76037dc 100644
--- a/string/strcasestr.c
+++ b/string/strcasestr.c
@@ -37,8 +37,9 @@
 /* Two-Way algorithm.  */
 #define RETURN_TYPE char *
 #define AVAILABLE(h, h_l, j, n_l)			\
-  (!memchr ((h) + (h_l), '\0', (j) + (n_l) - (h_l))	\
-   && ((h_l) = (j) + (n_l)))
+  (((j) + (n_l) <= (h_l)) \
+   || ((h_l) += __strnlen ((void*)((h) + (h_l)), (n_l) + 512), \
+       (j) + (n_l) <= (h_l)))
 #define CHECK_EOL (1)
 #define RET0_IF_0(a) if (!a) goto ret0
 #define CANON_ELEMENT(c) TOLOWER (c)
@@ -58,31 +59,22 @@
    case-insensitive comparison.  This function gives unspecified
    results in multibyte locales.  */
 char *
-STRCASESTR (const char *haystack_start, const char *needle_start)
+STRCASESTR (const char *haystack, const char *needle)
 {
-  const char *haystack = haystack_start;
-  const char *needle = needle_start;
   size_t needle_len; /* Length of NEEDLE.  */
   size_t haystack_len; /* Known minimum length of HAYSTACK.  */
-  bool ok = true; /* True if NEEDLE is prefix of HAYSTACK.  */
-
-  /* Determine length of NEEDLE, and in the process, make sure
-     HAYSTACK is at least as long (no point processing all of a long
-     NEEDLE if HAYSTACK is too short).  */
-  while (*haystack && *needle)
-    {
-      ok &= (TOLOWER ((unsigned char) *haystack)
-	     == TOLOWER ((unsigned char) *needle));
-      haystack++;
-      needle++;
-    }
-  if (*needle)
+
+  /* Handle empty NEEDLE special case.  */
+  if (needle[0] == '\0')
+    return (char *) haystack;
+
+  /* Ensure HAYSTACK length is at least as long as NEEDLE length.
+     Since a match may occur early on in a huge HAYSTACK, use strnlen
+     and read ahead a few cachelines for improved performance.  */
+  needle_len = strlen (needle);
+  haystack_len = __strnlen (haystack, needle_len + 256);
+  if (haystack_len < needle_len)
     return NULL;
-  if (ok)
-    return (char *) haystack_start;
-  needle_len = needle - needle_start;
-  haystack = haystack_start + 1;
-  haystack_len = needle_len - 1;
 
   /* Perform the search.  Abstract memory is considered to be an array
      of 'unsigned char' values, not an array of 'char' values.  See
@@ -90,10 +82,10 @@ STRCASESTR (const char *haystack_start, const char *needle_start)
   if (needle_len < LONG_NEEDLE_THRESHOLD)
     return two_way_short_needle ((const unsigned char *) haystack,
 				 haystack_len,
-				 (const unsigned char *) needle_start,
+				 (const unsigned char *) needle,
 				 needle_len);
   return two_way_long_needle ((const unsigned char *) haystack, haystack_len,
-			      (const unsigned char *) needle_start,
+			      (const unsigned char *) needle,
 			      needle_len);
 }
 
diff --git a/string/string.h b/string/string.h
index 150cfd8b13..22cd0fa08f 100644
--- a/string/string.h
+++ b/string/string.h
@@ -33,7 +33,8 @@ __BEGIN_DECLS
 #include <stddef.h>
 
 /* Tell the caller that we provide correct C++ prototypes.  */
-#if defined __cplusplus && __GNUC_PREREQ (4, 4)
+#if defined __cplusplus && (__GNUC_PREREQ (4, 4) \
+			    || __glibc_clang_prereq (3, 5))
 # define __CORRECT_ISO_CPP_STRING_H_PROTO
 #endif
 
diff --git a/string/strstr.c b/string/strstr.c
index b3b5deb673..7ffb18ab42 100644
--- a/string/strstr.c
+++ b/string/strstr.c
@@ -16,27 +16,17 @@
    License along with the GNU C Library; if not, see
    <http://www.gnu.org/licenses/>.  */
 
-/* This particular implementation was written by Eric Blake, 2008.  */
-
 #ifndef _LIBC
 # include <config.h>
 #endif
 
-/* Specification of strstr.  */
 #include <string.h>
 
-#include <stdbool.h>
-
-#ifndef _LIBC
-# define __builtin_expect(expr, val)   (expr)
-#endif
-
 #define RETURN_TYPE char *
 #define AVAILABLE(h, h_l, j, n_l)			\
-  (!memchr ((h) + (h_l), '\0', (j) + (n_l) - (h_l))	\
-   && ((h_l) = (j) + (n_l)))
-#define CHECK_EOL (1)
-#define RET0_IF_0(a) if (!a) goto ret0
+  (((j) + (n_l) <= (h_l)) \
+   || ((h_l) += __strnlen ((void*)((h) + (h_l)), (n_l) + 512), \
+       (j) + (n_l) <= (h_l)))
 #include "str-two-way.h"
 
 #undef strstr
@@ -45,48 +35,128 @@
 #define STRSTR strstr
 #endif
 
-/* Return the first occurrence of NEEDLE in HAYSTACK.  Return HAYSTACK
-   if NEEDLE is empty, otherwise NULL if NEEDLE is not found in
-   HAYSTACK.  */
+static inline char *
+strstr2 (const unsigned char *hs, const unsigned char *ne)
+{
+  uint32_t h1 = (ne[0] << 16) | ne[1];
+  uint32_t h2 = 0;
+  for (int c = hs[0]; h1 != h2 && c != 0; c = *++hs)
+      h2 = (h2 << 16) | c;
+  return h1 == h2 ? (char *)hs - 2 : NULL;
+}
+
+static inline char *
+strstr3 (const unsigned char *hs, const unsigned char *ne)
+{
+  uint32_t h1 = ((uint32_t)ne[0] << 24) | (ne[1] << 16) | (ne[2] << 8);
+  uint32_t h2 = 0;
+  for (int c = hs[0]; h1 != h2 && c != 0; c = *++hs)
+      h2 = (h2 | c) << 8;
+  return h1 == h2 ? (char *)hs - 3 : NULL;
+}
+
+/* Hash character pairs so a small shift table can be used.  All bits of
+   p[0] are included, but not all bits from p[-1].  So if two equal hashes
+   match on p[-1], p[0] matches too.  Hash collisions are harmless and result
+   in smaller shifts.  */
+#define hash2(p) (((size_t)(p)[0] - ((size_t)(p)[-1] << 3)) % sizeof (shift))
+
+/* Fast strstr algorithm with guaranteed linear-time performance.
+   Small needles up to size 3 use a dedicated linear search.  Longer needles
+   up to size 256 use a novel modified Horspool algorithm.  It hashes pairs
+   of characters to quickly skip past mismatches.  The main search loop only
+   exits if the last 2 characters match, avoiding unnecessary calls to memcmp
+   and allowing for a larger skip if there is no match.  A self-adapting
+   filtering check is used to quickly detect mismatches in long needles.
+   By limiting the needle length to 256, the shift table can be reduced to 8
+   bits per entry, lowering preprocessing overhead and minimizing cache effects.
+   The limit also implies worst-case performance is linear.
+   Needles larger than 256 characters use the linear-time Two-Way algorithm.  */
 char *
-STRSTR (const char *haystack_start, const char *needle_start)
+STRSTR (const char *haystack, const char *needle)
 {
-  const char *haystack = haystack_start;
-  const char *needle = needle_start;
-  size_t needle_len; /* Length of NEEDLE.  */
-  size_t haystack_len; /* Known minimum length of HAYSTACK.  */
-  bool ok = true; /* True if NEEDLE is prefix of HAYSTACK.  */
-
-  /* Determine length of NEEDLE, and in the process, make sure
-     HAYSTACK is at least as long (no point processing all of a long
-     NEEDLE if HAYSTACK is too short).  */
-  while (*haystack && *needle)
-    ok &= *haystack++ == *needle++;
-  if (*needle)
+  const unsigned char *hs = (const unsigned char *) haystack;
+  const unsigned char *ne = (const unsigned char *) needle;
+
+  /* Handle short needle special cases first.  */
+  if (ne[0] == '\0')
+    return (char *)hs;
+  hs = (const unsigned char *)strchr ((const char*)hs, ne[0]);
+  if (hs == NULL || ne[1] == '\0')
+    return (char*)hs;
+  if (ne[2] == '\0')
+    return strstr2 (hs, ne);
+  if (ne[3] == '\0')
+    return strstr3 (hs, ne);
+
+  /* Ensure haystack length is at least as long as needle length.
+     Since a match may occur early on in a huge haystack, use strnlen
+     and read ahead a few cachelines for improved performance.  */
+  size_t ne_len = strlen ((const char*)ne);
+  size_t hs_len = __strnlen ((const char*)hs, ne_len | 512);
+  if (hs_len < ne_len)
     return NULL;
-  if (ok)
-    return (char *) haystack_start;
-
-  /* Reduce the size of haystack using strchr, since it has a smaller
-     linear coefficient than the Two-Way algorithm.  */
-  needle_len = needle - needle_start;
-  haystack = strchr (haystack_start + 1, *needle_start);
-  if (!haystack || __builtin_expect (needle_len == 1, 0))
-    return (char *) haystack;
-  needle -= needle_len;
-  haystack_len = (haystack > haystack_start + needle_len ? 1
-		  : needle_len + haystack_start - haystack);
-
-  /* Perform the search.  Abstract memory is considered to be an array
-     of 'unsigned char' values, not an array of 'char' values.  See
-     ISO C 99 section 6.2.6.1.  */
-  if (needle_len < LONG_NEEDLE_THRESHOLD)
-    return two_way_short_needle ((const unsigned char *) haystack,
-				 haystack_len,
-				 (const unsigned char *) needle, needle_len);
-  return two_way_long_needle ((const unsigned char *) haystack, haystack_len,
-			      (const unsigned char *) needle, needle_len);
+
+  /* Check whether we have a match.  This improves performance since we
+     avoid initialization overheads.  */
+  if (memcmp (hs, ne, ne_len) == 0)
+    return (char *) hs;
+
+  /* Use Two-Way algorithm for very long needles.  */
+  if (__glibc_unlikely (ne_len > 256))
+    return two_way_long_needle (hs, hs_len, ne, ne_len);
+
+  const unsigned char *end = hs + hs_len - ne_len;
+  uint8_t shift[256];
+  size_t tmp, shift1;
+  size_t m1 = ne_len - 1;
+  size_t offset = 0;
+
+  /* Initialize bad character shift hash table.  */
+  memset (shift, 0, sizeof (shift));
+  for (int i = 1; i < m1; i++)
+    shift[hash2 (ne + i)] = i;
+  /* Shift1 is the amount we can skip after matching the hash of the
+     needle end but not the full needle.  */
+  shift1 = m1 - shift[hash2 (ne + m1)];
+  shift[hash2 (ne + m1)] = m1;
+
+  while (1)
+    {
+      if (__glibc_unlikely (hs > end))
+	{
+	  end += __strnlen ((const char*)end + m1 + 1, 2048);
+	  if (hs > end)
+	    return NULL;
+	}
+
+      /* Skip past character pairs not in the needle.  */
+      do
+	{
+	  hs += m1;
+	  tmp = shift[hash2 (hs)];
+	}
+      while (tmp == 0 && hs <= end);
+
+      /* If the match is not at the end of the needle, shift to the end
+	 and continue until we match the hash of the needle end.  */
+      hs -= tmp;
+      if (tmp < m1)
+	continue;
+
+      /* Hash of the last 2 characters matches.  If the needle is long,
+	 try to quickly filter out mismatches.  */
+      if (m1 < 15 || memcmp (hs + offset, ne + offset, 8) == 0)
+	{
+	  if (memcmp (hs, ne, m1) == 0)
+	    return (void *) hs;
+
+	  /* Adjust filter offset when it doesn't find the mismatch.  */
+	  offset = (offset >= 8 ? offset : m1) - 8;
+	}
+
+      /* Skip based on matching the hash of the needle end.  */
+      hs += shift1;
+    }
 }
 libc_hidden_builtin_def (strstr)
-
-#undef LONG_NEEDLE_THRESHOLD
diff --git a/string/test-memcpy.c b/string/test-memcpy.c
index 45f20a6d80..3c8066da52 100644
--- a/string/test-memcpy.c
+++ b/string/test-memcpy.c
@@ -212,6 +212,50 @@ do_random_tests (void)
     }
 }
 
+static void
+do_test1 (void)
+{
+  size_t size = 0x100000;
+  void *large_buf;
+
+  large_buf = mmap (NULL, size * 2 + page_size, PROT_READ | PROT_WRITE,
+		    MAP_PRIVATE | MAP_ANON, -1, 0);
+  if (large_buf == MAP_FAILED)
+    {
+      puts ("Failed to allocat large_buf, skipping do_test1");
+      return;
+    }
+
+  if (mprotect (large_buf + size, page_size, PROT_NONE))
+    error (EXIT_FAILURE, errno, "mprotect failed");
+
+  size_t arrary_size = size / sizeof (uint32_t);
+  uint32_t *dest = large_buf;
+  uint32_t *src = large_buf + size + page_size;
+  size_t i;
+
+  for (i = 0; i < arrary_size; i++)
+    src[i] = (uint32_t) i;
+
+  FOR_EACH_IMPL (impl, 0)
+    {
+      memset (dest, -1, size);
+      CALL (impl, (char *) dest, (char *) src, size);
+      for (i = 0; i < arrary_size; i++)
+	if (dest[i] != src[i])
+	  {
+	    error (0, 0,
+		   "Wrong result in function %s dst \"%p\" src \"%p\" offset \"%zd\"",
+		   impl->name, dest, src, i);
+	    ret = 1;
+	    break;
+	  }
+    }
+
+  munmap ((void *) dest, size);
+  munmap ((void *) src, size);
+}
+
 int
 test_main (void)
 {
@@ -253,6 +297,9 @@ test_main (void)
   do_test (0, 0, getpagesize ());
 
   do_random_tests ();
+
+  do_test1 ();
+
   return ret;
 }
 
diff --git a/string/test-memmove.c b/string/test-memmove.c
index edc7a4c3bf..64e3651ba4 100644
--- a/string/test-memmove.c
+++ b/string/test-memmove.c
@@ -24,6 +24,7 @@
 # define TEST_NAME "memmove"
 #endif
 #include "test-string.h"
+#include <support/test-driver.h>
 
 char *simple_memmove (char *, const char *, size_t);
 
@@ -245,6 +246,60 @@ do_random_tests (void)
     }
 }
 
+static void
+do_test2 (void)
+{
+  size_t size = 0x20000000;
+  uint32_t * large_buf;
+
+  large_buf = mmap ((void*) 0x70000000, size, PROT_READ | PROT_WRITE,
+		    MAP_PRIVATE | MAP_ANON, -1, 0);
+
+  if (large_buf == MAP_FAILED)
+    error (EXIT_UNSUPPORTED, errno, "Large mmap failed");
+
+  if ((uintptr_t) large_buf > 0x80000000 - 128
+      || 0x80000000 - (uintptr_t) large_buf > 0x20000000)
+    {
+      error (0, 0, "Large mmap allocated improperly");
+      ret = EXIT_UNSUPPORTED;
+      munmap ((void *) large_buf, size);
+      return;
+    }
+
+  size_t bytes_move = 0x80000000 - (uintptr_t) large_buf;
+  size_t arr_size = bytes_move / sizeof (uint32_t);
+  size_t i;
+
+  FOR_EACH_IMPL (impl, 0)
+    {
+      for (i = 0; i < arr_size; i++)
+        large_buf[i] = (uint32_t) i;
+
+      uint32_t * dst = &large_buf[33];
+
+#ifdef TEST_BCOPY
+      CALL (impl, (char *) large_buf, (char *) dst, bytes_move);
+#else
+      CALL (impl, (char *) dst, (char *) large_buf, bytes_move);
+#endif
+
+      for (i = 0; i < arr_size; i++)
+	{
+	  if (dst[i] != (uint32_t) i)
+	    {
+	      error (0, 0,
+		     "Wrong result in function %s dst \"%p\" src \"%p\" offset \"%zd\"",
+		     impl->name, dst, large_buf, i);
+	      ret = 1;
+	      break;
+	    }
+	}
+    }
+
+  munmap ((void *) large_buf, size);
+}
+
 int
 test_main (void)
 {
@@ -284,6 +339,9 @@ test_main (void)
     }
 
   do_random_tests ();
+
+  do_test2 ();
+
   return ret;
 }
 
diff --git a/string/test-mempcpy.c b/string/test-mempcpy.c
index c08fba895e..d98ecdd2d9 100644
--- a/string/test-mempcpy.c
+++ b/string/test-mempcpy.c
@@ -18,6 +18,7 @@
    <http://www.gnu.org/licenses/>.  */
 
 #define MEMCPY_RESULT(dst, len) (dst) + (len)
+#define MIN_PAGE_SIZE 131072
 #define TEST_MAIN
 #define TEST_NAME "mempcpy"
 #include "test-string.h"
diff --git a/string/test-strcasestr.c b/string/test-strcasestr.c
index 2b0a38ea73..9b1088df54 100644
--- a/string/test-strcasestr.c
+++ b/string/test-strcasestr.c
@@ -25,6 +25,7 @@
 #define STRCASESTR simple_strcasestr
 #define NO_ALIAS
 #define __strncasecmp strncasecmp
+#define __strnlen strnlen
 #include "strcasestr.c"
 
 
diff --git a/string/test-strstr.c b/string/test-strstr.c
index acf6ff8224..5861b01b73 100644
--- a/string/test-strstr.c
+++ b/string/test-strstr.c
@@ -24,6 +24,7 @@
 
 #define STRSTR simple_strstr
 #define libc_hidden_builtin_def(arg) /* nothing */
+#define __strnlen strnlen
 #include "strstr.c"
 
 
@@ -150,6 +151,32 @@ check2 (void)
     }
 }
 
+#define N 1024
+
+static void
+pr23637 (void)
+{
+  char *h = (char*) buf1;
+  char *n = (char*) buf2;
+
+  for (int i = 0; i < N; i++)
+    {
+      n[i] = 'x';
+      h[i] = ' ';
+      h[i + N] = 'x';
+    }
+
+  n[N] = '\0';
+  h[N * 2] = '\0';
+
+  /* Ensure we don't match at the first 'x'.  */
+  h[0] = 'x';
+
+  char *exp_result = stupid_strstr (h, n);
+  FOR_EACH_IMPL (impl, 0)
+    check_result (impl, h, n, exp_result);
+}
+
 static int
 test_main (void)
 {
@@ -157,6 +184,7 @@ test_main (void)
 
   check1 ();
   check2 ();
+  pr23637 ();
 
   printf ("%23s", "");
   FOR_EACH_IMPL (impl, 0)
@@ -201,6 +229,9 @@ test_main (void)
 	do_test (15, 9, hlen, klen, 1);
 	do_test (15, 15, hlen, klen, 0);
 	do_test (15, 15, hlen, klen, 1);
+
+	do_test (15, 15, hlen + klen * 4, klen * 4, 0);
+	do_test (15, 15, hlen + klen * 4, klen * 4, 1);
       }
 
   do_test (0, 0, page_size - 1, 16, 0);
diff --git a/sunrpc/rpc_common.c b/sunrpc/rpc_common.c
index 710191163c..2d42827a87 100644
--- a/sunrpc/rpc_common.c
+++ b/sunrpc/rpc_common.c
@@ -46,7 +46,14 @@
    the variable is declared.  So we use the section attribute.  */
 struct opaque_auth _null_auth __attribute__ ((nocommon));
 libc_hidden_nolink_sunrpc (_null_auth, GLIBC_2_0)
-fd_set svc_fdset;
-struct rpc_createerr rpc_createerr;
-struct pollfd *svc_pollfd;
-int svc_max_pollfd;
+
+/* The variables need the nocommon attribute, so that it is possible
+   to create aliases and specify symbol versions.  */
+fd_set svc_fdset  __attribute__ ((nocommon));
+libc_hidden_nolink_sunrpc (svc_fdset, GLIBC_2_0)
+struct rpc_createerr rpc_createerr  __attribute__ ((nocommon));
+libc_hidden_nolink_sunrpc (rpc_createerr, GLIBC_2_0)
+struct pollfd *svc_pollfd  __attribute__ ((nocommon));
+libc_hidden_nolink_sunrpc (svc_pollfd, GLIBC_2_2)
+int svc_max_pollfd  __attribute__ ((nocommon));
+libc_hidden_nolink_sunrpc (svc_max_pollfd, GLIBC_2_2)
diff --git a/sunrpc/svcauth_des.c b/sunrpc/svcauth_des.c
index f99a5a324f..9ce4804239 100644
--- a/sunrpc/svcauth_des.c
+++ b/sunrpc/svcauth_des.c
@@ -87,16 +87,21 @@ static void cache_ref (uint32_t sid); /* note that sid was ref'd */
 
 static void invalidate (char *cred); /* invalidate entry in cache */
 
-/*
- * cache statistics
- */
+/* Cache statistics.  Accidental historic export without a matching
+   declaration in any header file.  */
+#ifndef SHARED
+static
+#endif
 struct
   {
     u_long ncachehits;		/* times cache hit, and is not replay */
     u_long ncachereplays;	/* times cache hit, and is replay */
     u_long ncachemisses;	/* times cache missed */
   }
-svcauthdes_stats;
+svcauthdes_stats __attribute__ ((nocommon));
+#ifdef SHARED
+compat_symbol (libc, svcauthdes_stats, svcauthdes_stats, GLIBC_2_0);
+#endif
 
 /*
  * Service side authenticator for AUTH_DES
diff --git a/support/Makefile b/support/Makefile
index 1bda81e55e..e88a144096 100644
--- a/support/Makefile
+++ b/support/Makefile
@@ -43,6 +43,7 @@ libsupport-routines = \
   support_capture_subprocess \
   support_capture_subprocess_check \
   support_chroot \
+  support_descriptors \
   support_enter_mount_namespace \
   support_enter_network_namespace \
   support_format_address_family \
@@ -52,10 +53,15 @@ libsupport-routines = \
   support_format_hostent \
   support_format_netent \
   support_isolate_in_subprocess \
+  support_openpty \
+  support_quote_blob \
+  support_quote_string \
   support_record_failure \
   support_run_diff \
   support_shared_allocate \
+  support_test_compare_blob \
   support_test_compare_failure \
+  support_test_compare_string \
   support_write_file_string \
   support_test_main \
   support_test_verify_impl \
@@ -95,6 +101,9 @@ libsupport-routines = \
   xpthread_barrier_destroy \
   xpthread_barrier_init \
   xpthread_barrier_wait \
+  xpthread_barrierattr_destroy \
+  xpthread_barrierattr_init \
+  xpthread_barrierattr_setpshared \
   xpthread_cancel \
   xpthread_check_return \
   xpthread_cond_wait \
@@ -127,6 +136,7 @@ libsupport-routines = \
   xrealloc \
   xrecvfrom \
   xsendto \
+  xsetlocale \
   xsetsockopt \
   xsigaction \
   xsignal \
@@ -149,9 +159,14 @@ tests = \
   README-testing \
   tst-support-namespace \
   tst-support_capture_subprocess \
+  tst-support_descriptors \
   tst-support_format_dns_packet \
+  tst-support_quote_blob \
+  tst-support_quote_string \
   tst-support_record_failure \
   tst-test_compare \
+  tst-test_compare_blob \
+  tst-test_compare_string \
   tst-xreadlink \
 
 ifeq ($(run-built-tests),yes)
diff --git a/support/check.h b/support/check.h
index 2192f38941..7ea9a86a9c 100644
--- a/support/check.h
+++ b/support/check.h
@@ -64,6 +64,8 @@ __BEGIN_DECLS
         (1, __FILE__, __LINE__, #expr);                         \
   })
 
+
+
 int support_print_failure_impl (const char *file, int line,
                                 const char *format, ...)
   __attribute__ ((nonnull (1), format (printf, 3, 4)));
@@ -141,6 +143,39 @@ void support_test_compare_failure (const char *file, int line,
                                    int right_size);
 
 
+/* Compare [LEFT, LEFT + LEFT_LENGTH) with [RIGHT, RIGHT +
+   RIGHT_LENGTH) and report a test failure if the arrays are
+   different.  LEFT_LENGTH and RIGHT_LENGTH are measured in bytes.  If
+   the length is null, the corresponding pointer is ignored (i.e., it
+   can be NULL).  The blobs should be reasonably short because on
+   mismatch, both are printed.  */
+#define TEST_COMPARE_BLOB(left, left_length, right, right_length)       \
+  (support_test_compare_blob (left, left_length, right, right_length,   \
+                              __FILE__, __LINE__,                       \
+                              #left, #left_length, #right, #right_length))
+
+void support_test_compare_blob (const void *left,
+                                unsigned long int left_length,
+                                const void *right,
+                                unsigned long int right_length,
+                                const char *file, int line,
+                                const char *left_exp, const char *left_len_exp,
+                                const char *right_exp,
+                                const char *right_len_exp);
+
+/* Compare the strings LEFT and RIGHT and report a test failure if
+   they are different.  Also report failure if one of the arguments is
+   a null pointer and the other is not.  The strings should be
+   reasonably short because on mismatch, both are printed.  */
+#define TEST_COMPARE_STRING(left, right)                         \
+  (support_test_compare_string (left, right, __FILE__, __LINE__, \
+                                #left, #right))
+
+void support_test_compare_string (const char *left, const char *right,
+                                  const char *file, int line,
+                                  const char *left_expr,
+                                  const char *right_expr);
+
 /* Internal function called by the test driver.  */
 int support_report_failure (int status)
   __attribute__ ((weak, warn_unused_result));
@@ -148,6 +183,10 @@ int support_report_failure (int status)
 /* Internal function used to test the failure recording framework.  */
 void support_record_failure_reset (void);
 
+/* Returns true or false depending on whether there have been test
+   failures or not.  */
+int support_record_failure_is_failed (void);
+
 __END_DECLS
 
 #endif /* SUPPORT_CHECK_H */
diff --git a/support/descriptors.h b/support/descriptors.h
new file mode 100644
index 0000000000..8ec4cbbdfb
--- /dev/null
+++ b/support/descriptors.h
@@ -0,0 +1,47 @@
+/* Monitoring file descriptor usage.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef SUPPORT_DESCRIPTORS_H
+#define SUPPORT_DESCRIPTORS_H
+
+#include <stdio.h>
+
+/* Opaque pointer, for capturing file descriptor lists.  */
+struct support_descriptors;
+
+/* Record the currently open file descriptors and store them in the
+   returned list.  Terminate the process if the listing operation
+   fails.  */
+struct support_descriptors *support_descriptors_list (void);
+
+/* Deallocate the list of descriptors.  */
+void support_descriptors_free (struct support_descriptors *);
+
+/* Write the list of descriptors to STREAM, adding PREFIX to each
+   line.  */
+void support_descriptors_dump (struct support_descriptors *,
+                               const char *prefix, FILE *stream);
+
+/* Check for file descriptor leaks and other file descriptor changes:
+   Compare the current list of descriptors with the passed list.
+   Record a test failure if there are additional open descriptors,
+   descriptors have been closed, or if a change in file descriptor can
+   be detected.  */
+void support_descriptors_check (struct support_descriptors *);
+
+#endif /* SUPPORT_DESCRIPTORS_H */
diff --git a/support/support.h b/support/support.h
index bc5827ed87..e2de14cf83 100644
--- a/support/support.h
+++ b/support/support.h
@@ -59,6 +59,17 @@ void support_shared_free (void *);
    process on error.  */
 void support_write_file_string (const char *path, const char *contents);
 
+/* Quote the contents of the byte array starting at BLOB, of LENGTH
+   bytes, in such a way that the result string can be included in a C
+   literal (in single/double quotes, without putting the quotes into
+   the result).  */
+char *support_quote_blob (const void *blob, size_t length);
+
+/* Quote the contents of the string, in such a way that the result
+   string can be included in a C literal (in single/double quotes,
+   without putting the quotes into the result).  */
+char *support_quote_string (const char *);
+
 /* Error-checking wrapper functions which terminate the process on
    error.  */
 
@@ -69,6 +80,7 @@ char *xasprintf (const char *format, ...)
   __attribute__ ((format (printf, 1, 2), malloc));
 char *xstrdup (const char *);
 char *xstrndup (const char *, size_t);
+char *xsetlocale (int category, const char *locale);
 
 __END_DECLS
 
diff --git a/support/support_capture_subprocess.c b/support/support_capture_subprocess.c
index 6d2029e13b..93f6ea3102 100644
--- a/support/support_capture_subprocess.c
+++ b/support/support_capture_subprocess.c
@@ -59,8 +59,12 @@ support_capture_subprocess (void (*callback) (void *), void *closure)
 
   int stdout_pipe[2];
   xpipe (stdout_pipe);
+  TEST_VERIFY (stdout_pipe[0] > STDERR_FILENO);
+  TEST_VERIFY (stdout_pipe[1] > STDERR_FILENO);
   int stderr_pipe[2];
   xpipe (stderr_pipe);
+  TEST_VERIFY (stderr_pipe[0] > STDERR_FILENO);
+  TEST_VERIFY (stderr_pipe[1] > STDERR_FILENO);
 
   TEST_VERIFY (fflush (stdout) == 0);
   TEST_VERIFY (fflush (stderr) == 0);
@@ -72,6 +76,8 @@ support_capture_subprocess (void (*callback) (void *), void *closure)
       xclose (stderr_pipe[0]);
       xdup2 (stdout_pipe[1], STDOUT_FILENO);
       xdup2 (stderr_pipe[1], STDERR_FILENO);
+      xclose (stdout_pipe[1]);
+      xclose (stderr_pipe[1]);
       callback (closure);
       _exit (0);
     }
diff --git a/support/support_descriptors.c b/support/support_descriptors.c
new file mode 100644
index 0000000000..d66cf55080
--- /dev/null
+++ b/support/support_descriptors.c
@@ -0,0 +1,274 @@
+/* Monitoring file descriptor usage.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <dirent.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <support/check.h>
+#include <support/support.h>
+#include <sys/stat.h>
+#include <sys/sysmacros.h>
+#include <xunistd.h>
+
+struct procfs_descriptor
+{
+  int fd;
+  char *link_target;
+  dev_t dev;
+  ino64_t ino;
+};
+
+/* Used with qsort.  */
+static int
+descriptor_compare (const void *l, const void *r)
+{
+  const struct procfs_descriptor *left = l;
+  const struct procfs_descriptor *right = r;
+  /* Cannot overflow due to limited file descriptor range.  */
+  return left->fd - right->fd;
+}
+
+#define DYNARRAY_STRUCT descriptor_list
+#define DYNARRAY_ELEMENT struct procfs_descriptor
+#define DYNARRAY_PREFIX descriptor_list_
+#define DYNARRAY_ELEMENT_FREE(e) free ((e)->link_target)
+#define DYNARRAY_INITIAL_SIZE 0
+#include <malloc/dynarray-skeleton.c>
+
+struct support_descriptors
+{
+  struct descriptor_list list;
+};
+
+struct support_descriptors *
+support_descriptors_list (void)
+{
+  struct support_descriptors *result = xmalloc (sizeof (*result));
+  descriptor_list_init (&result->list);
+
+  DIR *fds = opendir ("/proc/self/fd");
+  if (fds == NULL)
+    FAIL_EXIT1 ("opendir (\"/proc/self/fd\"): %m");
+
+  while (true)
+    {
+      errno = 0;
+      struct dirent64 *e = readdir64 (fds);
+      if (e == NULL)
+        {
+          if (errno != 0)
+            FAIL_EXIT1 ("readdir: %m");
+          break;
+        }
+
+      if (e->d_name[0] == '.')
+        continue;
+
+      char *endptr;
+      long int fd = strtol (e->d_name, &endptr, 10);
+      if (*endptr != '\0' || fd < 0 || fd > INT_MAX)
+        FAIL_EXIT1 ("readdir: invalid file descriptor name: /proc/self/fd/%s",
+                    e->d_name);
+
+      /* Skip the descriptor which is used to enumerate the
+         descriptors.  */
+      if (fd == dirfd (fds))
+        continue;
+
+      char *target;
+      {
+        char *path = xasprintf ("/proc/self/fd/%ld", fd);
+        target = xreadlink (path);
+        free (path);
+      }
+      struct stat64 st;
+      if (fstat64 (fd, &st) != 0)
+        FAIL_EXIT1 ("readdir: fstat64 (%ld) failed: %m", fd);
+
+      struct procfs_descriptor *item = descriptor_list_emplace (&result->list);
+      if (item == NULL)
+        FAIL_EXIT1 ("descriptor_list_emplace: %m");
+      item->fd = fd;
+      item->link_target = target;
+      item->dev = st.st_dev;
+      item->ino = st.st_ino;
+    }
+
+  closedir (fds);
+
+  /* Perform a merge join between descrs and current.  This assumes
+     that the arrays are sorted by file descriptor.  */
+
+  qsort (descriptor_list_begin (&result->list),
+         descriptor_list_size (&result->list),
+         sizeof (struct procfs_descriptor), descriptor_compare);
+
+  return result;
+}
+
+void
+support_descriptors_free (struct support_descriptors *descrs)
+{
+  descriptor_list_free (&descrs->list);
+  free (descrs);
+}
+
+void
+support_descriptors_dump (struct support_descriptors *descrs,
+                          const char *prefix, FILE *fp)
+{
+  struct procfs_descriptor *end = descriptor_list_end (&descrs->list);
+  for (struct procfs_descriptor *d = descriptor_list_begin (&descrs->list);
+       d != end; ++d)
+    {
+      char *quoted = support_quote_string (d->link_target);
+      fprintf (fp, "%s%d: target=\"%s\" major=%lld minor=%lld ino=%lld\n",
+               prefix, d->fd, quoted,
+               (long long int) major (d->dev),
+               (long long int) minor (d->dev),
+               (long long int) d->ino);
+      free (quoted);
+    }
+}
+
+static void
+dump_mismatch (bool *first,
+               struct support_descriptors *descrs,
+               struct support_descriptors *current)
+{
+  if (*first)
+    *first = false;
+  else
+    return;
+
+  puts ("error: Differences found in descriptor set");
+  puts ("Reference descriptor set:");
+  support_descriptors_dump (descrs, "  ", stdout);
+  puts ("Current descriptor set:");
+  support_descriptors_dump (current, "  ", stdout);
+  puts ("Differences:");
+}
+
+static void
+report_closed_descriptor (bool *first,
+                          struct support_descriptors *descrs,
+                          struct support_descriptors *current,
+                          struct procfs_descriptor *left)
+{
+  support_record_failure ();
+  dump_mismatch (first, descrs, current);
+  printf ("error: descriptor %d was closed\n", left->fd);
+}
+
+static void
+report_opened_descriptor (bool *first,
+                          struct support_descriptors *descrs,
+                          struct support_descriptors *current,
+                          struct procfs_descriptor *right)
+{
+  support_record_failure ();
+  dump_mismatch (first, descrs, current);
+  char *quoted = support_quote_string (right->link_target);
+  printf ("error: descriptor %d was opened (\"%s\")\n", right->fd, quoted);
+  free (quoted);
+}
+
+void
+support_descriptors_check (struct support_descriptors *descrs)
+{
+  struct support_descriptors *current = support_descriptors_list ();
+
+  /* Perform a merge join between descrs and current.  This assumes
+     that the arrays are sorted by file descriptor.  */
+
+  struct procfs_descriptor *left = descriptor_list_begin (&descrs->list);
+  struct procfs_descriptor *left_end = descriptor_list_end (&descrs->list);
+  struct procfs_descriptor *right = descriptor_list_begin (&current->list);
+  struct procfs_descriptor *right_end = descriptor_list_end (&current->list);
+
+  bool first = true;
+  while (left != left_end && right != right_end)
+    {
+      if (left->fd == right->fd)
+        {
+          if (strcmp (left->link_target, right->link_target) != 0)
+            {
+              support_record_failure ();
+              char *left_quoted = support_quote_string (left->link_target);
+              char *right_quoted = support_quote_string (right->link_target);
+              dump_mismatch (&first, descrs, current);
+              printf ("error: descriptor %d changed from \"%s\" to \"%s\"\n",
+                      left->fd, left_quoted, right_quoted);
+              free (left_quoted);
+              free (right_quoted);
+            }
+          if (left->dev != right->dev)
+            {
+              support_record_failure ();
+              dump_mismatch (&first, descrs, current);
+              printf ("error: descriptor %d changed device"
+                      " from %lld:%lld to %lld:%lld\n",
+                      left->fd,
+                      (long long int) major (left->dev),
+                      (long long int) minor (left->dev),
+                      (long long int) major (right->dev),
+                      (long long int) minor (right->dev));
+            }
+          if (left->ino != right->ino)
+            {
+              support_record_failure ();
+              dump_mismatch (&first, descrs, current);
+              printf ("error: descriptor %d changed ino from %lld to %lld\n",
+                      left->fd,
+                      (long long int) left->ino, (long long int) right->ino);
+            }
+          ++left;
+          ++right;
+        }
+      else if (left->fd < right->fd)
+        {
+          /* Gap on the right.  */
+          report_closed_descriptor (&first, descrs, current, left);
+          ++left;
+        }
+      else
+        {
+          /* Gap on the left.  */
+          TEST_VERIFY_EXIT (left->fd > right->fd);
+          report_opened_descriptor (&first, descrs, current, right);
+          ++right;
+        }
+    }
+
+  while (left != left_end)
+    {
+      /* Closed descriptors (more descriptors on the left).  */
+      report_closed_descriptor (&first, descrs, current, left);
+      ++left;
+    }
+
+  while (right != right_end)
+    {
+      /* Opened descriptors (more descriptors on the right).  */
+      report_opened_descriptor (&first, descrs, current, right);
+      ++right;
+    }
+
+  support_descriptors_free (current);
+}
diff --git a/support/support_format_addrinfo.c b/support/support_format_addrinfo.c
index c5e00e516a..60d2cc40f6 100644
--- a/support/support_format_addrinfo.c
+++ b/support/support_format_addrinfo.c
@@ -67,8 +67,6 @@ format_ai_flags (FILE *out, struct addrinfo *ai)
       FLAG (AI_ADDRCONFIG);
       FLAG (AI_IDN);
       FLAG (AI_CANONIDN);
-      FLAG (AI_IDN_ALLOW_UNASSIGNED);
-      FLAG (AI_IDN_USE_STD3_ASCII_RULES);
       FLAG (AI_NUMERICSERV);
 #undef FLAG
       int remaining = ai->ai_flags & ~flags_printed;
@@ -220,7 +218,11 @@ support_format_addrinfo (struct addrinfo *ai, int ret)
   xopen_memstream (&mem);
   if (ret != 0)
     {
-      fprintf (mem.out, "error: %s\n", gai_strerror (ret));
+      const char *errmsg = gai_strerror (ret);
+      if (strcmp (errmsg, "Unknown error") == 0)
+        fprintf (mem.out, "error: Unknown error %d\n", ret);
+      else
+        fprintf (mem.out, "error: %s\n", errmsg);
       if (ret == EAI_SYSTEM)
         {
           errno = errno_copy;
diff --git a/support/support_openpty.c b/support/support_openpty.c
new file mode 100644
index 0000000000..ac779ab91e
--- /dev/null
+++ b/support/support_openpty.c
@@ -0,0 +1,109 @@
+/* Open a pseudoterminal.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <support/tty.h>
+#include <support/check.h>
+#include <support/support.h>
+
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <fcntl.h>
+#include <termios.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+
+/* As ptsname, but allocates space for an appropriately-sized string
+   using malloc.  */
+static char *
+xptsname (int fd)
+{
+  int rv;
+  size_t buf_len = 128;
+  char *buf = xmalloc (buf_len);
+  for (;;)
+    {
+      rv = ptsname_r (fd, buf, buf_len);
+      if (rv)
+        FAIL_EXIT1 ("ptsname_r: %s", strerror (errno));
+
+      if (memchr (buf, '\0', buf_len))
+        return buf; /* ptsname succeeded and the buffer was not truncated */
+
+      buf_len *= 2;
+      buf = xrealloc (buf, buf_len);
+    }
+}
+
+void
+support_openpty (int *a_outer, int *a_inner, char **a_name,
+                 const struct termios *termp,
+                 const struct winsize *winp)
+{
+  int outer = -1, inner = -1;
+  char *namebuf = 0;
+
+  outer = posix_openpt (O_RDWR | O_NOCTTY);
+  if (outer == -1)
+    FAIL_EXIT1 ("posix_openpt: %s", strerror (errno));
+
+  if (grantpt (outer))
+    FAIL_EXIT1 ("grantpt: %s", strerror (errno));
+
+  if (unlockpt (outer))
+    FAIL_EXIT1 ("unlockpt: %s", strerror (errno));
+
+
+#ifdef TIOCGPTPEER
+  inner = ioctl (outer, TIOCGPTPEER, O_RDWR | O_NOCTTY);
+#endif
+  if (inner == -1)
+    {
+      /* The kernel might not support TIOCGPTPEER, fall back to open
+         by name.  */
+      namebuf = xptsname (outer);
+      inner = open (namebuf, O_RDWR | O_NOCTTY);
+      if (inner == -1)
+        FAIL_EXIT1 ("%s: %s", namebuf, strerror (errno));
+    }
+
+  if (termp)
+    {
+      if (tcsetattr (inner, TCSAFLUSH, termp))
+        FAIL_EXIT1 ("tcsetattr: %s", strerror (errno));
+    }
+#ifdef TIOCSWINSZ
+  if (winp)
+    {
+      if (ioctl (inner, TIOCSWINSZ, winp))
+        FAIL_EXIT1 ("TIOCSWINSZ: %s", strerror (errno));
+    }
+#endif
+
+  if (a_name)
+    {
+      if (!namebuf)
+        namebuf = xptsname (outer);
+      *a_name = namebuf;
+    }
+  else
+    free (namebuf);
+  *a_outer = outer;
+  *a_inner = inner;
+}
diff --git a/support/support_quote_blob.c b/support/support_quote_blob.c
new file mode 100644
index 0000000000..d6a678d8d6
--- /dev/null
+++ b/support/support_quote_blob.c
@@ -0,0 +1,83 @@
+/* Quote a blob so that it can be used in C literals.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <support/support.h>
+#include <support/xmemstream.h>
+
+char *
+support_quote_blob (const void *blob, size_t length)
+{
+  struct xmemstream out;
+  xopen_memstream (&out);
+
+  const unsigned char *p = blob;
+  for (size_t i = 0; i < length; ++i)
+    {
+      unsigned char ch = p[i];
+
+      /* Use C backslash escapes for those control characters for
+         which they are defined.  */
+      switch (ch)
+        {
+          case '\a':
+            putc_unlocked ('\\', out.out);
+            putc_unlocked ('a', out.out);
+            break;
+          case '\b':
+            putc_unlocked ('\\', out.out);
+            putc_unlocked ('b', out.out);
+            break;
+          case '\f':
+            putc_unlocked ('\\', out.out);
+            putc_unlocked ('f', out.out);
+            break;
+          case '\n':
+            putc_unlocked ('\\', out.out);
+            putc_unlocked ('n', out.out);
+            break;
+          case '\r':
+            putc_unlocked ('\\', out.out);
+            putc_unlocked ('r', out.out);
+            break;
+          case '\t':
+            putc_unlocked ('\\', out.out);
+            putc_unlocked ('t', out.out);
+            break;
+          case '\v':
+            putc_unlocked ('\\', out.out);
+            putc_unlocked ('v', out.out);
+            break;
+          case '\\':
+          case '\'':
+          case '\"':
+            putc_unlocked ('\\', out.out);
+            putc_unlocked (ch, out.out);
+            break;
+        default:
+          if (ch < ' ' || ch > '~')
+            /* Use octal sequences because they are fixed width,
+               unlike hexadecimal sequences.  */
+            fprintf (out.out, "\\%03o", ch);
+          else
+            putc_unlocked (ch, out.out);
+        }
+    }
+
+  xfclose_memstream (&out);
+  return out.buffer;
+}
diff --git a/support/support_quote_string.c b/support/support_quote_string.c
new file mode 100644
index 0000000000..d324371b13
--- /dev/null
+++ b/support/support_quote_string.c
@@ -0,0 +1,26 @@
+/* Quote a string so that it can be used in C literals.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <string.h>
+#include <support/support.h>
+
+char *
+support_quote_string (const char *str)
+{
+  return support_quote_blob (str, strlen (str));
+}
diff --git a/support/support_record_failure.c b/support/support_record_failure.c
index 356798f556..17ab1d80ef 100644
--- a/support/support_record_failure.c
+++ b/support/support_record_failure.c
@@ -104,3 +104,11 @@ support_record_failure_reset (void)
   __atomic_store_n (&state->failed, 0, __ATOMIC_RELAXED);
   __atomic_add_fetch (&state->counter, 0, __ATOMIC_RELAXED);
 }
+
+int
+support_record_failure_is_failed (void)
+{
+  /* Relaxed MO is sufficient because we need (blocking) external
+     synchronization for reliable test error reporting anyway.  */
+  return __atomic_load_n (&state->failed, __ATOMIC_RELAXED);
+}
diff --git a/support/support_test_compare_blob.c b/support/support_test_compare_blob.c
new file mode 100644
index 0000000000..c5e63d1b93
--- /dev/null
+++ b/support/support_test_compare_blob.c
@@ -0,0 +1,76 @@
+/* Check two binary blobs for equality.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <support/check.h>
+#include <support/support.h>
+#include <support/xmemstream.h>
+
+static void
+report_length (const char *what, unsigned long int length, const char *expr)
+{
+  printf ("  %s %lu bytes (from %s)\n", what, length, expr);
+}
+
+static void
+report_blob (const char *what, const unsigned char *blob,
+             unsigned long int length, const char *expr)
+{
+  if (length > 0)
+    {
+      printf ("  %s (evaluated from %s):\n", what, expr);
+      char *quoted = support_quote_blob (blob, length);
+      printf ("      \"%s\"\n", quoted);
+      free (quoted);
+
+      fputs ("     ", stdout);
+      for (unsigned long i = 0; i < length; ++i)
+        printf (" %02X", blob[i]);
+      putc ('\n', stdout);
+    }
+}
+
+void
+support_test_compare_blob (const void *left, unsigned long int left_length,
+                           const void *right, unsigned long int right_length,
+                           const char *file, int line,
+                           const char *left_expr, const char *left_len_expr,
+                           const char *right_expr, const char *right_len_expr)
+{
+  /* No differences are possible if both lengths are null.  */
+  if (left_length == 0 && right_length == 0)
+    return;
+
+  if (left_length != right_length || left == NULL || right == NULL
+      || memcmp (left, right, left_length) != 0)
+    {
+      support_record_failure ();
+      printf ("%s:%d: error: blob comparison failed\n", file, line);
+      if (left_length == right_length)
+        printf ("  blob length: %lu bytes\n", left_length);
+      else
+        {
+          report_length ("left length: ", left_length, left_len_expr);
+          report_length ("right length:", right_length, right_len_expr);
+        }
+      report_blob ("left", left, left_length, left_expr);
+      report_blob ("right", right, right_length, right_expr);
+    }
+}
diff --git a/support/support_test_compare_string.c b/support/support_test_compare_string.c
new file mode 100644
index 0000000000..b6eaa24570
--- /dev/null
+++ b/support/support_test_compare_string.c
@@ -0,0 +1,91 @@
+/* Check two strings for equality.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <support/check.h>
+#include <support/support.h>
+#include <support/xmemstream.h>
+
+static void
+report_length (const char *what, const char *str, size_t length)
+{
+  if (str == NULL)
+    printf ("  %s string: NULL\n", what);
+  else
+    printf ("  %s string: %zu bytes\n", what, length);
+}
+
+static void
+report_string (const char *what, const unsigned char *blob,
+               size_t length, const char *expr)
+{
+  if (length > 0)
+    {
+      printf ("  %s (evaluated from %s):\n", what, expr);
+      char *quoted = support_quote_blob (blob, length);
+      printf ("      \"%s\"\n", quoted);
+      free (quoted);
+
+      fputs ("     ", stdout);
+      for (size_t i = 0; i < length; ++i)
+        printf (" %02X", blob[i]);
+      putc ('\n', stdout);
+    }
+}
+
+static size_t
+string_length_or_zero (const char *str)
+{
+  if (str == NULL)
+    return 0;
+  else
+    return strlen (str);
+}
+
+void
+support_test_compare_string (const char *left, const char *right,
+                             const char *file, int line,
+                             const char *left_expr, const char *right_expr)
+{
+  /* Two null pointers are accepted.  */
+  if (left == NULL && right == NULL)
+    return;
+
+  size_t left_length = string_length_or_zero (left);
+  size_t right_length = string_length_or_zero (right);
+
+  if (left_length != right_length || left == NULL || right == NULL
+      || memcmp (left, right, left_length) != 0)
+    {
+      support_record_failure ();
+      printf ("%s:%d: error: string comparison failed\n", file, line);
+      if (left_length == right_length && right != NULL && left != NULL)
+        printf ("  string length: %zu bytes\n", left_length);
+      else
+        {
+          report_length ("left", left, left_length);
+          report_length ("right", right, right_length);
+        }
+      report_string ("left", (const unsigned char *) left,
+                     left_length, left_expr);
+      report_string ("right", (const unsigned char *) right,
+                     right_length, right_expr);
+    }
+}
diff --git a/support/support_test_main.c b/support/support_test_main.c
index 396385729b..23429779ac 100644
--- a/support/support_test_main.c
+++ b/support/support_test_main.c
@@ -270,7 +270,8 @@ support_test_main (int argc, char **argv, const struct test_config *config)
     timeout =  DEFAULT_TIMEOUT;
 
   /* Make sure we see all message, even those on stdout.  */
-  setvbuf (stdout, NULL, _IONBF, 0);
+  if (!config->no_setvbuf)
+    setvbuf (stdout, NULL, _IONBF, 0);
 
   /* Make sure temporary files are deleted.  */
   if (support_delete_temp_files != NULL)
diff --git a/support/test-driver.c b/support/test-driver.c
index 09c8783e4f..9798f16227 100644
--- a/support/test-driver.c
+++ b/support/test-driver.c
@@ -140,6 +140,10 @@ main (int argc, char **argv)
   test_config.no_mallopt = 1;
 #endif
 
+#ifdef TEST_NO_SETVBUF
+  test_config.no_setvbuf = 1;
+#endif
+
 #ifdef TIMEOUT
   test_config.timeout = TIMEOUT;
 #endif
diff --git a/support/test-driver.h b/support/test-driver.h
index 1708d68d60..549179b254 100644
--- a/support/test-driver.h
+++ b/support/test-driver.h
@@ -35,6 +35,7 @@ struct test_config
   int expected_status;   /* Expected exit status.  */
   int expected_signal;   /* If non-zero, expect termination by signal.  */
   char no_mallopt;       /* Boolean flag to disable mallopt.  */
+  char no_setvbuf;       /* Boolean flag to disable setvbuf.  */
   const char *optstring; /* Short command line options.  */
 };
 
diff --git a/support/tst-support_descriptors.c b/support/tst-support_descriptors.c
new file mode 100644
index 0000000000..5e9e824bc3
--- /dev/null
+++ b/support/tst-support_descriptors.c
@@ -0,0 +1,198 @@
+/* Tests for monitoring file descriptor usage.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <fcntl.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <string.h>
+#include <support/capture_subprocess.h>
+#include <support/check.h>
+#include <support/descriptors.h>
+#include <support/support.h>
+#include <support/xunistd.h>
+
+/* This is the next free descriptor that the subprocess will pick.  */
+static int free_descriptor;
+
+static void
+subprocess_no_change (void *closure)
+{
+  struct support_descriptors *descrs = support_descriptors_list ();
+  int fd = xopen ("/dev/null", O_WRONLY, 0);
+  TEST_COMPARE (fd, free_descriptor);
+  xclose (fd);
+  support_descriptors_free (descrs);
+}
+
+static void
+subprocess_closed_descriptor (void *closure)
+{
+  int fd = xopen ("/dev/null", O_WRONLY, 0);
+  TEST_COMPARE (fd, free_descriptor);
+  struct support_descriptors *descrs = support_descriptors_list ();
+  xclose (fd);
+  support_descriptors_check (descrs); /* Will report failure.  */
+  puts ("EOT");
+  support_descriptors_free (descrs);
+}
+
+static void
+subprocess_opened_descriptor (void *closure)
+{
+  struct support_descriptors *descrs = support_descriptors_list ();
+  int fd = xopen ("/dev/null", O_WRONLY, 0);
+  TEST_COMPARE (fd, free_descriptor);
+  support_descriptors_check (descrs); /* Will report failure.  */
+  puts ("EOT");
+  support_descriptors_free (descrs);
+}
+
+static void
+subprocess_changed_descriptor (void *closure)
+{
+  int fd = xopen ("/dev/null", O_WRONLY, 0);
+  TEST_COMPARE (fd, free_descriptor);
+  struct support_descriptors *descrs = support_descriptors_list ();
+  xclose (fd);
+  TEST_COMPARE (xopen ("/dev", O_DIRECTORY | O_RDONLY, 0), fd);
+  support_descriptors_check (descrs); /* Will report failure.  */
+  puts ("EOT");
+  support_descriptors_free (descrs);
+}
+
+static void
+report_subprocess_output (const char *name,
+                          struct support_capture_subprocess *proc)
+{
+  printf ("info: BEGIN %s output\n"
+          "%s"
+          "info: END %s output\n",
+          name, proc->out.buffer, name);
+}
+
+/* Use an explicit flag to preserve failure status across
+   support_record_failure_reset calls.  */
+static bool good = true;
+
+static void
+test_run (void)
+{
+  struct support_capture_subprocess proc = support_capture_subprocess
+    (&subprocess_no_change, NULL);
+  support_capture_subprocess_check (&proc, "subprocess_no_change",
+                                    0, sc_allow_none);
+  support_capture_subprocess_free (&proc);
+
+  char *expected = xasprintf ("\nDifferences:\n"
+                              "error: descriptor %d was closed\n"
+                              "EOT\n",
+                              free_descriptor);
+  good = good && !support_record_failure_is_failed ();
+  proc = support_capture_subprocess (&subprocess_closed_descriptor, NULL);
+  good = good && support_record_failure_is_failed ();
+  support_record_failure_reset (); /* Discard the reported error.  */
+  report_subprocess_output ("subprocess_closed_descriptor", &proc);
+  TEST_VERIFY (strstr (proc.out.buffer, expected) != NULL);
+  support_capture_subprocess_check (&proc, "subprocess_closed_descriptor",
+                                    0, sc_allow_stdout);
+  support_capture_subprocess_free (&proc);
+  free (expected);
+
+  expected = xasprintf ("\nDifferences:\n"
+                        "error: descriptor %d was opened (\"/dev/null\")\n"
+                        "EOT\n",
+                        free_descriptor);
+  good = good && !support_record_failure_is_failed ();
+  proc = support_capture_subprocess (&subprocess_opened_descriptor, NULL);
+  good = good && support_record_failure_is_failed ();
+  support_record_failure_reset (); /* Discard the reported error.  */
+  report_subprocess_output ("subprocess_opened_descriptor", &proc);
+  TEST_VERIFY (strstr (proc.out.buffer, expected) != NULL);
+  support_capture_subprocess_check (&proc, "subprocess_opened_descriptor",
+                                    0, sc_allow_stdout);
+  support_capture_subprocess_free (&proc);
+  free (expected);
+
+  expected = xasprintf ("\nDifferences:\n"
+                        "error: descriptor %d changed from \"/dev/null\""
+                        " to \"/dev\"\n"
+                        "error: descriptor %d changed ino ",
+                        free_descriptor, free_descriptor);
+  good = good && !support_record_failure_is_failed ();
+  proc = support_capture_subprocess (&subprocess_changed_descriptor, NULL);
+  good = good && support_record_failure_is_failed ();
+  support_record_failure_reset (); /* Discard the reported error.  */
+  report_subprocess_output ("subprocess_changed_descriptor", &proc);
+  TEST_VERIFY (strstr (proc.out.buffer, expected) != NULL);
+  support_capture_subprocess_check (&proc, "subprocess_changed_descriptor",
+                                    0, sc_allow_stdout);
+  support_capture_subprocess_free (&proc);
+  free (expected);
+}
+
+static int
+do_test (void)
+{
+  puts ("info: initial descriptor set");
+  {
+    struct support_descriptors *descrs = support_descriptors_list ();
+    support_descriptors_dump (descrs, "info:  ", stdout);
+    support_descriptors_free (descrs);
+  }
+
+  free_descriptor = xopen ("/dev/null", O_WRONLY, 0);
+  puts ("info: descriptor set with additional free descriptor");
+  {
+    struct support_descriptors *descrs = support_descriptors_list ();
+    support_descriptors_dump (descrs, "info:  ", stdout);
+    support_descriptors_free (descrs);
+  }
+  TEST_VERIFY (free_descriptor >= 3);
+  xclose (free_descriptor);
+
+  /* Initial test run without a sentinel descriptor.  The presence of
+     such a descriptor exercises different conditions in the list
+     comparison in support_descriptors_check.  */
+  test_run ();
+
+  /* Allocate a sentinel descriptor at the end of the descriptor list,
+     after free_descriptor.  */
+  int sentinel_fd;
+  {
+    int fd = xopen ("/dev/full", O_WRONLY, 0);
+    TEST_COMPARE (fd, free_descriptor);
+    sentinel_fd = dup (fd);
+    TEST_VERIFY_EXIT (sentinel_fd > fd);
+    xclose (fd);
+  }
+  puts ("info: descriptor set with sentinel descriptor");
+  {
+    struct support_descriptors *descrs = support_descriptors_list ();
+    support_descriptors_dump (descrs, "info:  ", stdout);
+    support_descriptors_free (descrs);
+  }
+
+  /* Second test run with sentinel descriptor.  */
+  test_run ();
+
+  xclose (sentinel_fd);
+
+  return !good;
+}
+
+#include <support/test-driver.c>
diff --git a/support/tst-support_quote_blob.c b/support/tst-support_quote_blob.c
new file mode 100644
index 0000000000..5467a190a6
--- /dev/null
+++ b/support/tst-support_quote_blob.c
@@ -0,0 +1,61 @@
+/* Test the support_quote_blob function.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <support/check.h>
+#include <support/support.h>
+#include <string.h>
+#include <stdlib.h>
+
+static int
+do_test (void)
+{
+  /* Check handling of the empty blob, both with and without trailing
+     NUL byte.  */
+  char *p = support_quote_blob ("", 0);
+  TEST_COMPARE (strlen (p), 0);
+  free (p);
+  p = support_quote_blob ("X", 0);
+  TEST_COMPARE (strlen (p), 0);
+  free (p);
+
+  /* Check escaping of backslash-escaped characters, and lack of
+     escaping for other shell meta-characters.  */
+  p = support_quote_blob ("$()*?`@[]{}~\'\"X", 14);
+  TEST_COMPARE (strcmp (p, "$()*?`@[]{}~\\'\\\""), 0);
+  free (p);
+
+  /* Check lack of escaping for letters and digits.  */
+#define LETTERS_AND_DIGTS                       \
+  "abcdefghijklmnopqrstuvwxyz"                  \
+  "ABCDEFGHIJKLMNOPQRSTUVWXYZ"                  \
+  "0123456789"
+  p = support_quote_blob (LETTERS_AND_DIGTS "@", 2 * 26 + 10);
+  TEST_COMPARE (strcmp (p, LETTERS_AND_DIGTS), 0);
+  free (p);
+
+  /* Check escaping of control characters and other non-printable
+     characters.  */
+  p = support_quote_blob ("\r\n\t\a\b\f\v\1\177\200\377\0@", 14);
+  TEST_COMPARE (strcmp (p, "\\r\\n\\t\\a\\b\\f\\v\\001"
+                        "\\177\\200\\377\\000@\\000"), 0);
+  free (p);
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/support/tst-support_quote_string.c b/support/tst-support_quote_string.c
new file mode 100644
index 0000000000..3c004759b7
--- /dev/null
+++ b/support/tst-support_quote_string.c
@@ -0,0 +1,60 @@
+/* Test the support_quote_string function.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <support/check.h>
+#include <support/support.h>
+#include <string.h>
+#include <stdlib.h>
+
+static int
+do_test (void)
+{
+  char *p = support_quote_string ("");
+  TEST_COMPARE (strlen (p), 0);
+  free (p);
+  p = support_quote_string ("X");
+  TEST_COMPARE (strlen (p), 1);
+  TEST_COMPARE (p[0], 'X');
+  free (p);
+
+  /* Check escaping of backslash-escaped characters, and lack of
+     escaping for other shell meta-characters.  */
+  p = support_quote_string ("$()*?`@[]{}~\'\"X");
+  TEST_COMPARE (strcmp (p, "$()*?`@[]{}~\\'\\\"X"), 0);
+  free (p);
+
+  /* Check lack of escaping for letters and digits.  */
+#define LETTERS_AND_DIGTS                       \
+  "abcdefghijklmnopqrstuvwxyz"                  \
+  "ABCDEFGHIJKLMNOPQRSTUVWXYZ"                  \
+  "0123456789"
+  p = support_quote_string (LETTERS_AND_DIGTS "@");
+  TEST_COMPARE (strcmp (p, LETTERS_AND_DIGTS "@"), 0);
+  free (p);
+
+  /* Check escaping of control characters and other non-printable
+     characters.  */
+  p = support_quote_string ("\r\n\t\a\b\f\v\1\177\200\377@");
+  TEST_COMPARE (strcmp (p, "\\r\\n\\t\\a\\b\\f\\v\\001"
+                        "\\177\\200\\377@"), 0);
+  free (p);
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/support/tst-test_compare_blob.c b/support/tst-test_compare_blob.c
new file mode 100644
index 0000000000..aa8643e182
--- /dev/null
+++ b/support/tst-test_compare_blob.c
@@ -0,0 +1,125 @@
+/* Basic test for the TEST_COMPARE_BLOB macro.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <string.h>
+#include <support/check.h>
+#include <support/capture_subprocess.h>
+
+static void
+subprocess (void *closure)
+{
+  /* These tests should fail.  They were chosen to cover differences
+     in length (with the same contents), single-bit mismatches, and
+     mismatching null pointers.  */
+  TEST_COMPARE_BLOB ("", 0, "", 1);    /* Line 29.  */
+  TEST_COMPARE_BLOB ("X", 1, "", 1);   /* Line 30.  */
+  TEST_COMPARE_BLOB ("abcd", 3, "abcd", 4); /* Line 31.  */
+  TEST_COMPARE_BLOB ("abcd", 4, "abcD", 4); /* Line 32.  */
+  TEST_COMPARE_BLOB ("abcd", 4, NULL, 0); /* Line 33.  */
+  TEST_COMPARE_BLOB (NULL, 0, "abcd", 4); /* Line 34.  */
+}
+
+/* Same contents, different addresses.  */
+char buffer_abc_1[] = "abc";
+char buffer_abc_2[] = "abc";
+
+static int
+do_test (void)
+{
+  /* This should succeed.  Even if the pointers and array contents are
+     different, zero-length inputs are not different.  */
+  TEST_COMPARE_BLOB ("", 0, "", 0);
+  TEST_COMPARE_BLOB ("", 0, buffer_abc_1, 0);
+  TEST_COMPARE_BLOB (buffer_abc_1, 0, "", 0);
+  TEST_COMPARE_BLOB (NULL, 0, "", 0);
+  TEST_COMPARE_BLOB ("", 0, NULL, 0);
+  TEST_COMPARE_BLOB (NULL, 0, NULL, 0);
+
+  /* Check equality of blobs containing a single NUL byte.  */
+  TEST_COMPARE_BLOB ("", 1, "", 1);
+  TEST_COMPARE_BLOB ("", 1, &buffer_abc_1[3], 1);
+
+  /* Check equality of blobs of varying lengths.  */
+  for (size_t i = 0; i <= sizeof (buffer_abc_1); ++i)
+    TEST_COMPARE_BLOB (buffer_abc_1, i, buffer_abc_2, i);
+
+  struct support_capture_subprocess proc = support_capture_subprocess
+    (&subprocess, NULL);
+
+  /* Discard the reported error.  */
+  support_record_failure_reset ();
+
+  puts ("info: *** subprocess output starts ***");
+  fputs (proc.out.buffer, stdout);
+  puts ("info: *** subprocess output ends ***");
+
+  TEST_VERIFY
+    (strcmp (proc.out.buffer,
+"tst-test_compare_blob.c:29: error: blob comparison failed\n"
+"  left length:  0 bytes (from 0)\n"
+"  right length: 1 bytes (from 1)\n"
+"  right (evaluated from \"\"):\n"
+"      \"\\000\"\n"
+"      00\n"
+"tst-test_compare_blob.c:30: error: blob comparison failed\n"
+"  blob length: 1 bytes\n"
+"  left (evaluated from \"X\"):\n"
+"      \"X\"\n"
+"      58\n"
+"  right (evaluated from \"\"):\n"
+"      \"\\000\"\n"
+"      00\n"
+"tst-test_compare_blob.c:31: error: blob comparison failed\n"
+"  left length:  3 bytes (from 3)\n"
+"  right length: 4 bytes (from 4)\n"
+"  left (evaluated from \"abcd\"):\n"
+"      \"abc\"\n"
+"      61 62 63\n"
+"  right (evaluated from \"abcd\"):\n"
+"      \"abcd\"\n"
+"      61 62 63 64\n"
+"tst-test_compare_blob.c:32: error: blob comparison failed\n"
+"  blob length: 4 bytes\n"
+"  left (evaluated from \"abcd\"):\n"
+"      \"abcd\"\n"
+"      61 62 63 64\n"
+"  right (evaluated from \"abcD\"):\n"
+"      \"abcD\"\n"
+"      61 62 63 44\n"
+"tst-test_compare_blob.c:33: error: blob comparison failed\n"
+"  left length:  4 bytes (from 4)\n"
+"  right length: 0 bytes (from 0)\n"
+"  left (evaluated from \"abcd\"):\n"
+"      \"abcd\"\n"
+"      61 62 63 64\n"
+"tst-test_compare_blob.c:34: error: blob comparison failed\n"
+"  left length:  0 bytes (from 0)\n"
+"  right length: 4 bytes (from 4)\n"
+"  right (evaluated from \"abcd\"):\n"
+"      \"abcd\"\n"
+"      61 62 63 64\n"
+             ) == 0);
+
+  /* Check that there is no output on standard error.  */
+  support_capture_subprocess_check (&proc, "TEST_COMPARE_BLOB",
+                                    0, sc_allow_stdout);
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/support/tst-test_compare_string.c b/support/tst-test_compare_string.c
new file mode 100644
index 0000000000..d3c037a1ec
--- /dev/null
+++ b/support/tst-test_compare_string.c
@@ -0,0 +1,107 @@
+/* Basic test for the TEST_COMPARE_STRING macro.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <string.h>
+#include <support/check.h>
+#include <support/capture_subprocess.h>
+
+static void
+subprocess (void *closure)
+{
+  /* These tests should fail.  They were chosen to cover differences
+     in length (with the same contents), single-bit mismatches, and
+     mismatching null pointers.  */
+  TEST_COMPARE_STRING ("", NULL);             /* Line 29.  */
+  TEST_COMPARE_STRING ("X", "");              /* Line 30.  */
+  TEST_COMPARE_STRING (NULL, "X");            /* Line 31.  */
+  TEST_COMPARE_STRING ("abcd", "abcD");       /* Line 32.  */
+  TEST_COMPARE_STRING ("abcd", NULL);         /* Line 33.  */
+  TEST_COMPARE_STRING (NULL, "abcd");         /* Line 34.  */
+}
+
+/* Same contents, different addresses.  */
+char buffer_abc_1[] = "abc";
+char buffer_abc_2[] = "abc";
+
+static int
+do_test (void)
+{
+  /* This should succeed.  Even if the pointers and array contents are
+     different, zero-length inputs are not different.  */
+  TEST_COMPARE_STRING (NULL, NULL);
+  TEST_COMPARE_STRING ("", "");
+  TEST_COMPARE_STRING (buffer_abc_1, buffer_abc_2);
+  TEST_COMPARE_STRING (buffer_abc_1, "abc");
+
+  struct support_capture_subprocess proc = support_capture_subprocess
+    (&subprocess, NULL);
+
+  /* Discard the reported error.  */
+  support_record_failure_reset ();
+
+  puts ("info: *** subprocess output starts ***");
+  fputs (proc.out.buffer, stdout);
+  puts ("info: *** subprocess output ends ***");
+
+  TEST_VERIFY
+    (strcmp (proc.out.buffer,
+"tst-test_compare_string.c:29: error: string comparison failed\n"
+"  left string: 0 bytes\n"
+"  right string: NULL\n"
+"tst-test_compare_string.c:30: error: string comparison failed\n"
+"  left string: 1 bytes\n"
+"  right string: 0 bytes\n"
+"  left (evaluated from \"X\"):\n"
+"      \"X\"\n"
+"      58\n"
+"tst-test_compare_string.c:31: error: string comparison failed\n"
+"  left string: NULL\n"
+"  right string: 1 bytes\n"
+"  right (evaluated from \"X\"):\n"
+"      \"X\"\n"
+"      58\n"
+"tst-test_compare_string.c:32: error: string comparison failed\n"
+"  string length: 4 bytes\n"
+"  left (evaluated from \"abcd\"):\n"
+"      \"abcd\"\n"
+"      61 62 63 64\n"
+"  right (evaluated from \"abcD\"):\n"
+"      \"abcD\"\n"
+"      61 62 63 44\n"
+"tst-test_compare_string.c:33: error: string comparison failed\n"
+"  left string: 4 bytes\n"
+"  right string: NULL\n"
+"  left (evaluated from \"abcd\"):\n"
+"      \"abcd\"\n"
+"      61 62 63 64\n"
+"tst-test_compare_string.c:34: error: string comparison failed\n"
+"  left string: NULL\n"
+"  right string: 4 bytes\n"
+"  right (evaluated from \"abcd\"):\n"
+"      \"abcd\"\n"
+"      61 62 63 64\n"
+             ) == 0);
+
+  /* Check that there is no output on standard error.  */
+  support_capture_subprocess_check (&proc, "TEST_COMPARE_STRING",
+                                    0, sc_allow_stdout);
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/support/tty.h b/support/tty.h
new file mode 100644
index 0000000000..1d37c42279
--- /dev/null
+++ b/support/tty.h
@@ -0,0 +1,45 @@
+/* Support functions related to (pseudo)terminals.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SUPPORT_TTY_H
+#define _SUPPORT_TTY_H 1
+
+struct termios;
+struct winsize;
+
+/** Open a pseudoterminal pair.  The outer fd is written to the address
+    A_OUTER and the inner fd to A_INNER.
+
+    If A_NAME is not NULL, it will be set to point to a string naming
+    the /dev/pts/NNN device corresponding to the inner fd; space for
+    this string is allocated with malloc and should be freed by the
+    caller when no longer needed.  (This is different from the libutil
+    function 'openpty'.)
+
+    If TERMP is not NULL, the terminal parameters will be initialized
+    according to the termios structure it points to.
+
+    If WINP is not NULL, the terminal window size will be set
+    accordingly.
+
+    Terminates the process on failure (like xmalloc).  */
+extern void support_openpty (int *a_outer, int *a_inner, char **a_name,
+                             const struct termios *termp,
+                             const struct winsize *winp);
+
+#endif
diff --git a/support/xpthread_barrierattr_destroy.c b/support/xpthread_barrierattr_destroy.c
new file mode 100644
index 0000000000..3e471f9a81
--- /dev/null
+++ b/support/xpthread_barrierattr_destroy.c
@@ -0,0 +1,26 @@
+/* pthread_barrierattr_destroy with error checking.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <support/xthread.h>
+
+void
+xpthread_barrierattr_destroy (pthread_barrierattr_t *attr)
+{
+  xpthread_check_return ("pthread_barrierattr_destroy",
+                         pthread_barrierattr_destroy (attr));
+}
diff --git a/support/xpthread_barrierattr_init.c b/support/xpthread_barrierattr_init.c
new file mode 100644
index 0000000000..4ee14e78f3
--- /dev/null
+++ b/support/xpthread_barrierattr_init.c
@@ -0,0 +1,26 @@
+/* pthread_barrierattr_init with error checking.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <support/xthread.h>
+
+void
+xpthread_barrierattr_init (pthread_barrierattr_t *attr)
+{
+  xpthread_check_return ("pthread_barrierattr_init",
+                         pthread_barrierattr_init (attr));
+}
diff --git a/support/xpthread_barrierattr_setpshared.c b/support/xpthread_barrierattr_setpshared.c
new file mode 100644
index 0000000000..90b2c5bec6
--- /dev/null
+++ b/support/xpthread_barrierattr_setpshared.c
@@ -0,0 +1,26 @@
+/* pthread_barrierattr_setpshared with error checking.
+   Copyright (C) 2018 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <support/xthread.h>
+
+void
+xpthread_barrierattr_setpshared (pthread_barrierattr_t *attr, int pshared)
+{
+  xpthread_check_return ("pthread_barrierattr_setpshared",
+                         pthread_barrierattr_setpshared (attr, pshared));
+}
diff --git a/support/xsetlocale.c b/support/xsetlocale.c
new file mode 100644
index 0000000000..063ed4b0d6
--- /dev/null
+++ b/support/xsetlocale.c
@@ -0,0 +1,30 @@
+/* setlocale with error checking.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <support/check.h>
+
+#include <locale.h>
+
+char *
+xsetlocale (int category, const char *locale)
+{
+  char *p = setlocale (category, locale);
+  if (p == NULL)
+    FAIL_EXIT1 ("error: setlocale (%d, \"%s\")\n", category, locale);
+  return p;
+}
diff --git a/support/xthread.h b/support/xthread.h
index 79358e7c99..623f5ad0ac 100644
--- a/support/xthread.h
+++ b/support/xthread.h
@@ -41,6 +41,9 @@ void xpthread_check_return (const char *function, int value);
 void xpthread_barrier_init (pthread_barrier_t *barrier,
                             pthread_barrierattr_t *attr, unsigned int count);
 void xpthread_barrier_destroy (pthread_barrier_t *barrier);
+void xpthread_barrierattr_destroy (pthread_barrierattr_t *);
+void xpthread_barrierattr_init (pthread_barrierattr_t *);
+void xpthread_barrierattr_setpshared (pthread_barrierattr_t *, int pshared);
 void xpthread_mutexattr_destroy (pthread_mutexattr_t *);
 void xpthread_mutexattr_init (pthread_mutexattr_t *);
 void xpthread_mutexattr_setprotocol (pthread_mutexattr_t *, int);
diff --git a/sysdeps/aarch64/dl-machine.h b/sysdeps/aarch64/dl-machine.h
index 7ce3c8eb8b..8989398186 100644
--- a/sysdeps/aarch64/dl-machine.h
+++ b/sysdeps/aarch64/dl-machine.h
@@ -388,7 +388,30 @@ elf_machine_lazy_rel (struct link_map *map,
   /* Check for unexpected PLT reloc type.  */
   if (__builtin_expect (r_type == AARCH64_R(JUMP_SLOT), 1))
     {
-      if (__builtin_expect (map->l_mach.plt, 0) == 0)
+      if (1) /* DT_AARCH64_VARIANT_PCS is not available, so always check.  */
+	{
+	  /* Check the symbol table for variant PCS symbols.  */
+	  const Elf_Symndx symndx = ELFW (R_SYM) (reloc->r_info);
+	  const ElfW (Sym) *symtab =
+	    (const void *)D_PTR (map, l_info[DT_SYMTAB]);
+	  const ElfW (Sym) *sym = &symtab[symndx];
+	  if (__glibc_unlikely (sym->st_other & STO_AARCH64_VARIANT_PCS))
+	    {
+	      /* Avoid lazy resolution of variant PCS symbols.  */
+	      const struct r_found_version *version = NULL;
+	      if (map->l_info[VERSYMIDX (DT_VERSYM)] != NULL)
+		{
+		  const ElfW (Half) *vernum =
+		    (const void *)D_PTR (map, l_info[VERSYMIDX (DT_VERSYM)]);
+		  version = &map->l_versions[vernum[symndx] & 0x7fff];
+		}
+	      elf_machine_rela (map, reloc, sym, version, reloc_addr,
+				skip_ifunc);
+	      return;
+	    }
+	}
+
+      if (map->l_mach.plt == 0)
 	*reloc_addr += l_addr;
       else
 	*reloc_addr = map->l_mach.plt;
diff --git a/sysdeps/aarch64/memcmp.S b/sysdeps/aarch64/memcmp.S
index ccc795adeb..743bc078bb 100644
--- a/sysdeps/aarch64/memcmp.S
+++ b/sysdeps/aarch64/memcmp.S
@@ -34,9 +34,12 @@
 /* Internal variables.  */
 #define data1		x3
 #define data1w		w3
-#define data2		x4
-#define data2w		w4
-#define tmp1		x5
+#define data1h		x4
+#define data2		x5
+#define data2w		w5
+#define data2h		x6
+#define tmp1		x7
+#define tmp2		x8
 
 ENTRY_ALIGN (memcmp, 6)
 	DELOUSE (0)
@@ -44,73 +47,104 @@ ENTRY_ALIGN (memcmp, 6)
 	DELOUSE (2)
 
 	subs	limit, limit, 8
-	b.lo	.Lless8
+	b.lo	L(less8)
 
-	/* Limit >= 8, so check first 8 bytes using unaligned loads.  */
 	ldr	data1, [src1], 8
 	ldr	data2, [src2], 8
-	and	tmp1, src1, 7
-	add	limit, limit, tmp1
 	cmp	data1, data2
-	bne	.Lreturn
+	b.ne	L(return)
+
+	subs	limit, limit, 8
+	b.gt	L(more16)
+
+	ldr	data1, [src1, limit]
+	ldr	data2, [src2, limit]
+	b	L(return)
+
+L(more16):
+	ldr	data1, [src1], 8
+	ldr	data2, [src2], 8
+	cmp	data1, data2
+	bne	L(return)
+
+	/* Jump directly to comparing the last 16 bytes for 32 byte (or less)
+	   strings.  */
+	subs	limit, limit, 16
+	b.ls	L(last_bytes)
+
+	/* We overlap loads between 0-32 bytes at either side of SRC1 when we
+	   try to align, so limit it only to strings larger than 128 bytes.  */
+	cmp	limit, 96
+	b.ls	L(loop16)
 
 	/* Align src1 and adjust src2 with bytes not yet done.  */
+	and	tmp1, src1, 15
+	add	limit, limit, tmp1
 	sub	src1, src1, tmp1
 	sub	src2, src2, tmp1
 
-	subs	limit, limit, 8
-	b.ls	.Llast_bytes
-
-	/* Loop performing 8 bytes per iteration using aligned src1.
-	   Limit is pre-decremented by 8 and must be larger than zero.
-	   Exit if <= 8 bytes left to do or if the data is not equal.  */
+	/* Loop performing 16 bytes per iteration using aligned src1.
+	   Limit is pre-decremented by 16 and must be larger than zero.
+	   Exit if <= 16 bytes left to do or if the data is not equal.  */
 	.p2align 4
-.Lloop8:
-	ldr	data1, [src1], 8
-	ldr	data2, [src2], 8
-	subs	limit, limit, 8
-	ccmp	data1, data2, 0, hi  /* NZCV = 0b0000.  */
-	b.eq	.Lloop8
+L(loop16):
+	ldp	data1, data1h, [src1], 16
+	ldp	data2, data2h, [src2], 16
+	subs	limit, limit, 16
+	ccmp	data1, data2, 0, hi
+	ccmp	data1h, data2h, 0, eq
+	b.eq	L(loop16)
 
 	cmp	data1, data2
-	bne	.Lreturn
-
-	/* Compare last 1-8 bytes using unaligned access.  */
-.Llast_bytes:
-	ldr	data1, [src1, limit]
-	ldr	data2, [src2, limit]
+	bne	L(return)
+	mov	data1, data1h
+	mov	data2, data2h
+	cmp	data1, data2
+	bne	L(return)
+
+	/* Compare last 1-16 bytes using unaligned access.  */
+L(last_bytes):
+	add	src1, src1, limit
+	add	src2, src2, limit
+	ldp	data1, data1h, [src1]
+	ldp	data2, data2h, [src2]
+	cmp     data1, data2
+	bne	L(return)
+	mov	data1, data1h
+	mov	data2, data2h
+	cmp	data1, data2
 
 	/* Compare data bytes and set return value to 0, -1 or 1.  */
-.Lreturn:
+L(return):
 #ifndef __AARCH64EB__
 	rev	data1, data1
 	rev	data2, data2
 #endif
 	cmp     data1, data2
-.Lret_eq:
+L(ret_eq):
 	cset	result, ne
 	cneg	result, result, lo
 	ret
 
 	.p2align 4
 	/* Compare up to 8 bytes.  Limit is [-8..-1].  */
-.Lless8:
+L(less8):
 	adds	limit, limit, 4
-	b.lo	.Lless4
+	b.lo	L(less4)
 	ldr	data1w, [src1], 4
 	ldr	data2w, [src2], 4
 	cmp	data1w, data2w
-	b.ne	.Lreturn
+	b.ne	L(return)
 	sub	limit, limit, 4
-.Lless4:
+L(less4):
 	adds	limit, limit, 4
-	beq	.Lret_eq
-.Lbyte_loop:
+	beq	L(ret_eq)
+L(byte_loop):
 	ldrb	data1w, [src1], 1
 	ldrb	data2w, [src2], 1
 	subs	limit, limit, 1
 	ccmp	data1w, data2w, 0, ne	/* NZCV = 0b0000.  */
-	b.eq	.Lbyte_loop
+	b.eq	L(byte_loop)
 	sub	result, data1w, data2w
 	ret
 
diff --git a/sysdeps/aarch64/multiarch/memcpy.c b/sysdeps/aarch64/multiarch/memcpy.c
index 3efea2c644..abeca6cff4 100644
--- a/sysdeps/aarch64/multiarch/memcpy.c
+++ b/sysdeps/aarch64/multiarch/memcpy.c
@@ -35,7 +35,7 @@ extern __typeof (__redirect_memcpy) __memcpy_falkor attribute_hidden;
 libc_ifunc (__libc_memcpy,
             (IS_THUNDERX (midr)
 	     ? __memcpy_thunderx
-	     : (IS_FALKOR (midr)
+	     : (IS_FALKOR (midr) || IS_ARES (midr)
 		? __memcpy_falkor
 		: __memcpy_generic)));
 
diff --git a/sysdeps/aarch64/multiarch/memcpy_falkor.S b/sysdeps/aarch64/multiarch/memcpy_falkor.S
index 8dd8c1e03a..cdc2de4750 100644
--- a/sysdeps/aarch64/multiarch/memcpy_falkor.S
+++ b/sysdeps/aarch64/multiarch/memcpy_falkor.S
@@ -29,11 +29,19 @@
 #define dst	x3
 #define srcend	x4
 #define dstend	x5
-#define A_l	x6
-#define A_lw	w6
-#define A_h	x7
-#define A_hw	w7
 #define tmp1	x14
+#define A_x	x6
+#define B_x	x7
+#define A_w	w6
+#define B_w	w7
+
+#define A_q	q0
+#define B_q	q1
+#define C_q	q2
+#define D_q	q3
+#define E_q	q4
+#define F_q	q5
+#define G_q	q6
 
 /* Copies are split into 3 main cases:
 
@@ -53,9 +61,9 @@
    bumping up the small copies up to 32 bytes allows us to do that without
    cost and also allows us to reduce the size of the prep code before loop64.
 
-   All copies are done only via two registers r6 and r7.  This is to ensure
-   that all loads hit a single hardware prefetcher which can get correctly
-   trained to prefetch a single stream.
+   The copy loop uses only one register q0.  This is to ensure that all loads
+   hit a single hardware prefetcher which can get correctly trained to prefetch
+   a single stream.
 
    The non-temporal stores help optimize cache utilization.  */
 
@@ -66,29 +74,29 @@ ENTRY_ALIGN (__memcpy_falkor, 6)
 	add	srcend, src, count
 	add	dstend, dstin, count
 	b.ls	L(copy32)
-	ldp	A_l, A_h, [src]
+	ldr	A_q, [src]
 	cmp	count, 128
-	stp	A_l, A_h, [dstin]
+	str	A_q, [dstin]
 	b.hi	L(copy_long)
 
 	/* Medium copies: 33..128 bytes.  */
 	sub	tmp1, count, 1
-	ldp	A_l, A_h, [src, 16]
-	stp	A_l, A_h, [dstin, 16]
+	ldr	A_q, [src, 16]
+	ldr	B_q, [srcend, -32]
+	ldr	C_q, [srcend, -16]
 	tbz	tmp1, 6, 1f
-	ldp	A_l, A_h, [src, 32]
-	stp	A_l, A_h, [dstin, 32]
-	ldp	A_l, A_h, [src, 48]
-	stp	A_l, A_h, [dstin, 48]
-	ldp	A_l, A_h, [srcend, -64]
-	stp	A_l, A_h, [dstend, -64]
-	ldp	A_l, A_h, [srcend, -48]
-	stp	A_l, A_h, [dstend, -48]
+	ldr	D_q, [src, 32]
+	ldr	E_q, [src, 48]
+	str	D_q, [dstin, 32]
+	str	E_q, [dstin, 48]
+	ldr	F_q, [srcend, -64]
+	ldr	G_q, [srcend, -48]
+	str	F_q, [dstend, -64]
+	str	G_q, [dstend, -48]
 1:
-	ldp	A_l, A_h, [srcend, -32]
-	stp	A_l, A_h, [dstend, -32]
-	ldp	A_l, A_h, [srcend, -16]
-	stp	A_l, A_h, [dstend, -16]
+	str	A_q, [dstin, 16]
+	str	B_q, [dstend, -32]
+	str	C_q, [dstend, -16]
 	ret
 
 	.p2align 4
@@ -97,44 +105,44 @@ L(copy32):
 	/* 16-32 */
 	cmp	count, 16
 	b.lo	1f
-	ldp	A_l, A_h, [src]
-	stp	A_l, A_h, [dstin]
-	ldp	A_l, A_h, [srcend, -16]
-	stp	A_l, A_h, [dstend, -16]
+	ldr	A_q, [src]
+	ldr	B_q, [srcend, -16]
+	str	A_q, [dstin]
+	str	B_q, [dstend, -16]
 	ret
 	.p2align 4
 1:
 	/* 8-15 */
 	tbz	count, 3, 1f
-	ldr	A_l, [src]
-	str	A_l, [dstin]
-	ldr	A_l, [srcend, -8]
-	str	A_l, [dstend, -8]
+	ldr	A_x, [src]
+	ldr	B_x, [srcend, -8]
+	str	A_x, [dstin]
+	str	B_x, [dstend, -8]
 	ret
 	.p2align 4
 1:
 	/* 4-7 */
 	tbz	count, 2, 1f
-	ldr	A_lw, [src]
-	str	A_lw, [dstin]
-	ldr	A_lw, [srcend, -4]
-	str	A_lw, [dstend, -4]
+	ldr	A_w, [src]
+	ldr	B_w, [srcend, -4]
+	str	A_w, [dstin]
+	str	B_w, [dstend, -4]
 	ret
 	.p2align 4
 1:
 	/* 2-3 */
 	tbz	count, 1, 1f
-	ldrh	A_lw, [src]
-	strh	A_lw, [dstin]
-	ldrh	A_lw, [srcend, -2]
-	strh	A_lw, [dstend, -2]
+	ldrh	A_w, [src]
+	ldrh	B_w, [srcend, -2]
+	strh	A_w, [dstin]
+	strh	B_w, [dstend, -2]
 	ret
 	.p2align 4
 1:
 	/* 0-1 */
 	tbz	count, 0, 1f
-	ldrb	A_lw, [src]
-	strb	A_lw, [dstin]
+	ldrb	A_w, [src]
+	strb	A_w, [dstin]
 1:
 	ret
 
@@ -153,30 +161,29 @@ L(copy_long):
 	add	count, count, tmp1
 
 L(loop64):
-	ldp	A_l, A_h, [src, 16]!
-	stnp	A_l, A_h, [dst, 16]
-	ldp	A_l, A_h, [src, 16]!
+	ldr	A_q, [src, 16]!
+	str	A_q, [dst, 16]
+	ldr	A_q, [src, 16]!
 	subs	count, count, 64
-	stnp	A_l, A_h, [dst, 32]
-	ldp	A_l, A_h, [src, 16]!
-	stnp	A_l, A_h, [dst, 48]
-	ldp	A_l, A_h, [src, 16]!
-	stnp	A_l, A_h, [dst, 64]
-	add	dst, dst, 64
+	str	A_q, [dst, 32]
+	ldr	A_q, [src, 16]!
+	str	A_q, [dst, 48]
+	ldr	A_q, [src, 16]!
+	str	A_q, [dst, 64]!
 	b.hi	L(loop64)
 
 	/* Write the last full set of 64 bytes.  The remainder is at most 64
 	   bytes, so it is safe to always copy 64 bytes from the end even if
 	   there is just 1 byte left.  */
 L(last64):
-	ldp	A_l, A_h, [srcend, -64]
-	stnp	A_l, A_h, [dstend, -64]
-	ldp	A_l, A_h, [srcend, -48]
-	stnp	A_l, A_h, [dstend, -48]
-	ldp	A_l, A_h, [srcend, -32]
-	stnp	A_l, A_h, [dstend, -32]
-	ldp	A_l, A_h, [srcend, -16]
-	stnp	A_l, A_h, [dstend, -16]
+	ldr	E_q, [srcend, -64]
+	str	E_q, [dstend, -64]
+	ldr	D_q, [srcend, -48]
+	str	D_q, [dstend, -48]
+	ldr	C_q, [srcend, -32]
+	str	C_q, [dstend, -32]
+	ldr	B_q, [srcend, -16]
+	str	B_q, [dstend, -16]
 	ret
 
 END (__memcpy_falkor)
diff --git a/sysdeps/aarch64/strcmp.S b/sysdeps/aarch64/strcmp.S
index 0b22f168b5..267aa4b551 100644
--- a/sysdeps/aarch64/strcmp.S
+++ b/sysdeps/aarch64/strcmp.S
@@ -158,7 +158,7 @@ L(do_misaligned):
 	ccmp	data1w, data2w, #0, cs	/* NZCV = 0b0000.  */
 	b.ne	L(done)
 	tst	src1, #7
-	b.ne	L(misaligned8)
+	b.ne	L(do_misaligned)
 
 L(loop_misaligned):
 	/* Test if we are within the last dword of the end of a 4K page.  If
diff --git a/sysdeps/aarch64/strncmp.S b/sysdeps/aarch64/strncmp.S
index a08d2c0aa5..6ee5746482 100644
--- a/sysdeps/aarch64/strncmp.S
+++ b/sysdeps/aarch64/strncmp.S
@@ -25,7 +25,6 @@
 
 #define REP8_01 0x0101010101010101
 #define REP8_7f 0x7f7f7f7f7f7f7f7f
-#define REP8_80 0x8080808080808080
 
 /* Parameters and result.  */
 #define src1		x0
@@ -46,24 +45,38 @@
 #define tmp3		x10
 #define zeroones	x11
 #define pos		x12
-#define limit_wd	x13
-#define mask		x14
-#define endloop		x15
-
-ENTRY_ALIGN_AND_PAD (strncmp, 6, 7)
-	DELOUSE (0)
-	DELOUSE (1)
-	DELOUSE (2)
+#define mask		x13
+#define endloop		x14
+#define count		mask
+#define offset		pos
+#define neg_offset	x15
+
+/* Define endian dependent shift operations.
+   On big-endian early bytes are at MSB and on little-endian LSB.
+   LS_FW means shifting towards early bytes.
+   LS_BK means shifting towards later bytes.
+   */
+#ifdef __AARCH64EB__
+#define LS_FW lsl
+#define LS_BK lsr
+#else
+#define LS_FW lsr
+#define LS_BK lsl
+#endif
+
+	.text
+	.p2align 6
+	.rep 9
+	nop	/* Pad so that the loop below fits a cache line.  */
+	.endr
+ENTRY_ALIGN (strncmp, 0)
 	cbz	limit, L(ret0)
 	eor	tmp1, src1, src2
 	mov	zeroones, #REP8_01
 	tst	tmp1, #7
+	and	count, src1, #7
 	b.ne	L(misaligned8)
-	ands	tmp1, src1, #7
-	b.ne	L(mutual_align)
-	/* Calculate the number of full and partial words -1.  */
-	sub	limit_wd, limit, #1	/* limit != 0, so no underflow.  */
-	lsr	limit_wd, limit_wd, #3	/* Convert to Dwords.  */
+	cbnz	count, L(mutual_align)
 
 	/* NUL detection works on the principle that (X - 1) & (~X) & 0x80
 	   (=> (X - 1) & ~(X | 0x7f)) is non-zero iff a byte is zero, and
@@ -73,56 +86,52 @@ L(loop_aligned):
 	ldr	data1, [src1], #8
 	ldr	data2, [src2], #8
 L(start_realigned):
-	subs	limit_wd, limit_wd, #1
+	subs	limit, limit, #8
 	sub	tmp1, data1, zeroones
 	orr	tmp2, data1, #REP8_7f
 	eor	diff, data1, data2	/* Non-zero if differences found.  */
-	csinv	endloop, diff, xzr, pl	/* Last Dword or differences.  */
+	csinv	endloop, diff, xzr, hi	/* Last Dword or differences.  */
 	bics	has_nul, tmp1, tmp2	/* Non-zero if NUL terminator.  */
 	ccmp	endloop, #0, #0, eq
 	b.eq	L(loop_aligned)
 	/* End of performance-critical section  -- one 64B cache line.  */
 
-	/* Not reached the limit, must have found the end or a diff.  */
-	tbz	limit_wd, #63, L(not_limit)
-
-	/* Limit % 8 == 0 => all bytes significant.  */
-	ands	limit, limit, #7
-	b.eq	L(not_limit)
-
-	lsl	limit, limit, #3	/* Bits -> bytes.  */
-	mov	mask, #~0
-#ifdef __AARCH64EB__
-	lsr	mask, mask, limit
-#else
-	lsl	mask, mask, limit
-#endif
-	bic	data1, data1, mask
-	bic	data2, data2, mask
-
-	/* Make sure that the NUL byte is marked in the syndrome.  */
-	orr	has_nul, has_nul, mask
-
-L(not_limit):
+L(full_check):
+#ifndef __AARCH64EB__
 	orr	syndrome, diff, has_nul
-
-#ifndef	__AARCH64EB__
+	add	limit, limit, 8	/* Rewind limit to before last subs. */
+L(syndrome_check):
+	/* Limit was reached. Check if the NUL byte or the difference
+	   is before the limit. */
 	rev	syndrome, syndrome
 	rev	data1, data1
-	/* The MS-non-zero bit of the syndrome marks either the first bit
-	   that is different, or the top bit of the first zero byte.
-	   Shifting left now will bring the critical information into the
-	   top bits.  */
 	clz	pos, syndrome
 	rev	data2, data2
 	lsl	data1, data1, pos
+	cmp	limit, pos, lsr #3
 	lsl	data2, data2, pos
 	/* But we need to zero-extend (char is unsigned) the value and then
 	   perform a signed 32-bit subtraction.  */
 	lsr	data1, data1, #56
 	sub	result, data1, data2, lsr #56
-	RET
+	csel result, result, xzr, hi
+	ret
 #else
+	/* Not reached the limit, must have found the end or a diff.  */
+	tbz	limit, #63, L(not_limit)
+	add	tmp1, limit, 8
+	cbz	limit, L(not_limit)
+
+	lsl	limit, tmp1, #3	/* Bits -> bytes.  */
+	mov	mask, #~0
+	lsr	mask, mask, limit
+	bic	data1, data1, mask
+	bic	data2, data2, mask
+
+	/* Make sure that the NUL byte is marked in the syndrome.  */
+	orr	has_nul, has_nul, mask
+
+L(not_limit):
 	/* For big-endian we cannot use the trick with the syndrome value
 	   as carry-propagation can corrupt the upper bits if the trailing
 	   bytes in the string contain 0x01.  */
@@ -133,7 +142,7 @@ L(not_limit):
 	cmp	data1, data2
 	cset	result, ne
 	cneg	result, result, lo
-	RET
+	ret
 1:
 	/* Re-compute the NUL-byte detection, using a byte-reversed value.  */
 	rev	tmp3, data1
@@ -143,17 +152,18 @@ L(not_limit):
 	rev	has_nul, has_nul
 	orr	syndrome, diff, has_nul
 	clz	pos, syndrome
-	/* The MS-non-zero bit of the syndrome marks either the first bit
-	   that is different, or the top bit of the first zero byte.
+	/* The most-significant-non-zero bit of the syndrome marks either the
+	   first bit that is different, or the top bit of the first zero byte.
 	   Shifting left now will bring the critical information into the
 	   top bits.  */
+L(end_quick):
 	lsl	data1, data1, pos
 	lsl	data2, data2, pos
 	/* But we need to zero-extend (char is unsigned) the value and then
 	   perform a signed 32-bit subtraction.  */
 	lsr	data1, data1, #56
 	sub	result, data1, data2, lsr #56
-	RET
+	ret
 #endif
 
 L(mutual_align):
@@ -165,43 +175,144 @@ L(mutual_align):
 	bic	src1, src1, #7
 	bic	src2, src2, #7
 	ldr	data1, [src1], #8
-	neg	tmp3, tmp1, lsl #3	/* 64 - bits(bytes beyond align). */
+	neg	tmp3, count, lsl #3	/* 64 - bits(bytes beyond align). */
 	ldr	data2, [src2], #8
 	mov	tmp2, #~0
-	sub	limit_wd, limit, #1	/* limit != 0, so no underflow.  */
-#ifdef __AARCH64EB__
-	/* Big-endian.  Early bytes are at MSB.  */
-	lsl	tmp2, tmp2, tmp3	/* Shift (tmp1 & 63).  */
-#else
-	/* Little-endian.  Early bytes are at LSB.  */
-	lsr	tmp2, tmp2, tmp3	/* Shift (tmp1 & 63).  */
-#endif
-	and	tmp3, limit_wd, #7
-	lsr	limit_wd, limit_wd, #3
-	/* Adjust the limit. Only low 3 bits used, so overflow irrelevant.  */
-	add	limit, limit, tmp1
-	add	tmp3, tmp3, tmp1
+	LS_FW	tmp2, tmp2, tmp3	/* Shift (count & 63).  */
+	/* Adjust the limit and ensure it doesn't overflow.  */
+	adds	limit, limit, count
+	csinv	limit, limit, xzr, lo
 	orr	data1, data1, tmp2
 	orr	data2, data2, tmp2
-	add	limit_wd, limit_wd, tmp3, lsr #3
 	b	L(start_realigned)
 
-L(ret0):
-	mov	result, #0
-	RET
-
 	.p2align 6
+	/* Don't bother with dwords for up to 16 bytes.  */
 L(misaligned8):
-	sub	limit, limit, #1
-1:
+	cmp	limit, #16
+	b.hs	L(try_misaligned_words)
+
+L(byte_loop):
 	/* Perhaps we can do better than this.  */
 	ldrb	data1w, [src1], #1
 	ldrb	data2w, [src2], #1
 	subs	limit, limit, #1
-	ccmp	data1w, #1, #0, cs	/* NZCV = 0b0000.  */
+	ccmp	data1w, #1, #0, hi	/* NZCV = 0b0000.  */
 	ccmp	data1w, data2w, #0, cs	/* NZCV = 0b0000.  */
-	b.eq	1b
+	b.eq	L(byte_loop)
+L(done):
 	sub	result, data1, data2
-	RET
+	ret
+	/* Align the SRC1 to a dword by doing a bytewise compare and then do
+	   the dword loop.  */
+L(try_misaligned_words):
+	cbz	count, L(src1_aligned)
+
+	neg	count, count
+	and	count, count, #7
+	sub	limit, limit, count
+
+L(page_end_loop):
+	ldrb	data1w, [src1], #1
+	ldrb	data2w, [src2], #1
+	cmp	data1w, #1
+	ccmp	data1w, data2w, #0, cs	/* NZCV = 0b0000.  */
+	b.ne	L(done)
+	subs	count, count, #1
+	b.hi	L(page_end_loop)
+
+	/* The following diagram explains the comparison of misaligned strings.
+	   The bytes are shown in natural order. For little-endian, it is
+	   reversed in the registers. The "x" bytes are before the string.
+	   The "|" separates data that is loaded at one time.
+	   src1     | a a a a a a a a | b b b c c c c c | . . .
+	   src2     | x x x x x a a a   a a a a a b b b | c c c c c . . .
+	   After shifting in each step, the data looks like this:
+	                STEP_A              STEP_B              STEP_C
+	   data1    a a a a a a a a     b b b c c c c c     b b b c c c c c
+	   data2    a a a a a a a a     b b b 0 0 0 0 0     0 0 0 c c c c c
+	   The bytes with "0" are eliminated from the syndrome via mask.
+	   Align SRC2 down to 16 bytes. This way we can read 16 bytes at a
+	   time from SRC2. The comparison happens in 3 steps. After each step
+	   the loop can exit, or read from SRC1 or SRC2. */
+L(src1_aligned):
+	/* Calculate offset from 8 byte alignment to string start in bits. No
+	   need to mask offset since shifts are ignoring upper bits. */
+	lsl	offset, src2, #3
+	bic	src2, src2, #0xf
+	mov	mask, -1
+	neg	neg_offset, offset
+	ldr	data1, [src1], #8
+	ldp	tmp1, tmp2, [src2], #16
+	LS_BK	mask, mask, neg_offset
+	and	neg_offset, neg_offset, #63	/* Need actual value for cmp later. */
+	/* Skip the first compare if data in tmp1 is irrelevant. */
+	tbnz	offset, 6, L(misaligned_mid_loop)
+
+L(loop_misaligned):
+	/* STEP_A: Compare full 8 bytes when there is enough data from SRC2.*/
+	LS_FW	data2, tmp1, offset
+	LS_BK	tmp1, tmp2, neg_offset
+	subs	limit, limit, #8
+	orr	data2, data2, tmp1	/* 8 bytes from SRC2 combined from two regs.*/
+	sub	has_nul, data1, zeroones
+	eor	diff, data1, data2	/* Non-zero if differences found.  */
+	orr	tmp3, data1, #REP8_7f
+	csinv	endloop, diff, xzr, hi	/* If limit, set to all ones. */
+	bic	has_nul, has_nul, tmp3	/* Non-zero if NUL byte found in SRC1. */
+	orr	tmp3, endloop, has_nul
+	cbnz	tmp3, L(full_check)
+
+	ldr	data1, [src1], #8
+L(misaligned_mid_loop):
+	/* STEP_B: Compare first part of data1 to second part of tmp2. */
+	LS_FW	data2, tmp2, offset
+#ifdef __AARCH64EB__
+	/* For big-endian we do a byte reverse to avoid carry-propagation
+	problem described above. This way we can reuse the has_nul in the
+	next step and also use syndrome value trick at the end. */
+	rev	tmp3, data1
+	#define data1_fixed tmp3
+#else
+	#define data1_fixed data1
+#endif
+	sub	has_nul, data1_fixed, zeroones
+	orr	tmp3, data1_fixed, #REP8_7f
+	eor	diff, data2, data1	/* Non-zero if differences found.  */
+	bic	has_nul, has_nul, tmp3	/* Non-zero if NUL terminator.  */
+#ifdef __AARCH64EB__
+	rev	has_nul, has_nul
+#endif
+	cmp	limit, neg_offset, lsr #3
+	orr	syndrome, diff, has_nul
+	bic	syndrome, syndrome, mask	/* Ignore later bytes. */
+	csinv	tmp3, syndrome, xzr, hi	/* If limit, set to all ones. */
+	cbnz	tmp3, L(syndrome_check)
+
+	/* STEP_C: Compare second part of data1 to first part of tmp1. */
+	ldp	tmp1, tmp2, [src2], #16
+	cmp	limit, #8
+	LS_BK	data2, tmp1, neg_offset
+	eor	diff, data2, data1	/* Non-zero if differences found.  */
+	orr	syndrome, diff, has_nul
+	and	syndrome, syndrome, mask	/* Ignore earlier bytes. */
+	csinv	tmp3, syndrome, xzr, hi	/* If limit, set to all ones. */
+	cbnz	tmp3, L(syndrome_check)
+
+	ldr	data1, [src1], #8
+	sub	limit, limit, #8
+	b	L(loop_misaligned)
+
+#ifdef	__AARCH64EB__
+L(syndrome_check):
+	clz	pos, syndrome
+	cmp	pos, limit, lsl #3
+	b.lo	L(end_quick)
+#endif
+
+L(ret0):
+	mov	result, #0
+	ret
+
 END (strncmp)
 libc_hidden_builtin_def (strncmp)
diff --git a/sysdeps/arm/armv7/multiarch/memcpy_impl.S b/sysdeps/arm/armv7/multiarch/memcpy_impl.S
index 2de172635c..802c310f3e 100644
--- a/sysdeps/arm/armv7/multiarch/memcpy_impl.S
+++ b/sysdeps/arm/armv7/multiarch/memcpy_impl.S
@@ -268,7 +268,7 @@ ENTRY(memcpy)
 
 	mov	dst, dstin	/* Preserve dstin, we need to return it.  */
 	cmp	count, #64
-	bge	.Lcpy_not_short
+	bhs	.Lcpy_not_short
 	/* Deal with small copies quickly by dropping straight into the
 	   exit block.  */
 
@@ -351,10 +351,10 @@ ENTRY(memcpy)
 
 1:
 	subs	tmp2, count, #64	/* Use tmp2 for count.  */
-	blt	.Ltail63aligned
+	blo	.Ltail63aligned
 
 	cmp	tmp2, #512
-	bge	.Lcpy_body_long
+	bhs	.Lcpy_body_long
 
 .Lcpy_body_medium:			/* Count in tmp2.  */
 #ifdef USE_VFP
@@ -378,7 +378,7 @@ ENTRY(memcpy)
 	add	src, src, #64
 	vstr	d1, [dst, #56]
 	add	dst, dst, #64
-	bge	1b
+	bhs	1b
 	tst	tmp2, #0x3f
 	beq	.Ldone
 
@@ -412,7 +412,7 @@ ENTRY(memcpy)
 	ldrd	A_l, A_h, [src, #64]!
 	strd	A_l, A_h, [dst, #64]!
 	subs	tmp2, tmp2, #64
-	bge	1b
+	bhs	1b
 	tst	tmp2, #0x3f
 	bne	1f
 	ldr	tmp2,[sp], #FRAME_SIZE
@@ -482,7 +482,7 @@ ENTRY(memcpy)
 	add	src, src, #32
 
 	subs	tmp2, tmp2, #prefetch_lines * 64 * 2
-	blt	2f
+	blo	2f
 1:
 	cpy_line_vfp	d3, 0
 	cpy_line_vfp	d4, 64
@@ -494,7 +494,7 @@ ENTRY(memcpy)
 	add	dst, dst, #2 * 64
 	add	src, src, #2 * 64
 	subs	tmp2, tmp2, #prefetch_lines * 64
-	bge	1b
+	bhs	1b
 
 2:
 	cpy_tail_vfp	d3, 0
@@ -615,8 +615,8 @@ ENTRY(memcpy)
 1:
 	pld	[src, #(3 * 64)]
 	subs	count, count, #64
-	ldrmi	tmp2, [sp], #FRAME_SIZE
-	bmi	.Ltail63unaligned
+	ldrlo	tmp2, [sp], #FRAME_SIZE
+	blo	.Ltail63unaligned
 	pld	[src, #(4 * 64)]
 
 #ifdef USE_NEON
@@ -633,7 +633,7 @@ ENTRY(memcpy)
 	neon_load_multi d0-d3, src
 	neon_load_multi d4-d7, src
 	subs	count, count, #64
-	bmi	2f
+	blo	2f
 1:
 	pld	[src, #(4 * 64)]
 	neon_store_multi d0-d3, dst
@@ -641,7 +641,7 @@ ENTRY(memcpy)
 	neon_store_multi d4-d7, dst
 	neon_load_multi d4-d7, src
 	subs	count, count, #64
-	bpl	1b
+	bhs	1b
 2:
 	neon_store_multi d0-d3, dst
 	neon_store_multi d4-d7, dst
diff --git a/sysdeps/arm/memcpy.S b/sysdeps/arm/memcpy.S
index cba8609813..7b4214aae9 100644
--- a/sysdeps/arm/memcpy.S
+++ b/sysdeps/arm/memcpy.S
@@ -68,7 +68,7 @@ ENTRY(memcpy)
 		cfi_remember_state
 
 		subs	r2, r2, #4
-		blt	8f
+		blo	8f
 		ands	ip, r0, #3
 	PLD(	pld	[r1, #0]		)
 		bne	9f
@@ -82,7 +82,7 @@ ENTRY(memcpy)
 		cfi_rel_offset (r6, 4)
 		cfi_rel_offset (r7, 8)
 		cfi_rel_offset (r8, 12)
-		blt	5f
+		blo	5f
 
 	CALGN(	ands	ip, r1, #31		)
 	CALGN(	rsb	r3, ip, #32		)
@@ -98,9 +98,9 @@ ENTRY(memcpy)
 #endif
 
 	PLD(	pld	[r1, #0]		)
-2:	PLD(	subs	r2, r2, #96		)
+2:	PLD(	cmp	r2, #96			)
 	PLD(	pld	[r1, #28]		)
-	PLD(	blt	4f			)
+	PLD(	blo	4f			)
 	PLD(	pld	[r1, #60]		)
 	PLD(	pld	[r1, #92]		)
 
@@ -108,9 +108,7 @@ ENTRY(memcpy)
 4:		ldmia	r1!, {r3, r4, r5, r6, r7, r8, ip, lr}
 		subs	r2, r2, #32
 		stmia	r0!, {r3, r4, r5, r6, r7, r8, ip, lr}
-		bge	3b
-	PLD(	cmn	r2, #96			)
-	PLD(	bge	4b			)
+		bhs	3b
 
 5:		ands	ip, r2, #28
 		rsb	ip, ip, #32
@@ -222,7 +220,7 @@ ENTRY(memcpy)
 		strbge	r4, [r0], #1
 		subs	r2, r2, ip
 		strb	lr, [r0], #1
-		blt	8b
+		blo	8b
 		ands	ip, r1, #3
 		beq	1b
 
@@ -236,7 +234,7 @@ ENTRY(memcpy)
 		.macro	forward_copy_shift pull push
 
 		subs	r2, r2, #28
-		blt	14f
+		blo	14f
 
 	CALGN(	ands	ip, r1, #31		)
 	CALGN(	rsb	ip, ip, #32		)
@@ -253,9 +251,9 @@ ENTRY(memcpy)
 		cfi_rel_offset (r10, 16)
 
 	PLD(	pld	[r1, #0]		)
-	PLD(	subs	r2, r2, #96		)
+	PLD(	cmp	r2, #96			)
 	PLD(	pld	[r1, #28]		)
-	PLD(	blt	13f			)
+	PLD(	blo	13f			)
 	PLD(	pld	[r1, #60]		)
 	PLD(	pld	[r1, #92]		)
 
@@ -280,9 +278,7 @@ ENTRY(memcpy)
 		mov	ip, ip, PULL #\pull
 		orr	ip, ip, lr, PUSH #\push
 		stmia	r0!, {r3, r4, r5, r6, r7, r8, r10, ip}
-		bge	12b
-	PLD(	cmn	r2, #96			)
-	PLD(	bge	13b			)
+		bhs	12b
 
 		pop	{r5 - r8, r10}
 		cfi_adjust_cfa_offset (-20)
diff --git a/sysdeps/arm/memmove.S b/sysdeps/arm/memmove.S
index 74d3042043..b28a811912 100644
--- a/sysdeps/arm/memmove.S
+++ b/sysdeps/arm/memmove.S
@@ -85,7 +85,7 @@ ENTRY(memmove)
 		add	r1, r1, r2
 		add	r0, r0, r2
 		subs	r2, r2, #4
-		blt	8f
+		blo	8f
 		ands	ip, r0, #3
 	PLD(	pld	[r1, #-4]		)
 		bne	9f
@@ -99,7 +99,7 @@ ENTRY(memmove)
 		cfi_rel_offset (r6, 4)
 		cfi_rel_offset (r7, 8)
 		cfi_rel_offset (r8, 12)
-		blt	5f
+		blo     5f
 
 	CALGN(	ands	ip, r1, #31		)
 	CALGN(	sbcsne	r4, ip, r2		)  @ C is always set here
@@ -114,9 +114,9 @@ ENTRY(memmove)
 #endif
 
 	PLD(	pld	[r1, #-4]		)
-2:	PLD(	subs	r2, r2, #96		)
+2:	PLD(	cmp	r2, #96			)
 	PLD(	pld	[r1, #-32]		)
-	PLD(	blt	4f			)
+	PLD(    blo     4f                      )
 	PLD(	pld	[r1, #-64]		)
 	PLD(	pld	[r1, #-96]		)
 
@@ -124,9 +124,7 @@ ENTRY(memmove)
 4:		ldmdb	r1!, {r3, r4, r5, r6, r7, r8, ip, lr}
 		subs	r2, r2, #32
 		stmdb	r0!, {r3, r4, r5, r6, r7, r8, ip, lr}
-		bge	3b
-	PLD(	cmn	r2, #96			)
-	PLD(	bge	4b			)
+		bhs     3b
 
 5:		ands	ip, r2, #28
 		rsb	ip, ip, #32
@@ -237,7 +235,7 @@ ENTRY(memmove)
 		strbge	r4, [r0, #-1]!
 		subs	r2, r2, ip
 		strb	lr, [r0, #-1]!
-		blt	8b
+		blo	8b
 		ands	ip, r1, #3
 		beq	1b
 
@@ -251,7 +249,7 @@ ENTRY(memmove)
 		.macro	backward_copy_shift push pull
 
 		subs	r2, r2, #28
-		blt	14f
+		blo	14f
 
 	CALGN(	ands	ip, r1, #31		)
 	CALGN(	rsb	ip, ip, #32		)
@@ -268,9 +266,9 @@ ENTRY(memmove)
 		cfi_rel_offset (r10, 16)
 
 	PLD(	pld	[r1, #-4]		)
-	PLD(	subs	r2, r2, #96		)
+	PLD(	cmp	r2, #96			)
 	PLD(	pld	[r1, #-32]		)
-	PLD(	blt	13f			)
+	PLD(	blo	13f			)
 	PLD(	pld	[r1, #-64]		)
 	PLD(	pld	[r1, #-96]		)
 
@@ -295,9 +293,7 @@ ENTRY(memmove)
 		mov     r4, r4, PUSH #\push
 		orr     r4, r4, r3, PULL #\pull
 		stmdb   r0!, {r4 - r8, r10, ip, lr}
-		bge	12b
-	PLD(	cmn	r2, #96			)
-	PLD(	bge	13b			)
+		bhs	12b
 
 		pop	{r5 - r8, r10}
 		cfi_adjust_cfa_offset (-20)
diff --git a/sysdeps/generic/math_private.h b/sysdeps/generic/math_private.h
index e4b9d8697f..cff76149d6 100644
--- a/sysdeps/generic/math_private.h
+++ b/sysdeps/generic/math_private.h
@@ -514,33 +514,6 @@ default_libc_feupdateenv_test (fenv_t *e, int ex)
 # define HAVE_RM_CTX 0
 #endif
 
-#if HAVE_RM_CTX
-/* Set/Restore Rounding Modes only when necessary.  If defined, these functions
-   set/restore floating point state only if the state needed within the lexical
-   block is different from the current state.  This saves a lot of time when
-   the floating point unit is much slower than the fixed point units.  */
-
-# ifndef libc_feholdsetround_noex_ctx
-#   define libc_feholdsetround_noex_ctx  libc_feholdsetround_ctx
-# endif
-# ifndef libc_feholdsetround_noexf_ctx
-#   define libc_feholdsetround_noexf_ctx libc_feholdsetroundf_ctx
-# endif
-# ifndef libc_feholdsetround_noexl_ctx
-#   define libc_feholdsetround_noexl_ctx libc_feholdsetroundl_ctx
-# endif
-
-# ifndef libc_feresetround_noex_ctx
-#   define libc_feresetround_noex_ctx  libc_fesetenv_ctx
-# endif
-# ifndef libc_feresetround_noexf_ctx
-#   define libc_feresetround_noexf_ctx libc_fesetenvf_ctx
-# endif
-# ifndef libc_feresetround_noexl_ctx
-#   define libc_feresetround_noexl_ctx libc_fesetenvl_ctx
-# endif
-
-#else
 
 /* Default implementation using standard fenv functions.
    Avoid unnecessary rounding mode changes by first checking the
@@ -548,7 +521,7 @@ default_libc_feupdateenv_test (fenv_t *e, int ex)
    important for performance.  */
 
 static __always_inline void
-libc_feholdsetround_ctx (struct rm_ctx *ctx, int round)
+default_libc_feholdsetround_ctx (struct rm_ctx *ctx, int round)
 {
   ctx->updated_status = false;
 
@@ -562,7 +535,7 @@ libc_feholdsetround_ctx (struct rm_ctx *ctx, int round)
 }
 
 static __always_inline void
-libc_feresetround_ctx (struct rm_ctx *ctx)
+default_libc_feresetround_ctx (struct rm_ctx *ctx)
 {
   /* Restore the rounding mode if updated.  */
   if (__glibc_unlikely (ctx->updated_status))
@@ -570,7 +543,7 @@ libc_feresetround_ctx (struct rm_ctx *ctx)
 }
 
 static __always_inline void
-libc_feholdsetround_noex_ctx (struct rm_ctx *ctx, int round)
+default_libc_feholdsetround_noex_ctx (struct rm_ctx *ctx, int round)
 {
   /* Save exception flags and rounding mode, and disable exception
      traps.  */
@@ -582,12 +555,45 @@ libc_feholdsetround_noex_ctx (struct rm_ctx *ctx, int round)
 }
 
 static __always_inline void
-libc_feresetround_noex_ctx (struct rm_ctx *ctx)
+default_libc_feresetround_noex_ctx (struct rm_ctx *ctx)
 {
   /* Restore exception flags and rounding mode.  */
   __fesetenv (&ctx->env);
 }
 
+#if HAVE_RM_CTX
+/* Set/Restore Rounding Modes only when necessary.  If defined, these functions
+   set/restore floating point state only if the state needed within the lexical
+   block is different from the current state.  This saves a lot of time when
+   the floating point unit is much slower than the fixed point units.  */
+
+# ifndef libc_feholdsetround_noex_ctx
+#   define libc_feholdsetround_noex_ctx  libc_feholdsetround_ctx
+# endif
+# ifndef libc_feholdsetround_noexf_ctx
+#   define libc_feholdsetround_noexf_ctx libc_feholdsetroundf_ctx
+# endif
+# ifndef libc_feholdsetround_noexl_ctx
+#   define libc_feholdsetround_noexl_ctx libc_feholdsetroundl_ctx
+# endif
+
+# ifndef libc_feresetround_noex_ctx
+#   define libc_feresetround_noex_ctx  libc_fesetenv_ctx
+# endif
+# ifndef libc_feresetround_noexf_ctx
+#   define libc_feresetround_noexf_ctx libc_fesetenvf_ctx
+# endif
+# ifndef libc_feresetround_noexl_ctx
+#   define libc_feresetround_noexl_ctx libc_fesetenvl_ctx
+# endif
+
+#else
+
+# define libc_feholdsetround_ctx      default_libc_feholdsetround_ctx
+# define libc_feresetround_ctx        default_libc_feresetround_ctx
+# define libc_feholdsetround_noex_ctx default_libc_feholdsetround_noex_ctx
+# define libc_feresetround_noex_ctx   default_libc_feresetround_noex_ctx
+
 # define libc_feholdsetroundf_ctx libc_feholdsetround_ctx
 # define libc_feholdsetroundl_ctx libc_feholdsetround_ctx
 # define libc_feresetroundf_ctx   libc_feresetround_ctx
diff --git a/sysdeps/generic/mmap_info.h b/sysdeps/generic/mmap_info.h
new file mode 100644
index 0000000000..b3087df2d3
--- /dev/null
+++ b/sysdeps/generic/mmap_info.h
@@ -0,0 +1,16 @@
+/* As default architectures with sizeof (off_t) < sizeof (off64_t) the mmap is
+   implemented with __SYS_mmap2 syscall and the offset is represented in
+   multiples of page size.  For offset larger than
+   '1 << (page_shift + 8 * sizeof (off_t))' (that is, 1<<44 on system with
+   page size of 4096 bytes) the system call silently truncates the offset.
+   For this case, glibc mmap implementation returns EINVAL.  */
+
+/* Return the maximum value expected as offset argument in mmap64 call.  */
+static inline uint64_t
+mmap64_maximum_offset (long int page_shift)
+{
+  if (sizeof (off_t) < sizeof (off64_t))
+    return (UINT64_C(1) << (page_shift + (8 * sizeof (off_t)))) - 1;
+  else
+    return UINT64_MAX;
+}
diff --git a/sysdeps/i386/Makefile b/sysdeps/i386/Makefile
index a1500454e5..9c7078e33c 100644
--- a/sysdeps/i386/Makefile
+++ b/sysdeps/i386/Makefile
@@ -5,6 +5,14 @@ asm-CPPFLAGS += -DGAS_SYNTAX
 # The i386 `long double' is a distinct type we support.
 long-double-fcts = yes
 
+ifeq ($(subdir),math)
+# These functions change the rounding mode internally and need to
+# update both the SSE2 rounding mode and the 387 rounding mode.  See
+# the handling of MATH_SET_BOTH_ROUNDING_MODES in
+# sysdeps/i386/fpu/fenv_private.h.
+CFLAGS-e_gamma_r.c += -DMATH_SET_BOTH_ROUNDING_MODES
+endif
+
 ifeq ($(subdir),string)
 sysdep_routines += cacheinfo
 endif
diff --git a/sysdeps/i386/fpu/fenv_private.h b/sysdeps/i386/fpu/fenv_private.h
index 38fd0b92b5..03177bb1ed 100644
--- a/sysdeps/i386/fpu/fenv_private.h
+++ b/sysdeps/i386/fpu/fenv_private.h
@@ -491,11 +491,19 @@ libc_feupdateenv_387_ctx (struct rm_ctx *ctx)
 #endif /* __SSE_MATH__ */
 
 #ifdef __SSE2_MATH__
-# define libc_feholdexcept_setround_ctx	libc_feholdexcept_setround_sse_ctx
-# define libc_fesetenv_ctx		libc_fesetenv_sse_ctx
-# define libc_feupdateenv_ctx		libc_feupdateenv_sse_ctx
-# define libc_feholdsetround_ctx	libc_feholdsetround_sse_ctx
-# define libc_feresetround_ctx		libc_feresetround_sse_ctx
+# if defined (__x86_64__) || !defined (MATH_SET_BOTH_ROUNDING_MODES)
+#  define libc_feholdexcept_setround_ctx libc_feholdexcept_setround_sse_ctx
+#  define libc_fesetenv_ctx		libc_fesetenv_sse_ctx
+#  define libc_feupdateenv_ctx		libc_feupdateenv_sse_ctx
+#  define libc_feholdsetround_ctx	libc_feholdsetround_sse_ctx
+#  define libc_feresetround_ctx		libc_feresetround_sse_ctx
+# else
+#  define libc_feholdexcept_setround_ctx default_libc_feholdexcept_setround_ctx
+#  define libc_fesetenv_ctx		default_libc_fesetenv_ctx
+#  define libc_feupdateenv_ctx		default_libc_feupdateenv_ctx
+#  define libc_feholdsetround_ctx	default_libc_feholdsetround_ctx
+#  define libc_feresetround_ctx		default_libc_feresetround_ctx
+# endif
 #else
 # define libc_feholdexcept_setround_ctx	libc_feholdexcept_setround_387_ctx
 # define libc_feupdateenv_ctx		libc_feupdateenv_387_ctx
diff --git a/sysdeps/i386/fpu/libm-test-ulps b/sysdeps/i386/fpu/libm-test-ulps
index 862a74e09d..9d1c35c605 100644
--- a/sysdeps/i386/fpu/libm-test-ulps
+++ b/sysdeps/i386/fpu/libm-test-ulps
@@ -281,20 +281,20 @@ ldouble: 1
 
 Function: Real part of "cacos":
 double: 1
-float: 1
+float: 2
 float128: 2
 idouble: 1
-ifloat: 1
+ifloat: 2
 ifloat128: 2
 ildouble: 1
 ldouble: 1
 
 Function: Imaginary part of "cacos":
-double: 1
-float: 1
+double: 2
+float: 2
 float128: 2
-idouble: 1
-ifloat: 1
+idouble: 2
+ifloat: 2
 ifloat128: 2
 ildouble: 2
 ldouble: 2
@@ -360,21 +360,21 @@ ildouble: 7
 ldouble: 7
 
 Function: Real part of "cacosh":
-double: 1
-float: 1
+double: 2
+float: 2
 float128: 2
-idouble: 1
-ifloat: 1
+idouble: 2
+ifloat: 2
 ifloat128: 2
 ildouble: 2
 ldouble: 2
 
 Function: Imaginary part of "cacosh":
 double: 1
-float: 1
+float: 2
 float128: 2
 idouble: 1
-ifloat: 1
+ifloat: 2
 ifloat128: 2
 ildouble: 1
 ldouble: 1
@@ -420,10 +420,10 @@ ildouble: 2
 ldouble: 2
 
 Function: Real part of "cacosh_upward":
-double: 4
+double: 5
 float: 4
 float128: 6
-idouble: 4
+idouble: 5
 ifloat: 4
 ifloat128: 6
 ildouble: 5
@@ -488,11 +488,11 @@ ildouble: 1
 ldouble: 1
 
 Function: Imaginary part of "casin":
-double: 1
-float: 1
+double: 2
+float: 2
 float128: 2
-idouble: 1
-ifloat: 1
+idouble: 2
+ifloat: 2
 ifloat128: 2
 ildouble: 2
 ldouble: 2
@@ -558,11 +558,11 @@ ildouble: 7
 ldouble: 7
 
 Function: Real part of "casinh":
-double: 1
-float: 1
+double: 2
+float: 2
 float128: 2
-idouble: 1
-ifloat: 1
+idouble: 2
+ifloat: 2
 ifloat128: 2
 ildouble: 2
 ldouble: 2
@@ -774,11 +774,11 @@ ildouble: 1
 ldouble: 1
 
 Function: Real part of "catanh_upward":
-double: 2
-float: 2
+double: 4
+float: 4
 float128: 4
-idouble: 2
-ifloat: 2
+idouble: 4
+ifloat: 4
 ifloat128: 4
 ildouble: 4
 ldouble: 4
@@ -875,10 +875,10 @@ ldouble: 3
 
 Function: Real part of "ccos_towardzero":
 double: 1
-float: 1
+float: 2
 float128: 2
 idouble: 1
-ifloat: 1
+ifloat: 2
 ifloat128: 2
 ildouble: 3
 ldouble: 3
@@ -934,10 +934,10 @@ ildouble: 1
 ldouble: 1
 
 Function: Real part of "ccosh_downward":
-double: 1
+double: 2
 float: 2
 float128: 2
-idouble: 1
+idouble: 2
 ifloat: 2
 ifloat128: 2
 ildouble: 3
@@ -954,11 +954,11 @@ ildouble: 3
 ldouble: 3
 
 Function: Real part of "ccosh_towardzero":
-double: 1
-float: 2
+double: 2
+float: 3
 float128: 2
-idouble: 1
-ifloat: 2
+idouble: 2
+ifloat: 3
 ifloat128: 2
 ildouble: 3
 ldouble: 3
@@ -1075,10 +1075,10 @@ ldouble: 3
 
 Function: Real part of "clog":
 double: 2
-float: 1
+float: 3
 float128: 2
 idouble: 2
-ifloat: 1
+ifloat: 3
 ifloat128: 2
 ildouble: 3
 ldouble: 3
@@ -1092,79 +1092,81 @@ ildouble: 1
 ldouble: 1
 
 Function: Real part of "clog10":
-double: 2
-float: 2
+double: 3
+float: 4
 float128: 2
-idouble: 2
-ifloat: 2
+idouble: 3
+ifloat: 4
 ifloat128: 2
 ildouble: 4
 ldouble: 4
 
 Function: Imaginary part of "clog10":
-double: 1
+double: 2
+float: 1
 float128: 2
-idouble: 1
+idouble: 2
+ifloat: 1
 ifloat128: 2
 ildouble: 2
 ldouble: 2
 
 Function: Real part of "clog10_downward":
-double: 3
-float: 3
+double: 4
+float: 4
 float128: 3
-idouble: 3
-ifloat: 3
+idouble: 4
+ifloat: 4
 ifloat128: 3
 ildouble: 8
 ldouble: 8
 
 Function: Imaginary part of "clog10_downward":
-double: 1
-float: 1
+double: 2
+float: 2
 float128: 3
-idouble: 1
-ifloat: 1
+idouble: 2
+ifloat: 2
 ifloat128: 3
 ildouble: 3
 ldouble: 3
 
 Function: Real part of "clog10_towardzero":
-double: 3
-float: 3
+double: 5
+float: 5
 float128: 4
-idouble: 3
-ifloat: 3
+idouble: 5
+ifloat: 5
 ifloat128: 4
 ildouble: 8
 ldouble: 8
 
 Function: Imaginary part of "clog10_towardzero":
-double: 1
-float: 1
+double: 2
+float: 2
 float128: 3
-idouble: 1
-ifloat: 1
+idouble: 2
+ifloat: 2
 ifloat128: 3
 ildouble: 3
 ldouble: 3
 
 Function: Real part of "clog10_upward":
-double: 3
-float: 3
+double: 4
+float: 5
 float128: 4
-idouble: 3
-ifloat: 3
+idouble: 4
+ifloat: 5
 ifloat128: 4
 ildouble: 7
 ldouble: 7
 
 Function: Imaginary part of "clog10_upward":
-double: 1
-float: 1
+double: 2
+float: 2
 float128: 3
-idouble: 1
-ifloat: 1
+idouble: 2
+ifloat: 2
 ifloat128: 3
 ildouble: 3
 ldouble: 3
@@ -1191,10 +1193,10 @@ ldouble: 1
 
 Function: Real part of "clog_towardzero":
 double: 3
-float: 3
+float: 4
 float128: 3
 idouble: 3
-ifloat: 3
+ifloat: 4
 ifloat128: 3
 ildouble: 5
 ldouble: 5
@@ -1230,8 +1232,10 @@ ildouble: 1
 ldouble: 1
 
 Function: "cos":
+double: 1
 float: 1
 float128: 1
+idouble: 1
 ifloat: 1
 ifloat128: 1
 ildouble: 1
@@ -1462,7 +1466,9 @@ ildouble: 2
 ldouble: 2
 
 Function: Real part of "csinh":
+float: 1
 float128: 1
+ifloat: 1
 ifloat128: 1
 ildouble: 1
 ldouble: 1
@@ -1478,10 +1484,10 @@ ildouble: 1
 ldouble: 1
 
 Function: Real part of "csinh_downward":
-double: 1
+double: 2
 float: 1
 float128: 2
-idouble: 1
+idouble: 2
 ifloat: 1
 ifloat128: 2
 ildouble: 3
@@ -1498,11 +1504,11 @@ ildouble: 3
 ldouble: 3
 
 Function: Real part of "csinh_towardzero":
-double: 1
-float: 1
+double: 2
+float: 2
 float128: 2
-idouble: 1
-ifloat: 1
+idouble: 2
+ifloat: 2
 ifloat128: 2
 ildouble: 3
 ldouble: 3
@@ -1538,79 +1544,81 @@ ildouble: 2
 ldouble: 2
 
 Function: Real part of "csqrt":
-double: 1
+double: 2
+float: 2
 float128: 2
-idouble: 1
+idouble: 2
+ifloat: 2
 ifloat128: 2
 ildouble: 2
 ldouble: 2
 
 Function: Imaginary part of "csqrt":
-double: 1
-float: 1
+double: 2
+float: 2
 float128: 2
-idouble: 1
-ifloat: 1
+idouble: 2
+ifloat: 2
 ifloat128: 2
 ildouble: 2
 ldouble: 2
 
 Function: Real part of "csqrt_downward":
-double: 1
-float: 1
+double: 4
+float: 4
 float128: 4
-idouble: 1
-ifloat: 1
+idouble: 4
+ifloat: 4
 ifloat128: 4
 ildouble: 5
 ldouble: 5
 
 Function: Imaginary part of "csqrt_downward":
-double: 1
-float: 1
+double: 3
+float: 3
 float128: 3
-idouble: 1
-ifloat: 1
+idouble: 3
+ifloat: 3
 ifloat128: 3
 ildouble: 4
 ldouble: 4
 
 Function: Real part of "csqrt_towardzero":
-double: 1
-float: 1
+double: 3
+float: 3
 float128: 3
-idouble: 1
-ifloat: 1
+idouble: 3
+ifloat: 3
 ifloat128: 3
 ildouble: 4
 ldouble: 4
 
 Function: Imaginary part of "csqrt_towardzero":
-double: 1
-float: 1
+double: 3
+float: 3
 float128: 3
-idouble: 1
-ifloat: 1
+idouble: 3
+ifloat: 3
 ifloat128: 3
 ildouble: 4
 ldouble: 4
 
 Function: Real part of "csqrt_upward":
-double: 1
-float: 1
+double: 4
+float: 4
 float128: 4
-idouble: 1
-ifloat: 1
+idouble: 4
+ifloat: 4
 ifloat128: 4
 ildouble: 5
 ldouble: 5
 
 Function: Imaginary part of "csqrt_upward":
-double: 1
-float: 2
+double: 3
+float: 3
 float128: 3
-idouble: 1
-ifloat: 2
+idouble: 3
+ifloat: 3
 ifloat128: 3
 ildouble: 4
 ldouble: 4
@@ -1626,21 +1634,21 @@ ildouble: 2
 ldouble: 2
 
 Function: Imaginary part of "ctan":
-double: 1
-float: 1
+double: 2
+float: 2
 float128: 3
-idouble: 1
-ifloat: 1
+idouble: 2
+ifloat: 2
 ifloat128: 3
 ildouble: 1
 ldouble: 1
 
 Function: Real part of "ctan_downward":
-double: 1
-float: 2
+double: 6
+float: 5
 float128: 4
-idouble: 1
-ifloat: 2
+idouble: 6
+ifloat: 5
 ifloat128: 4
 ildouble: 5
 ldouble: 5
@@ -1656,11 +1664,11 @@ ildouble: 4
 ldouble: 4
 
 Function: Real part of "ctan_towardzero":
-double: 3
-float: 2
+double: 5
+float: 3
 float128: 4
-idouble: 3
-ifloat: 2
+idouble: 5
+ifloat: 3
 ifloat128: 4
 ildouble: 5
 ldouble: 5
@@ -1677,10 +1685,10 @@ ldouble: 4
 
 Function: Real part of "ctan_upward":
 double: 3
-float: 2
+float: 4
 float128: 5
 idouble: 3
-ifloat: 2
+ifloat: 4
 ifloat128: 5
 ildouble: 3
 ldouble: 3
@@ -1696,21 +1704,21 @@ ildouble: 3
 ldouble: 3
 
 Function: Real part of "ctanh":
-double: 1
-float: 1
+double: 2
+float: 2
 float128: 3
-idouble: 1
-ifloat: 1
+idouble: 2
+ifloat: 2
 ifloat128: 3
 ildouble: 1
 ldouble: 1
 
 Function: Imaginary part of "ctanh":
-double: 1
-float: 1
+double: 2
+float: 2
 float128: 3
-idouble: 1
-ifloat: 1
+idouble: 2
+ifloat: 2
 ifloat128: 3
 ildouble: 2
 ldouble: 2
@@ -1726,11 +1734,11 @@ ildouble: 4
 ldouble: 4
 
 Function: Imaginary part of "ctanh_downward":
-double: 2
-float: 1
+double: 6
+float: 5
 float128: 4
-idouble: 2
-ifloat: 1
+idouble: 6
+ifloat: 5
 ifloat128: 4
 ildouble: 4
 ldouble: 4
@@ -1746,31 +1754,31 @@ ildouble: 4
 ldouble: 4
 
 Function: Imaginary part of "ctanh_towardzero":
-double: 2
-float: 2
+double: 5
+float: 3
 float128: 3
-idouble: 2
-ifloat: 2
+idouble: 5
+ifloat: 3
 ifloat128: 3
 ildouble: 3
 ldouble: 3
 
 Function: Real part of "ctanh_upward":
 double: 2
-float: 1
+float: 2
 float128: 5
 idouble: 2
-ifloat: 1
+ifloat: 2
 ifloat128: 5
 ildouble: 3
 ldouble: 3
 
 Function: Imaginary part of "ctanh_upward":
 double: 3
-float: 2
+float: 3
 float128: 5
 idouble: 3
-ifloat: 2
+ifloat: 3
 ifloat128: 5
 ildouble: 3
 ldouble: 3
@@ -1816,41 +1824,41 @@ ildouble: 1
 ldouble: 1
 
 Function: "erfc":
-double: 1
-float: 1
+double: 3
+float: 2
 float128: 2
-idouble: 1
-ifloat: 1
+idouble: 3
+ifloat: 2
 ifloat128: 2
 ildouble: 3
 ldouble: 3
 
 Function: "erfc_downward":
-double: 2
-float: 3
+double: 5
+float: 6
 float128: 5
-idouble: 2
-ifloat: 3
+idouble: 5
+ifloat: 6
 ifloat128: 5
 ildouble: 4
 ldouble: 4
 
 Function: "erfc_towardzero":
-double: 2
-float: 2
+double: 3
+float: 4
 float128: 4
-idouble: 2
-ifloat: 2
+idouble: 3
+ifloat: 4
 ifloat128: 4
 ildouble: 4
 ldouble: 4
 
 Function: "erfc_upward":
-double: 2
-float: 3
+double: 5
+float: 6
 float128: 5
-idouble: 2
-ifloat: 3
+idouble: 5
+ifloat: 6
 ifloat128: 5
 ildouble: 5
 ldouble: 5
@@ -1994,34 +2002,34 @@ ildouble: 4
 ldouble: 4
 
 Function: "gamma":
-double: 3
+double: 4
 float: 3
-idouble: 3
+idouble: 4
 ifloat: 3
 ildouble: 4
 ldouble: 4
 
 Function: "gamma_downward":
-double: 4
+double: 5
 float: 5
-idouble: 4
+idouble: 5
 ifloat: 5
 ildouble: 7
 ldouble: 7
 
 Function: "gamma_towardzero":
-double: 4
-float: 3
-idouble: 4
-ifloat: 3
+double: 5
+float: 4
+idouble: 5
+ifloat: 4
 ildouble: 7
 ldouble: 7
 
 Function: "gamma_upward":
-double: 3
-float: 4
-idouble: 3
-ifloat: 4
+double: 5
+float: 5
+idouble: 5
+ifloat: 5
 ildouble: 5
 ldouble: 5
 
@@ -2059,39 +2067,39 @@ ldouble: 1
 
 Function: "j0":
 double: 2
-float: 1
+float: 2
 float128: 2
 idouble: 2
-ifloat: 1
+ifloat: 2
 ifloat128: 2
 ildouble: 2
 ldouble: 2
 
 Function: "j0_downward":
-double: 1
-float: 3
+double: 2
+float: 4
 float128: 4
-idouble: 1
-ifloat: 3
+idouble: 2
+ifloat: 4
 ifloat128: 4
 ildouble: 4
 ldouble: 4
 
 Function: "j0_towardzero":
-double: 2
-float: 1
+double: 3
+float: 2
 float128: 2
-idouble: 2
-ifloat: 1
+idouble: 3
+ifloat: 2
 ifloat128: 2
 ildouble: 5
 ldouble: 5
 
 Function: "j0_upward":
-double: 2
+double: 3
 float: 3
 float128: 5
-idouble: 2
+idouble: 3
 ifloat: 3
 ifloat128: 5
 ildouble: 4
@@ -2108,111 +2116,111 @@ ildouble: 1
 ldouble: 1
 
 Function: "j1_downward":
-double: 2
-float: 2
+double: 3
+float: 3
 float128: 4
-idouble: 2
-ifloat: 2
+idouble: 3
+ifloat: 3
 ifloat128: 4
 ildouble: 4
 ldouble: 4
 
 Function: "j1_towardzero":
-double: 2
+double: 3
 float: 2
 float128: 4
-idouble: 2
+idouble: 3
 ifloat: 2
 ifloat128: 4
 ildouble: 4
 ldouble: 4
 
 Function: "j1_upward":
-double: 2
-float: 3
+double: 3
+float: 5
 float128: 3
-idouble: 2
-ifloat: 3
+idouble: 3
+ifloat: 5
 ifloat128: 3
 ildouble: 3
 ldouble: 3
 
 Function: "jn":
-double: 2
-float: 3
+double: 4
+float: 4
 float128: 7
-idouble: 2
-ifloat: 3
+idouble: 4
+ifloat: 4
 ifloat128: 7
 ildouble: 4
 ldouble: 4
 
 Function: "jn_downward":
-double: 2
-float: 3
+double: 5
+float: 5
 float128: 8
-idouble: 2
-ifloat: 3
+idouble: 5
+ifloat: 5
 ifloat128: 8
 ildouble: 4
 ldouble: 4
 
 Function: "jn_towardzero":
-double: 2
-float: 3
+double: 5
+float: 5
 float128: 8
-idouble: 2
-ifloat: 3
+idouble: 5
+ifloat: 5
 ifloat128: 8
 ildouble: 5
 ldouble: 5
 
 Function: "jn_upward":
-double: 2
-float: 3
+double: 5
+float: 5
 float128: 7
-idouble: 2
-ifloat: 3
+idouble: 5
+ifloat: 5
 ifloat128: 7
 ildouble: 5
 ldouble: 5
 
 Function: "lgamma":
-double: 3
+double: 4
 float: 3
 float128: 5
-idouble: 3
+idouble: 4
 ifloat: 3
 ifloat128: 5
 ildouble: 4
 ldouble: 4
 
 Function: "lgamma_downward":
-double: 4
+double: 5
 float: 5
 float128: 8
-idouble: 4
+idouble: 5
 ifloat: 5
 ifloat128: 8
 ildouble: 7
 ldouble: 7
 
 Function: "lgamma_towardzero":
-double: 4
-float: 3
+double: 5
+float: 4
 float128: 5
-idouble: 4
-ifloat: 3
+idouble: 5
+ifloat: 4
 ifloat128: 5
 ildouble: 7
 ldouble: 7
 
 Function: "lgamma_upward":
-double: 3
-float: 4
+double: 5
+float: 5
 float128: 8
-idouble: 3
-ifloat: 4
+idouble: 5
+ifloat: 5
 ifloat128: 8
 ildouble: 5
 ldouble: 5
@@ -2402,8 +2410,10 @@ ildouble: 4
 ldouble: 4
 
 Function: "sin":
+double: 1
 float: 1
 float128: 1
+idouble: 1
 ifloat: 1
 ifloat128: 1
 ildouble: 1
@@ -2440,8 +2450,10 @@ ildouble: 3
 ldouble: 3
 
 Function: "sincos":
+double: 1
 float: 1
 float128: 1
+idouble: 1
 ifloat: 1
 ifloat128: 1
 ildouble: 1
@@ -2478,39 +2490,41 @@ ildouble: 3
 ldouble: 3
 
 Function: "sinh":
-double: 1
+double: 2
+float: 2
 float128: 2
-idouble: 1
+idouble: 2
+ifloat: 2
 ifloat128: 2
 ildouble: 2
 ldouble: 2
 
 Function: "sinh_downward":
-double: 2
-float: 1
+double: 3
+float: 3
 float128: 3
-idouble: 2
-ifloat: 1
+idouble: 3
+ifloat: 3
 ifloat128: 3
 ildouble: 5
 ldouble: 5
 
 Function: "sinh_towardzero":
 double: 2
-float: 1
+float: 2
 float128: 3
 idouble: 2
-ifloat: 1
+ifloat: 2
 ifloat128: 3
 ildouble: 4
 ldouble: 4
 
 Function: "sinh_upward":
 double: 4
-float: 2
+float: 3
 float128: 4
 idouble: 4
-ifloat: 2
+ifloat: 3
 ifloat128: 4
 ildouble: 5
 ldouble: 5
@@ -2554,199 +2568,201 @@ ildouble: 2
 ldouble: 2
 
 Function: "tanh":
-double: 1
+double: 2
+float: 2
 float128: 2
-idouble: 1
+idouble: 2
+ifloat: 2
 ifloat128: 2
 ildouble: 3
 ldouble: 3
 
 Function: "tanh_downward":
-double: 1
-float: 1
+double: 3
+float: 3
 float128: 4
-idouble: 1
-ifloat: 1
+idouble: 3
+ifloat: 3
 ifloat128: 4
 ildouble: 7
 ldouble: 4
 
 Function: "tanh_towardzero":
-double: 1
-float: 1
+double: 2
+float: 2
 float128: 3
-idouble: 1
-ifloat: 1
+idouble: 2
+ifloat: 2
 ifloat128: 3
 ildouble: 3
 ldouble: 3
 
 Function: "tanh_upward":
-double: 1
-float: 1
+double: 3
+float: 3
 float128: 3
-idouble: 1
-ifloat: 1
+idouble: 3
+ifloat: 3
 ifloat128: 3
 ildouble: 5
 ldouble: 4
 
 Function: "tgamma":
-double: 3
-float: 3
+double: 5
+float: 4
 float128: 4
-idouble: 3
-ifloat: 3
+idouble: 5
+ifloat: 4
 ifloat128: 4
 ildouble: 5
 ldouble: 5
 
 Function: "tgamma_downward":
-double: 3
-float: 3
+double: 6
+float: 5
 float128: 5
-idouble: 3
-ifloat: 3
+idouble: 6
+ifloat: 5
 ifloat128: 5
 ildouble: 5
 ldouble: 5
 
 Function: "tgamma_towardzero":
-double: 3
-float: 3
+double: 6
+float: 4
 float128: 5
-idouble: 3
-ifloat: 3
+idouble: 6
+ifloat: 4
 ifloat128: 5
 ildouble: 5
 ldouble: 5
 
 Function: "tgamma_upward":
-double: 3
-float: 3
+double: 5
+float: 4
 float128: 4
-idouble: 3
-ifloat: 3
+idouble: 5
+ifloat: 4
 ifloat128: 4
 ildouble: 5
 ldouble: 5
 
 Function: "y0":
-double: 1
+double: 2
 float: 1
 float128: 3
-idouble: 1
+idouble: 2
 ifloat: 1
 ifloat128: 3
 ildouble: 1
 ldouble: 1
 
 Function: "y0_downward":
-double: 2
-float: 3
+double: 3
+float: 4
 float128: 4
-idouble: 2
-ifloat: 3
+idouble: 3
+ifloat: 4
 ifloat128: 4
 ildouble: 5
 ldouble: 5
 
 Function: "y0_towardzero":
-double: 2
+double: 3
 float: 3
 float128: 3
-idouble: 2
+idouble: 3
 ifloat: 3
 ifloat128: 3
 ildouble: 5
 ldouble: 5
 
 Function: "y0_upward":
-double: 1
-float: 3
+double: 3
+float: 5
 float128: 3
-idouble: 1
-ifloat: 3
+idouble: 3
+ifloat: 5
 ifloat128: 3
 ildouble: 3
 ldouble: 3
 
 Function: "y1":
-double: 2
+double: 3
 float: 2
 float128: 2
-idouble: 2
+idouble: 3
 ifloat: 2
 ifloat128: 2
 ildouble: 2
 ldouble: 2
 
 Function: "y1_downward":
-double: 2
+double: 3
 float: 3
 float128: 4
-idouble: 2
+idouble: 3
 ifloat: 3
 ifloat128: 4
 ildouble: 7
 ldouble: 7
 
 Function: "y1_towardzero":
-double: 2
+double: 3
 float: 3
 float128: 2
-idouble: 2
+idouble: 3
 ifloat: 3
 ifloat128: 2
 ildouble: 5
 ldouble: 5
 
 Function: "y1_upward":
-double: 1
+double: 7
 float: 3
 float128: 5
-idouble: 1
+idouble: 7
 ifloat: 3
 ifloat128: 5
 ildouble: 7
 ldouble: 7
 
 Function: "yn":
-double: 2
+double: 3
 float: 3
 float128: 5
-idouble: 2
+idouble: 3
 ifloat: 3
 ifloat128: 5
 ildouble: 4
 ldouble: 4
 
 Function: "yn_downward":
-double: 2
-float: 3
+double: 3
+float: 4
 float128: 5
-idouble: 2
-ifloat: 3
+idouble: 3
+ifloat: 4
 ifloat128: 5
 ildouble: 5
 ldouble: 5
 
 Function: "yn_towardzero":
 double: 3
-float: 3
+float: 4
 float128: 5
 idouble: 3
-ifloat: 3
+ifloat: 4
 ifloat128: 5
 ildouble: 5
 ldouble: 5
 
 Function: "yn_upward":
-double: 3
-float: 3
+double: 4
+float: 5
 float128: 5
-idouble: 3
-ifloat: 3
+idouble: 4
+ifloat: 5
 ifloat128: 5
 ildouble: 4
 ldouble: 4
diff --git a/sysdeps/i386/i686/fpu/multiarch/libm-test-ulps b/sysdeps/i386/i686/fpu/multiarch/libm-test-ulps
index 8a862ef2eb..1bc39f47e8 100644
--- a/sysdeps/i386/i686/fpu/multiarch/libm-test-ulps
+++ b/sysdeps/i386/i686/fpu/multiarch/libm-test-ulps
@@ -281,20 +281,20 @@ ldouble: 1
 
 Function: Real part of "cacos":
 double: 1
-float: 1
+float: 2
 float128: 2
 idouble: 1
-ifloat: 1
+ifloat: 2
 ifloat128: 2
 ildouble: 1
 ldouble: 1
 
 Function: Imaginary part of "cacos":
-double: 1
-float: 1
+double: 2
+float: 2
 float128: 2
-idouble: 1
-ifloat: 1
+idouble: 2
+ifloat: 2
 ifloat128: 2
 ildouble: 2
 ldouble: 2
@@ -360,21 +360,21 @@ ildouble: 7
 ldouble: 7
 
 Function: Real part of "cacosh":
-double: 1
-float: 1
+double: 2
+float: 2
 float128: 2
-idouble: 1
-ifloat: 1
+idouble: 2
+ifloat: 2
 ifloat128: 2
 ildouble: 2
 ldouble: 2
 
 Function: Imaginary part of "cacosh":
 double: 1
-float: 1
+float: 2
 float128: 2
 idouble: 1
-ifloat: 1
+ifloat: 2
 ifloat128: 2
 ildouble: 1
 ldouble: 1
@@ -420,10 +420,10 @@ ildouble: 2
 ldouble: 2
 
 Function: Real part of "cacosh_upward":
-double: 4
+double: 5
 float: 4
 float128: 6
-idouble: 4
+idouble: 5
 ifloat: 4
 ifloat128: 6
 ildouble: 5
@@ -488,11 +488,11 @@ ildouble: 1
 ldouble: 1
 
 Function: Imaginary part of "casin":
-double: 1
-float: 1
+double: 2
+float: 2
 float128: 2
-idouble: 1
-ifloat: 1
+idouble: 2
+ifloat: 2
 ifloat128: 2
 ildouble: 2
 ldouble: 2
@@ -558,11 +558,11 @@ ildouble: 7
 ldouble: 7
 
 Function: Real part of "casinh":
-double: 1
-float: 1
+double: 2
+float: 2
 float128: 2
-idouble: 1
-ifloat: 1
+idouble: 2
+ifloat: 2
 ifloat128: 2
 ildouble: 2
 ldouble: 2
@@ -774,11 +774,11 @@ ildouble: 1
 ldouble: 1
 
 Function: Real part of "catanh_upward":
-double: 2
-float: 2
+double: 4
+float: 4
 float128: 4
-idouble: 2
-ifloat: 2
+idouble: 4
+ifloat: 4
 ifloat128: 4
 ildouble: 4
 ldouble: 4
@@ -875,10 +875,10 @@ ldouble: 3
 
 Function: Real part of "ccos_towardzero":
 double: 1
-float: 1
+float: 2
 float128: 2
 idouble: 1
-ifloat: 1
+ifloat: 2
 ifloat128: 2
 ildouble: 3
 ldouble: 3
@@ -934,10 +934,10 @@ ildouble: 1
 ldouble: 1
 
 Function: Real part of "ccosh_downward":
-double: 1
+double: 2
 float: 2
 float128: 2
-idouble: 1
+idouble: 2
 ifloat: 2
 ifloat128: 2
 ildouble: 3
@@ -954,11 +954,11 @@ ildouble: 3
 ldouble: 3
 
 Function: Real part of "ccosh_towardzero":
-double: 1
-float: 2
+double: 2
+float: 3
 float128: 2
-idouble: 1
-ifloat: 2
+idouble: 2
+ifloat: 3
 ifloat128: 2
 ildouble: 3
 ldouble: 3
@@ -1075,10 +1075,10 @@ ldouble: 3
 
 Function: Real part of "clog":
 double: 2
-float: 1
+float: 3
 float128: 2
 idouble: 2
-ifloat: 1
+ifloat: 3
 ifloat128: 2
 ildouble: 3
 ldouble: 3
@@ -1092,79 +1092,81 @@ ildouble: 1
 ldouble: 1
 
 Function: Real part of "clog10":
-double: 2
-float: 2
+double: 3
+float: 4
 float128: 2
-idouble: 2
-ifloat: 2
+idouble: 3
+ifloat: 4
 ifloat128: 2
 ildouble: 4
 ldouble: 4
 
 Function: Imaginary part of "clog10":
-double: 1
+double: 2
+float: 1
 float128: 2
-idouble: 1
+idouble: 2
+ifloat: 1
 ifloat128: 2
 ildouble: 2
 ldouble: 2
 
 Function: Real part of "clog10_downward":
-double: 3
-float: 3
+double: 4
+float: 4
 float128: 3
-idouble: 3
-ifloat: 3
+idouble: 4
+ifloat: 4
 ifloat128: 3
 ildouble: 8
 ldouble: 8
 
 Function: Imaginary part of "clog10_downward":
-double: 1
-float: 1
+double: 2
+float: 2
 float128: 3
-idouble: 1
-ifloat: 1
+idouble: 2
+ifloat: 2
 ifloat128: 3
 ildouble: 3
 ldouble: 3
 
 Function: Real part of "clog10_towardzero":
-double: 3
-float: 3
+double: 5
+float: 5
 float128: 4
-idouble: 3
-ifloat: 3
+idouble: 5
+ifloat: 5
 ifloat128: 4
 ildouble: 8
 ldouble: 8
 
 Function: Imaginary part of "clog10_towardzero":
-double: 1
-float: 1
+double: 2
+float: 2
 float128: 3
-idouble: 1
-ifloat: 1
+idouble: 2
+ifloat: 2
 ifloat128: 3
 ildouble: 3
 ldouble: 3
 
 Function: Real part of "clog10_upward":
-double: 3
-float: 3
+double: 4
+float: 5
 float128: 4
-idouble: 3
-ifloat: 3
+idouble: 4
+ifloat: 5
 ifloat128: 4
 ildouble: 8
 ldouble: 8
 
 Function: Imaginary part of "clog10_upward":
-double: 1
-float: 1
+double: 2
+float: 2
 float128: 3
-idouble: 1
-ifloat: 1
+idouble: 2
+ifloat: 2
 ifloat128: 3
 ildouble: 3
 ldouble: 3
@@ -1191,10 +1193,10 @@ ldouble: 1
 
 Function: Real part of "clog_towardzero":
 double: 3
-float: 3
+float: 4
 float128: 3
 idouble: 3
-ifloat: 3
+ifloat: 4
 ifloat128: 3
 ildouble: 5
 ldouble: 5
@@ -1230,7 +1232,9 @@ ildouble: 1
 ldouble: 1
 
 Function: "cos":
+double: 1
 float128: 1
+idouble: 1
 ifloat128: 1
 ildouble: 1
 ldouble: 1
@@ -1478,10 +1482,10 @@ ildouble: 1
 ldouble: 1
 
 Function: Real part of "csinh_downward":
-double: 1
+double: 2
 float: 2
 float128: 2
-idouble: 1
+idouble: 2
 ifloat: 2
 ifloat128: 2
 ildouble: 3
@@ -1498,10 +1502,10 @@ ildouble: 3
 ldouble: 3
 
 Function: Real part of "csinh_towardzero":
-double: 1
+double: 2
 float: 2
 float128: 2
-idouble: 1
+idouble: 2
 ifloat: 2
 ifloat128: 2
 ildouble: 3
@@ -1538,79 +1542,81 @@ ildouble: 3
 ldouble: 3
 
 Function: Real part of "csqrt":
-double: 1
+double: 2
+float: 2
 float128: 2
-idouble: 1
+idouble: 2
+ifloat: 2
 ifloat128: 2
 ildouble: 2
 ldouble: 2
 
 Function: Imaginary part of "csqrt":
-double: 1
-float: 1
+double: 2
+float: 2
 float128: 2
-idouble: 1
-ifloat: 1
+idouble: 2
+ifloat: 2
 ifloat128: 2
 ildouble: 2
 ldouble: 2
 
 Function: Real part of "csqrt_downward":
-double: 1
-float: 1
+double: 4
+float: 4
 float128: 4
-idouble: 1
-ifloat: 1
+idouble: 4
+ifloat: 4
 ifloat128: 4
 ildouble: 5
 ldouble: 5
 
 Function: Imaginary part of "csqrt_downward":
-double: 1
-float: 1
+double: 3
+float: 3
 float128: 3
-idouble: 1
-ifloat: 1
+idouble: 3
+ifloat: 3
 ifloat128: 3
 ildouble: 4
 ldouble: 4
 
 Function: Real part of "csqrt_towardzero":
-double: 1
-float: 1
+double: 3
+float: 3
 float128: 3
-idouble: 1
-ifloat: 1
+idouble: 3
+ifloat: 3
 ifloat128: 3
 ildouble: 4
 ldouble: 4
 
 Function: Imaginary part of "csqrt_towardzero":
-double: 1
-float: 1
+double: 3
+float: 3
 float128: 3
-idouble: 1
-ifloat: 1
+idouble: 3
+ifloat: 3
 ifloat128: 3
 ildouble: 4
 ldouble: 4
 
 Function: Real part of "csqrt_upward":
-double: 1
-float: 1
+double: 4
+float: 4
 float128: 4
-idouble: 1
-ifloat: 1
+idouble: 4
+ifloat: 4
 ifloat128: 4
 ildouble: 5
 ldouble: 5
 
 Function: Imaginary part of "csqrt_upward":
-double: 1
-float: 2
+double: 3
+float: 3
 float128: 3
-idouble: 1
-ifloat: 2
+idouble: 3
+ifloat: 3
 ifloat128: 3
 ildouble: 4
 ldouble: 4
@@ -1626,21 +1632,21 @@ ildouble: 2
 ldouble: 2
 
 Function: Imaginary part of "ctan":
-double: 1
-float: 1
+double: 2
+float: 2
 float128: 3
-idouble: 1
-ifloat: 1
+idouble: 2
+ifloat: 2
 ifloat128: 3
 ildouble: 1
 ldouble: 1
 
 Function: Real part of "ctan_downward":
-double: 1
-float: 2
+double: 6
+float: 5
 float128: 4
-idouble: 1
-ifloat: 2
+idouble: 6
+ifloat: 5
 ifloat128: 4
 ildouble: 5
 ldouble: 5
@@ -1656,31 +1662,31 @@ ildouble: 4
 ldouble: 4
 
 Function: Real part of "ctan_towardzero":
-double: 3
-float: 1
+double: 5
+float: 3
 float128: 4
-idouble: 3
-ifloat: 1
+idouble: 5
+ifloat: 3
 ifloat128: 4
 ildouble: 5
 ldouble: 5
 
 Function: Imaginary part of "ctan_towardzero":
 double: 2
-float: 1
+float: 2
 float128: 5
 idouble: 2
-ifloat: 1
+ifloat: 2
 ifloat128: 5
 ildouble: 4
 ldouble: 4
 
 Function: Real part of "ctan_upward":
 double: 3
-float: 2
+float: 4
 float128: 5
 idouble: 3
-ifloat: 2
+ifloat: 4
 ifloat128: 5
 ildouble: 3
 ldouble: 3
@@ -1696,21 +1702,21 @@ ildouble: 3
 ldouble: 3
 
 Function: Real part of "ctanh":
-double: 1
-float: 1
+double: 2
+float: 2
 float128: 3
-idouble: 1
-ifloat: 1
+idouble: 2
+ifloat: 2
 ifloat128: 3
 ildouble: 1
 ldouble: 1
 
 Function: Imaginary part of "ctanh":
-double: 1
-float: 1
+double: 2
+float: 2
 float128: 3
-idouble: 1
-ifloat: 1
+idouble: 2
+ifloat: 2
 ifloat128: 3
 ildouble: 2
 ldouble: 2
@@ -1726,51 +1732,51 @@ ildouble: 4
 ldouble: 4
 
 Function: Imaginary part of "ctanh_downward":
-double: 2
-float: 1
+double: 6
+float: 5
 float128: 4
-idouble: 2
-ifloat: 1
+idouble: 6
+ifloat: 5
 ifloat128: 4
 ildouble: 4
 ldouble: 4
 
 Function: Real part of "ctanh_towardzero":
 double: 2
-float: 1
+float: 2
 float128: 5
 idouble: 2
-ifloat: 1
+ifloat: 2
 ifloat128: 5
 ildouble: 4
 ldouble: 4
 
 Function: Imaginary part of "ctanh_towardzero":
-double: 2
-float: 1
+double: 5
+float: 3
 float128: 3
-idouble: 2
-ifloat: 1
+idouble: 5
+ifloat: 3
 ifloat128: 3
 ildouble: 3
 ldouble: 3
 
 Function: Real part of "ctanh_upward":
 double: 2
-float: 1
+float: 2
 float128: 5
 idouble: 2
-ifloat: 1
+ifloat: 2
 ifloat128: 5
 ildouble: 3
 ldouble: 3
 
 Function: Imaginary part of "ctanh_upward":
 double: 3
-float: 2
+float: 3
 float128: 5
 idouble: 3
-ifloat: 2
+ifloat: 3
 ifloat128: 5
 ildouble: 3
 ldouble: 3
@@ -1816,41 +1822,41 @@ ildouble: 1
 ldouble: 1
 
 Function: "erfc":
-double: 1
-float: 1
+double: 3
+float: 2
 float128: 2
-idouble: 1
-ifloat: 1
+idouble: 3
+ifloat: 2
 ifloat128: 2
 ildouble: 3
 ldouble: 3
 
 Function: "erfc_downward":
-double: 2
-float: 3
+double: 5
+float: 6
 float128: 5
-idouble: 2
-ifloat: 3
+idouble: 5
+ifloat: 6
 ifloat128: 5
 ildouble: 4
 ldouble: 4
 
 Function: "erfc_towardzero":
-double: 2
-float: 2
+double: 3
+float: 4
 float128: 4
-idouble: 2
-ifloat: 2
+idouble: 3
+ifloat: 4
 ifloat128: 4
 ildouble: 4
 ldouble: 4
 
 Function: "erfc_upward":
-double: 2
-float: 3
+double: 5
+float: 6
 float128: 5
-idouble: 2
-ifloat: 3
+idouble: 5
+ifloat: 6
 ifloat128: 5
 ildouble: 5
 ldouble: 5
@@ -1994,34 +2000,34 @@ ildouble: 4
 ldouble: 4
 
 Function: "gamma":
-double: 3
+double: 4
 float: 3
-idouble: 3
+idouble: 4
 ifloat: 3
 ildouble: 4
 ldouble: 4
 
 Function: "gamma_downward":
-double: 4
+double: 5
 float: 5
-idouble: 4
+idouble: 5
 ifloat: 5
 ildouble: 7
 ldouble: 7
 
 Function: "gamma_towardzero":
-double: 4
+double: 5
 float: 4
-idouble: 4
+idouble: 5
 ifloat: 4
 ildouble: 7
 ldouble: 7
 
 Function: "gamma_upward":
-double: 3
-float: 4
-idouble: 3
-ifloat: 4
+double: 5
+float: 5
+idouble: 5
+ifloat: 5
 ildouble: 6
 ldouble: 6
 
@@ -2059,39 +2065,39 @@ ldouble: 1
 
 Function: "j0":
 double: 2
-float: 1
+float: 2
 float128: 2
 idouble: 2
-ifloat: 1
+ifloat: 2
 ifloat128: 2
 ildouble: 2
 ldouble: 2
 
 Function: "j0_downward":
-double: 1
-float: 3
+double: 2
+float: 4
 float128: 4
-idouble: 1
-ifloat: 3
+idouble: 2
+ifloat: 4
 ifloat128: 4
 ildouble: 4
 ldouble: 4
 
 Function: "j0_towardzero":
-double: 2
-float: 1
+double: 3
+float: 2
 float128: 2
-idouble: 2
-ifloat: 1
+idouble: 3
+ifloat: 2
 ifloat128: 2
 ildouble: 5
 ldouble: 5
 
 Function: "j0_upward":
-double: 2
+double: 3
 float: 3
 float128: 5
-idouble: 2
+idouble: 3
 ifloat: 3
 ifloat128: 5
 ildouble: 4
@@ -2099,120 +2105,120 @@ ldouble: 4
 
 Function: "j1":
 double: 2
-float: 1
+float: 2
 float128: 4
 idouble: 2
-ifloat: 1
+ifloat: 2
 ifloat128: 4
 ildouble: 1
 ldouble: 1
 
 Function: "j1_downward":
-double: 2
-float: 2
+double: 3
+float: 3
 float128: 4
-idouble: 2
-ifloat: 2
+idouble: 3
+ifloat: 3
 ifloat128: 4
 ildouble: 4
 ldouble: 4
 
 Function: "j1_towardzero":
-double: 2
+double: 3
 float: 2
 float128: 4
-idouble: 2
+idouble: 3
 ifloat: 2
 ifloat128: 4
 ildouble: 4
 ldouble: 4
 
 Function: "j1_upward":
-double: 2
-float: 3
+double: 3
+float: 5
 float128: 3
-idouble: 2
-ifloat: 3
+idouble: 3
+ifloat: 5
 ifloat128: 3
 ildouble: 3
 ldouble: 3
 
 Function: "jn":
-double: 2
-float: 3
+double: 4
+float: 4
 float128: 7
-idouble: 2
-ifloat: 3
+idouble: 4
+ifloat: 4
 ifloat128: 7
 ildouble: 4
 ldouble: 4
 
 Function: "jn_downward":
-double: 2
-float: 3
+double: 5
+float: 5
 float128: 8
-idouble: 2
-ifloat: 3
+idouble: 5
+ifloat: 5
 ifloat128: 8
 ildouble: 4
 ldouble: 4
 
 Function: "jn_towardzero":
-double: 2
-float: 3
+double: 5
+float: 5
 float128: 8
-idouble: 2
-ifloat: 3
+idouble: 5
+ifloat: 5
 ifloat128: 8
 ildouble: 5
 ldouble: 5
 
 Function: "jn_upward":
-double: 2
-float: 3
+double: 5
+float: 5
 float128: 7
-idouble: 2
-ifloat: 3
+idouble: 5
+ifloat: 5
 ifloat128: 7
 ildouble: 5
 ldouble: 5
 
 Function: "lgamma":
-double: 3
+double: 4
 float: 3
 float128: 5
-idouble: 3
+idouble: 4
 ifloat: 3
 ifloat128: 5
 ildouble: 4
 ldouble: 4
 
 Function: "lgamma_downward":
-double: 4
+double: 5
 float: 5
 float128: 8
-idouble: 4
+idouble: 5
 ifloat: 5
 ifloat128: 8
 ildouble: 7
 ldouble: 7
 
 Function: "lgamma_towardzero":
-double: 4
+double: 5
 float: 4
 float128: 5
-idouble: 4
+idouble: 5
 ifloat: 4
 ifloat128: 5
 ildouble: 7
 ldouble: 7
 
 Function: "lgamma_upward":
-double: 3
-float: 4
+double: 5
+float: 5
 float128: 8
-idouble: 3
-ifloat: 4
+idouble: 5
+ifloat: 5
 ifloat128: 8
 ildouble: 6
 ldouble: 6
@@ -2402,7 +2408,9 @@ ildouble: 4
 ldouble: 4
 
 Function: "sin":
+double: 1
 float128: 1
+idouble: 1
 ifloat128: 1
 ildouble: 1
 ldouble: 1
@@ -2432,7 +2440,9 @@ ildouble: 3
 ldouble: 3
 
 Function: "sincos":
+double: 1
 float128: 1
+idouble: 1
 ifloat128: 1
 ildouble: 1
 ldouble: 1
@@ -2462,39 +2472,41 @@ ildouble: 3
 ldouble: 3
 
 Function: "sinh":
-double: 1
+double: 2
+float: 2
 float128: 2
-idouble: 1
+idouble: 2
+ifloat: 2
 ifloat128: 2
 ildouble: 2
 ldouble: 2
 
 Function: "sinh_downward":
-double: 2
-float: 1
+double: 3
+float: 3
 float128: 3
-idouble: 2
-ifloat: 1
+idouble: 3
+ifloat: 3
 ifloat128: 3
 ildouble: 5
 ldouble: 5
 
 Function: "sinh_towardzero":
 double: 2
-float: 1
+float: 2
 float128: 3
 idouble: 2
-ifloat: 1
+ifloat: 2
 ifloat128: 3
 ildouble: 4
 ldouble: 4
 
 Function: "sinh_upward":
 double: 4
-float: 2
+float: 3
 float128: 4
 idouble: 4
-ifloat: 2
+ifloat: 3
 ifloat128: 4
 ildouble: 5
 ldouble: 5
@@ -2538,199 +2550,201 @@ ildouble: 2
 ldouble: 2
 
 Function: "tanh":
-double: 1
+double: 2
+float: 2
 float128: 2
-idouble: 1
+idouble: 2
+ifloat: 2
 ifloat128: 2
 ildouble: 3
 ldouble: 3
 
 Function: "tanh_downward":
-double: 1
-float: 1
+double: 3
+float: 3
 float128: 4
-idouble: 1
-ifloat: 1
+idouble: 3
+ifloat: 3
 ifloat128: 4
 ildouble: 7
 ldouble: 4
 
 Function: "tanh_towardzero":
-double: 1
-float: 1
+double: 2
+float: 2
 float128: 3
-idouble: 1
-ifloat: 1
+idouble: 2
+ifloat: 2
 ifloat128: 3
 ildouble: 3
 ldouble: 3
 
 Function: "tanh_upward":
-double: 1
-float: 1
+double: 3
+float: 3
 float128: 3
-idouble: 1
-ifloat: 1
+idouble: 3
+ifloat: 3
 ifloat128: 3
 ildouble: 5
 ldouble: 4
 
 Function: "tgamma":
-double: 3
-float: 3
+double: 5
+float: 4
 float128: 4
-idouble: 3
-ifloat: 3
+idouble: 5
+ifloat: 4
 ifloat128: 4
 ildouble: 5
 ldouble: 5
 
 Function: "tgamma_downward":
-double: 3
+double: 6
 float: 5
 float128: 5
-idouble: 3
+idouble: 6
 ifloat: 5
 ifloat128: 5
 ildouble: 5
 ldouble: 5
 
 Function: "tgamma_towardzero":
-double: 4
+double: 6
 float: 5
 float128: 5
-idouble: 4
+idouble: 6
 ifloat: 5
 ifloat128: 5
 ildouble: 5
 ldouble: 5
 
 Function: "tgamma_upward":
-double: 4
+double: 5
 float: 6
 float128: 4
-idouble: 4
+idouble: 5
 ifloat: 6
 ifloat128: 4
 ildouble: 5
 ldouble: 5
 
 Function: "y0":
-double: 1
+double: 2
 float: 1
 float128: 3
-idouble: 1
+idouble: 2
 ifloat: 1
 ifloat128: 3
 ildouble: 1
 ldouble: 1
 
 Function: "y0_downward":
-double: 2
-float: 2
+double: 3
+float: 4
 float128: 4
-idouble: 2
-ifloat: 2
+idouble: 3
+ifloat: 4
 ifloat128: 4
 ildouble: 5
 ldouble: 5
 
 Function: "y0_towardzero":
-double: 2
+double: 3
 float: 3
 float128: 3
-idouble: 2
+idouble: 3
 ifloat: 3
 ifloat128: 3
 ildouble: 5
 ldouble: 5
 
 Function: "y0_upward":
-double: 1
-float: 3
+double: 3
+float: 5
 float128: 3
-idouble: 1
-ifloat: 3
+idouble: 3
+ifloat: 5
 ifloat128: 3
 ildouble: 3
 ldouble: 3
 
 Function: "y1":
-double: 2
+double: 3
 float: 2
 float128: 2
-idouble: 2
+idouble: 3
 ifloat: 2
 ifloat128: 2
 ildouble: 2
 ldouble: 2
 
 Function: "y1_downward":
-double: 2
-float: 2
+double: 3
+float: 4
 float128: 4
-idouble: 2
-ifloat: 2
+idouble: 3
+ifloat: 4
 ifloat128: 4
 ildouble: 7
 ldouble: 7
 
 Function: "y1_towardzero":
-double: 2
-float: 2
+double: 3
+float: 3
 float128: 2
-idouble: 2
-ifloat: 2
+idouble: 3
+ifloat: 3
 ifloat128: 2
 ildouble: 5
 ldouble: 5
 
 Function: "y1_upward":
-double: 1
+double: 7
 float: 3
 float128: 5
-idouble: 1
+idouble: 7
 ifloat: 3
 ifloat128: 5
 ildouble: 7
 ldouble: 7
 
 Function: "yn":
-double: 2
+double: 3
 float: 3
 float128: 5
-idouble: 2
+idouble: 3
 ifloat: 3
 ifloat128: 5
 ildouble: 4
 ldouble: 4
 
 Function: "yn_downward":
-double: 2
-float: 2
+double: 3
+float: 4
 float128: 5
-idouble: 2
-ifloat: 2
+idouble: 3
+ifloat: 4
 ifloat128: 5
 ildouble: 5
 ldouble: 5
 
 Function: "yn_towardzero":
 double: 3
-float: 3
+float: 4
 float128: 5
 idouble: 3
-ifloat: 3
+ifloat: 4
 ifloat128: 5
 ildouble: 5
 ldouble: 5
 
 Function: "yn_upward":
-double: 3
-float: 3
+double: 4
+float: 5
 float128: 5
-idouble: 3
-ifloat: 3
+idouble: 4
+ifloat: 5
 ifloat128: 5
 ildouble: 4
 ldouble: 4
diff --git a/sysdeps/i386/i686/multiarch/memcpy-sse2-unaligned.S b/sysdeps/i386/i686/multiarch/memcpy-sse2-unaligned.S
index 9c3bbe7e17..9aa17de99c 100644
--- a/sysdeps/i386/i686/multiarch/memcpy-sse2-unaligned.S
+++ b/sysdeps/i386/i686/multiarch/memcpy-sse2-unaligned.S
@@ -72,7 +72,7 @@ ENTRY (MEMCPY)
 	cmp	%edx, %eax
 
 # ifdef USE_AS_MEMMOVE
-	jg	L(check_forward)
+	ja	L(check_forward)
 
 L(mm_len_0_or_more_backward):
 /* Now do checks for lengths. We do [0..16], [16..32], [32..64], [64..128]
@@ -81,7 +81,7 @@ L(mm_len_0_or_more_backward):
 	jbe	L(mm_len_0_16_bytes_backward)
 
 	cmpl	$32, %ecx
-	jg	L(mm_len_32_or_more_backward)
+	ja	L(mm_len_32_or_more_backward)
 
 /* Copy [0..32] and return.  */
 	movdqu	(%eax), %xmm0
@@ -92,7 +92,7 @@ L(mm_len_0_or_more_backward):
 
 L(mm_len_32_or_more_backward):
 	cmpl	$64, %ecx
-	jg	L(mm_len_64_or_more_backward)
+	ja	L(mm_len_64_or_more_backward)
 
 /* Copy [0..64] and return.  */
 	movdqu	(%eax), %xmm0
@@ -107,7 +107,7 @@ L(mm_len_32_or_more_backward):
 
 L(mm_len_64_or_more_backward):
 	cmpl	$128, %ecx
-	jg	L(mm_len_128_or_more_backward)
+	ja	L(mm_len_128_or_more_backward)
 
 /* Copy [0..128] and return.  */
 	movdqu	(%eax), %xmm0
@@ -132,7 +132,7 @@ L(mm_len_128_or_more_backward):
 	add	%ecx, %eax
 	cmp	%edx, %eax
 	movl	SRC(%esp), %eax
-	jle	L(forward)
+	jbe	L(forward)
 	PUSH (%esi)
 	PUSH (%edi)
 	PUSH (%ebx)
@@ -269,7 +269,7 @@ L(check_forward):
 	add	%edx, %ecx
 	cmp	%eax, %ecx
 	movl	LEN(%esp), %ecx
-	jle	L(forward)
+	jbe	L(forward)
 
 /* Now do checks for lengths. We do [0..16], [0..32], [0..64], [0..128]
 	separately.  */
diff --git a/sysdeps/i386/i686/multiarch/strncmp-c.c b/sysdeps/i386/i686/multiarch/strncmp-c.c
index cc059da494..2e3eca9b2b 100644
--- a/sysdeps/i386/i686/multiarch/strncmp-c.c
+++ b/sysdeps/i386/i686/multiarch/strncmp-c.c
@@ -1,4 +1,4 @@
-#ifdef SHARED
+#if defined (SHARED) && IS_IN (libc)
 # define STRNCMP __strncmp_ia32
 # undef libc_hidden_builtin_def
 # define libc_hidden_builtin_def(name)  \
diff --git a/sysdeps/ia64/fpu/e_exp2f.S b/sysdeps/ia64/fpu/e_exp2f.S
index 77bc6ea686..3010a95a2d 100644
--- a/sysdeps/ia64/fpu/e_exp2f.S
+++ b/sysdeps/ia64/fpu/e_exp2f.S
@@ -221,7 +221,7 @@ LOCAL_OBJECT_END(T_table)
 
 
 .section .text
-GLOBAL_LIBM_ENTRY(__exp2f)
+WEAK_LIBM_ENTRY(exp2f)
 
 
 {.mfi
@@ -468,10 +468,10 @@ OUT_RANGE_exp2:
 }
 ;;
 
-GLOBAL_LIBM_END(__exp2f)
+WEAK_LIBM_END(exp2f)
 libm_alias_float_other (__exp2, exp2)
 #ifdef SHARED
-.symver __exp2f,exp2f@@GLIBC_2.27
+.symver exp2f,exp2f@@GLIBC_2.27
 .weak __exp2f_compat
 .set __exp2f_compat,__exp2f
 .symver __exp2f_compat,exp2f@GLIBC_2.2
diff --git a/sysdeps/ia64/fpu/e_log2f.S b/sysdeps/ia64/fpu/e_log2f.S
index 5ca3bd61ea..e4ea094344 100644
--- a/sysdeps/ia64/fpu/e_log2f.S
+++ b/sysdeps/ia64/fpu/e_log2f.S
@@ -252,7 +252,7 @@ LOCAL_OBJECT_END(T_table)
 
 
 .section .text
-GLOBAL_LIBM_ENTRY(__log2f)
+WEAK_LIBM_ENTRY(log2f)
 
 { .mfi
   alloc r32=ar.pfs,1,4,4,0
@@ -491,10 +491,10 @@ SPECIAL_log2f:
   br.ret.sptk b0;;
 }
 
-GLOBAL_LIBM_END(__log2f)
+WEAK_LIBM_END(log2f)
 libm_alias_float_other (__log2, log2)
 #ifdef SHARED
-.symver __log2f,log2f@@GLIBC_2.27
+.symver log2f,log2f@@GLIBC_2.27
 .weak __log2f_compat
 .set __log2f_compat,__log2f
 .symver __log2f_compat,log2f@GLIBC_2.2
diff --git a/sysdeps/ia64/fpu/e_powf.S b/sysdeps/ia64/fpu/e_powf.S
index 7449f8c7d5..945d5cdf28 100644
--- a/sysdeps/ia64/fpu/e_powf.S
+++ b/sysdeps/ia64/fpu/e_powf.S
@@ -868,7 +868,7 @@ data8 0xEAC0C6E7DD24392F , 0x00003FFF
 LOCAL_OBJECT_END(pow_tbl2)
 
 .section .text
-GLOBAL_LIBM_ENTRY(__powf)
+WEAK_LIBM_ENTRY(powf)
 
 // Get exponent of x.  Will be used to calculate K.
 { .mfi
@@ -2002,10 +2002,10 @@ POW_OVER_UNDER_ERROR:
 }
 ;;
 
-GLOBAL_LIBM_END(__powf)
+WEAK_LIBM_END(powf)
 libm_alias_float_other (__pow, pow)
 #ifdef SHARED
-.symver __powf,powf@@GLIBC_2.27
+.symver powf,powf@@GLIBC_2.27
 .weak __powf_compat
 .set __powf_compat,__powf
 .symver __powf_compat,powf@GLIBC_2.2
diff --git a/sysdeps/ieee754/ldbl-96/Makefile b/sysdeps/ieee754/ldbl-96/Makefile
index 790f670e44..daa2753cf1 100644
--- a/sysdeps/ieee754/ldbl-96/Makefile
+++ b/sysdeps/ieee754/ldbl-96/Makefile
@@ -17,5 +17,8 @@
 # <http://www.gnu.org/licenses/>.
 
 ifeq ($(subdir),math)
-tests += test-canonical-ldbl-96 test-totalorderl-ldbl-96
+tests += test-canonical-ldbl-96 test-totalorderl-ldbl-96 test-sinl-pseudo
+ifeq ($(have-ssp),yes)
+CFLAGS-test-sinl-pseudo.c += -fstack-protector-all
 endif
+endif # $(subdir) == math
diff --git a/sysdeps/ieee754/ldbl-96/e_rem_pio2l.c b/sysdeps/ieee754/ldbl-96/e_rem_pio2l.c
index f67805f2d3..c2ee56e71f 100644
--- a/sysdeps/ieee754/ldbl-96/e_rem_pio2l.c
+++ b/sysdeps/ieee754/ldbl-96/e_rem_pio2l.c
@@ -210,6 +210,18 @@ __ieee754_rem_pio2l (long double x, long double *y)
       return 0;
     }
 
+  if ((i0 & 0x80000000) == 0)
+    {
+      /* Pseudo-zero and unnormal representations are not valid
+	 representations of long double.  We need to avoid stack
+	 corruption in __kernel_rem_pio2, which expects input in a
+	 particular normal form, but those representations do not need
+	 to be consistently handled like any particular floating-point
+	 value.  */
+      y[1] = y[0] = __builtin_nanl ("");
+      return 0;
+    }
+
   /* Split the 64 bits of the mantissa into three 24-bit integers
      stored in a double array.  */
   exp = j0 - 23;
diff --git a/sysdeps/ieee754/ldbl-96/test-sinl-pseudo.c b/sysdeps/ieee754/ldbl-96/test-sinl-pseudo.c
new file mode 100644
index 0000000000..f59b97769d
--- /dev/null
+++ b/sysdeps/ieee754/ldbl-96/test-sinl-pseudo.c
@@ -0,0 +1,41 @@
+/* Test sinl for pseudo-zeros and unnormals for ldbl-96 (bug 25487).
+   Copyright (C) 2020 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <math.h>
+#include <math_ldbl.h>
+#include <stdint.h>
+
+static int
+do_test (void)
+{
+  for (int i = 0; i < 64; i++)
+    {
+      uint64_t sig = i == 63 ? 0 : 1ULL << i;
+      long double ld;
+      SET_LDOUBLE_WORDS (ld, 0x4141,
+			 sig >> 32, sig & 0xffffffffULL);
+      /* The requirement is that no stack overflow occurs when the
+	 pseudo-zero or unnormal goes through range reduction.  */
+      volatile long double ldr;
+      ldr = sinl (ld);
+      (void) ldr;
+    }
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/sysdeps/nptl/bits/thread-shared-types.h b/sysdeps/nptl/bits/thread-shared-types.h
index 1e2092a05d..05c94e7a71 100644
--- a/sysdeps/nptl/bits/thread-shared-types.h
+++ b/sysdeps/nptl/bits/thread-shared-types.h
@@ -124,7 +124,27 @@ struct __pthread_mutex_s
   unsigned int __nusers;
 #endif
   /* KIND must stay at this position in the structure to maintain
-     binary compatibility with static initializers.  */
+     binary compatibility with static initializers.
+
+     Concurrency notes:
+     The __kind of a mutex is initialized either by the static
+     PTHREAD_MUTEX_INITIALIZER or by a call to pthread_mutex_init.
+
+     After a mutex has been initialized, the __kind of a mutex is usually not
+     changed.  BUT it can be set to -1 in pthread_mutex_destroy or elision can
+     be enabled.  This is done concurrently in the pthread_mutex_*lock functions
+     by using the macro FORCE_ELISION. This macro is only defined for
+     architectures which supports lock elision.
+
+     For elision, there are the flags PTHREAD_MUTEX_ELISION_NP and
+     PTHREAD_MUTEX_NO_ELISION_NP which can be set in addition to the already set
+     type of a mutex.
+     Before a mutex is initialized, only PTHREAD_MUTEX_NO_ELISION_NP can be set
+     with pthread_mutexattr_settype.
+     After a mutex has been initialized, the functions pthread_mutex_*lock can
+     enable elision - if the mutex-type and the machine supports it - by setting
+     the flag PTHREAD_MUTEX_ELISION_NP. This is done concurrently. Afterwards
+     the lock / unlock functions are using specific elision code-paths.  */
   int __kind;
   __PTHREAD_COMPAT_PADDING_MID
 #if __PTHREAD_MUTEX_NUSERS_AFTER_KIND
diff --git a/sysdeps/nptl/lowlevellock.h b/sysdeps/nptl/lowlevellock.h
index 8326e2805c..bfbda99940 100644
--- a/sysdeps/nptl/lowlevellock.h
+++ b/sysdeps/nptl/lowlevellock.h
@@ -181,11 +181,14 @@ extern int __lll_timedlock_wait (int *futex, const struct timespec *,
    thread ID while the clone is running and is reset to zero by the kernel
    afterwards.  The kernel up to version 3.16.3 does not use the private futex
    operations for futex wake-up when the clone terminates.  */
-#define lll_wait_tid(tid) \
-  do {					\
-    __typeof (tid) __tid;		\
-    while ((__tid = (tid)) != 0)	\
-      lll_futex_wait (&(tid), __tid, LLL_SHARED);\
+#define lll_wait_tid(tid)				\
+  do {							\
+    __typeof (tid) __tid;				\
+    /* We need acquire MO here so that we synchronize	\
+       with the kernel's store to 0 when the clone	\
+       terminates. (see above)  */			\
+    while ((__tid = atomic_load_acquire (&(tid))) != 0)	\
+      lll_futex_wait (&(tid), __tid, LLL_SHARED);	\
   } while (0)
 
 extern int __lll_timedwait_tid (int *, const struct timespec *)
diff --git a/sysdeps/posix/preadv2.c b/sysdeps/posix/preadv2.c
index d29147608f..4f8557ac83 100644
--- a/sysdeps/posix/preadv2.c
+++ b/sysdeps/posix/preadv2.c
@@ -33,7 +33,10 @@ preadv2 (int fd, const struct iovec *vector, int count, off_t offset,
       return -1;
     }
 
-  return preadv (fd, vector, count, offset);
+  if (offset == -1)
+    return __readv (fd, vector, count);
+  else
+    return preadv (fd, vector, count, offset);
 }
 
 #endif
diff --git a/sysdeps/posix/preadv64v2.c b/sysdeps/posix/preadv64v2.c
index a4844b145c..f89ad08c54 100644
--- a/sysdeps/posix/preadv64v2.c
+++ b/sysdeps/posix/preadv64v2.c
@@ -30,7 +30,10 @@ preadv64v2 (int fd, const struct iovec *vector, int count, off64_t offset,
       return -1;
     }
 
-  return preadv64 (fd, vector, count, offset);
+  if (offset == -1)
+    return __readv (fd, vector, count);
+  else
+    return preadv64 (fd, vector, count, offset);
 }
 
 #ifdef __OFF_T_MATCHES_OFF64_T
diff --git a/sysdeps/posix/pwritev2.c b/sysdeps/posix/pwritev2.c
index 3abf37a810..a39304d9d9 100644
--- a/sysdeps/posix/pwritev2.c
+++ b/sysdeps/posix/pwritev2.c
@@ -33,7 +33,10 @@ pwritev2 (int fd, const struct iovec *vector, int count, off_t offset,
       return -1;
     }
 
-  return pwritev (fd, vector, count, offset);
+  if (offset == -1)
+    return __writev (fd, vector, count);
+  else
+    return pwritev (fd, vector, count, offset);
 }
 
 #endif
diff --git a/sysdeps/posix/pwritev64v2.c b/sysdeps/posix/pwritev64v2.c
index 374d2ad8a9..7a3a3239d7 100644
--- a/sysdeps/posix/pwritev64v2.c
+++ b/sysdeps/posix/pwritev64v2.c
@@ -31,7 +31,10 @@ pwritev64v2 (int fd, const struct iovec *vector, int count, off64_t offset,
       return -1;
     }
 
-  return pwritev64 (fd, vector, count, offset);
+  if (offset == -1)
+    return __writev (fd, vector, count);
+  else
+    return pwritev64 (fd, vector, count, offset);
 }
 
 #ifdef __OFF_T_MATCHES_OFF64_T
diff --git a/sysdeps/posix/spawni.c b/sysdeps/posix/spawni.c
index 36bb5b4f78..b138ab4393 100644
--- a/sysdeps/posix/spawni.c
+++ b/sysdeps/posix/spawni.c
@@ -310,6 +310,8 @@ __spawni (pid_t * pid, const char *file,
 	  const posix_spawnattr_t * attrp, char *const argv[],
 	  char *const envp[], int xflags)
 {
+  /* It uses __execvpex to avoid run ENOEXEC in non compatibility mode (it
+     will be handled by maybe_script_execute).  */
   return __spawnix (pid, file, acts, attrp, argv, envp, xflags,
-		    xflags & SPAWN_XFLAGS_USE_PATH ? __execvpe : __execve);
+		    xflags & SPAWN_XFLAGS_USE_PATH ? __execvpex : __execve);
 }
diff --git a/sysdeps/powerpc/powerpc32/backtrace.c b/sysdeps/powerpc/powerpc32/backtrace.c
index 5422fdd50d..c7b64f9e9b 100644
--- a/sysdeps/powerpc/powerpc32/backtrace.c
+++ b/sysdeps/powerpc/powerpc32/backtrace.c
@@ -114,6 +114,8 @@ __backtrace (void **array, int size)
         }
       if (gregset)
 	{
+	  if (count + 1 == size)
+	    break;
 	  array[++count] = (void*)((*gregset)[PT_NIP]);
 	  current = (void*)((*gregset)[PT_R1]);
 	}
diff --git a/sysdeps/powerpc/powerpc32/sysdep.h b/sysdeps/powerpc/powerpc32/sysdep.h
index 8e32a2a131..5f1294ead3 100644
--- a/sysdeps/powerpc/powerpc32/sysdep.h
+++ b/sysdeps/powerpc/powerpc32/sysdep.h
@@ -90,7 +90,7 @@ GOT_LABEL:			;					      \
   cfi_endproc;								      \
   ASM_SIZE_DIRECTIVE(name)
 
-#if ! IS_IN(rtld)
+#if !IS_IN(rtld) && !defined(__SPE__)
 # define ABORT_TRANSACTION_IMPL \
     cmpwi    2,0;		\
     beq      1f;		\
diff --git a/sysdeps/powerpc/powerpc64/addmul_1.S b/sysdeps/powerpc/powerpc64/addmul_1.S
index 48e3b1b290..e450d6a52c 100644
--- a/sysdeps/powerpc/powerpc64/addmul_1.S
+++ b/sysdeps/powerpc/powerpc64/addmul_1.S
@@ -34,16 +34,27 @@
 #define N   r5
 #define VL  r6
 
+#define R27SAVE  (-40)
+#define R28SAVE  (-32)
+#define R29SAVE  (-24)
+#define R30SAVE  (-16)
+#define R31SAVE  (-8)
+
 ENTRY_TOCLESS (FUNC, 5)
-	std	r31, -8(r1)
+	std	r31, R31SAVE(r1)
 	rldicl.	r0, N, 0, 62
-	std	r30, -16(r1)
+	std	r30, R30SAVE(r1)
 	cmpdi	VL, r0, 2
-	std	r29, -24(r1)
+	std	r29, R29SAVE(r1)
 	addi	N, N, 3
-	std	r28, -32(r1)
+	std	r28, R28SAVE(r1)
 	srdi	N, N, 2
-	std	r27, -40(r1)
+	std	r27, R27SAVE(r1)
+	cfi_offset(r31, R31SAVE)
+	cfi_offset(r30, R30SAVE)
+	cfi_offset(r29, R29SAVE)
+	cfi_offset(r28, R28SAVE)
+	cfi_offset(r27, R27SAVE)
 	mtctr	N
 	beq	cr0, L(b00)
 	blt	cr6, L(b01)
@@ -199,10 +210,10 @@ L(end):	mulld	r0, r9, VL
 	addic	r11, r11, 1
 #endif
 	addze	RP, r8
-	ld	r31, -8(r1)
-	ld	r30, -16(r1)
-	ld	r29, -24(r1)
-	ld	r28, -32(r1)
-	ld	r27, -40(r1)
+	ld	r31, R31SAVE(r1)
+	ld	r30, R30SAVE(r1)
+	ld	r29, R29SAVE(r1)
+	ld	r28, R28SAVE(r1)
+	ld	r27, R27SAVE(r1)
 	blr
 END(FUNC)
diff --git a/sysdeps/powerpc/powerpc64/backtrace.c b/sysdeps/powerpc/powerpc64/backtrace.c
index c0c4b48262..0acf17b37e 100644
--- a/sysdeps/powerpc/powerpc64/backtrace.c
+++ b/sysdeps/powerpc/powerpc64/backtrace.c
@@ -87,6 +87,8 @@ __backtrace (void **array, int size)
       if (is_sigtramp_address (current->return_address))
         {
 	  struct signal_frame_64 *sigframe = (struct signal_frame_64*) current;
+	  if (count + 1 == size)
+	    break;
           array[++count] = (void*) sigframe->uc.uc_mcontext.gp_regs[PT_NIP];
 	  current = (void*) sigframe->uc.uc_mcontext.gp_regs[PT_R1];
 	}
diff --git a/sysdeps/powerpc/powerpc64/lshift.S b/sysdeps/powerpc/powerpc64/lshift.S
index 8b6396ee6c..855d6f2993 100644
--- a/sysdeps/powerpc/powerpc64/lshift.S
+++ b/sysdeps/powerpc/powerpc64/lshift.S
@@ -26,11 +26,15 @@
 #define TNC      r0
 #define U0      r30
 #define U1      r31
+#define U0SAVE  (-16)
+#define U1SAVE  (-8)
 #define RETVAL   r5
 
 ENTRY_TOCLESS (__mpn_lshift, 5)
-	std	U1, -8(r1)
-	std	U0, -16(r1)
+	std	U1, U1SAVE(r1)
+	std	U0, U0SAVE(r1)
+	cfi_offset(U1, U1SAVE)
+	cfi_offset(U0, U0SAVE)
 	subfic	TNC, CNT, 64
 	sldi	r7, N, RP
 	add	UP, UP, r7
@@ -170,8 +174,8 @@ L(cj3):	or	r10, r12, r7
 L(cj2):	std	r10, -32(RP)
 	std	r8, -40(RP)
 
-L(ret):	ld	U1, -8(r1)
-	ld	U0, -16(r1)
+L(ret):	ld	U1, U1SAVE(r1)
+	ld	U0, U0SAVE(r1)
 	mr	RP, RETVAL
 	blr
 END(__mpn_lshift)
diff --git a/sysdeps/powerpc/powerpc64/mul_1.S b/sysdeps/powerpc/powerpc64/mul_1.S
index 953ded8028..cade365258 100644
--- a/sysdeps/powerpc/powerpc64/mul_1.S
+++ b/sysdeps/powerpc/powerpc64/mul_1.S
@@ -24,9 +24,14 @@
 #define N   r5
 #define VL  r6
 
+#define R26SAVE  (-48)
+#define R27SAVE  (-40)
+
 ENTRY_TOCLESS (__mpn_mul_1, 5)
-	std	r27, -40(r1)
-	std	r26, -48(r1)
+	std	r27, R27SAVE(r1)
+	std	r26, R26SAVE(r1)
+	cfi_offset(r27, R27SAVE)
+	cfi_offset(r26, R26SAVE)
 	li	r12, 0
 	ld	r26, 0(UP)
 
@@ -129,7 +134,7 @@ L(end):	mulld	r0, r26, VL
 	std	r0, 0(RP)
 	std	r7, 8(RP)
 L(ret):	addze	RP, r8
-	ld	r27, -40(r1)
-	ld	r26, -48(r1)
+	ld	r27, R27SAVE(r1)
+	ld	r26, R26SAVE(r1)
 	blr
 END(__mpn_mul_1)
diff --git a/sysdeps/powerpc/sysdep.h b/sysdeps/powerpc/sysdep.h
index 03db75fcb7..8a6d236caa 100644
--- a/sysdeps/powerpc/sysdep.h
+++ b/sysdeps/powerpc/sysdep.h
@@ -174,7 +174,7 @@
    we abort transaction just before syscalls.
 
    [1] Documentation/powerpc/transactional_memory.txt [Syscalls]  */
-#if !IS_IN(rtld)
+#if !IS_IN(rtld) && !defined(__SPE__)
 # define ABORT_TRANSACTION \
   ({ 						\
     if (THREAD_GET_TM_CAPABLE ())		\
diff --git a/sysdeps/riscv/rvd/s_fmax.c b/sysdeps/riscv/rvd/s_fmax.c
index ef8f1344ce..22e91bfc4b 100644
--- a/sysdeps/riscv/rvd/s_fmax.c
+++ b/sysdeps/riscv/rvd/s_fmax.c
@@ -17,12 +17,19 @@
    <http://www.gnu.org/licenses/>.  */
 
 #include <math.h>
+#include <math_private.h>
 #include <libm-alias-double.h>
 
 double
 __fmax (double x, double y)
 {
-  asm ("fmax.d %0, %1, %2" : "=f" (x) : "f" (x), "f" (y));
-  return x;
+  double res;
+
+  if (__glibc_unlikely ((_FCLASS (x) | _FCLASS (y)) & _FCLASS_SNAN))
+    return x + y;
+  else
+    asm ("fmax.d %0, %1, %2" : "=f" (res) : "f" (x), "f" (y));
+
+  return res;
 }
 libm_alias_double (__fmax, fmax)
diff --git a/sysdeps/riscv/rvd/s_fmin.c b/sysdeps/riscv/rvd/s_fmin.c
index c6ff24cefb..7b35230cac 100644
--- a/sysdeps/riscv/rvd/s_fmin.c
+++ b/sysdeps/riscv/rvd/s_fmin.c
@@ -17,12 +17,19 @@
    <http://www.gnu.org/licenses/>.  */
 
 #include <math.h>
+#include <math_private.h>
 #include <libm-alias-double.h>
 
 double
 __fmin (double x, double y)
 {
-  asm ("fmin.d %0, %1, %2" : "=f" (x) : "f" (x), "f" (y));
-  return x;
+  double res;
+
+  if (__glibc_unlikely ((_FCLASS (x) | _FCLASS (y)) & _FCLASS_SNAN))
+    return x + y;
+  else
+    asm ("fmin.d %0, %1, %2" : "=f" (res) : "f" (x), "f" (y));
+
+  return res;
 }
 libm_alias_double (__fmin, fmin)
diff --git a/sysdeps/riscv/rvf/s_fmaxf.c b/sysdeps/riscv/rvf/s_fmaxf.c
index 3293f2f41c..63f7e3d664 100644
--- a/sysdeps/riscv/rvf/s_fmaxf.c
+++ b/sysdeps/riscv/rvf/s_fmaxf.c
@@ -17,12 +17,19 @@
    <http://www.gnu.org/licenses/>.  */
 
 #include <math.h>
+#include <math_private.h>
 #include <libm-alias-float.h>
 
 float
 __fmaxf (float x, float y)
 {
-  asm ("fmax.s %0, %1, %2" : "=f" (x) : "f" (x), "f" (y));
-  return x;
+  float res;
+
+  if (__glibc_unlikely ((_FCLASS (x) | _FCLASS (y)) & _FCLASS_SNAN))
+    return x + y;
+  else
+    asm ("fmax.s %0, %1, %2" : "=f" (res) : "f" (x), "f" (y));
+
+  return res;
 }
 libm_alias_float (__fmax, fmax)
diff --git a/sysdeps/riscv/rvf/s_fminf.c b/sysdeps/riscv/rvf/s_fminf.c
index e4411f04b2..82cca4e37d 100644
--- a/sysdeps/riscv/rvf/s_fminf.c
+++ b/sysdeps/riscv/rvf/s_fminf.c
@@ -17,12 +17,19 @@
    <http://www.gnu.org/licenses/>.  */
 
 #include <math.h>
+#include <math_private.h>
 #include <libm-alias-float.h>
 
 float
 __fminf (float x, float y)
 {
-  asm ("fmin.s %0, %1, %2" : "=f" (x) : "f" (x), "f" (y));
-  return x;
+  float res;
+
+  if (__glibc_unlikely ((_FCLASS (x) | _FCLASS (y)) & _FCLASS_SNAN))
+    return x + y;
+  else
+    asm ("fmin.s %0, %1, %2" : "=f" (res) : "f" (x), "f" (y));
+
+  return res;
 }
 libm_alias_float (__fmin, fmin)
diff --git a/sysdeps/riscv/tls-macros.h b/sysdeps/riscv/tls-macros.h
index 5433ed9d16..7f0dd926d0 100644
--- a/sysdeps/riscv/tls-macros.h
+++ b/sysdeps/riscv/tls-macros.h
@@ -23,19 +23,9 @@
 #include <sysdep.h>
 #include "dl-tls.h"
 
-#define LOAD_GP						\
-	".option push\n\t"				\
-	".option norelax\n\t"				\
-	"la gp, __global_pointer$\n\t"			\
-	".option pop\n\t"
-
-#define UNLOAD_GP
-
 #define TLS_GD(x)					\
 	({ void *__result;				\
-	asm (LOAD_GP					\
-	     "la.tls.gd %0, " #x "\n\t"			\
-	     UNLOAD_GP					\
+	asm ("la.tls.gd %0, " #x "\n\t"			\
 	     : "=r" (__result));			\
 	__tls_get_addr (__result); })
 
@@ -43,19 +33,15 @@
 
 #define TLS_IE(x)					\
 	({ void *__result;				\
-	asm (LOAD_GP					\
-	     "la.tls.ie %0, " #x "\n\t"			\
+	asm ("la.tls.ie %0, " #x "\n\t"			\
 	     "add %0, %0, tp\n\t"			\
-	     UNLOAD_GP					\
 	     : "=r" (__result));			\
 	__result; })
 
 #define TLS_LE(x)					\
 	({ void *__result;				\
-	asm (LOAD_GP					\
-	     "lui %0, %%tprel_hi(" #x ")\n\t"		\
+	asm ("lui %0, %%tprel_hi(" #x ")\n\t"		\
 	     "add %0, %0, tp, %%tprel_add(" #x ")\n\t"	\
 	     "addi %0, %0, %%tprel_lo(" #x ")\n\t"	\
-	     UNLOAD_GP					\
 	     : "=r" (__result));			\
 	__result; })
diff --git a/sysdeps/s390/dl-procinfo.h b/sysdeps/s390/dl-procinfo.h
index b0383bfb4c..f71d64c3ab 100644
--- a/sysdeps/s390/dl-procinfo.h
+++ b/sysdeps/s390/dl-procinfo.h
@@ -57,7 +57,8 @@ enum
 };
 
 #define HWCAP_IMPORTANT (HWCAP_S390_ZARCH | HWCAP_S390_LDISP \
-			  | HWCAP_S390_EIMM | HWCAP_S390_DFP)
+			 | HWCAP_S390_EIMM | HWCAP_S390_DFP  \
+			 | HWCAP_S390_VX | HWCAP_S390_VXE)
 
 /* We cannot provide a general printing function.  */
 #define _dl_procinfo(type, word) -1
diff --git a/sysdeps/s390/multiarch/gconv_simple.c b/sysdeps/s390/multiarch/gconv_simple.c
index aaa1ebf74a..88772fab46 100644
--- a/sysdeps/s390/multiarch/gconv_simple.c
+++ b/sysdeps/s390/multiarch/gconv_simple.c
@@ -403,7 +403,7 @@ ICONV_VX_NAME (internal_ucs4le_loop) (struct __gconv_step *step,
 				      const unsigned char **inptrp,
 				      const unsigned char *inend,
 				      unsigned char **outptrp,
-				      unsigned char *outend,
+				      const unsigned char *outend,
 				      size_t *irreversible)
 {
   const unsigned char *inptr = *inptrp;
@@ -503,7 +503,7 @@ ICONV_VX_NAME (ucs4_internal_loop) (struct __gconv_step *step,
 				    const unsigned char **inptrp,
 				    const unsigned char *inend,
 				    unsigned char **outptrp,
-				    unsigned char *outend,
+				    const unsigned char *outend,
 				    size_t *irreversible)
 {
   int flags = step_data->__flags;
@@ -630,7 +630,7 @@ ICONV_VX_NAME (ucs4le_internal_loop) (struct __gconv_step *step,
 				      const unsigned char **inptrp,
 				      const unsigned char *inend,
 				      unsigned char **outptrp,
-				      unsigned char *outend,
+				      const unsigned char *outend,
 				      size_t *irreversible)
 {
   int flags = step_data->__flags;
diff --git a/sysdeps/sh/libm-test-ulps b/sysdeps/sh/libm-test-ulps
index da4224c2d6..11c5f3216d 100644
--- a/sysdeps/sh/libm-test-ulps
+++ b/sysdeps/sh/libm-test-ulps
@@ -1,13 +1,31 @@
 # Begin of automatic generation
 
 # Maximal error of functions:
-Function: "acos_towardzero":
+Function: "acos":
 float: 1
 ifloat: 1
 
-Function: "acosh":
+Function: "acos_towardzero":
 double: 1
+float: 1
 idouble: 1
+ifloat: 1
+
+Function: "acosh":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+
+Function: "acosh_towardzero":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+
+Function: "asin":
+float: 1
+ifloat: 1
 
 Function: "asin_towardzero":
 double: 1
@@ -18,16 +36,55 @@ ifloat: 1
 Function: "asinh":
 double: 1
 float: 1
+idouble: 1
+ifloat: 1
+
+Function: "asinh_towardzero":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+
+Function: "atan":
+float: 1
 ifloat: 1
 
 Function: "atan2":
 float: 1
 ifloat: 1
 
-Function: "atanh":
+Function: "atan2_towardzero":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+
+Function: "atan_towardzero":
+double: 1
 float: 1
+idouble: 1
 ifloat: 1
 
+Function: "atanh":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+
+Function: "atanh_towardzero":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+
+Function: "cabs":
+double: 1
+idouble: 1
+
+Function: "cabs_towardzero":
+double: 1
+idouble: 1
+
 Function: Real part of "cacos":
 double: 1
 float: 2
@@ -35,18 +92,52 @@ idouble: 1
 ifloat: 2
 
 Function: Imaginary part of "cacos":
-double: 1
+double: 2
 float: 2
-idouble: 1
+idouble: 2
+ifloat: 2
+
+Function: Real part of "cacos_towardzero":
+double: 3
+float: 2
+idouble: 3
+ifloat: 2
+
+Function: Imaginary part of "cacos_towardzero":
+double: 4
+float: 2
+idouble: 4
 ifloat: 2
 
 Function: Real part of "cacosh":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+
+Function: Imaginary part of "cacosh":
 double: 1
 float: 2
 idouble: 1
 ifloat: 2
 
-Function: Imaginary part of "cacosh":
+Function: Real part of "cacosh_towardzero":
+double: 4
+float: 2
+idouble: 4
+ifloat: 2
+
+Function: Imaginary part of "cacosh_towardzero":
+double: 3
+float: 2
+idouble: 3
+ifloat: 2
+
+Function: "carg":
+float: 1
+ifloat: 1
+
+Function: "carg_towardzero":
 double: 1
 float: 2
 idouble: 1
@@ -59,15 +150,27 @@ idouble: 1
 ifloat: 1
 
 Function: Imaginary part of "casin":
-double: 1
+double: 2
 float: 2
-idouble: 1
+idouble: 2
+ifloat: 2
+
+Function: Real part of "casin_towardzero":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+
+Function: Imaginary part of "casin_towardzero":
+double: 4
+float: 2
+idouble: 4
 ifloat: 2
 
 Function: Real part of "casinh":
-double: 1
+double: 2
 float: 2
-idouble: 1
+idouble: 2
 ifloat: 2
 
 Function: Imaginary part of "casinh":
@@ -76,8 +179,22 @@ float: 1
 idouble: 1
 ifloat: 1
 
+Function: Real part of "casinh_towardzero":
+double: 4
+float: 2
+idouble: 4
+ifloat: 2
+
+Function: Imaginary part of "casinh_towardzero":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+
 Function: Real part of "catan":
+double: 1
 float: 1
+idouble: 1
 ifloat: 1
 
 Function: Imaginary part of "catan":
@@ -86,6 +203,18 @@ float: 1
 idouble: 1
 ifloat: 1
 
+Function: Real part of "catan_towardzero":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+
+Function: Imaginary part of "catan_towardzero":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+
 Function: Real part of "catanh":
 double: 1
 float: 1
@@ -93,13 +222,33 @@ idouble: 1
 ifloat: 1
 
 Function: Imaginary part of "catanh":
+double: 1
 float: 1
+idouble: 1
 ifloat: 1
 
-Function: "cbrt":
+Function: Real part of "catanh_towardzero":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+
+Function: Imaginary part of "catanh_towardzero":
 double: 1
-float: 1
+float: 2
 idouble: 1
+ifloat: 2
+
+Function: "cbrt":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+
+Function: "cbrt_towardzero":
+double: 3
+float: 1
+idouble: 3
 ifloat: 1
 
 Function: Real part of "ccos":
@@ -114,6 +263,18 @@ float: 1
 idouble: 1
 ifloat: 1
 
+Function: Real part of "ccos_towardzero":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+
+Function: Imaginary part of "ccos_towardzero":
+double: 2
+float: 3
+idouble: 2
+ifloat: 3
+
 Function: Real part of "ccosh":
 double: 1
 float: 1
@@ -126,6 +287,18 @@ float: 1
 idouble: 1
 ifloat: 1
 
+Function: Real part of "ccosh_towardzero":
+double: 1
+float: 3
+idouble: 1
+ifloat: 3
+
+Function: Imaginary part of "ccosh_towardzero":
+double: 2
+float: 3
+idouble: 2
+ifloat: 3
+
 Function: Real part of "cexp":
 double: 2
 float: 1
@@ -138,27 +311,63 @@ float: 2
 idouble: 1
 ifloat: 2
 
-Function: Real part of "clog":
+Function: Real part of "cexp_towardzero":
 double: 1
-float: 1
+float: 2
 idouble: 1
-ifloat: 1
+ifloat: 2
+
+Function: Imaginary part of "cexp_towardzero":
+double: 1
+float: 3
+idouble: 1
+ifloat: 3
+
+Function: Real part of "clog":
+double: 3
+float: 3
+idouble: 3
+ifloat: 3
 
 Function: Imaginary part of "clog":
 float: 1
 ifloat: 1
 
 Function: Real part of "clog10":
+double: 3
+float: 4
+idouble: 3
+ifloat: 4
+
+Function: Imaginary part of "clog10":
 double: 2
 float: 2
 idouble: 2
 ifloat: 2
 
-Function: Imaginary part of "clog10":
+Function: Real part of "clog10_towardzero":
+double: 5
+float: 5
+idouble: 5
+ifloat: 5
+
+Function: Imaginary part of "clog10_towardzero":
+double: 2
+float: 3
+idouble: 2
+ifloat: 3
+
+Function: Real part of "clog_towardzero":
+double: 4
+float: 4
+idouble: 4
+ifloat: 4
+
+Function: Imaginary part of "clog_towardzero":
 double: 1
-float: 1
+float: 3
 idouble: 1
-ifloat: 1
+ifloat: 3
 
 Function: "cos":
 float: 1
@@ -184,42 +393,90 @@ ifloat: 1
 
 Function: Real part of "cpow":
 double: 2
-float: 4
+float: 5
 idouble: 2
-ifloat: 4
+ifloat: 5
 
 Function: Imaginary part of "cpow":
 float: 2
 ifloat: 2
 
+Function: Real part of "cpow_towardzero":
+double: 4
+float: 8
+idouble: 4
+ifloat: 8
+
+Function: Imaginary part of "cpow_towardzero":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+
 Function: Real part of "csin":
 double: 1
 float: 1
 idouble: 1
 ifloat: 1
 
-Function: Real part of "csinh":
-float: 1
-ifloat: 1
+Function: Real part of "csin_towardzero":
+double: 2
+float: 3
+idouble: 2
+ifloat: 3
 
-Function: Imaginary part of "csinh":
+Function: Imaginary part of "csin_towardzero":
 double: 1
 float: 1
 idouble: 1
 ifloat: 1
 
-Function: Real part of "csqrt":
-double: 1
+Function: Real part of "csinh":
 float: 1
-idouble: 1
 ifloat: 1
 
-Function: Imaginary part of "csqrt":
+Function: Imaginary part of "csinh":
 double: 1
 float: 1
 idouble: 1
 ifloat: 1
 
+Function: Real part of "csinh_towardzero":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+
+Function: Imaginary part of "csinh_towardzero":
+double: 2
+float: 3
+idouble: 2
+ifloat: 3
+
+Function: Real part of "csqrt":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+
+Function: Imaginary part of "csqrt":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+
+Function: Real part of "csqrt_towardzero":
+double: 4
+float: 3
+idouble: 4
+ifloat: 3
+
+Function: Imaginary part of "csqrt_towardzero":
+double: 4
+float: 3
+idouble: 4
+ifloat: 3
+
 Function: Real part of "ctan":
 double: 1
 float: 1
@@ -246,9 +503,9 @@ ifloat: 3
 
 Function: Real part of "ctanh":
 double: 2
-float: 1
+float: 2
 idouble: 2
-ifloat: 1
+ifloat: 2
 
 Function: Imaginary part of "ctanh":
 double: 2
@@ -270,25 +527,51 @@ ifloat: 3
 
 Function: "erf":
 double: 1
+float: 1
 idouble: 1
+ifloat: 1
 
-Function: "erfc":
+Function: "erf_towardzero":
 double: 1
 float: 1
 idouble: 1
 ifloat: 1
 
+Function: "erfc":
+double: 3
+float: 2
+idouble: 3
+ifloat: 2
+
+Function: "erfc_towardzero":
+double: 3
+float: 3
+idouble: 3
+ifloat: 3
+
 Function: "exp10":
+double: 2
+idouble: 2
+
+Function: "exp10_towardzero":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+
+Function: "exp2":
 double: 1
 idouble: 1
 
-Function: "exp10_towardzero":
+Function: "exp2_towardzero":
 double: 1
 idouble: 1
 
 Function: "exp_towardzero":
 double: 1
+float: 1
 idouble: 1
+ifloat: 1
 
 Function: "expm1":
 double: 1
@@ -298,21 +581,31 @@ ifloat: 1
 
 Function: "expm1_towardzero":
 double: 1
-float: 1
+float: 2
 idouble: 1
-ifloat: 1
+ifloat: 2
 
 Function: "fma_towardzero":
 double: 1
 idouble: 1
 
 Function: "gamma":
+double: 4
+float: 3
+idouble: 4
+ifloat: 3
+
+Function: "gamma_towardzero":
+double: 5
+float: 3
+idouble: 5
+ifloat: 3
+
+Function: "hypot":
 double: 1
-float: 1
 idouble: 1
-ifloat: 1
 
-Function: "hypot":
+Function: "hypot_towardzero":
 double: 1
 idouble: 1
 
@@ -322,44 +615,94 @@ float: 2
 idouble: 2
 ifloat: 2
 
+Function: "j0_towardzero":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+
 Function: "j1":
 double: 1
 float: 2
 idouble: 1
 ifloat: 2
 
+Function: "j1_towardzero":
+double: 3
+float: 2
+idouble: 3
+ifloat: 2
+
 Function: "jn":
 double: 4
 float: 4
 idouble: 4
 ifloat: 4
 
+Function: "jn_towardzero":
+double: 5
+float: 5
+idouble: 5
+ifloat: 5
+
 Function: "lgamma":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
+double: 4
+float: 3
+idouble: 4
+ifloat: 3
+
+Function: "lgamma_towardzero":
+double: 5
+float: 3
+idouble: 5
+ifloat: 3
 
 Function: "log":
 float: 1
 ifloat: 1
 
 Function: "log10":
-double: 1
+double: 2
 float: 2
-idouble: 1
+idouble: 2
 ifloat: 2
 
+Function: "log10_towardzero":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+
 Function: "log1p":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: "log1p_towardzero":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+
+Function: "log2":
+double: 2
 float: 1
+idouble: 2
 ifloat: 1
 
+Function: "log2_towardzero":
+double: 2
+idouble: 2
+
 Function: "pow":
 float: 1
 ifloat: 1
 
 Function: "pow_towardzero":
+double: 1
 float: 1
+idouble: 1
 ifloat: 1
 
 Function: "sin":
@@ -376,9 +719,27 @@ Function: "sincos":
 float: 1
 ifloat: 1
 
-Function: "sinh_towardzero":
+Function: "sincos_towardzero":
 double: 1
+float: 1
 idouble: 1
+ifloat: 1
+
+Function: "sinh":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+
+Function: "sinh_towardzero":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+
+Function: "tan":
+float: 1
+ifloat: 1
 
 Function: "tan_towardzero":
 double: 1
@@ -386,11 +747,29 @@ float: 1
 idouble: 1
 ifloat: 1
 
+Function: "tanh":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+
+Function: "tanh_towardzero":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+
 Function: "tgamma":
-double: 4
-float: 3
-idouble: 4
-ifloat: 3
+double: 5
+float: 4
+idouble: 5
+ifloat: 4
+
+Function: "tgamma_towardzero":
+double: 5
+float: 4
+idouble: 5
+ifloat: 4
 
 Function: "y0":
 double: 2
@@ -398,16 +777,34 @@ float: 1
 idouble: 2
 ifloat: 1
 
+Function: "y0_towardzero":
+double: 3
+float: 3
+idouble: 3
+ifloat: 3
+
 Function: "y1":
 double: 3
 float: 2
 idouble: 3
 ifloat: 2
 
+Function: "y1_towardzero":
+double: 3
+float: 2
+idouble: 3
+ifloat: 2
+
 Function: "yn":
 double: 3
 float: 2
 idouble: 3
 ifloat: 2
 
+Function: "yn_towardzero":
+double: 3
+float: 3
+idouble: 3
+ifloat: 3
+
 # end of automatic generation
diff --git a/sysdeps/sparc/sparc32/start.S b/sysdeps/sparc/sparc32/start.S
index 1db7327fc6..46ba8b6afa 100644
--- a/sysdeps/sparc/sparc32/start.S
+++ b/sysdeps/sparc/sparc32/start.S
@@ -42,7 +42,7 @@
 	.global _start
 	.type _start,#function
 _start:
-#ifdef SHARED
+#ifdef PIC
 	SETUP_PIC_REG(l7)
 #endif
 
@@ -57,7 +57,7 @@ _start:
 	add	%sp, 23*4, %o2
 
   /* Load the addresses of the user entry points.  */
-#ifndef SHARED
+#ifndef PIC
 	sethi	%hi(main), %o0
 	sethi	%hi(__libc_csu_init), %o3
 	sethi	%hi(__libc_csu_fini), %o4
diff --git a/sysdeps/sparc/sparc64/start.S b/sysdeps/sparc/sparc64/start.S
index e1865f10cb..75ff5093dc 100644
--- a/sysdeps/sparc/sparc64/start.S
+++ b/sysdeps/sparc/sparc64/start.S
@@ -42,7 +42,7 @@
 	.global _start
 	.type _start,#function
 _start:
-#ifdef SHARED
+#ifdef PIC
 	SETUP_PIC_REG(l7)
 #endif
 
@@ -58,7 +58,7 @@ _start:
 	add	%sp, STACK_BIAS+23*8, %o2
 
   /* Load the addresses of the user entry points.  */
-#ifndef SHARED
+#ifndef PIC
 	sethi	%hi(main), %o0
 	sethi	%hi(__libc_csu_init), %o3
 	sethi	%hi(__libc_csu_fini), %o4
diff --git a/sysdeps/unix/sysv/linux/aarch64/cpu-features.c b/sysdeps/unix/sysv/linux/aarch64/cpu-features.c
index 33b87a8c46..540e93be27 100644
--- a/sysdeps/unix/sysv/linux/aarch64/cpu-features.c
+++ b/sysdeps/unix/sysv/linux/aarch64/cpu-features.c
@@ -35,6 +35,7 @@ static struct cpu_list cpu_list[] = {
       {"thunderxt88",	 0x430F0A10},
       {"thunderx2t99",   0x431F0AF0},
       {"thunderx2t99p1", 0x420F5160},
+      {"ares",		 0x411FD0C0},
       {"generic", 	 0x0}
 };
 
@@ -52,9 +53,6 @@ get_midr_from_mcpu (const char *mcpu)
 static inline void
 init_cpu_features (struct cpu_features *cpu_features)
 {
-  uint64_t hwcap_mask = GET_HWCAP_MASK();
-  uint64_t hwcap = GLRO (dl_hwcap) & hwcap_mask;
-
   register uint64_t midr = UINT64_MAX;
 
 #if HAVE_TUNABLES
@@ -68,7 +66,7 @@ init_cpu_features (struct cpu_features *cpu_features)
      allows it.  */
   if (midr == UINT64_MAX)
     {
-      if (hwcap & HWCAP_CPUID)
+      if (GLRO (dl_hwcap) & HWCAP_CPUID)
 	asm volatile ("mrs %0, midr_el1" : "=r"(midr));
       else
 	midr = 0;
diff --git a/sysdeps/unix/sysv/linux/aarch64/cpu-features.h b/sysdeps/unix/sysv/linux/aarch64/cpu-features.h
index c646f9dad1..9e315751c2 100644
--- a/sysdeps/unix/sysv/linux/aarch64/cpu-features.h
+++ b/sysdeps/unix/sysv/linux/aarch64/cpu-features.h
@@ -44,6 +44,9 @@
 #define IS_FALKOR(midr) (MIDR_IMPLEMENTOR(midr) == 'Q'			      \
                         && MIDR_PARTNUM(midr) == 0xc00)
 
+#define IS_ARES(midr) (MIDR_IMPLEMENTOR(midr) == 'A'			      \
+			&& MIDR_PARTNUM(midr) == 0xd0c)
+
 struct cpu_features
 {
   uint64_t midr_el1;
diff --git a/sysdeps/unix/sysv/linux/aarch64/dl-procinfo.h b/sysdeps/unix/sysv/linux/aarch64/dl-procinfo.h
index 6887713149..f746f52c8d 100644
--- a/sysdeps/unix/sysv/linux/aarch64/dl-procinfo.h
+++ b/sysdeps/unix/sysv/linux/aarch64/dl-procinfo.h
@@ -27,9 +27,8 @@
 /* We cannot provide a general printing function.  */
 #define _dl_procinfo(type, word) -1
 
-/* HWCAP_CPUID should be available by default to influence IFUNC as well as
-   library search.  */
-#define HWCAP_IMPORTANT HWCAP_CPUID
+/* No additional library search paths.  */
+#define HWCAP_IMPORTANT HWCAP_ATOMICS
 
 static inline const char *
 __attribute__ ((unused))
diff --git a/sysdeps/unix/sysv/linux/aarch64/sys/ptrace.h b/sysdeps/unix/sysv/linux/aarch64/sys/ptrace.h
index 4be45b95ff..93e373c3ad 100644
--- a/sysdeps/unix/sysv/linux/aarch64/sys/ptrace.h
+++ b/sysdeps/unix/sysv/linux/aarch64/sys/ptrace.h
@@ -78,18 +78,10 @@ enum __ptrace_request
   PTRACE_DETACH = 17,
 #define PT_DETACH PTRACE_DETACH
 
-  PTRACE_GET_THREAD_AREA = 22,
-
   /* Continue and stop at the next entry to or return from syscall.  */
   PTRACE_SYSCALL = 24,
 #define PT_SYSCALL PTRACE_SYSCALL
 
-  /* Get all hardware breakpoint registers.  */
-  PTRACE_GETHBPREGS = 29,
-
-  /* Set all hardware breakpoint registers.  */
-  PTRACE_SETHBPREGS = 30,
-
   /* Set ptrace filter options.  */
   PTRACE_SETOPTIONS = 0x4200,
 #define PT_SETOPTIONS PTRACE_SETOPTIONS
@@ -140,8 +132,12 @@ enum __ptrace_request
 #define PTRACE_SETSIGMASK PTRACE_SETSIGMASK
 
   /* Get seccomp BPF filters.  */
-  PTRACE_SECCOMP_GET_FILTER = 0x420c
+  PTRACE_SECCOMP_GET_FILTER = 0x420c,
 #define PTRACE_SECCOMP_GET_FILTER PTRACE_SECCOMP_GET_FILTER
+
+  /* Get seccomp BPF filter metadata.  */
+  PTRACE_SECCOMP_GET_METADATA = 0x420d
+#define PTRACE_SECCOMP_GET_METADATA PTRACE_SECCOMP_GET_METADATA
 };
 
 
diff --git a/sysdeps/unix/sysv/linux/arm/sys/ptrace.h b/sysdeps/unix/sysv/linux/arm/sys/ptrace.h
index fbcb9384bd..bc54a1e5e2 100644
--- a/sysdeps/unix/sysv/linux/arm/sys/ptrace.h
+++ b/sysdeps/unix/sysv/linux/arm/sys/ptrace.h
@@ -192,8 +192,12 @@ enum __ptrace_request
 #define PTRACE_SETSIGMASK PTRACE_SETSIGMASK
 
   /* Get seccomp BPF filters.  */
-  PTRACE_SECCOMP_GET_FILTER = 0x420c
+  PTRACE_SECCOMP_GET_FILTER = 0x420c,
 #define PTRACE_SECCOMP_GET_FILTER PTRACE_SECCOMP_GET_FILTER
+
+  /* Get seccomp BPF filter metadata.  */
+  PTRACE_SECCOMP_GET_METADATA = 0x420d
+#define PTRACE_SECCOMP_GET_METADATA PTRACE_SECCOMP_GET_METADATA
 };
 
 
diff --git a/sysdeps/unix/sysv/linux/bits/mman-shared.h b/sysdeps/unix/sysv/linux/bits/mman-shared.h
index 7715e680ca..d15ba95c9d 100644
--- a/sysdeps/unix/sysv/linux/bits/mman-shared.h
+++ b/sysdeps/unix/sysv/linux/bits/mman-shared.h
@@ -61,7 +61,7 @@ int pkey_set (int __key, unsigned int __access_rights) __THROW;
 
 /* Return the access rights for the current thread for KEY, which must
    have been allocated using pkey_alloc.  */
-int pkey_get (int _key) __THROW;
+int pkey_get (int __key) __THROW;
 
 /* Free an allocated protection key, which must have been allocated
    using pkey_alloc.  */
diff --git a/sysdeps/unix/sysv/linux/bits/ptrace-shared.h b/sysdeps/unix/sysv/linux/bits/ptrace-shared.h
index 960b101f94..03a779140c 100644
--- a/sysdeps/unix/sysv/linux/bits/ptrace-shared.h
+++ b/sysdeps/unix/sysv/linux/bits/ptrace-shared.h
@@ -66,6 +66,13 @@ enum __ptrace_peeksiginfo_flags
   PTRACE_PEEKSIGINFO_SHARED = (1 << 0)
 };
 
+/* Argument and results of PTRACE_SECCOMP_GET_METADATA.  */
+struct __ptrace_seccomp_metadata
+{
+  __uint64_t filter_off;	/* Input: which filter.  */
+  __uint64_t flags;		/* Output: filter's flags.  */
+};
+
 /* Perform process tracing functions.  REQUEST is one of the values
    above, and determines the action to be taken.
    For all requests except PTRACE_TRACEME, PID specifies the process to be
diff --git a/sysdeps/unix/sysv/linux/bits/types/siginfo_t.h b/sysdeps/unix/sysv/linux/bits/types/siginfo_t.h
index 33766d1813..43c4e009a4 100644
--- a/sysdeps/unix/sysv/linux/bits/types/siginfo_t.h
+++ b/sysdeps/unix/sysv/linux/bits/types/siginfo_t.h
@@ -107,7 +107,7 @@ typedef struct
 	/* SIGPOLL.  */
 	struct
 	  {
-	    long int si_band;	/* Band event for SIGPOLL.  */
+	    __SI_BAND_TYPE si_band;	/* Band event for SIGPOLL.  */
 	    int si_fd;
 	  } _sigpoll;
 
diff --git a/sysdeps/unix/sysv/linux/bits/uio-ext.h b/sysdeps/unix/sysv/linux/bits/uio-ext.h
index 53663ed1a2..8698bc1200 100644
--- a/sysdeps/unix/sysv/linux/bits/uio-ext.h
+++ b/sysdeps/unix/sysv/linux/bits/uio-ext.h
@@ -46,6 +46,7 @@ extern ssize_t process_vm_writev (pid_t __pid, const struct iovec *__lvec,
 #define RWF_DSYNC	0x00000002 /* per-IO O_DSYNC.  */
 #define RWF_SYNC	0x00000004 /* per-IO O_SYNC.  */
 #define RWF_NOWAIT	0x00000008 /* per-IO nonblocking mode.  */
+#define RWF_APPEND	0x00000010 /* per-IO O_APPEND.  */
 
 __END_DECLS
 
diff --git a/sysdeps/unix/sysv/linux/copy_file_range.c b/sysdeps/unix/sysv/linux/copy_file_range.c
index 7b1a50f752..b88b7c9e2e 100644
--- a/sysdeps/unix/sysv/linux/copy_file_range.c
+++ b/sysdeps/unix/sysv/linux/copy_file_range.c
@@ -20,27 +20,16 @@
 #include <sysdep-cancel.h>
 #include <unistd.h>
 
-/* Include the fallback implementation.  */
-#ifndef __ASSUME_COPY_FILE_RANGE
-#define COPY_FILE_RANGE_DECL static
-#define COPY_FILE_RANGE copy_file_range_compat
-#include <io/copy_file_range-compat.c>
-#endif
-
 ssize_t
 copy_file_range (int infd, __off64_t *pinoff,
                  int outfd, __off64_t *poutoff,
                  size_t length, unsigned int flags)
 {
 #ifdef __NR_copy_file_range
-  ssize_t ret = SYSCALL_CANCEL (copy_file_range, infd, pinoff, outfd, poutoff,
-                                length, flags);
-# ifndef __ASSUME_COPY_FILE_RANGE
-  if (ret == -1 && errno == ENOSYS)
-    ret = copy_file_range_compat (infd, pinoff, outfd, poutoff, length, flags);
-# endif
-  return ret;
-#else  /* !__NR_copy_file_range */
-  return copy_file_range_compat (infd, pinoff, outfd, poutoff, length, flags);
+  return SYSCALL_CANCEL (copy_file_range, infd, pinoff, outfd, poutoff,
+                         length, flags);
+#else
+  __set_errno (ENOSYS);
+  return -1;
 #endif
 }
diff --git a/sysdeps/unix/sysv/linux/getlogin_r.c b/sysdeps/unix/sysv/linux/getlogin_r.c
index 84c51d0ecd..7a814ea92f 100644
--- a/sysdeps/unix/sysv/linux/getlogin_r.c
+++ b/sysdeps/unix/sysv/linux/getlogin_r.c
@@ -54,6 +54,15 @@ __getlogin_r_loginuid (char *name, size_t namesize)
 	  endp == uidbuf || *endp != '\0'))
     return -1;
 
+  /* If there is no login uid, linux sets /proc/self/loginid to the sentinel
+     value of, (uid_t) -1, so check if that value is set and return early to
+     avoid making unneeded nss lookups. */
+  if (uid == (uid_t) -1)
+    {
+      __set_errno (ENXIO);
+      return ENXIO;
+    }
+
   size_t buflen = 1024;
   char *buf = alloca (buflen);
   bool use_malloc = false;
diff --git a/sysdeps/unix/sysv/linux/i386/Makefile b/sysdeps/unix/sysv/linux/i386/Makefile
index 4080b8c966..da716e2c1b 100644
--- a/sysdeps/unix/sysv/linux/i386/Makefile
+++ b/sysdeps/unix/sysv/linux/i386/Makefile
@@ -3,6 +3,9 @@ default-abi := 32
 
 ifeq ($(subdir),misc)
 sysdep_routines += ioperm iopl vm86
+
+tests += tst-bz21269
+$(objpfx)tst-bz21269: $(shared-thread-library)
 endif
 
 ifeq ($(subdir),elf)
diff --git a/sysdeps/unix/sysv/linux/i386/sigaction.c b/sysdeps/unix/sysv/linux/i386/sigaction.c
index a5eb9e0d3e..177ff60ee6 100644
--- a/sysdeps/unix/sysv/linux/i386/sigaction.c
+++ b/sysdeps/unix/sysv/linux/i386/sigaction.c
@@ -42,7 +42,6 @@ extern void restore_rt (void) asm ("__restore_rt") attribute_hidden;
 #endif
 extern void restore (void) asm ("__restore") attribute_hidden;
 
-
 /* If ACT is not NULL, change the action for SIG to *ACT.
    If OACT is not NULL, put the old action for SIG in *OACT.  */
 int
@@ -65,6 +64,8 @@ __libc_sigaction (int sig, const struct sigaction *act, struct sigaction *oact)
 	  kact.sa_restorer = ((act->sa_flags & SA_SIGINFO)
 			      ? &restore_rt : &restore);
 	}
+      else
+	kact.sa_restorer = NULL;
     }
 
   /* XXX The size argument hopefully will have to be changed to the
diff --git a/sysdeps/unix/sysv/linux/i386/tst-bz21269.c b/sysdeps/unix/sysv/linux/i386/tst-bz21269.c
new file mode 100644
index 0000000000..6ee3fc62be
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/i386/tst-bz21269.c
@@ -0,0 +1,235 @@
+/* Test for i386 sigaction sa_restorer handling (BZ#21269)
+   Copyright (C) 2017 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This is based on Linux test tools/testing/selftests/x86/ldt_gdt.c,
+   more specifically in do_multicpu_tests function.  The main changes
+   are:
+
+   - C11 atomics instead of plain access.
+   - Remove x86_64 support which simplifies the syscall handling
+     and fallbacks.
+   - Replicate only the test required to trigger the issue for the
+     BZ#21269.  */
+
+#include <stdatomic.h>
+
+#include <asm/ldt.h>
+#include <linux/futex.h>
+
+#include <setjmp.h>
+#include <signal.h>
+#include <errno.h>
+#include <sys/syscall.h>
+#include <sys/mman.h>
+
+#include <support/xunistd.h>
+#include <support/check.h>
+#include <support/xthread.h>
+
+static int
+xset_thread_area (struct user_desc *u_info)
+{
+  long ret = syscall (SYS_set_thread_area, u_info);
+  TEST_VERIFY_EXIT (ret == 0);
+  return ret;
+}
+
+static void
+xmodify_ldt (int func, const void *ptr, unsigned long bytecount)
+{
+  TEST_VERIFY_EXIT (syscall (SYS_modify_ldt, 1, ptr, bytecount) == 0);
+}
+
+static int
+futex (int *uaddr, int futex_op, int val, void *timeout, int *uaddr2,
+	int val3)
+{
+  return syscall (SYS_futex, uaddr, futex_op, val, timeout, uaddr2, val3);
+}
+
+static void
+xsethandler (int sig, void (*handler)(int, siginfo_t *, void *), int flags)
+{
+  struct sigaction sa = { 0 };
+  sa.sa_sigaction = handler;
+  sa.sa_flags = SA_SIGINFO | flags;
+  TEST_VERIFY_EXIT (sigemptyset (&sa.sa_mask) == 0);
+  TEST_VERIFY_EXIT (sigaction (sig, &sa, 0) == 0);
+}
+
+static jmp_buf jmpbuf;
+
+static void
+sigsegv_handler (int sig, siginfo_t *info, void *ctx_void)
+{
+  siglongjmp (jmpbuf, 1);
+}
+
+/* Points to an array of 1024 ints, each holding its own index.  */
+static const unsigned int *counter_page;
+static struct user_desc *low_user_desc;
+static struct user_desc *low_user_desc_clear; /* Used to delete GDT entry.  */
+static int gdt_entry_num;
+
+static void
+setup_counter_page (void)
+{
+  long page_size = sysconf (_SC_PAGE_SIZE);
+  TEST_VERIFY_EXIT (page_size > 0);
+  unsigned int *page = xmmap (NULL, page_size, PROT_READ | PROT_WRITE,
+			      MAP_ANONYMOUS | MAP_PRIVATE | MAP_32BIT, -1);
+  for (int i = 0; i < (page_size / sizeof (unsigned int)); i++)
+    page[i] = i;
+  counter_page = page;
+}
+
+static void
+setup_low_user_desc (void)
+{
+  low_user_desc = xmmap (NULL, 2 * sizeof (struct user_desc),
+			 PROT_READ | PROT_WRITE,
+			 MAP_ANONYMOUS | MAP_PRIVATE | MAP_32BIT, -1);
+
+  low_user_desc->entry_number    = -1;
+  low_user_desc->base_addr       = (unsigned long) &counter_page[1];
+  low_user_desc->limit           = 0xffff;
+  low_user_desc->seg_32bit       = 1;
+  low_user_desc->contents        = 0;
+  low_user_desc->read_exec_only  = 0;
+  low_user_desc->limit_in_pages  = 1;
+  low_user_desc->seg_not_present = 0;
+  low_user_desc->useable         = 0;
+
+  xset_thread_area (low_user_desc);
+
+  low_user_desc_clear = low_user_desc + 1;
+  low_user_desc_clear->entry_number = gdt_entry_num;
+  low_user_desc_clear->read_exec_only = 1;
+  low_user_desc_clear->seg_not_present = 1;
+}
+
+/* Possible values of futex:
+   0: thread is idle.
+   1: thread armed.
+   2: thread should clear LDT entry 0.
+   3: thread should exit.  */
+static atomic_uint ftx;
+
+static void *
+threadproc (void *ctx)
+{
+  while (1)
+    {
+      futex ((int *) &ftx, FUTEX_WAIT, 1, NULL, NULL, 0);
+      while (atomic_load (&ftx) != 2)
+	{
+	  if (atomic_load (&ftx) >= 3)
+	    return NULL;
+	}
+
+      /* clear LDT entry 0.  */
+      const struct user_desc desc = { 0 };
+      xmodify_ldt (1, &desc, sizeof (desc));
+
+      /* If ftx == 2, set it to zero,  If ftx == 100, quit.  */
+      if (atomic_fetch_add (&ftx, -2) != 2)
+	return NULL;
+    }
+}
+
+
+/* As described in testcase, for historical reasons x86_32 Linux (and compat
+   on x86_64) interprets SA_RESTORER clear with nonzero sa_restorer as a
+   request for stack switching if the SS segment is 'funny' (this is default
+   scenario for vDSO system).  This means that anything that tries to mix
+   signal handling with segmentation should explicit clear the sa_restorer.
+
+   This testcase check if sigaction in fact does it by changing the local
+   descriptor table (LDT) through the modify_ldt syscall and triggering
+   a synchronous segfault on iret fault by trying to install an invalid
+   segment.  With a correct zeroed sa_restorer it should not trigger an
+   'real' SEGSEGV and allows the siglongjmp in signal handler.  */
+
+static int
+do_test (void)
+{
+  setup_counter_page ();
+  setup_low_user_desc ();
+
+  pthread_t thread;
+  unsigned short orig_ss;
+
+  xsethandler (SIGSEGV, sigsegv_handler, 0);
+  /* 32-bit kernels send SIGILL instead of SIGSEGV on IRET faults.  */
+  xsethandler (SIGILL, sigsegv_handler, 0);
+  /* Some kernels send SIGBUS instead.  */
+  xsethandler (SIGBUS, sigsegv_handler, 0);
+
+  thread = xpthread_create (0, threadproc, 0);
+
+  asm volatile ("mov %%ss, %0" : "=rm" (orig_ss));
+
+  for (int i = 0; i < 5; i++)
+    {
+      if (sigsetjmp (jmpbuf, 1) != 0)
+	continue;
+
+      /* Make sure the thread is ready after the last test. */
+      while (atomic_load (&ftx) != 0)
+	;
+
+      struct user_desc desc = {
+	.entry_number       = 0,
+	.base_addr          = 0,
+	.limit              = 0xffff,
+	.seg_32bit          = 1,
+	.contents           = 0,
+	.read_exec_only     = 0,
+	.limit_in_pages     = 1,
+	.seg_not_present    = 0,
+	.useable            = 0
+      };
+
+      xmodify_ldt (0x11, &desc, sizeof (desc));
+
+      /* Arm the thread.  */
+      ftx = 1;
+      futex ((int*) &ftx, FUTEX_WAKE, 0, NULL, NULL, 0);
+
+      asm volatile ("mov %0, %%ss" : : "r" (0x7));
+
+      /* Fire up thread modify_ldt call.  */
+      atomic_store (&ftx, 2);
+
+      while (atomic_load (&ftx) != 0)
+	;
+
+      /* On success, modify_ldt will segfault us synchronously and we will
+	 escape via siglongjmp.  */
+      support_record_failure ();
+    }
+
+  atomic_store (&ftx, 100);
+  futex ((int*) &ftx, FUTEX_WAKE, 0, NULL, NULL, 0);
+
+  xpthread_join (thread);
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/sysdeps/unix/sysv/linux/ia64/sys/ptrace.h b/sysdeps/unix/sysv/linux/ia64/sys/ptrace.h
index 1c73b9dee6..e00b1212fc 100644
--- a/sysdeps/unix/sysv/linux/ia64/sys/ptrace.h
+++ b/sysdeps/unix/sysv/linux/ia64/sys/ptrace.h
@@ -145,8 +145,12 @@ enum __ptrace_request
 #define PTRACE_SETSIGMASK PTRACE_SETSIGMASK
 
   /* Get seccomp BPF filters.  */
-  PTRACE_SECCOMP_GET_FILTER = 0x420c
+  PTRACE_SECCOMP_GET_FILTER = 0x420c,
 #define PTRACE_SECCOMP_GET_FILTER PTRACE_SECCOMP_GET_FILTER
+
+  /* Get seccomp BPF filter metadata.  */
+  PTRACE_SECCOMP_GET_METADATA = 0x420d
+#define PTRACE_SECCOMP_GET_METADATA PTRACE_SECCOMP_GET_METADATA
 };
 
 
diff --git a/sysdeps/unix/sysv/linux/if_index.c b/sysdeps/unix/sysv/linux/if_index.c
index e3d08982d9..782fc5e175 100644
--- a/sysdeps/unix/sysv/linux/if_index.c
+++ b/sysdeps/unix/sysv/linux/if_index.c
@@ -38,11 +38,6 @@ __if_nametoindex (const char *ifname)
   return 0;
 #else
   struct ifreq ifr;
-  int fd = __opensock ();
-
-  if (fd < 0)
-    return 0;
-
   if (strlen (ifname) >= IFNAMSIZ)
     {
       __set_errno (ENODEV);
@@ -50,6 +45,12 @@ __if_nametoindex (const char *ifname)
     }
 
   strncpy (ifr.ifr_name, ifname, sizeof (ifr.ifr_name));
+
+  int fd = __opensock ();
+
+  if (fd < 0)
+    return 0;
+
   if (__ioctl (fd, SIOCGIFINDEX, &ifr) < 0)
     {
       int saved_errno = errno;
diff --git a/sysdeps/unix/sysv/linux/ifaddrs.c b/sysdeps/unix/sysv/linux/ifaddrs.c
index 32381f54e4..ac0e1e5738 100644
--- a/sysdeps/unix/sysv/linux/ifaddrs.c
+++ b/sysdeps/unix/sysv/linux/ifaddrs.c
@@ -370,6 +370,14 @@ getifaddrs_internal (struct ifaddrs **ifap)
 	  if ((pid_t) nlh->nlmsg_pid != nh.pid || nlh->nlmsg_seq != nlp->seq)
 	    continue;
 
+	  /* If the dump got interrupted, we can't rely on the results
+	     so try again. */
+	  if (nlh->nlmsg_flags & NLM_F_DUMP_INTR)
+	    {
+	      result = -EAGAIN;
+	      goto exit_free;
+	    }
+
 	  if (nlh->nlmsg_type == NLMSG_DONE)
 	    break;		/* ok */
 
diff --git a/sysdeps/unix/sysv/linux/kernel-features.h b/sysdeps/unix/sysv/linux/kernel-features.h
index 3aa2052c71..880af1a31f 100644
--- a/sysdeps/unix/sysv/linux/kernel-features.h
+++ b/sysdeps/unix/sysv/linux/kernel-features.h
@@ -111,7 +111,3 @@
 #if __LINUX_KERNEL_VERSION >= 0x040400
 # define __ASSUME_MLOCK2 1
 #endif
-
-#if __LINUX_KERNEL_VERSION >= 0x040500
-# define __ASSUME_COPY_FILE_RANGE 1
-#endif
diff --git a/sysdeps/unix/sysv/linux/microblaze/kernel-features.h b/sysdeps/unix/sysv/linux/microblaze/kernel-features.h
index 745f899911..e0e6483c91 100644
--- a/sysdeps/unix/sysv/linux/microblaze/kernel-features.h
+++ b/sysdeps/unix/sysv/linux/microblaze/kernel-features.h
@@ -52,8 +52,3 @@
 #if __LINUX_KERNEL_VERSION < 0x040000
 # undef __ASSUME_EXECVEAT
 #endif
-
-/* Support for the copy_file_range syscall was added in 4.10.  */
-#if __LINUX_KERNEL_VERSION < 0x040A00
-# undef __ASSUME_COPY_FILE_RANGE
-#endif
diff --git a/sysdeps/unix/sysv/linux/mips/Makefile b/sysdeps/unix/sysv/linux/mips/Makefile
index 8217f42e75..03044e7365 100644
--- a/sysdeps/unix/sysv/linux/mips/Makefile
+++ b/sysdeps/unix/sysv/linux/mips/Makefile
@@ -63,14 +63,25 @@ sysdep-dl-routines += dl-static
 
 sysdep_routines += dl-vdso
 endif
-
-# Supporting non-executable stacks on MIPS requires changes to both
-# the Linux kernel and glibc.  See
-# <https://sourceware.org/ml/libc-alpha/2016-01/msg00567.html> and
-# <https://sourceware.org/ml/libc-alpha/2016-01/msg00719.html>.
+# If the compiler doesn't use GNU.stack note,
+# this test is expected to fail.
+ifneq ($(mips-has-gnustack),yes)
 test-xfail-check-execstack = yes
 endif
+endif
 
 ifeq ($(subdir),stdlib)
 gen-as-const-headers += ucontext_i.sym
 endif
+
+ifeq ($(mips-force-execstack),yes)
+CFLAGS-.o += -Wa,-execstack
+CFLAGS-.os += -Wa,-execstack
+CFLAGS-.op += -Wa,-execstack
+CFLAGS-.oS += -Wa,-execstack
+
+ASFLAGS-.o += -Wa,-execstack
+ASFLAGS-.os += -Wa,-execstack
+ASFLAGS-.op += -Wa,-execstack
+ASFLAGS-.oS += -Wa,-execstack
+endif
diff --git a/sysdeps/unix/sysv/linux/mips/configure b/sysdeps/unix/sysv/linux/mips/configure
index 1ee7f41a36..25f98e0c7b 100644
--- a/sysdeps/unix/sysv/linux/mips/configure
+++ b/sysdeps/unix/sysv/linux/mips/configure
@@ -475,3 +475,44 @@ if test -z "$arch_minimum_kernel"; then
     arch_minimum_kernel=4.5.0
   fi
 fi
+
+# Check if we are supposed to run on kernels older than 4.8.0. If so,
+# force executable stack to avoid potential runtime problems with fpu
+# emulation.
+# NOTE: The check below assumes that in absence of user-provided minumum_kernel
+# we will default to arch_minimum_kernel which is currently less than 4.8.0 for
+# all known configurations. If this changes, the check must be updated.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the compiler must use executable stack" >&5
+$as_echo_n "checking whether the compiler must use executable stack... " >&6; }
+if ${libc_cv_mips_force_execstack+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  libc_cv_mips_force_execstack=no
+  if test $libc_mips_float = hard; then
+    if test -n "$minimum_kernel"; then
+
+       min_version=$((`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1 \* 65536 + \2 \* 256 + \3/'`))
+
+       if test $min_version -lt 264192; then
+         libc_cv_mips_force_execstack=yes
+       fi
+    else
+      libc_cv_mips_force_execstack=yes
+    fi
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $libc_cv_mips_force_execstack" >&5
+$as_echo "$libc_cv_mips_force_execstack" >&6; }
+
+libc_mips_has_gnustack=$libc_cv_as_noexecstack
+
+if test $libc_cv_mips_force_execstack = yes; then
+  libc_mips_has_gnustack=no
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: forcing executable stack for pre-4.8.0 Linux kernels" >&5
+$as_echo "$as_me: WARNING: forcing executable stack for pre-4.8.0 Linux kernels" >&2;}
+fi
+
+config_vars="$config_vars
+mips-force-execstack = ${libc_cv_mips_force_execstack}"
+config_vars="$config_vars
+mips-has-gnustack = ${libc_mips_has_gnustack}"
diff --git a/sysdeps/unix/sysv/linux/mips/configure.ac b/sysdeps/unix/sysv/linux/mips/configure.ac
index 9147aa4582..3db1b32b08 100644
--- a/sysdeps/unix/sysv/linux/mips/configure.ac
+++ b/sysdeps/unix/sysv/linux/mips/configure.ac
@@ -134,3 +134,35 @@ if test -z "$arch_minimum_kernel"; then
     arch_minimum_kernel=4.5.0
   fi
 fi
+
+# Check if we are supposed to run on kernels older than 4.8.0. If so,
+# force executable stack to avoid potential runtime problems with fpu
+# emulation.
+# NOTE: The check below assumes that in absence of user-provided minumum_kernel
+# we will default to arch_minimum_kernel which is currently less than 4.8.0 for
+# all known configurations. If this changes, the check must be updated.
+AC_CACHE_CHECK([whether the compiler must use executable stack],
+        libc_cv_mips_force_execstack, [dnl
+libc_cv_mips_force_execstack=no
+  if test $libc_mips_float = hard; then
+    if test -n "$minimum_kernel"; then
+       changequote(,)
+       min_version=$((`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1 \* 65536 + \2 \* 256 + \3/'`))
+       changequote([,])
+       if test $min_version -lt 264192; then
+         libc_cv_mips_force_execstack=yes
+       fi
+    else
+      libc_cv_mips_force_execstack=yes
+    fi
+  fi])
+
+libc_mips_has_gnustack=$libc_cv_as_noexecstack
+
+if test $libc_cv_mips_force_execstack = yes; then
+  libc_mips_has_gnustack=no
+  AC_MSG_WARN([forcing executable stack for pre-4.8.0 Linux kernels])
+fi
+
+LIBC_CONFIG_VAR([mips-force-execstack],[${libc_cv_mips_force_execstack}])
+LIBC_CONFIG_VAR([mips-has-gnustack],[${libc_mips_has_gnustack}])
diff --git a/sysdeps/unix/sysv/linux/mips/mmap_info.h b/sysdeps/unix/sysv/linux/mips/mmap_info.h
new file mode 100644
index 0000000000..07c9e3a044
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/mips/mmap_info.h
@@ -0,0 +1,13 @@
+/* mips64n32 uses __NR_mmap for mmap64 while still having sizeof (off_t)
+   smaller than sizeof (off64_t).  So it allows mapping large offsets
+   using mmap64 than 32-bit archs which uses __NR_mmap2.  */
+
+static inline uint64_t
+mmap64_maximum_offset (long int page_shift)
+{
+#if _MIPS_SIM == _ABIN32 || _MIPS_SIM == _ABI64
+  return UINT64_MAX;
+#else
+  return (UINT64_C(1) << (page_shift + (8 * sizeof (off_t)))) - 1;
+#endif
+}
diff --git a/sysdeps/unix/sysv/linux/mmap64.c b/sysdeps/unix/sysv/linux/mmap64.c
index 118624185e..5d7598b4ba 100644
--- a/sysdeps/unix/sysv/linux/mmap64.c
+++ b/sysdeps/unix/sysv/linux/mmap64.c
@@ -23,11 +23,18 @@
 #include <sysdep.h>
 #include <mmap_internal.h>
 
+#ifdef __NR_mmap2
 /* To avoid silent truncation of offset when using mmap2, do not accept
    offset larger than 1 << (page_shift + off_t bits).  For archictures with
    32 bits off_t and page size of 4096 it would be 1^44.  */
-#define MMAP_OFF_HIGH_MASK \
+# define MMAP_OFF_HIGH_MASK \
   ((-(MMAP2_PAGE_UNIT << 1) << (8 * sizeof (off_t) - 1)))
+#else
+/* Some ABIs might use __NR_mmap while having sizeof (off_t) smaller than
+   sizeof (off64_t) (currently only MIPS64n32).  For this case just set
+   zero the higher bits so mmap with large offset does not fail.  */
+# define MMAP_OFF_HIGH_MASK  0x0
+#endif
 
 #define MMAP_OFF_MASK (MMAP_OFF_HIGH_MASK | MMAP_OFF_LOW_MASK)
 
diff --git a/sysdeps/unix/sysv/linux/powerpc/elision-lock.c b/sysdeps/unix/sysv/linux/powerpc/elision-lock.c
index b7093feab9..98a23f0dd2 100644
--- a/sysdeps/unix/sysv/linux/powerpc/elision-lock.c
+++ b/sysdeps/unix/sysv/linux/powerpc/elision-lock.c
@@ -45,6 +45,7 @@
 int
 __lll_lock_elision (int *lock, short *adapt_count, EXTRAARG int pshared)
 {
+#ifndef __SPE__
   /* adapt_count is accessed concurrently but is just a hint.  Thus,
      use atomic accesses but relaxed MO is sufficient.  */
   if (atomic_load_relaxed (adapt_count) > 0)
@@ -82,5 +83,6 @@ __lll_lock_elision (int *lock, short *adapt_count, EXTRAARG int pshared)
 			  aconf.skip_lock_out_of_tbegin_retries);
 
 use_lock:
+#endif
   return LLL_LOCK ((*lock), pshared);
 }
diff --git a/sysdeps/unix/sysv/linux/powerpc/elision-trylock.c b/sysdeps/unix/sysv/linux/powerpc/elision-trylock.c
index b74a810648..fabb03b2c4 100644
--- a/sysdeps/unix/sysv/linux/powerpc/elision-trylock.c
+++ b/sysdeps/unix/sysv/linux/powerpc/elision-trylock.c
@@ -30,6 +30,7 @@
 int
 __lll_trylock_elision (int *futex, short *adapt_count)
 {
+#ifndef __SPE__
   /* Implement POSIX semantics by forbiding nesting elided trylocks.  */
   __libc_tabort (_ABORT_NESTED_TRYLOCK);
 
@@ -65,5 +66,6 @@ __lll_trylock_elision (int *futex, short *adapt_count)
     }
 
 use_lock:
+#endif
   return lll_trylock (*futex);
 }
diff --git a/sysdeps/unix/sysv/linux/powerpc/elision-unlock.c b/sysdeps/unix/sysv/linux/powerpc/elision-unlock.c
index dcfab199d7..14e0680ee9 100644
--- a/sysdeps/unix/sysv/linux/powerpc/elision-unlock.c
+++ b/sysdeps/unix/sysv/linux/powerpc/elision-unlock.c
@@ -23,6 +23,7 @@
 int
 __lll_unlock_elision (int *lock, short *adapt_count, int pshared)
 {
+#ifndef __SPE__
   /* When the lock was free we're in a transaction.  */
   if (*lock == 0)
     __libc_tend (0);
@@ -39,5 +40,8 @@ __lll_unlock_elision (int *lock, short *adapt_count, int pshared)
 
       lll_unlock ((*lock), pshared);
     }
+#else
+  lll_unlock ((*lock), pshared);
+#endif
   return 0;
 }
diff --git a/sysdeps/unix/sysv/linux/powerpc/force-elision.h b/sysdeps/unix/sysv/linux/powerpc/force-elision.h
index fe5d6ceade..d8f5a4b1c7 100644
--- a/sysdeps/unix/sysv/linux/powerpc/force-elision.h
+++ b/sysdeps/unix/sysv/linux/powerpc/force-elision.h
@@ -18,9 +18,45 @@
 
 /* Automatically enable elision for existing user lock kinds.  */
 #define FORCE_ELISION(m, s)						\
-  if (__pthread_force_elision						\
-      && (m->__data.__kind & PTHREAD_MUTEX_ELISION_FLAGS_NP) == 0)	\
+  if (__pthread_force_elision)						\
     {									\
-      mutex->__data.__kind |= PTHREAD_MUTEX_ELISION_NP;			\
-      s;								\
+      /* See concurrency notes regarding __kind in			\
+	 struct __pthread_mutex_s in					\
+	 sysdeps/nptl/bits/thread-shared-types.h.			\
+									\
+	 There are the following cases for the kind of a mutex		\
+	 (The mask PTHREAD_MUTEX_ELISION_FLAGS_NP covers the flags	\
+	 PTHREAD_MUTEX_ELISION_NP and PTHREAD_MUTEX_NO_ELISION_NP where	\
+	 only one of both flags can be set):				\
+	 - both flags are not set:					\
+	 This is the first lock operation for this mutex.  Enable	\
+	 elision as it is not enabled so far.				\
+	 Note: It can happen that multiple threads are calling e.g.	\
+	 pthread_mutex_lock at the same time as the first lock		\
+	 operation for this mutex.  Then elision is enabled for this	\
+	 mutex by multiple threads.  Storing with relaxed MO is enough	\
+	 as all threads will store the same new value for the kind of	\
+	 the mutex.  But we have to ensure that we always use the	\
+	 elision path regardless if this thread has enabled elision or	\
+	 another one.							\
+									\
+	 - PTHREAD_MUTEX_ELISION_NP flag is set:			\
+	 Elision was already enabled for this mutex by a previous lock	\
+	 operation.  See case above.  Just use the elision path.	\
+									\
+	 - PTHREAD_MUTEX_NO_ELISION_NP flag is set:			\
+	 Elision was explicitly disabled by pthread_mutexattr_settype.	\
+	 Do not use the elision path.					\
+	 Note: The flag PTHREAD_MUTEX_NO_ELISION_NP will never be	\
+	 changed after mutex initialization.  */			\
+      int mutex_kind = atomic_load_relaxed (&((m)->__data.__kind));	\
+      if ((mutex_kind & PTHREAD_MUTEX_ELISION_FLAGS_NP) == 0)		\
+	{								\
+	  mutex_kind |= PTHREAD_MUTEX_ELISION_NP;			\
+	  atomic_store_relaxed (&((m)->__data.__kind), mutex_kind);	\
+	}								\
+      if ((mutex_kind & PTHREAD_MUTEX_ELISION_NP) != 0)			\
+	{								\
+	  s;								\
+	}								\
     }
diff --git a/sysdeps/unix/sysv/linux/powerpc/sys/ptrace.h b/sysdeps/unix/sysv/linux/powerpc/sys/ptrace.h
index 75567b2bad..9fde99c748 100644
--- a/sysdeps/unix/sysv/linux/powerpc/sys/ptrace.h
+++ b/sysdeps/unix/sysv/linux/powerpc/sys/ptrace.h
@@ -24,6 +24,50 @@
 
 __BEGIN_DECLS
 
+#if defined _LINUX_PTRACE_H || defined _ASM_POWERPC_PTRACE_H
+/* Do not let Linux headers macros interfere with enum __ptrace_request.  */
+# undef PTRACE_ATTACH
+# undef PTRACE_CONT
+# undef PTRACE_DETACH
+# undef PTRACE_GET_DEBUGREG
+# undef PTRACE_GETEVENTMSG
+# undef PTRACE_GETEVRREGS
+# undef PTRACE_GETFPREGS
+# undef PTRACE_GETREGS
+# undef PTRACE_GETREGS64
+# undef PTRACE_GETREGSET
+# undef PTRACE_GETSIGINFO
+# undef PTRACE_GETSIGMASK
+# undef PTRACE_GETVRREGS
+# undef PTRACE_GETVSRREGS
+# undef PTRACE_INTERRUPT
+# undef PTRACE_KILL
+# undef PTRACE_LISTEN
+# undef PTRACE_PEEKDATA
+# undef PTRACE_PEEKSIGINFO
+# undef PTRACE_PEEKTEXT
+# undef PTRACE_POKEDATA
+# undef PTRACE_POKETEXT
+# undef PTRACE_SECCOMP_GET_FILTER
+# undef PTRACE_SECCOMP_GET_METADATA
+# undef PTRACE_SEIZE
+# undef PTRACE_SET_DEBUGREG
+# undef PTRACE_SETEVRREGS
+# undef PTRACE_SETFPREGS
+# undef PTRACE_SETOPTIONS
+# undef PTRACE_SETREGS
+# undef PTRACE_SETREGS64
+# undef PTRACE_SETREGSET
+# undef PTRACE_SETSIGINFO
+# undef PTRACE_SETSIGMASK
+# undef PTRACE_SETVRREGS
+# undef PTRACE_SETVSRREGS
+# undef PTRACE_SINGLEBLOCK
+# undef PTRACE_SINGLESTEP
+# undef PTRACE_SYSCALL
+# undef PTRACE_TRACEME
+#endif
+
 /* Type of the REQUEST argument to `ptrace.'  */
 enum __ptrace_request
 {
@@ -69,6 +113,22 @@ enum __ptrace_request
   PTRACE_SINGLESTEP = 9,
 #define PT_STEP PTRACE_SINGLESTEP
 
+  /* Get all general purpose registers used by a process.  */
+  PTRACE_GETREGS = 12,
+#define PT_GETREGS PTRACE_GETREGS
+
+  /* Set all general purpose registers used by a process.  */
+  PTRACE_SETREGS = 13,
+#define PT_SETREGS PTRACE_SETREGS
+
+  /* Get all floating point registers used by a process.  */
+  PTRACE_GETFPREGS = 14,
+#define PT_GETFPREGS PTRACE_GETFPREGS
+
+  /* Set all floating point registers used by a process.  */
+  PTRACE_SETFPREGS = 15,
+#define PT_SETFPREGS PTRACE_SETFPREGS
+
   /* Attach to a process that is already running. */
   PTRACE_ATTACH = 16,
 #define PT_ATTACH PTRACE_ATTACH
@@ -77,10 +137,56 @@ enum __ptrace_request
   PTRACE_DETACH = 17,
 #define PT_DETACH PTRACE_DETACH
 
+  /* Get all altivec registers used by a process.  */
+  PTRACE_GETVRREGS = 18,
+#define PT_GETVRREGS PTRACE_GETVRREGS
+
+  /* Set all altivec registers used by a process.  */
+  PTRACE_SETVRREGS = 19,
+#define PT_SETVRREGS PTRACE_SETVRREGS
+
+  /* Get all SPE registers used by a process.  */
+  PTRACE_GETEVRREGS = 20,
+#define PT_GETEVRREGS PTRACE_GETEVRREGS
+
+  /* Set all SPE registers used by a process.  */
+  PTRACE_SETEVRREGS = 21,
+#define PT_SETEVRREGS PTRACE_SETEVRREGS
+
+  /* Same as PTRACE_GETREGS except a 32-bit process will obtain
+     the full 64-bit registers.  Implemented by 64-bit kernels only.  */
+  PTRACE_GETREGS64 = 22,
+#define PT_GETREGS64 PTRACE_GETREGS64
+
+  /* Same as PTRACE_SETREGS except a 32-bit process will set
+     the full 64-bit registers.  Implemented by 64-bit kernels only.  */
+  PTRACE_SETREGS64 = 23,
+#define PT_SETREGS64 PTRACE_SETREGS64
+
   /* Continue and stop at the next entry to or return from syscall.  */
   PTRACE_SYSCALL = 24,
 #define PT_SYSCALL PTRACE_SYSCALL
 
+  /* Get a debug register of a process.  */
+  PTRACE_GET_DEBUGREG = 25,
+#define PT_GET_DEBUGREG PTRACE_GET_DEBUGREG
+
+  /* Set a debug register of a process.  */
+  PTRACE_SET_DEBUGREG = 26,
+#define PT_SET_DEBUGREG PTRACE_SET_DEBUGREG
+
+  /* Get the first 32 VSX registers of a process.  */
+  PTRACE_GETVSRREGS = 27,
+#define PT_GETVSRREGS PTRACE_GETVSRREGS
+
+  /* Set the first 32 VSX registers of a process.  */
+  PTRACE_SETVSRREGS = 28,
+#define PT_SETVSRREGS PTRACE_SETVSRREGS
+
+  /* Execute process until next taken branch.  */
+  PTRACE_SINGLEBLOCK = 256,
+#define PT_STEPBLOCK PTRACE_SINGLEBLOCK
+
   /* Set ptrace filter options.  */
   PTRACE_SETOPTIONS = 0x4200,
 #define PT_SETOPTIONS PTRACE_SETOPTIONS
@@ -131,8 +237,12 @@ enum __ptrace_request
 #define PTRACE_SETSIGMASK PTRACE_SETSIGMASK
 
   /* Get seccomp BPF filters.  */
-  PTRACE_SECCOMP_GET_FILTER = 0x420c
+  PTRACE_SECCOMP_GET_FILTER = 0x420c,
 #define PTRACE_SECCOMP_GET_FILTER PTRACE_SECCOMP_GET_FILTER
+
+  /* Get seccomp BPF filter metadata.  */
+  PTRACE_SECCOMP_GET_METADATA = 0x420d
+#define PTRACE_SECCOMP_GET_METADATA PTRACE_SECCOMP_GET_METADATA
 };
 
 
diff --git a/sysdeps/unix/sysv/linux/preadv2.c b/sysdeps/unix/sysv/linux/preadv2.c
index 06d29b1322..bb08cbc5fd 100644
--- a/sysdeps/unix/sysv/linux/preadv2.c
+++ b/sysdeps/unix/sysv/linux/preadv2.c
@@ -32,7 +32,7 @@ preadv2 (int fd, const struct iovec *vector, int count, off_t offset,
 # ifdef __NR_preadv2
   ssize_t result = SYSCALL_CANCEL (preadv2, fd, vector, count,
 				   LO_HI_LONG (offset), flags);
-  if (result >= 0)
+  if (result >= 0 || errno != ENOSYS)
     return result;
 # endif
   /* Trying to emulate the preadv2 syscall flags is troublesome:
@@ -49,7 +49,10 @@ preadv2 (int fd, const struct iovec *vector, int count, off_t offset,
       __set_errno (ENOTSUP);
       return -1;
     }
-  return preadv (fd, vector, count, offset);
+  if (offset == -1)
+    return __readv (fd, vector, count);
+  else
+    return preadv (fd, vector, count, offset);
 }
 
 #endif
diff --git a/sysdeps/unix/sysv/linux/preadv64v2.c b/sysdeps/unix/sysv/linux/preadv64v2.c
index 58f7848352..b72a047347 100644
--- a/sysdeps/unix/sysv/linux/preadv64v2.c
+++ b/sysdeps/unix/sysv/linux/preadv64v2.c
@@ -30,7 +30,7 @@ preadv64v2 (int fd, const struct iovec *vector, int count, off64_t offset,
 #ifdef __NR_preadv64v2
   ssize_t result = SYSCALL_CANCEL (preadv64v2, fd, vector, count,
 				   LO_HI_LONG (offset), flags);
-  if (result >= 0)
+  if (result >= 0 || errno != ENOSYS)
     return result;
 #endif
   /* Trying to emulate the preadv2 syscall flags is troublesome:
@@ -47,7 +47,11 @@ preadv64v2 (int fd, const struct iovec *vector, int count, off64_t offset,
       __set_errno (ENOTSUP);
       return -1;
     }
-  return preadv64 (fd, vector, count, offset);
+
+  if (offset == -1)
+    return __readv (fd, vector, count);
+  else
+    return preadv64 (fd, vector, count, offset);
 }
 
 #ifdef __OFF_T_MATCHES_OFF64_T
diff --git a/sysdeps/unix/sysv/linux/pwritev2.c b/sysdeps/unix/sysv/linux/pwritev2.c
index d50d9f51f9..26333ebd43 100644
--- a/sysdeps/unix/sysv/linux/pwritev2.c
+++ b/sysdeps/unix/sysv/linux/pwritev2.c
@@ -28,7 +28,7 @@ pwritev2 (int fd, const struct iovec *vector, int count, off_t offset,
 # ifdef __NR_pwritev2
   ssize_t result = SYSCALL_CANCEL (pwritev2, fd, vector, count,
 				   LO_HI_LONG (offset), flags);
-  if (result >= 0)
+  if (result >= 0 || errno != ENOSYS)
     return result;
 # endif
   /* Trying to emulate the pwritev2 syscall flags is troublesome:
@@ -45,7 +45,10 @@ pwritev2 (int fd, const struct iovec *vector, int count, off_t offset,
       __set_errno (ENOTSUP);
       return -1;
     }
-  return pwritev (fd, vector, count, offset);
+  if (offset == -1)
+    return __writev (fd, vector, count);
+  else
+    return pwritev (fd, vector, count, offset);
 }
 
 #endif
diff --git a/sysdeps/unix/sysv/linux/pwritev64v2.c b/sysdeps/unix/sysv/linux/pwritev64v2.c
index 40c2387690..17ea905aa6 100644
--- a/sysdeps/unix/sysv/linux/pwritev64v2.c
+++ b/sysdeps/unix/sysv/linux/pwritev64v2.c
@@ -30,7 +30,7 @@ pwritev64v2 (int fd, const struct iovec *vector, int count, off64_t offset,
 #ifdef __NR_pwritev64v2
   ssize_t result = SYSCALL_CANCEL (pwritev64v2, fd, vector, count,
 				   LO_HI_LONG (offset), flags);
-  if (result >= 0)
+  if (result >= 0 || errno != ENOSYS)
     return result;
 #endif
   /* Trying to emulate the pwritev2 syscall flags is troublesome:
@@ -47,7 +47,10 @@ pwritev64v2 (int fd, const struct iovec *vector, int count, off64_t offset,
       __set_errno (ENOTSUP);
       return -1;
     }
-  return pwritev64 (fd, vector, count, offset);
+  if (offset == -1)
+    return __writev (fd, vector, count);
+  else
+    return pwritev64 (fd, vector, count, offset);
 }
 
 #ifdef __OFF_T_MATCHES_OFF64_T
diff --git a/sysdeps/unix/sysv/linux/riscv/kernel_sigaction.h b/sysdeps/unix/sysv/linux/riscv/kernel_sigaction.h
new file mode 100644
index 0000000000..2a62bcc5bc
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/riscv/kernel_sigaction.h
@@ -0,0 +1,7 @@
+/* This is the sigaction structure from the RISC-V Linux 4.15 kernel.  */
+
+struct kernel_sigaction {
+	__sighandler_t k_sa_handler;
+	unsigned long sa_flags;
+	sigset_t sa_mask;
+};
diff --git a/sysdeps/unix/sysv/linux/riscv/readelflib.c b/sysdeps/unix/sysv/linux/riscv/readelflib.c
index 6e249ff82f..7e27e0c1d6 100644
--- a/sysdeps/unix/sysv/linux/riscv/readelflib.c
+++ b/sysdeps/unix/sysv/linux/riscv/readelflib.c
@@ -43,6 +43,7 @@ process_elf_file (const char *file_name, const char *lib, int *flag,
 {
   ElfW(Ehdr) *elf_header = (ElfW(Ehdr) *) file_contents;
   Elf32_Ehdr *elf32_header = (Elf32_Ehdr *) elf_header;
+  Elf64_Ehdr *elf64_header = (Elf64_Ehdr *) elf_header;
   int ret;
   long flags;
 
@@ -59,7 +60,7 @@ process_elf_file (const char *file_name, const char *lib, int *flag,
     {
       ret = process_elf64_file (file_name, lib, flag, osversion, soname,
 				file_contents, file_length);
-      flags = elf32_header->e_flags;
+      flags = elf64_header->e_flags;
     }
 
   /* RISC-V linkers encode the floating point ABI as part of the ELF headers.  */
diff --git a/sysdeps/unix/sysv/linux/s390/force-elision.h b/sysdeps/unix/sysv/linux/s390/force-elision.h
index d8a1b9972f..71f32367dd 100644
--- a/sysdeps/unix/sysv/linux/s390/force-elision.h
+++ b/sysdeps/unix/sysv/linux/s390/force-elision.h
@@ -18,9 +18,45 @@
 
 /* Automatically enable elision for existing user lock kinds.  */
 #define FORCE_ELISION(m, s)						\
-  if (__pthread_force_elision						\
-      && (m->__data.__kind & PTHREAD_MUTEX_ELISION_FLAGS_NP) == 0)	\
+  if (__pthread_force_elision)						\
     {									\
-      mutex->__data.__kind |= PTHREAD_MUTEX_ELISION_NP;			\
-      s;								\
+      /* See concurrency notes regarding __kind in			\
+	 struct __pthread_mutex_s in					\
+	 sysdeps/nptl/bits/thread-shared-types.h.			\
+									\
+	 There are the following cases for the kind of a mutex		\
+	 (The mask PTHREAD_MUTEX_ELISION_FLAGS_NP covers the flags	\
+	 PTHREAD_MUTEX_ELISION_NP and PTHREAD_MUTEX_NO_ELISION_NP where	\
+	 only one of both flags can be set):				\
+	 - both flags are not set:					\
+	 This is the first lock operation for this mutex.  Enable	\
+	 elision as it is not enabled so far.				\
+	 Note: It can happen that multiple threads are calling e.g.	\
+	 pthread_mutex_lock at the same time as the first lock		\
+	 operation for this mutex.  Then elision is enabled for this	\
+	 mutex by multiple threads.  Storing with relaxed MO is enough	\
+	 as all threads will store the same new value for the kind of	\
+	 the mutex.  But we have to ensure that we always use the	\
+	 elision path regardless if this thread has enabled elision or	\
+	 another one.							\
+									\
+	 - PTHREAD_MUTEX_ELISION_NP flag is set:			\
+	 Elision was already enabled for this mutex by a previous lock	\
+	 operation.  See case above.  Just use the elision path.	\
+									\
+	 - PTHREAD_MUTEX_NO_ELISION_NP flag is set:			\
+	 Elision was explicitly disabled by pthread_mutexattr_settype.	\
+	 Do not use the elision path.					\
+	 Note: The flag PTHREAD_MUTEX_NO_ELISION_NP will never be	\
+	 changed after mutex initialization.  */			\
+      int mutex_kind = atomic_load_relaxed (&((m)->__data.__kind));	\
+      if ((mutex_kind & PTHREAD_MUTEX_ELISION_FLAGS_NP) == 0)		\
+	{								\
+	  mutex_kind |= PTHREAD_MUTEX_ELISION_NP;			\
+	  atomic_store_relaxed (&((m)->__data.__kind), mutex_kind);	\
+	}								\
+      if ((mutex_kind & PTHREAD_MUTEX_ELISION_NP) != 0)			\
+	{								\
+	  s;								\
+	}								\
     }
diff --git a/sysdeps/unix/sysv/linux/s390/sys/ptrace.h b/sysdeps/unix/sysv/linux/s390/sys/ptrace.h
index cca02489d6..d60a034b11 100644
--- a/sysdeps/unix/sysv/linux/s390/sys/ptrace.h
+++ b/sysdeps/unix/sysv/linux/s390/sys/ptrace.h
@@ -52,6 +52,7 @@ __BEGIN_DECLS
 # undef PTRACE_GETSIGMASK
 # undef PTRACE_SETSIGMASK
 # undef PTRACE_SECCOMP_GET_FILTER
+# undef PTRACE_SECCOMP_GET_METADATA
 # undef PTRACE_PEEKUSR_AREA
 # undef PTRACE_POKEUSR_AREA
 # undef PTRACE_GET_LAST_BREAK
@@ -193,6 +194,10 @@ enum __ptrace_request
   PTRACE_SECCOMP_GET_FILTER = 0x420c,
 #define PTRACE_SECCOMP_GET_FILTER PTRACE_SECCOMP_GET_FILTER
 
+  /* Get seccomp BPF filter metadata.  */
+  PTRACE_SECCOMP_GET_METADATA = 0x420d,
+#define PTRACE_SECCOMP_GET_METADATA PTRACE_SECCOMP_GET_METADATA
+
   PTRACE_PEEKUSR_AREA = 0x5000,
 #define PTRACE_PEEKUSR_AREA PTRACE_PEEKUSR_AREA
 
diff --git a/sysdeps/unix/sysv/linux/sparc/bits/siginfo-arch.h b/sysdeps/unix/sysv/linux/sparc/bits/siginfo-arch.h
index 9f79715ebe..4dd35237f6 100644
--- a/sysdeps/unix/sysv/linux/sparc/bits/siginfo-arch.h
+++ b/sysdeps/unix/sysv/linux/sparc/bits/siginfo-arch.h
@@ -2,7 +2,12 @@
 #ifndef _BITS_SIGINFO_ARCH_H
 #define _BITS_SIGINFO_ARCH_H 1
 
-#define __SI_BAND_TYPE int
+/* The kernel uses int instead of long int (as in POSIX).  In 32-bit
+   mode, we can still use long int, but in 64-bit mode, we need to
+   deviate from POSIX.  */
+#if __WORDSIZE == 64
+# define __SI_BAND_TYPE int
+#endif
 
 #define __SI_SIGFAULT_ADDL \
   int _si_trapno;
diff --git a/sysdeps/unix/sysv/linux/sparc/sparc32/setcontext.S b/sysdeps/unix/sysv/linux/sparc/sparc32/setcontext.S
index 695f172c63..283aef1b30 100644
--- a/sysdeps/unix/sysv/linux/sparc/sparc32/setcontext.S
+++ b/sysdeps/unix/sysv/linux/sparc/sparc32/setcontext.S
@@ -95,6 +95,19 @@ END(__setcontext)
 
 weak_alias (__setcontext, setcontext)
 
+/* We add an NOP here to separate between __setcontext/__startcontext. The
+   wanted behavior that happens is: when unwinding from a function called
+   inside a makecontext() context, FDE lookup will use '&__startcontext - 1',
+   then returns NULL for no FDE found, and immediately ends the unwind, in
+   a normal fashion.
+
+   If this NOP word does not exist, FDE lookup just repeatedly finds
+   __setcontext's FDE in an infinite loop, due to the convention of using
+   'address - 1' for FDE lookup. Modifiying/deleting the below
+   __startcontext's FDE has no help on this.  */
+
+	nop
+
 /* This is the helper code which gets called if a function which is
    registered with 'makecontext' returns.  In this case we have to
    install the context listed in the uc_link element of the context
diff --git a/sysdeps/unix/sysv/linux/sparc/sparc64/Makefile b/sysdeps/unix/sysv/linux/sparc/sparc64/Makefile
index 715af3df7b..218c246f16 100644
--- a/sysdeps/unix/sysv/linux/sparc/sparc64/Makefile
+++ b/sysdeps/unix/sysv/linux/sparc/sparc64/Makefile
@@ -7,3 +7,8 @@ LD += -melf64_sparc
 ifeq ($(subdir),stdlib)
 sysdep_routines += __start_context
 endif
+
+ifeq ($(subdir),conform)
+# For bug 23821 (incorrect type of si_band).
+conformtest-xfail-conds += sparc64-linux
+endif
diff --git a/sysdeps/unix/sysv/linux/sparc/sys/ptrace.h b/sysdeps/unix/sysv/linux/sparc/sys/ptrace.h
index 9193275fac..c037734666 100644
--- a/sysdeps/unix/sysv/linux/sparc/sys/ptrace.h
+++ b/sysdeps/unix/sysv/linux/sparc/sys/ptrace.h
@@ -213,8 +213,12 @@ enum __ptrace_request
 #define PTRACE_SETSIGMASK PTRACE_SETSIGMASK
 
   /* Get seccomp BPF filters.  */
-  PTRACE_SECCOMP_GET_FILTER = 0x420c
+  PTRACE_SECCOMP_GET_FILTER = 0x420c,
 #define PTRACE_SECCOMP_GET_FILTER PTRACE_SECCOMP_GET_FILTER
+
+  /* Get seccomp BPF filter metadata.  */
+  PTRACE_SECCOMP_GET_METADATA = 0x420d
+#define PTRACE_SECCOMP_GET_METADATA PTRACE_SECCOMP_GET_METADATA
 };
 
 
diff --git a/sysdeps/unix/sysv/linux/spawni.c b/sysdeps/unix/sysv/linux/spawni.c
index 6b699a46dd..5fa49b229e 100644
--- a/sysdeps/unix/sysv/linux/spawni.c
+++ b/sysdeps/unix/sysv/linux/spawni.c
@@ -101,7 +101,7 @@ maybe_script_execute (struct posix_spawn_args *args)
       ptrdiff_t argc = args->argc;
 
       /* Construct an argument list for the shell.  */
-      char *new_argv[argc + 1];
+      char *new_argv[argc + 2];
       new_argv[0] = (char *) _PATH_BSHELL;
       new_argv[1] = (char *) args->file;
       if (argc > 1)
@@ -404,6 +404,8 @@ __spawni (pid_t * pid, const char *file,
 	  const posix_spawnattr_t * attrp, char *const argv[],
 	  char *const envp[], int xflags)
 {
+  /* It uses __execvpex to avoid run ENOEXEC in non compatibility mode (it
+     will be handled by maybe_script_execute).  */
   return __spawnix (pid, file, acts, attrp, argv, envp, xflags,
-		    xflags & SPAWN_XFLAGS_USE_PATH ? __execvpe : __execve);
+		    xflags & SPAWN_XFLAGS_USE_PATH ? __execvpex :__execve);
 }
diff --git a/sysdeps/unix/sysv/linux/sys/ptrace.h b/sysdeps/unix/sysv/linux/sys/ptrace.h
index 85772f348a..3c71a0ebd6 100644
--- a/sysdeps/unix/sysv/linux/sys/ptrace.h
+++ b/sysdeps/unix/sysv/linux/sys/ptrace.h
@@ -162,8 +162,12 @@ enum __ptrace_request
 #define PTRACE_SETSIGMASK PTRACE_SETSIGMASK
 
   /* Get seccomp BPF filters.  */
-  PTRACE_SECCOMP_GET_FILTER = 0x420c
+  PTRACE_SECCOMP_GET_FILTER = 0x420c,
 #define PTRACE_SECCOMP_GET_FILTER PTRACE_SECCOMP_GET_FILTER
+
+  /* Get seccomp BPF filter metadata.  */
+  PTRACE_SECCOMP_GET_METADATA = 0x420d
+#define PTRACE_SECCOMP_GET_METADATA PTRACE_SECCOMP_GET_METADATA
 };
 
 
diff --git a/sysdeps/unix/sysv/linux/test-errno-linux.c b/sysdeps/unix/sysv/linux/test-errno-linux.c
index be1135351d..073e2fba64 100644
--- a/sysdeps/unix/sysv/linux/test-errno-linux.c
+++ b/sysdeps/unix/sysv/linux/test-errno-linux.c
@@ -160,8 +160,9 @@ do_test (void)
   fails |= test_wrp (EINVAL, poll, &pollfd, -1, 0);
   /* quotactl returns ENOSYS for kernels not configured with
      CONFIG_QUOTA, and may return EPERM if called within certain types
-     of containers.  */
-  fails |= test_wrp2 (LIST (ENODEV, ENOSYS, EPERM),
+     of containers.  Linux 5.4 added additional argument validation
+     and can return EINVAL.  */
+  fails |= test_wrp2 (LIST (ENODEV, ENOSYS, EPERM, EINVAL),
 		      quotactl, Q_GETINFO, NULL, -1, (caddr_t) &dqblk);
   fails |= test_wrp (EINVAL, sched_getparam, -1, &sch_param);
   fails |= test_wrp (EINVAL, sched_getscheduler, -1);
diff --git a/sysdeps/unix/sysv/linux/tile/sys/ptrace.h b/sysdeps/unix/sysv/linux/tile/sys/ptrace.h
index a1db185073..d391037ca8 100644
--- a/sysdeps/unix/sysv/linux/tile/sys/ptrace.h
+++ b/sysdeps/unix/sysv/linux/tile/sys/ptrace.h
@@ -136,8 +136,12 @@ enum __ptrace_request
 #define PTRACE_SETSIGMASK PTRACE_SETSIGMASK
 
   /* Get seccomp BPF filters.  */
-  PTRACE_SECCOMP_GET_FILTER = 0x420c
+  PTRACE_SECCOMP_GET_FILTER = 0x420c,
 #define PTRACE_SECCOMP_GET_FILTER PTRACE_SECCOMP_GET_FILTER
+
+  /* Get seccomp BPF filter metadata.  */
+  PTRACE_SECCOMP_GET_METADATA = 0x420d
+#define PTRACE_SECCOMP_GET_METADATA PTRACE_SECCOMP_GET_METADATA
 };
 
 
diff --git a/sysdeps/unix/sysv/linux/x86/force-elision.h b/sysdeps/unix/sysv/linux/x86/force-elision.h
index dd659c908f..61282d6678 100644
--- a/sysdeps/unix/sysv/linux/x86/force-elision.h
+++ b/sysdeps/unix/sysv/linux/x86/force-elision.h
@@ -18,9 +18,45 @@
 
 /* Automatically enable elision for existing user lock kinds.  */
 #define FORCE_ELISION(m, s)						\
-  if (__pthread_force_elision						\
-      && (m->__data.__kind & PTHREAD_MUTEX_ELISION_FLAGS_NP) == 0)	\
+  if (__pthread_force_elision)						\
     {									\
-      mutex->__data.__kind |= PTHREAD_MUTEX_ELISION_NP;			\
-      s;								\
+      /* See concurrency notes regarding __kind in			\
+	 struct __pthread_mutex_s in					\
+	 sysdeps/nptl/bits/thread-shared-types.h.			\
+									\
+	 There are the following cases for the kind of a mutex		\
+	 (The mask PTHREAD_MUTEX_ELISION_FLAGS_NP covers the flags	\
+	 PTHREAD_MUTEX_ELISION_NP and PTHREAD_MUTEX_NO_ELISION_NP where	\
+	 only one of both flags can be set):				\
+	 - both flags are not set:					\
+	 This is the first lock operation for this mutex.  Enable	\
+	 elision as it is not enabled so far.				\
+	 Note: It can happen that multiple threads are calling e.g.	\
+	 pthread_mutex_lock at the same time as the first lock		\
+	 operation for this mutex.  Then elision is enabled for this	\
+	 mutex by multiple threads.  Storing with relaxed MO is enough	\
+	 as all threads will store the same new value for the kind of	\
+	 the mutex.  But we have to ensure that we always use the	\
+	 elision path regardless if this thread has enabled elision or	\
+	 another one.							\
+									\
+	 - PTHREAD_MUTEX_ELISION_NP flag is set:			\
+	 Elision was already enabled for this mutex by a previous lock	\
+	 operation.  See case above.  Just use the elision path.	\
+									\
+	 - PTHREAD_MUTEX_NO_ELISION_NP flag is set:			\
+	 Elision was explicitly disabled by pthread_mutexattr_settype.	\
+	 Do not use the elision path.					\
+	 Note: The flag PTHREAD_MUTEX_NO_ELISION_NP will never be	\
+	 changed after mutex initialization.  */			\
+      int mutex_kind = atomic_load_relaxed (&((m)->__data.__kind));	\
+      if ((mutex_kind & PTHREAD_MUTEX_ELISION_FLAGS_NP) == 0)		\
+	{								\
+	  mutex_kind |= PTHREAD_MUTEX_ELISION_NP;			\
+	  atomic_store_relaxed (&((m)->__data.__kind), mutex_kind);	\
+	}								\
+      if ((mutex_kind & PTHREAD_MUTEX_ELISION_NP) != 0)			\
+	{								\
+	  s;								\
+	}								\
     }
diff --git a/sysdeps/unix/sysv/linux/x86/sys/ptrace.h b/sysdeps/unix/sysv/linux/x86/sys/ptrace.h
index 60003422b3..6d4605b6ed 100644
--- a/sysdeps/unix/sysv/linux/x86/sys/ptrace.h
+++ b/sysdeps/unix/sysv/linux/x86/sys/ptrace.h
@@ -182,8 +182,12 @@ enum __ptrace_request
 #define PTRACE_SETSIGMASK PTRACE_SETSIGMASK
 
   /* Get seccomp BPF filters.  */
-  PTRACE_SECCOMP_GET_FILTER = 0x420c
+  PTRACE_SECCOMP_GET_FILTER = 0x420c,
 #define PTRACE_SECCOMP_GET_FILTER PTRACE_SECCOMP_GET_FILTER
+
+  /* Get seccomp BPF filter metadata.  */
+  PTRACE_SECCOMP_GET_METADATA = 0x420d
+#define PTRACE_SECCOMP_GET_METADATA PTRACE_SECCOMP_GET_METADATA
 };
 
 
diff --git a/sysdeps/unix/sysv/linux/x86_64/64/dl-librecon.h b/sysdeps/unix/sysv/linux/x86_64/64/dl-librecon.h
index 194369174d..ac694c032e 100644
--- a/sysdeps/unix/sysv/linux/x86_64/64/dl-librecon.h
+++ b/sysdeps/unix/sysv/linux/x86_64/64/dl-librecon.h
@@ -31,7 +31,8 @@
    environment variable, LD_PREFER_MAP_32BIT_EXEC.  */
 #define EXTRA_LD_ENVVARS \
   case 21:								  \
-    if (memcmp (envline, "PREFER_MAP_32BIT_EXEC", 21) == 0)		  \
+    if (!__libc_enable_secure						  \
+	&& memcmp (envline, "PREFER_MAP_32BIT_EXEC", 21) == 0)		  \
       GLRO(dl_x86_cpu_features).feature[index_arch_Prefer_MAP_32BIT_EXEC] \
 	|= bit_arch_Prefer_MAP_32BIT_EXEC;				  \
     break;
diff --git a/sysdeps/x86/cpu-features.c b/sysdeps/x86/cpu-features.c
index 0fc3674c4b..ecc82fc6af 100644
--- a/sysdeps/x86/cpu-features.c
+++ b/sysdeps/x86/cpu-features.c
@@ -30,6 +30,20 @@ extern void TUNABLE_CALLBACK (set_hwcaps) (tunable_val_t *)
   attribute_hidden;
 #endif
 
+static void
+get_extended_indices (struct cpu_features *cpu_features)
+{
+  unsigned int eax, ebx, ecx, edx;
+  __cpuid (0x80000000, eax, ebx, ecx, edx);
+  if (eax >= 0x80000001)
+    __cpuid (0x80000001,
+	     cpu_features->cpuid[COMMON_CPUID_INDEX_80000001].eax,
+	     cpu_features->cpuid[COMMON_CPUID_INDEX_80000001].ebx,
+	     cpu_features->cpuid[COMMON_CPUID_INDEX_80000001].ecx,
+	     cpu_features->cpuid[COMMON_CPUID_INDEX_80000001].edx);
+
+}
+
 static void
 get_common_indeces (struct cpu_features *cpu_features,
 		    unsigned int *family, unsigned int *model,
@@ -205,6 +219,8 @@ init_cpu_features (struct cpu_features *cpu_features)
       get_common_indeces (cpu_features, &family, &model, &extended_model,
 			  &stepping);
 
+      get_extended_indices (cpu_features);
+
       if (family == 0x06)
 	{
 	  model += extended_model;
@@ -281,7 +297,13 @@ init_cpu_features (struct cpu_features *cpu_features)
 		    | bit_arch_Fast_Unaligned_Copy
 		    | bit_arch_Prefer_PMINUB_for_stringop);
 	      break;
+	    }
 
+	 /* Disable TSX on some Haswell processors to avoid TSX on kernels that
+	    weren't updated with the latest microcode package (which disables
+	    broken feature by default).  */
+	 switch (model)
+	    {
 	    case 0x3f:
 	      /* Xeon E7 v3 with stepping >= 4 has working TSX.  */
 	      if (stepping >= 4)
@@ -324,16 +346,9 @@ init_cpu_features (struct cpu_features *cpu_features)
       get_common_indeces (cpu_features, &family, &model, &extended_model,
 			  &stepping);
 
-      ecx = cpu_features->cpuid[COMMON_CPUID_INDEX_1].ecx;
+      get_extended_indices (cpu_features);
 
-      unsigned int eax;
-      __cpuid (0x80000000, eax, ebx, ecx, edx);
-      if (eax >= 0x80000001)
-	__cpuid (0x80000001,
-		 cpu_features->cpuid[COMMON_CPUID_INDEX_80000001].eax,
-		 cpu_features->cpuid[COMMON_CPUID_INDEX_80000001].ebx,
-		 cpu_features->cpuid[COMMON_CPUID_INDEX_80000001].ecx,
-		 cpu_features->cpuid[COMMON_CPUID_INDEX_80000001].edx);
+      ecx = cpu_features->cpuid[COMMON_CPUID_INDEX_1].ecx;
 
       if (HAS_ARCH_FEATURE (AVX_Usable))
 	{
diff --git a/sysdeps/x86/cpu-features.h b/sysdeps/x86/cpu-features.h
index c60c2e4eeb..4588c11095 100644
--- a/sysdeps/x86/cpu-features.h
+++ b/sysdeps/x86/cpu-features.h
@@ -106,7 +106,7 @@ enum
   {
     COMMON_CPUID_INDEX_1 = 0,
     COMMON_CPUID_INDEX_7,
-    COMMON_CPUID_INDEX_80000001,	/* for AMD */
+    COMMON_CPUID_INDEX_80000001,
     /* Keep the following line at the end.  */
     COMMON_CPUID_INDEX_MAX
   };
@@ -202,7 +202,7 @@ extern const struct cpu_features *__get_cpu_features (void)
 # define index_cpu_HTT		COMMON_CPUID_INDEX_1
 # define index_cpu_BMI1		COMMON_CPUID_INDEX_7
 # define index_cpu_BMI2		COMMON_CPUID_INDEX_7
-# define index_cpu_LZCNT	COMMON_CPUID_INDEX_1
+# define index_cpu_LZCNT	COMMON_CPUID_INDEX_80000001
 # define index_cpu_MOVBE	COMMON_CPUID_INDEX_1
 # define index_cpu_POPCNT	COMMON_CPUID_INDEX_1
 # define index_cpu_IBT		COMMON_CPUID_INDEX_7
diff --git a/sysdeps/x86_64/memchr.S b/sysdeps/x86_64/memchr.S
index feef5d4f24..cb320257a2 100644
--- a/sysdeps/x86_64/memchr.S
+++ b/sysdeps/x86_64/memchr.S
@@ -34,12 +34,16 @@ ENTRY(MEMCHR)
 	mov	%edi, %ecx
 
 #ifdef USE_AS_WMEMCHR
-	test	%rdx, %rdx
+	test	%RDX_LP, %RDX_LP
 	jz	L(return_null)
-	shl	$2, %rdx
+	shl	$2, %RDX_LP
 #else
+# ifdef __ILP32__
+	/* Clear the upper 32 bits.  */
+	movl	%edx, %edx
+# endif
 	punpcklbw %xmm1, %xmm1
-	test	%rdx, %rdx
+	test	%RDX_LP, %RDX_LP
 	jz	L(return_null)
 	punpcklbw %xmm1, %xmm1
 #endif
diff --git a/sysdeps/x86_64/memcmp.S b/sysdeps/x86_64/memcmp.S
index bcb4a2e88d..45918d375a 100644
--- a/sysdeps/x86_64/memcmp.S
+++ b/sysdeps/x86_64/memcmp.S
@@ -21,14 +21,18 @@
 
 	.text
 ENTRY (memcmp)
-	test	%rdx, %rdx
+#ifdef __ILP32__
+	/* Clear the upper 32 bits.  */
+	movl	%edx, %edx
+#endif
+	test	%RDX_LP, %RDX_LP
 	jz	L(finz)
 	cmpq	$1, %rdx
-	jle	L(finr1b)
+	jbe	L(finr1b)
 	subq	%rdi, %rsi
 	movq	%rdx, %r10
 	cmpq	$32, %r10
-	jge	L(gt32)
+	jae	L(gt32)
 	/* Handle small chunks and last block of less than 32 bytes.  */
 L(small):
 	testq	$1, %r10
@@ -156,7 +160,7 @@ L(A32):
 	movq	%r11, %r10
 	andq	$-32, %r10
 	cmpq	%r10, %rdi
-        jge	L(mt16)
+        jae	L(mt16)
 	/* Pre-unroll to be ready for unrolled 64B loop.  */
 	testq	$32, %rdi
 	jz	L(A64)
@@ -178,7 +182,7 @@ L(A64):
 	movq	%r11, %r10
 	andq	$-64, %r10
 	cmpq	%r10, %rdi
-        jge	L(mt32)
+        jae	L(mt32)
 
 L(A64main):
 	movdqu    (%rdi,%rsi), %xmm0
@@ -216,7 +220,7 @@ L(mt32):
 	movq	%r11, %r10
 	andq	$-32, %r10
 	cmpq	%r10, %rdi
-        jge	L(mt16)
+        jae	L(mt16)
 
 L(A32main):
 	movdqu    (%rdi,%rsi), %xmm0
@@ -254,7 +258,7 @@ L(ATR):
 	movq	%r11, %r10
 	andq	$-32, %r10
 	cmpq	%r10, %rdi
-        jge	L(mt16)
+        jae	L(mt16)
 	testq	$16, %rdi
 	jz	L(ATR32)
 
@@ -325,7 +329,7 @@ L(ATR64main):
 	movq	%r11, %r10
 	andq	$-32, %r10
 	cmpq	%r10, %rdi
-        jge	L(mt16)
+        jae	L(mt16)
 
 L(ATR32res):
 	movdqa    (%rdi,%rsi), %xmm0
diff --git a/sysdeps/x86_64/memrchr.S b/sysdeps/x86_64/memrchr.S
index b8e3fa1d87..dc82f8f73d 100644
--- a/sysdeps/x86_64/memrchr.S
+++ b/sysdeps/x86_64/memrchr.S
@@ -24,13 +24,13 @@
 ENTRY (__memrchr)
 	movd	%esi, %xmm1
 
-	sub	$16, %rdx
+	sub	$16, %RDX_LP
 	jbe	L(length_less16)
 
 	punpcklbw	%xmm1, %xmm1
 	punpcklbw	%xmm1, %xmm1
 
-	add	%rdx, %rdi
+	add	%RDX_LP, %RDI_LP
 	pshufd	$0, %xmm1, %xmm1
 
 	movdqu	(%rdi), %xmm0
diff --git a/sysdeps/x86_64/multiarch/memchr-avx2.S b/sysdeps/x86_64/multiarch/memchr-avx2.S
index 5f5e772554..c81da19bf0 100644
--- a/sysdeps/x86_64/multiarch/memchr-avx2.S
+++ b/sysdeps/x86_64/multiarch/memchr-avx2.S
@@ -40,16 +40,20 @@
 ENTRY (MEMCHR)
 # ifndef USE_AS_RAWMEMCHR
 	/* Check for zero length.  */
-	testq	%rdx, %rdx
+	test	%RDX_LP, %RDX_LP
 	jz	L(null)
 # endif
 	movl	%edi, %ecx
 	/* Broadcast CHAR to YMM0.  */
 	vmovd	%esi, %xmm0
 # ifdef USE_AS_WMEMCHR
-	shl	$2, %rdx
+	shl	$2, %RDX_LP
 	vpbroadcastd %xmm0, %ymm0
 # else
+#  ifdef __ILP32__
+	/* Clear the upper 32 bits.  */
+	movl	%edx, %edx
+#  endif
 	vpbroadcastb %xmm0, %ymm0
 # endif
 	/* Check if we may cross page boundary with one vector load.  */
diff --git a/sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S b/sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
index 30f764c393..e3a35b899e 100644
--- a/sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
+++ b/sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
@@ -58,9 +58,12 @@
 	.section .text.avx,"ax",@progbits
 ENTRY (MEMCMP)
 # ifdef USE_AS_WMEMCMP
-	shl	$2, %rdx
+	shl	$2, %RDX_LP
+# elif defined __ILP32__
+	/* Clear the upper 32 bits.  */
+	movl	%edx, %edx
 # endif
-	cmpq	$VEC_SIZE, %rdx
+	cmp	$VEC_SIZE, %RDX_LP
 	jb	L(less_vec)
 
 	/* From VEC to 2 * VEC.  No branch when size == VEC_SIZE.  */
diff --git a/sysdeps/x86_64/multiarch/memcmp-sse4.S b/sysdeps/x86_64/multiarch/memcmp-sse4.S
index 0d96d6b775..07465dd7b4 100644
--- a/sysdeps/x86_64/multiarch/memcmp-sse4.S
+++ b/sysdeps/x86_64/multiarch/memcmp-sse4.S
@@ -42,13 +42,16 @@
 	.section .text.sse4.1,"ax",@progbits
 ENTRY (MEMCMP)
 # ifdef USE_AS_WMEMCMP
-	shl	$2, %rdx
+	shl	$2, %RDX_LP
+# elif defined __ILP32__
+	/* Clear the upper 32 bits.  */
+	mov	%edx, %edx
 # endif
 	pxor	%xmm0, %xmm0
-	cmp	$79, %rdx
+	cmp	$79, %RDX_LP
 	ja	L(79bytesormore)
 # ifndef USE_AS_WMEMCMP
-	cmp	$1, %rdx
+	cmp	$1, %RDX_LP
 	je	L(firstbyte)
 # endif
 	add	%rdx, %rsi
diff --git a/sysdeps/x86_64/multiarch/memcmp-ssse3.S b/sysdeps/x86_64/multiarch/memcmp-ssse3.S
index 6f76c64123..69d030fc00 100644
--- a/sysdeps/x86_64/multiarch/memcmp-ssse3.S
+++ b/sysdeps/x86_64/multiarch/memcmp-ssse3.S
@@ -33,9 +33,12 @@
 	atom_text_section
 ENTRY (MEMCMP)
 # ifdef USE_AS_WMEMCMP
-	shl	$2, %rdx
-	test	%rdx, %rdx
+	shl	$2, %RDX_LP
+	test	%RDX_LP, %RDX_LP
 	jz	L(equal)
+# elif defined __ILP32__
+	/* Clear the upper 32 bits.  */
+	mov	%edx, %edx
 # endif
 	mov	%rdx, %rcx
 	mov	%rdi, %rdx
diff --git a/sysdeps/x86_64/multiarch/memcpy-ssse3-back.S b/sysdeps/x86_64/multiarch/memcpy-ssse3-back.S
index 7e37035487..d5af5868fa 100644
--- a/sysdeps/x86_64/multiarch/memcpy-ssse3-back.S
+++ b/sysdeps/x86_64/multiarch/memcpy-ssse3-back.S
@@ -45,28 +45,33 @@
 	.section .text.ssse3,"ax",@progbits
 #if !defined USE_AS_MEMPCPY && !defined USE_AS_MEMMOVE
 ENTRY (MEMPCPY_CHK)
-	cmpq	%rdx, %rcx
+	cmp	%RDX_LP, %RCX_LP
 	jb	HIDDEN_JUMPTARGET (__chk_fail)
 END (MEMPCPY_CHK)
 
 ENTRY (MEMPCPY)
-	movq	%rdi, %rax
-	addq	%rdx, %rax
+	mov	%RDI_LP, %RAX_LP
+	add	%RDX_LP, %RAX_LP
 	jmp	L(start)
 END (MEMPCPY)
 #endif
 
 #if !defined USE_AS_BCOPY
 ENTRY (MEMCPY_CHK)
-	cmpq	%rdx, %rcx
+	cmp	%RDX_LP, %RCX_LP
 	jb	HIDDEN_JUMPTARGET (__chk_fail)
 END (MEMCPY_CHK)
 #endif
 
 ENTRY (MEMCPY)
-	mov	%rdi, %rax
+	mov	%RDI_LP, %RAX_LP
 #ifdef USE_AS_MEMPCPY
-	add	%rdx, %rax
+	add	%RDX_LP, %RAX_LP
+#endif
+
+#ifdef __ILP32__
+	/* Clear the upper 32 bits.  */
+	mov	%edx, %edx
 #endif
 
 #ifdef USE_AS_MEMMOVE
diff --git a/sysdeps/x86_64/multiarch/memcpy-ssse3.S b/sysdeps/x86_64/multiarch/memcpy-ssse3.S
index 5dd209034b..366626f33a 100644
--- a/sysdeps/x86_64/multiarch/memcpy-ssse3.S
+++ b/sysdeps/x86_64/multiarch/memcpy-ssse3.S
@@ -45,28 +45,33 @@
 	.section .text.ssse3,"ax",@progbits
 #if !defined USE_AS_MEMPCPY && !defined USE_AS_MEMMOVE
 ENTRY (MEMPCPY_CHK)
-	cmpq	%rdx, %rcx
+	cmp	%RDX_LP, %RCX_LP
 	jb	HIDDEN_JUMPTARGET (__chk_fail)
 END (MEMPCPY_CHK)
 
 ENTRY (MEMPCPY)
-	movq	%rdi, %rax
-	addq	%rdx, %rax
+	mov	%RDI_LP, %RAX_LP
+	add	%RDX_LP, %RAX_LP
 	jmp	L(start)
 END (MEMPCPY)
 #endif
 
 #if !defined USE_AS_BCOPY
 ENTRY (MEMCPY_CHK)
-	cmpq	%rdx, %rcx
+	cmp	%RDX_LP, %RCX_LP
 	jb	HIDDEN_JUMPTARGET (__chk_fail)
 END (MEMCPY_CHK)
 #endif
 
 ENTRY (MEMCPY)
-	mov	%rdi, %rax
+	mov	%RDI_LP, %RAX_LP
 #ifdef USE_AS_MEMPCPY
-	add	%rdx, %rax
+	add	%RDX_LP, %RAX_LP
+#endif
+
+#ifdef __ILP32__
+	/* Clear the upper 32 bits.  */
+	mov	%edx, %edx
 #endif
 
 #ifdef USE_AS_MEMMOVE
diff --git a/sysdeps/x86_64/multiarch/memmove-avx512-no-vzeroupper.S b/sysdeps/x86_64/multiarch/memmove-avx512-no-vzeroupper.S
index 23c0f7a9ed..6ca2bbc91a 100644
--- a/sysdeps/x86_64/multiarch/memmove-avx512-no-vzeroupper.S
+++ b/sysdeps/x86_64/multiarch/memmove-avx512-no-vzeroupper.S
@@ -24,27 +24,31 @@
 
 	.section .text.avx512,"ax",@progbits
 ENTRY (__mempcpy_chk_avx512_no_vzeroupper)
-	cmpq	%rdx, %rcx
+	cmp	%RDX_LP, %RCX_LP
 	jb	HIDDEN_JUMPTARGET (__chk_fail)
 END (__mempcpy_chk_avx512_no_vzeroupper)
 
 ENTRY (__mempcpy_avx512_no_vzeroupper)
-	movq	%rdi, %rax
-	addq	%rdx, %rax
+	mov	%RDI_LP, %RAX_LP
+	add	%RDX_LP, %RAX_LP
 	jmp	L(start)
 END (__mempcpy_avx512_no_vzeroupper)
 
 ENTRY (__memmove_chk_avx512_no_vzeroupper)
-	cmpq	%rdx, %rcx
+	cmp	%RDX_LP, %RCX_LP
 	jb	HIDDEN_JUMPTARGET (__chk_fail)
 END (__memmove_chk_avx512_no_vzeroupper)
 
 ENTRY (__memmove_avx512_no_vzeroupper)
-	mov	%rdi, %rax
+	mov	%RDI_LP, %RAX_LP
 # ifdef USE_AS_MEMPCPY
-	add	%rdx, %rax
+	add	%RDX_LP, %RAX_LP
 # endif
 L(start):
+# ifdef __ILP32__
+	/* Clear the upper 32 bits.  */
+	mov	%edx, %edx
+# endif
 	lea	(%rsi, %rdx), %rcx
 	lea	(%rdi, %rdx), %r9
 	cmp	$512, %rdx
@@ -336,6 +340,7 @@ L(preloop_large):
 	vmovups	(%rsi), %zmm4
 	vmovups	0x40(%rsi), %zmm5
 
+	mov	%rdi, %r11
 /* Align destination for access with non-temporal stores in the loop.  */
 	mov	%rdi, %r8
 	and	$-0x80, %rdi
@@ -366,8 +371,8 @@ L(gobble_256bytes_nt_loop):
 	cmp	$256, %rdx
 	ja	L(gobble_256bytes_nt_loop)
 	sfence
-	vmovups	%zmm4, (%rax)
-	vmovups	%zmm5, 0x40(%rax)
+	vmovups	%zmm4, (%r11)
+	vmovups	%zmm5, 0x40(%r11)
 	jmp	L(check)
 
 L(preloop_large_bkw):
diff --git a/sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S b/sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
index cbd0d077cf..be2cd1526a 100644
--- a/sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
+++ b/sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
@@ -107,20 +107,20 @@
 	.section SECTION(.text),"ax",@progbits
 #if defined SHARED && IS_IN (libc)
 ENTRY (MEMMOVE_CHK_SYMBOL (__mempcpy_chk, unaligned))
-	cmpq	%rdx, %rcx
+	cmp	%RDX_LP, %RCX_LP
 	jb	HIDDEN_JUMPTARGET (__chk_fail)
 END (MEMMOVE_CHK_SYMBOL (__mempcpy_chk, unaligned))
 #endif
 
 ENTRY (MEMPCPY_SYMBOL (__mempcpy, unaligned))
-	movq	%rdi, %rax
-	addq	%rdx, %rax
+	mov	%RDI_LP, %RAX_LP
+	add	%RDX_LP, %RAX_LP
 	jmp	L(start)
 END (MEMPCPY_SYMBOL (__mempcpy, unaligned))
 
 #if defined SHARED && IS_IN (libc)
 ENTRY (MEMMOVE_CHK_SYMBOL (__memmove_chk, unaligned))
-	cmpq	%rdx, %rcx
+	cmp	%RDX_LP, %RCX_LP
 	jb	HIDDEN_JUMPTARGET (__chk_fail)
 END (MEMMOVE_CHK_SYMBOL (__memmove_chk, unaligned))
 #endif
@@ -128,9 +128,13 @@ END (MEMMOVE_CHK_SYMBOL (__memmove_chk, unaligned))
 ENTRY (MEMMOVE_SYMBOL (__memmove, unaligned))
 	movq	%rdi, %rax
 L(start):
-	cmpq	$VEC_SIZE, %rdx
+# ifdef __ILP32__
+	/* Clear the upper 32 bits.  */
+	movl	%edx, %edx
+# endif
+	cmp	$VEC_SIZE, %RDX_LP
 	jb	L(less_vec)
-	cmpq	$(VEC_SIZE * 2), %rdx
+	cmp	$(VEC_SIZE * 2), %RDX_LP
 	ja	L(more_2x_vec)
 #if !defined USE_MULTIARCH || !IS_IN (libc)
 L(last_2x_vec):
@@ -150,32 +154,32 @@ END (MEMMOVE_SYMBOL (__memmove, unaligned))
 
 # if VEC_SIZE == 16
 ENTRY (__mempcpy_chk_erms)
-	cmpq	%rdx, %rcx
+	cmp	%RDX_LP, %RCX_LP
 	jb	HIDDEN_JUMPTARGET (__chk_fail)
 END (__mempcpy_chk_erms)
 
 /* Only used to measure performance of REP MOVSB.  */
 ENTRY (__mempcpy_erms)
-	movq	%rdi, %rax
-	addq	%rdx, %rax
+	mov	%RDI_LP, %RAX_LP
+	add	%RDX_LP, %RAX_LP
 	jmp	L(start_movsb)
 END (__mempcpy_erms)
 
 ENTRY (__memmove_chk_erms)
-	cmpq	%rdx, %rcx
+	cmp	%RDX_LP, %RCX_LP
 	jb	HIDDEN_JUMPTARGET (__chk_fail)
 END (__memmove_chk_erms)
 
 ENTRY (__memmove_erms)
 	movq	%rdi, %rax
 L(start_movsb):
-	movq	%rdx, %rcx
-	cmpq	%rsi, %rdi
+	mov	%RDX_LP, %RCX_LP
+	cmp	%RSI_LP, %RDI_LP
 	jb	1f
 	/* Source == destination is less common.  */
 	je	2f
-	leaq	(%rsi,%rcx), %rdx
-	cmpq	%rdx, %rdi
+	lea	(%rsi,%rcx), %RDX_LP
+	cmp	%RDX_LP, %RDI_LP
 	jb	L(movsb_backward)
 1:
 	rep movsb
@@ -195,20 +199,20 @@ strong_alias (__memmove_chk_erms, __memcpy_chk_erms)
 
 # ifdef SHARED
 ENTRY (MEMMOVE_CHK_SYMBOL (__mempcpy_chk, unaligned_erms))
-	cmpq	%rdx, %rcx
+	cmp	%RDX_LP, %RCX_LP
 	jb	HIDDEN_JUMPTARGET (__chk_fail)
 END (MEMMOVE_CHK_SYMBOL (__mempcpy_chk, unaligned_erms))
 # endif
 
 ENTRY (MEMMOVE_SYMBOL (__mempcpy, unaligned_erms))
-	movq	%rdi, %rax
-	addq	%rdx, %rax
+	mov	%RDI_LP, %RAX_LP
+	add	%RDX_LP, %RAX_LP
 	jmp	L(start_erms)
 END (MEMMOVE_SYMBOL (__mempcpy, unaligned_erms))
 
 # ifdef SHARED
 ENTRY (MEMMOVE_CHK_SYMBOL (__memmove_chk, unaligned_erms))
-	cmpq	%rdx, %rcx
+	cmp	%RDX_LP, %RCX_LP
 	jb	HIDDEN_JUMPTARGET (__chk_fail)
 END (MEMMOVE_CHK_SYMBOL (__memmove_chk, unaligned_erms))
 # endif
@@ -216,9 +220,13 @@ END (MEMMOVE_CHK_SYMBOL (__memmove_chk, unaligned_erms))
 ENTRY (MEMMOVE_SYMBOL (__memmove, unaligned_erms))
 	movq	%rdi, %rax
 L(start_erms):
-	cmpq	$VEC_SIZE, %rdx
+# ifdef __ILP32__
+	/* Clear the upper 32 bits.  */
+	movl	%edx, %edx
+# endif
+	cmp	$VEC_SIZE, %RDX_LP
 	jb	L(less_vec)
-	cmpq	$(VEC_SIZE * 2), %rdx
+	cmp	$(VEC_SIZE * 2), %RDX_LP
 	ja	L(movsb_more_2x_vec)
 L(last_2x_vec):
 	/* From VEC and to 2 * VEC.  No branch when size == VEC_SIZE. */
@@ -245,7 +253,7 @@ L(movsb):
 # endif
 	jb	L(more_8x_vec_backward)
 1:
-	movq	%rdx, %rcx
+	mov	%RDX_LP, %RCX_LP
 	rep movsb
 L(nop):
 	ret
diff --git a/sysdeps/x86_64/multiarch/memrchr-avx2.S b/sysdeps/x86_64/multiarch/memrchr-avx2.S
index b41a58bcba..ce488dd9e8 100644
--- a/sysdeps/x86_64/multiarch/memrchr-avx2.S
+++ b/sysdeps/x86_64/multiarch/memrchr-avx2.S
@@ -32,10 +32,10 @@ ENTRY (__memrchr_avx2)
 	vmovd	%esi, %xmm0
 	vpbroadcastb %xmm0, %ymm0
 
-	subq	$VEC_SIZE, %rdx
+	sub	$VEC_SIZE, %RDX_LP
 	jbe	L(last_vec_or_less)
 
-	addq	%rdx, %rdi
+	add	%RDX_LP, %RDI_LP
 
 	/* Check the last VEC_SIZE bytes.  */
 	vpcmpeqb (%rdi), %ymm0, %ymm1
diff --git a/sysdeps/x86_64/multiarch/memset-avx512-no-vzeroupper.S b/sysdeps/x86_64/multiarch/memset-avx512-no-vzeroupper.S
index 689cc1199c..99e255195a 100644
--- a/sysdeps/x86_64/multiarch/memset-avx512-no-vzeroupper.S
+++ b/sysdeps/x86_64/multiarch/memset-avx512-no-vzeroupper.S
@@ -29,12 +29,16 @@
 	.section .text.avx512,"ax",@progbits
 #if defined PIC
 ENTRY (MEMSET_CHK)
-	cmpq	%rdx, %rcx
+	cmp	%RDX_LP, %RCX_LP
 	jb	HIDDEN_JUMPTARGET (__chk_fail)
 END (MEMSET_CHK)
 #endif
 
 ENTRY (MEMSET)
+# ifdef __ILP32__
+	/* Clear the upper 32 bits.  */
+	mov	%edx, %edx
+# endif
 	vpxor	%xmm0, %xmm0, %xmm0
 	vmovd	%esi, %xmm1
 	lea	(%rdi, %rdx), %rsi
diff --git a/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S b/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
index 14d1aa5beb..535e86fb90 100644
--- a/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
+++ b/sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
@@ -75,8 +75,8 @@
 	.section SECTION(.text),"ax",@progbits
 #if VEC_SIZE == 16 && IS_IN (libc)
 ENTRY (__bzero)
-	movq	%rdi, %rax /* Set return value.  */
-	movq	%rsi, %rdx /* Set n.  */
+	mov	%RDI_LP, %RAX_LP /* Set return value.  */
+	mov	%RSI_LP, %RDX_LP /* Set n.  */
 	pxor	%xmm0, %xmm0
 	jmp	L(entry_from_bzero)
 END (__bzero)
@@ -86,13 +86,13 @@ weak_alias (__bzero, bzero)
 #if IS_IN (libc)
 # if defined SHARED
 ENTRY_CHK (WMEMSET_CHK_SYMBOL (__wmemset_chk, unaligned))
-	cmpq	%rdx, %rcx
+	cmp	%RDX_LP, %RCX_LP
 	jb	HIDDEN_JUMPTARGET (__chk_fail)
 END_CHK (WMEMSET_CHK_SYMBOL (__wmemset_chk, unaligned))
 # endif
 
 ENTRY (WMEMSET_SYMBOL (__wmemset, unaligned))
-	shlq	$2, %rdx
+	shl	$2, %RDX_LP
 	WMEMSET_VDUP_TO_VEC0_AND_SET_RETURN (%esi, %rdi)
 	jmp	L(entry_from_bzero)
 END (WMEMSET_SYMBOL (__wmemset, unaligned))
@@ -100,13 +100,17 @@ END (WMEMSET_SYMBOL (__wmemset, unaligned))
 
 #if defined SHARED && IS_IN (libc)
 ENTRY_CHK (MEMSET_CHK_SYMBOL (__memset_chk, unaligned))
-	cmpq	%rdx, %rcx
+	cmp	%RDX_LP, %RCX_LP
 	jb	HIDDEN_JUMPTARGET (__chk_fail)
 END_CHK (MEMSET_CHK_SYMBOL (__memset_chk, unaligned))
 #endif
 
 ENTRY (MEMSET_SYMBOL (__memset, unaligned))
 	MEMSET_VDUP_TO_VEC0_AND_SET_RETURN (%esi, %rdi)
+# ifdef __ILP32__
+	/* Clear the upper 32 bits.  */
+	mov	%edx, %edx
+# endif
 L(entry_from_bzero):
 	cmpq	$VEC_SIZE, %rdx
 	jb	L(less_vec)
@@ -122,7 +126,7 @@ END (MEMSET_SYMBOL (__memset, unaligned))
 
 # if VEC_SIZE == 16
 ENTRY (__memset_chk_erms)
-	cmpq	%rdx, %rcx
+	cmp	%RDX_LP, %RCX_LP
 	jb	HIDDEN_JUMPTARGET (__chk_fail)
 END (__memset_chk_erms)
 
@@ -135,11 +139,11 @@ ENTRY (MEMSET_SYMBOL (__memset, erms))
 L(stosb):
 	/* Issue vzeroupper before rep stosb.  */
 	VZEROUPPER
-	movq	%rdx, %rcx
+	mov	%RDX_LP, %RCX_LP
 	movzbl	%sil, %eax
-	movq	%rdi, %rdx
+	mov	%RDI_LP, %RDX_LP
 	rep stosb
-	movq	%rdx, %rax
+	mov	%RDX_LP, %RAX_LP
 	ret
 # if VEC_SIZE == 16
 END (__memset_erms)
@@ -149,16 +153,20 @@ END (MEMSET_SYMBOL (__memset, erms))
 
 # if defined SHARED && IS_IN (libc)
 ENTRY_CHK (MEMSET_CHK_SYMBOL (__memset_chk, unaligned_erms))
-	cmpq	%rdx, %rcx
+	cmp	%RDX_LP, %RCX_LP
 	jb	HIDDEN_JUMPTARGET (__chk_fail)
 END_CHK (MEMSET_CHK_SYMBOL (__memset_chk, unaligned_erms))
 # endif
 
 ENTRY (MEMSET_SYMBOL (__memset, unaligned_erms))
 	MEMSET_VDUP_TO_VEC0_AND_SET_RETURN (%esi, %rdi)
-	cmpq	$VEC_SIZE, %rdx
+# ifdef __ILP32__
+	/* Clear the upper 32 bits.  */
+	mov	%edx, %edx
+# endif
+	cmp	$VEC_SIZE, %RDX_LP
 	jb	L(less_vec)
-	cmpq	$(VEC_SIZE * 2), %rdx
+	cmp	$(VEC_SIZE * 2), %RDX_LP
 	ja	L(stosb_more_2x_vec)
 	/* From VEC and to 2 * VEC.  No branch when size == VEC_SIZE.  */
 	VMOVU	%VEC(0), -VEC_SIZE(%rdi,%rdx)
diff --git a/sysdeps/x86_64/multiarch/strcmp-sse42.S b/sysdeps/x86_64/multiarch/strcmp-sse42.S
index 6fa0c2c7d2..4e099b56cf 100644
--- a/sysdeps/x86_64/multiarch/strcmp-sse42.S
+++ b/sysdeps/x86_64/multiarch/strcmp-sse42.S
@@ -155,11 +155,11 @@ STRCMP_SSE42:
 #endif
 
 #if defined USE_AS_STRNCMP || defined USE_AS_STRNCASECMP_L
-	test	%rdx, %rdx
+	test	%RDX_LP, %RDX_LP
 	je	LABEL(strcmp_exitz)
-	cmp	$1, %rdx
+	cmp	$1, %RDX_LP
 	je	LABEL(Byte0)
-	mov	%rdx, %r11
+	mov	%RDX_LP, %R11_LP
 #endif
 	mov	%esi, %ecx
 	mov	%edi, %eax
diff --git a/sysdeps/x86_64/multiarch/strcpy-sse2-unaligned.S b/sysdeps/x86_64/multiarch/strcpy-sse2-unaligned.S
index 56b748eb2c..59c742d68b 100644
--- a/sysdeps/x86_64/multiarch/strcpy-sse2-unaligned.S
+++ b/sysdeps/x86_64/multiarch/strcpy-sse2-unaligned.S
@@ -40,8 +40,8 @@
 .text
 ENTRY (STRCPY)
 #  ifdef USE_AS_STRNCPY
-	mov	%rdx, %r8
-	test	%r8, %r8
+	mov	%RDX_LP, %R8_LP
+	test	%R8_LP, %R8_LP
 	jz	L(ExitZero)
 #  endif
 	mov	%rsi, %rcx
diff --git a/sysdeps/x86_64/multiarch/strcpy-ssse3.S b/sysdeps/x86_64/multiarch/strcpy-ssse3.S
index 9858d0c4d5..0a62814a06 100644
--- a/sysdeps/x86_64/multiarch/strcpy-ssse3.S
+++ b/sysdeps/x86_64/multiarch/strcpy-ssse3.S
@@ -31,13 +31,13 @@ ENTRY (STRCPY)
 
 	mov	%rsi, %rcx
 #  ifdef USE_AS_STRNCPY
-	mov	%rdx, %r8
+	mov	%RDX_LP, %R8_LP
 #  endif
 	mov	%rdi, %rdx
 #  ifdef USE_AS_STRNCPY
-	test	%r8, %r8
+	test	%R8_LP, %R8_LP
 	jz	L(Exit0)
-	cmp	$8, %r8
+	cmp	$8, %R8_LP
 	jbe	L(StrncpyExit8Bytes)
 # endif
 	cmpb	$0, (%rcx)
diff --git a/sysdeps/x86_64/multiarch/strlen-avx2.S b/sysdeps/x86_64/multiarch/strlen-avx2.S
index 85d7259746..0d0f9c8d5c 100644
--- a/sysdeps/x86_64/multiarch/strlen-avx2.S
+++ b/sysdeps/x86_64/multiarch/strlen-avx2.S
@@ -42,12 +42,15 @@
 ENTRY (STRLEN)
 # ifdef USE_AS_STRNLEN
 	/* Check for zero length.  */
-	testq	%rsi, %rsi
+	test	%RSI_LP, %RSI_LP
 	jz	L(zero)
 #  ifdef USE_AS_WCSLEN
-	shl	$2, %rsi
+	shl	$2, %RSI_LP
+#  elif defined __ILP32__
+	/* Clear the upper 32 bits.  */
+	movl	%esi, %esi
 #  endif
-	movq	%rsi, %r8
+	mov	%RSI_LP, %R8_LP
 # endif
 	movl	%edi, %ecx
 	movq	%rdi, %rdx
diff --git a/sysdeps/x86_64/multiarch/strncmp-sse2.S b/sysdeps/x86_64/multiarch/strncmp-sse2.S
index cc5252d826..a5ecb82b13 100644
--- a/sysdeps/x86_64/multiarch/strncmp-sse2.S
+++ b/sysdeps/x86_64/multiarch/strncmp-sse2.S
@@ -18,10 +18,13 @@
 
 #include <sysdep.h>
 
-#define STRCMP	__strncmp_sse2
-
-#undef libc_hidden_builtin_def
-#define libc_hidden_builtin_def(strcmp)
+#if IS_IN (libc)
+# define STRCMP __strncmp_sse2
+# undef libc_hidden_builtin_def
+# define libc_hidden_builtin_def(strcmp)
+#else
+# define STRCMP strncmp
+#endif
 
 #define USE_AS_STRNCMP
 #include <sysdeps/x86_64/strcmp.S>
diff --git a/sysdeps/x86_64/strcmp.S b/sysdeps/x86_64/strcmp.S
index de54fce647..0b16977ce6 100644
--- a/sysdeps/x86_64/strcmp.S
+++ b/sysdeps/x86_64/strcmp.S
@@ -135,11 +135,11 @@ ENTRY (STRCMP)
  * This implementation uses SSE to compare up to 16 bytes at a time.
  */
 #if defined USE_AS_STRNCMP || defined USE_AS_STRNCASECMP_L
-	test	%rdx, %rdx
+	test	%RDX_LP, %RDX_LP
 	je	LABEL(strcmp_exitz)
-	cmp	$1, %rdx
+	cmp	$1, %RDX_LP
 	je	LABEL(Byte0)
-	mov	%rdx, %r11
+	mov	%RDX_LP, %R11_LP
 #endif
 	mov	%esi, %ecx
 	mov	%edi, %eax
diff --git a/sysdeps/x86_64/strlen.S b/sysdeps/x86_64/strlen.S
index 01cb5fa846..f845f3d46e 100644
--- a/sysdeps/x86_64/strlen.S
+++ b/sysdeps/x86_64/strlen.S
@@ -59,21 +59,21 @@ ENTRY(strlen)
 
 #ifdef AS_STRNLEN
 /* Do not read anything when n==0.  */
-	test	%rsi, %rsi
+	test	%RSI_LP, %RSI_LP
 	jne	L(n_nonzero)
 	xor	%rax, %rax
 	ret
 L(n_nonzero):
 # ifdef AS_WCSLEN
-	shlq	$2, %rsi
+	shl	$2, %RSI_LP
 # endif
 
 /* Initialize long lived registers.  */
 
-	add	%rdi, %rsi
-	mov	%rsi, %r10
-	and	$-64, %r10
-	mov	%rsi, %r11
+	add	%RDI_LP, %RSI_LP
+	mov	%RSI_LP, %R10_LP
+	and	$-64, %R10_LP
+	mov	%RSI_LP, %R11_LP
 #endif
 
 	pxor	%xmm0, %xmm0
diff --git a/sysdeps/x86_64/x32/Makefile b/sysdeps/x86_64/x32/Makefile
index f2ebc24fb0..8748956563 100644
--- a/sysdeps/x86_64/x32/Makefile
+++ b/sysdeps/x86_64/x32/Makefile
@@ -4,3 +4,15 @@ ifeq ($(subdir),math)
 # 64-bit llround.  Add -fno-builtin-lround to silence the compiler.
 CFLAGS-s_llround.c += -fno-builtin-lround
 endif
+
+ifeq ($(subdir),string)
+tests += tst-size_t-memchr tst-size_t-memcmp tst-size_t-memcpy \
+	 tst-size_t-memrchr tst-size_t-memset tst-size_t-strncasecmp \
+	 tst-size_t-strncmp tst-size_t-strncpy tst-size_t-strnlen \
+	 tst-size_t-memcmp-2
+endif
+
+ifeq ($(subdir),wcsmbs)
+tests += tst-size_t-wmemchr tst-size_t-wmemcmp tst-size_t-wmemset \
+	 tst-size_t-wcsncmp tst-size_t-wcsnlen
+endif
diff --git a/sysdeps/x86_64/x32/test-size_t.h b/sysdeps/x86_64/x32/test-size_t.h
new file mode 100644
index 0000000000..78a940863e
--- /dev/null
+++ b/sysdeps/x86_64/x32/test-size_t.h
@@ -0,0 +1,35 @@
+/* Test string/memory functions with size_t in the lower 32 bits of
+   64-bit register.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define TEST_MAIN
+#include <string/test-string.h>
+
+/* On x32, parameter_t may be passed in a 64-bit register with the LEN
+   field in the lower 32 bits.  When the LEN field of 64-bit register
+   is passed to string/memory function as the size_t parameter, only
+   the lower 32 bits can be used.  */
+typedef struct
+{
+  union
+    {
+      size_t len;
+      void (*fn) (void);
+    };
+  void *p;
+} parameter_t;
diff --git a/sysdeps/x86_64/x32/tst-size_t-memchr.c b/sysdeps/x86_64/x32/tst-size_t-memchr.c
new file mode 100644
index 0000000000..29a3daf102
--- /dev/null
+++ b/sysdeps/x86_64/x32/tst-size_t-memchr.c
@@ -0,0 +1,72 @@
+/* Test memchr with size_t in the lower 32 bits of 64-bit register.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef WIDE
+# define TEST_NAME "memchr"
+#else
+# define TEST_NAME "wmemchr"
+#endif /* WIDE */
+#include "test-size_t.h"
+
+#ifndef WIDE
+# define MEMCHR memchr
+# define CHAR char
+# define UCHAR unsigned char
+#else
+# include <wchar.h>
+# define MEMCHR wmemchr
+# define CHAR wchar_t
+# define UCHAR wchar_t
+#endif /* WIDE */
+
+IMPL (MEMCHR, 1)
+
+typedef CHAR * (*proto_t) (const CHAR*, int, size_t);
+
+static CHAR *
+__attribute__ ((noinline, noclone))
+do_memchr (parameter_t a, parameter_t b)
+{
+  return CALL (&b, a.p, (uintptr_t) b.p, a.len);
+}
+
+static int
+test_main (void)
+{
+  test_init ();
+
+  parameter_t src = { { page_size / sizeof (CHAR) }, buf2 };
+  parameter_t c = { { 0 }, (void *) (uintptr_t) 0x12 };
+
+  int ret = 0;
+  FOR_EACH_IMPL (impl, 0)
+    {
+      c.fn = impl->fn;
+      CHAR *res = do_memchr (src, c);
+      if (res)
+	{
+	  error (0, 0, "Wrong result in function %s: %p != NULL",
+		 impl->name, res);
+	  ret = 1;
+	}
+    }
+
+  return ret ? EXIT_FAILURE : EXIT_SUCCESS;
+}
+
+#include <support/test-driver.c>
diff --git a/sysdeps/x86_64/x32/tst-size_t-memcmp-2.c b/sysdeps/x86_64/x32/tst-size_t-memcmp-2.c
new file mode 100644
index 0000000000..d8ae1a0813
--- /dev/null
+++ b/sysdeps/x86_64/x32/tst-size_t-memcmp-2.c
@@ -0,0 +1,79 @@
+/* Test memcmp with size_t in the lower 32 bits of 64-bit register.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define TEST_MAIN
+#ifdef WIDE
+# define TEST_NAME "wmemcmp"
+#else
+# define TEST_NAME "memcmp"
+#endif
+
+#include "test-size_t.h"
+
+#ifdef WIDE
+# include <inttypes.h>
+# include <wchar.h>
+
+# define MEMCMP wmemcmp
+# define CHAR wchar_t
+#else
+# define MEMCMP memcmp
+# define CHAR char
+#endif
+
+IMPL (MEMCMP, 1)
+
+typedef int (*proto_t) (const CHAR *, const CHAR *, size_t);
+
+static int
+__attribute__ ((noinline, noclone))
+do_memcmp (parameter_t a, parameter_t b)
+{
+  return CALL (&b, a.p, b.p, a.len);
+}
+
+static int
+test_main (void)
+{
+  test_init ();
+
+  parameter_t dest = { { page_size / sizeof (CHAR) }, buf1 };
+  parameter_t src = { { 0 }, buf2 };
+
+  memcpy (buf1, buf2, page_size);
+
+  CHAR *p = (CHAR *) buf1;
+  p[page_size / sizeof (CHAR) - 1] = (CHAR) 1;
+
+  int ret = 0;
+  FOR_EACH_IMPL (impl, 0)
+    {
+      src.fn = impl->fn;
+      int res = do_memcmp (dest, src);
+      if (res >= 0)
+	{
+	  error (0, 0, "Wrong result in function %s: %i >= 0",
+		 impl->name, res);
+	  ret = 1;
+	}
+    }
+
+  return ret ? EXIT_FAILURE : EXIT_SUCCESS;
+}
+
+#include <support/test-driver.c>
diff --git a/sysdeps/x86_64/x32/tst-size_t-memcmp.c b/sysdeps/x86_64/x32/tst-size_t-memcmp.c
new file mode 100644
index 0000000000..9bd6fdb45a
--- /dev/null
+++ b/sysdeps/x86_64/x32/tst-size_t-memcmp.c
@@ -0,0 +1,76 @@
+/* Test memcmp with size_t in the lower 32 bits of 64-bit register.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define TEST_MAIN
+#ifdef WIDE
+# define TEST_NAME "wmemcmp"
+#else
+# define TEST_NAME "memcmp"
+#endif
+
+#include "test-size_t.h"
+
+#ifdef WIDE
+# include <inttypes.h>
+# include <wchar.h>
+
+# define MEMCMP wmemcmp
+# define CHAR wchar_t
+#else
+# define MEMCMP memcmp
+# define CHAR char
+#endif
+
+IMPL (MEMCMP, 1)
+
+typedef int (*proto_t) (const CHAR *, const CHAR *, size_t);
+
+static int
+__attribute__ ((noinline, noclone))
+do_memcmp (parameter_t a, parameter_t b)
+{
+  return CALL (&b, a.p, b.p, a.len);
+}
+
+static int
+test_main (void)
+{
+  test_init ();
+
+  parameter_t dest = { { page_size / sizeof (CHAR) }, buf1 };
+  parameter_t src = { { 0 }, buf2 };
+
+  memcpy (buf1, buf2, page_size);
+
+  int ret = 0;
+  FOR_EACH_IMPL (impl, 0)
+    {
+      src.fn = impl->fn;
+      int res = do_memcmp (dest, src);
+      if (res)
+	{
+	  error (0, 0, "Wrong result in function %s: %i != 0",
+		 impl->name, res);
+	  ret = 1;
+	}
+    }
+
+  return ret ? EXIT_FAILURE : EXIT_SUCCESS;
+}
+
+#include <support/test-driver.c>
diff --git a/sysdeps/x86_64/x32/tst-size_t-memcpy.c b/sysdeps/x86_64/x32/tst-size_t-memcpy.c
new file mode 100644
index 0000000000..66b71e1749
--- /dev/null
+++ b/sysdeps/x86_64/x32/tst-size_t-memcpy.c
@@ -0,0 +1,58 @@
+/* Test memcpy with size_t in the lower 32 bits of 64-bit register.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define TEST_NAME "memcpy"
+#include "test-size_t.h"
+
+IMPL (memcpy, 1)
+
+typedef void *(*proto_t) (void *, const void *, size_t);
+
+static void *
+__attribute__ ((noinline, noclone))
+do_memcpy (parameter_t a, parameter_t b)
+{
+  return CALL (&b, a.p, b.p, a.len);
+}
+
+static int
+test_main (void)
+{
+  test_init ();
+
+  parameter_t dest = { { page_size }, buf1 };
+  parameter_t src = { { 0 }, buf2 };
+
+  int ret = 0;
+  FOR_EACH_IMPL (impl, 0)
+    {
+      src.fn = impl->fn;
+      do_memcpy (dest, src);
+      int res = memcmp (dest.p, src.p, dest.len);
+      if (res)
+	{
+	  error (0, 0, "Wrong result in function %s: %i != 0",
+		 impl->name, res);
+	  ret = 1;
+	}
+    }
+
+  return ret ? EXIT_FAILURE : EXIT_SUCCESS;
+}
+
+#include <support/test-driver.c>
diff --git a/sysdeps/x86_64/x32/tst-size_t-memrchr.c b/sysdeps/x86_64/x32/tst-size_t-memrchr.c
new file mode 100644
index 0000000000..c83699c097
--- /dev/null
+++ b/sysdeps/x86_64/x32/tst-size_t-memrchr.c
@@ -0,0 +1,57 @@
+/* Test memrchr with size_t in the lower 32 bits of 64-bit register.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define TEST_NAME "memrchr"
+#include "test-size_t.h"
+
+IMPL (memchr, 1)
+
+typedef void * (*proto_t) (const void *, int, size_t);
+
+static void *
+__attribute__ ((noinline, noclone))
+do_memrchr (parameter_t a, parameter_t b)
+{
+  return CALL (&b, a.p, (uintptr_t) b.p, a.len);
+}
+
+static int
+test_main (void)
+{
+  test_init ();
+
+  parameter_t src = { { page_size }, buf2 };
+  parameter_t c = { { 0 }, (void *) (uintptr_t) 0x12 };
+
+  int ret = 0;
+  FOR_EACH_IMPL (impl, 0)
+    {
+      c.fn = impl->fn;
+      void * res = do_memrchr (src, c);
+      if (res)
+	{
+	  error (0, 0, "Wrong result in function %s: %p != NULL",
+		 impl->name, res);
+	  ret = 1;
+	}
+    }
+
+  return ret ? EXIT_FAILURE : EXIT_SUCCESS;
+}
+
+#include <support/test-driver.c>
diff --git a/sysdeps/x86_64/x32/tst-size_t-memset.c b/sysdeps/x86_64/x32/tst-size_t-memset.c
new file mode 100644
index 0000000000..2c367af6cd
--- /dev/null
+++ b/sysdeps/x86_64/x32/tst-size_t-memset.c
@@ -0,0 +1,73 @@
+/* Test memset with size_t in the lower 32 bits of 64-bit register.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifdef WIDE
+# define TEST_NAME "wmemset"
+#else
+# define TEST_NAME "memset"
+#endif /* WIDE */
+
+#include "test-size_t.h"
+
+#ifdef WIDE
+# include <wchar.h>
+# define MEMSET wmemset
+# define CHAR wchar_t
+#else
+# define MEMSET memset
+# define CHAR char
+#endif /* WIDE */
+
+IMPL (MEMSET, 1)
+
+typedef CHAR *(*proto_t) (CHAR *, int, size_t);
+
+static void *
+__attribute__ ((noinline, noclone))
+do_memset (parameter_t a, parameter_t b)
+{
+  return CALL (&b, a.p, (uintptr_t) b.p, a.len);
+}
+
+static int
+test_main (void)
+{
+  test_init ();
+
+  CHAR ch = 0x23;
+  parameter_t src = { { page_size / sizeof (CHAR) }, buf2 };
+  parameter_t c = { { 0 }, (void *) (uintptr_t) ch };
+
+  int ret = 0;
+  FOR_EACH_IMPL (impl, 0)
+    {
+      c.fn = impl->fn;
+      CHAR *p = (CHAR *) do_memset (src, c);
+      size_t i;
+      for (i = 0; i < src.len; i++)
+	if (p[i] != ch)
+	  {
+	    error (0, 0, "Wrong result in function %s", impl->name);
+	    ret = 1;
+	  }
+    }
+
+  return ret ? EXIT_FAILURE : EXIT_SUCCESS;
+}
+
+#include <support/test-driver.c>
diff --git a/sysdeps/x86_64/x32/tst-size_t-strncasecmp.c b/sysdeps/x86_64/x32/tst-size_t-strncasecmp.c
new file mode 100644
index 0000000000..862335937b
--- /dev/null
+++ b/sysdeps/x86_64/x32/tst-size_t-strncasecmp.c
@@ -0,0 +1,59 @@
+/* Test strncaecmp with size_t in the lower 32 bits of 64-bit register.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define TEST_NAME "strncasecmp"
+#include "test-size_t.h"
+
+IMPL (strncasecmp, 1)
+
+typedef int (*proto_t) (const char *, const char *, size_t);
+
+static int
+__attribute__ ((noinline, noclone))
+do_strncasecmp (parameter_t a, parameter_t b)
+{
+  return CALL (&b, a.p, b.p, a.len);
+}
+
+static int
+test_main (void)
+{
+  test_init ();
+
+  parameter_t dest = { { page_size }, buf1 };
+  parameter_t src = { { 0 }, buf2 };
+
+  strncpy ((char *) buf1, (const char *) buf2, page_size);
+
+  int ret = 0;
+  FOR_EACH_IMPL (impl, 0)
+    {
+      src.fn = impl->fn;
+      int res = do_strncasecmp (dest, src);
+      if (res)
+	{
+	  error (0, 0, "Wrong result in function %s: %i != 0",
+		 impl->name, res);
+	  ret = 1;
+	}
+    }
+
+  return ret ? EXIT_FAILURE : EXIT_SUCCESS;
+}
+
+#include <support/test-driver.c>
diff --git a/sysdeps/x86_64/x32/tst-size_t-strncmp.c b/sysdeps/x86_64/x32/tst-size_t-strncmp.c
new file mode 100644
index 0000000000..54e6bd83ef
--- /dev/null
+++ b/sysdeps/x86_64/x32/tst-size_t-strncmp.c
@@ -0,0 +1,78 @@
+/* Test strncmp with size_t in the lower 32 bits of 64-bit register.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifdef WIDE
+# define TEST_NAME "wcsncmp"
+#else
+# define TEST_NAME "strncmp"
+#endif
+
+#include "test-size_t.h"
+
+#ifdef WIDE
+# include <wchar.h>
+
+# define STRNCMP wcsncmp
+# define STRNCPY wcsncpy
+# define CHAR wchar_t
+#else
+# define STRNCMP strncmp
+# define STRNCPY strncpy
+# define CHAR char
+#endif
+
+IMPL (STRNCMP, 1)
+
+typedef int (*proto_t) (const CHAR *, const CHAR *, size_t);
+
+
+static int
+__attribute__ ((noinline, noclone))
+do_strncmp (parameter_t a, parameter_t b)
+{
+  return CALL (&b, a.p, b.p, a.len);
+}
+
+static int
+test_main (void)
+{
+  test_init ();
+
+  size_t size = page_size / sizeof (CHAR);
+  parameter_t dest = { { size }, buf1 };
+  parameter_t src = { { 0 }, buf2 };
+
+  STRNCPY ((CHAR *) buf1, (const CHAR *) buf2, size);
+
+  int ret = 0;
+  FOR_EACH_IMPL (impl, 0)
+    {
+      src.fn = impl->fn;
+      int res = do_strncmp (dest, src);
+      if (res)
+	{
+	  error (0, 0, "Wrong result in function %s: %i != 0",
+		 impl->name, res);
+	  ret = 1;
+	}
+    }
+
+  return ret ? EXIT_FAILURE : EXIT_SUCCESS;
+}
+
+#include <support/test-driver.c>
diff --git a/sysdeps/x86_64/x32/tst-size_t-strncpy.c b/sysdeps/x86_64/x32/tst-size_t-strncpy.c
new file mode 100644
index 0000000000..4dec71e6b3
--- /dev/null
+++ b/sysdeps/x86_64/x32/tst-size_t-strncpy.c
@@ -0,0 +1,58 @@
+/* Test strncpy with size_t in the lower 32 bits of 64-bit register.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define TEST_NAME "strncpy"
+#include "test-size_t.h"
+
+IMPL (strncpy, 1)
+
+typedef char *(*proto_t) (char *, const char*, size_t);
+
+static void *
+__attribute__ ((noinline, noclone))
+do_strncpy (parameter_t a, parameter_t b)
+{
+  return CALL (&b, a.p, b.p, a.len);
+}
+
+static int
+test_main (void)
+{
+  test_init ();
+
+  parameter_t dest = { { page_size }, buf1 };
+  parameter_t src = { { 0 }, buf2 };
+
+  int ret = 0;
+  FOR_EACH_IMPL (impl, 0)
+    {
+      src.fn = impl->fn;
+      do_strncpy (dest, src);
+      int res = strncmp (dest.p, src.p, dest.len);
+      if (res)
+	{
+	  error (0, 0, "Wrong result in function %s: %i != 0",
+		 impl->name, res);
+	  ret = 1;
+	}
+    }
+
+  return ret ? EXIT_FAILURE : EXIT_SUCCESS;
+}
+
+#include <support/test-driver.c>
diff --git a/sysdeps/x86_64/x32/tst-size_t-strnlen.c b/sysdeps/x86_64/x32/tst-size_t-strnlen.c
new file mode 100644
index 0000000000..690a4a8a31
--- /dev/null
+++ b/sysdeps/x86_64/x32/tst-size_t-strnlen.c
@@ -0,0 +1,72 @@
+/* Test strnlen with size_t in the lower 32 bits of 64-bit register.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifdef WIDE
+# define TEST_NAME "wcsnlen"
+#else
+# define TEST_NAME "strnlen"
+#endif /* WIDE */
+
+#include "test-size_t.h"
+
+#ifdef WIDE
+# include <wchar.h>
+# define STRNLEN wcsnlen
+# define CHAR wchar_t
+#else
+# define STRNLEN strnlen
+# define CHAR char
+#endif /* WIDE */
+
+IMPL (STRNLEN, 1)
+
+typedef size_t (*proto_t) (const CHAR *, size_t);
+
+static size_t
+__attribute__ ((noinline, noclone))
+do_strnlen (parameter_t a, parameter_t b)
+{
+  return CALL (&a, a.p, b.len);
+}
+
+static int
+test_main (void)
+{
+  test_init ();
+
+  size_t size = page_size / sizeof (CHAR);
+  parameter_t src = { { 0 }, buf2 };
+  parameter_t c = { { size }, (void *) (uintptr_t) 'a' };
+
+  int ret = 0;
+  FOR_EACH_IMPL (impl, 0)
+    {
+      src.fn = impl->fn;
+      size_t res = do_strnlen (src, c);
+      if (res != size)
+	{
+	  error (0, 0, "Wrong result in function %s: 0x%x != 0x%x",
+		 impl->name, res, size);
+	  ret = 1;
+	}
+    }
+
+  return ret ? EXIT_FAILURE : EXIT_SUCCESS;
+}
+
+#include <support/test-driver.c>
diff --git a/sysdeps/x86_64/x32/tst-size_t-wcsncmp.c b/sysdeps/x86_64/x32/tst-size_t-wcsncmp.c
new file mode 100644
index 0000000000..4829647c19
--- /dev/null
+++ b/sysdeps/x86_64/x32/tst-size_t-wcsncmp.c
@@ -0,0 +1,20 @@
+/* Test wcsncmp with size_t in the lower 32 bits of 64-bit register.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define WIDE 1
+#include "tst-size_t-strncmp.c"
diff --git a/sysdeps/x86_64/x32/tst-size_t-wcsnlen.c b/sysdeps/x86_64/x32/tst-size_t-wcsnlen.c
new file mode 100644
index 0000000000..093b4bbe1b
--- /dev/null
+++ b/sysdeps/x86_64/x32/tst-size_t-wcsnlen.c
@@ -0,0 +1,20 @@
+/* Test wcsnlen with size_t in the lower 32 bits of 64-bit register.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define WIDE 1
+#include "tst-size_t-strnlen.c"
diff --git a/sysdeps/x86_64/x32/tst-size_t-wmemchr.c b/sysdeps/x86_64/x32/tst-size_t-wmemchr.c
new file mode 100644
index 0000000000..877801d646
--- /dev/null
+++ b/sysdeps/x86_64/x32/tst-size_t-wmemchr.c
@@ -0,0 +1,20 @@
+/* Test wmemchr with size_t in the lower 32 bits of 64-bit register.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define WIDE 1
+#include "tst-size_t-memchr.c"
diff --git a/sysdeps/x86_64/x32/tst-size_t-wmemcmp.c b/sysdeps/x86_64/x32/tst-size_t-wmemcmp.c
new file mode 100644
index 0000000000..e8b5ffd0d5
--- /dev/null
+++ b/sysdeps/x86_64/x32/tst-size_t-wmemcmp.c
@@ -0,0 +1,20 @@
+/* Test wmemcmp with size_t in the lower 32 bits of 64-bit register.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define WIDE 1
+#include "tst-size_t-memcmp.c"
diff --git a/sysdeps/x86_64/x32/tst-size_t-wmemset.c b/sysdeps/x86_64/x32/tst-size_t-wmemset.c
new file mode 100644
index 0000000000..955eb488c2
--- /dev/null
+++ b/sysdeps/x86_64/x32/tst-size_t-wmemset.c
@@ -0,0 +1,20 @@
+/* Test wmemset with size_t in the lower 32 bits of 64-bit register.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define WIDE 1
+#include "tst-size_t-memset.c"
diff --git a/time/bits/types/struct_timespec.h b/time/bits/types/struct_timespec.h
index 644db9fdb6..5b77c52b4f 100644
--- a/time/bits/types/struct_timespec.h
+++ b/time/bits/types/struct_timespec.h
@@ -1,5 +1,6 @@
-#ifndef __timespec_defined
-#define __timespec_defined 1
+/* NB: Include guard matches what <linux/time.h> uses.  */
+#ifndef _STRUCT_TIMESPEC
+#define _STRUCT_TIMESPEC 1
 
 #include <bits/types.h>
 
diff --git a/time/time.h b/time/time.h
index 49d30438f3..4b55e34402 100644
--- a/time/time.h
+++ b/time/time.h
@@ -68,7 +68,7 @@ typedef __pid_t pid_t;
 __BEGIN_DECLS
 
 /* Time used by the program so far (user time + system time).
-   The result / CLOCKS_PER_SECOND is program time in seconds.  */
+   The result / CLOCKS_PER_SEC is program time in seconds.  */
 extern clock_t clock (void) __THROW;
 
 /* Return the current time and put it in *TIMER if TIMER is not NULL.  */
